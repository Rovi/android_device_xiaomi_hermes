From 9046fd587c93944e4eaa180683683953d578349a Mon Sep 17 00:00:00 2001
From: jianminglok <jianminglok@hotmail.com>
Date: Thu, 27 Oct 2016 02:18:12 -0500
Subject: [PATCH] Setup for Mediatek

Change-Id: I3922518df4279cabcd58190cbe4fbc792a225789
---
 Android.mk                                         | 2230 +++---
 core/java/android/content/Context.java             | 7867 ++++++++++----------
 core/java/android/net/ConnectivityManager.java     |  125 +-
 core/java/android/os/storage/DiskInfo.java         |    2 +-
 core/java/com/mediatek/GbaBaseCredential.java      |  182 +
 core/java/com/mediatek/GbaCipherSuite.java         |  465 ++
 core/java/com/mediatek/GbaHttpUrlCredential.java   |   86 +
 core/java/com/mediatek/GbaManager.java             |  201 +
 core/java/com/mediatek/IGbaService.aidl            |   17 +
 core/java/com/mediatek/NafSessionKey.aidl          |    3 +
 core/java/com/mediatek/NafSessionKey.java          |  157 +
 .../com/android/server/lights/LightsManager.java   |    4 +-
 .../android/server/policy/PhoneWindowManager.java  |    3 +-
 .../java/android/telephony/PhoneNumberUtils.java   |  280 +
 telephony/java/android/telephony/ServiceState.java |  302 +
 .../android/telephony/SubscriptionManager.java     |  221 +
 .../java/com/android/ims/ImsCallForwardInfoEx.aidl |   40 +
 .../java/com/android/ims/ImsCallForwardInfoEx.java |  126 +
 telephony/java/com/android/ims/ImsCallProfile.java |   11 +
 telephony/java/com/android/ims/ImsReasonInfo.java  |   16 +
 .../com/android/ims/internal/IImsCallSession.aidl  |   32 +-
 .../ims/internal/IImsCallSessionListener.aidl      |   13 +
 .../java/com/android/ims/internal/IImsService.aidl |   36 +-
 .../java/com/android/ims/internal/IImsUt.aidl      |   15 +
 .../com/android/ims/internal/IImsUtListener.aidl   |   12 +
 .../ims/internal/IImsVideoCallCallback.aidl        |    7 +
 .../ims/internal/IImsVideoCallProvider.aidl        |    6 +
 .../android/internal/telephony/DctConstants.java   |   38 +-
 .../java/com/android/internal/telephony/ISub.aidl  |    4 +
 .../internal/telephony/IccCardConstants.java       |  109 +
 .../android/internal/telephony/PhoneConstants.java |  111 +
 .../android/internal/telephony/RILConstants.java   |  496 +-
 .../internal/telephony/TelephonyIntents.java       |  366 +
 .../internal/telephony/TelephonyProperties.java    |   82 +-
 .../internal/telephony/BtSimapOperResponse.aidl    |   39 +
 .../internal/telephony/BtSimapOperResponse.java    |  271 +
 .../internal/telephony/DefaultSmsSimSettings.java  |   81 +
 .../telephony/DefaultVoiceCallSubSettings.java     |   71 +
 .../mediatek/internal/telephony/ITelephonyEx.aidl  |  520 ++
 .../mediatek/internal/telephony/IccCardType.java   |  141 +
 .../internal/telephony/IccSmsStorageStatus.aidl    |   50 +
 .../internal/telephony/IccSmsStorageStatus.java    |  130 +
 .../internal/telephony/SmsCbConfigInfo.aidl        |   50 +
 .../internal/telephony/SmsCbConfigInfo.java        |   70 +
 .../telephony/gsm/IGsmVideoCallCallback.aidl       |   54 +
 .../telephony/gsm/IGsmVideoCallProvider.aidl       |   69 +
 46 files changed, 10156 insertions(+), 5055 deletions(-)
 create mode 100644 core/java/com/mediatek/GbaBaseCredential.java
 create mode 100644 core/java/com/mediatek/GbaCipherSuite.java
 create mode 100644 core/java/com/mediatek/GbaHttpUrlCredential.java
 create mode 100644 core/java/com/mediatek/GbaManager.java
 create mode 100644 core/java/com/mediatek/IGbaService.aidl
 create mode 100644 core/java/com/mediatek/NafSessionKey.aidl
 create mode 100644 core/java/com/mediatek/NafSessionKey.java
 create mode 100644 telephony/java/com/android/ims/ImsCallForwardInfoEx.aidl
 create mode 100644 telephony/java/com/android/ims/ImsCallForwardInfoEx.java
 create mode 100644 telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.aidl
 create mode 100644 telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.java
 create mode 100644 telephony/java/com/mediatek/internal/telephony/DefaultSmsSimSettings.java
 create mode 100644 telephony/java/com/mediatek/internal/telephony/DefaultVoiceCallSubSettings.java
 create mode 100644 telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl
 create mode 100644 telephony/java/com/mediatek/internal/telephony/IccCardType.java
 create mode 100644 telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.aidl
 create mode 100644 telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.java
 create mode 100644 telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.aidl
 create mode 100644 telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.java
 create mode 100644 telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallCallback.aidl
 create mode 100644 telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallProvider.aidl

diff --git a/Android.mk b/Android.mk
index 35d5894..08577bb 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,1114 +1,1116 @@
-#
-# Copyright (C) 2008 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-LOCAL_PATH := $(call my-dir)
-
-# We have a special case here where we build the library's resources
-# independently from its code, so we need to find where the resource
-# class source got placed in the course of building the resources.
-# Thus, the magic here.
-# Also, this module cannot depend directly on the R.java file; if it
-# did, the PRIVATE_* vars for R.java wouldn't be guaranteed to be correct.
-# Instead, it depends on the R.stamp file, which lists the corresponding
-# R.java file as a prerequisite.
-# TODO: find a more appropriate way to do this.
-framework_res_source_path := APPS/framework-res_intermediates/src
-
-# Build the master framework library.
-# The framework contains too many method references (>64K) for poor old DEX.
-# So we first build the framework as a monolithic static library then split it
-# up into smaller pieces.
-# ============================================================
-
-# embedded builds use nothing in frameworks/base
-ifneq ($(ANDROID_BUILD_EMBEDDED),true)
-
-include $(CLEAR_VARS)
-
-# FRAMEWORKS_BASE_SUBDIRS comes from build/core/pathmap.mk
-LOCAL_SRC_FILES := $(call find-other-java-files,$(FRAMEWORKS_BASE_SUBDIRS))
-
-# EventLogTags files.
-LOCAL_SRC_FILES += \
-       core/java/android/content/EventLogTags.logtags \
-       core/java/android/speech/tts/EventLogTags.logtags \
-       core/java/android/webkit/EventLogTags.logtags \
-       core/java/com/android/internal/logging/EventLogTags.logtags \
-
-## READ ME: ########################################################
-##
-## When updating this list of aidl files, consider if that aidl is
-## part of the SDK API.  If it is, also add it to the list below that
-## is preprocessed and distributed with the SDK.  This list should
-## not contain any aidl files for parcelables, but the one below should
-## if you intend for 3rd parties to be able to send those objects
-## across process boundaries.
-##
-## READ ME: ########################################################
-LOCAL_SRC_FILES += \
-	core/java/android/accessibilityservice/IAccessibilityServiceConnection.aidl \
-	core/java/android/accessibilityservice/IAccessibilityServiceClient.aidl \
-	core/java/android/accounts/IAccountManager.aidl \
-	core/java/android/accounts/IAccountManagerResponse.aidl \
-	core/java/android/accounts/IAccountAuthenticator.aidl \
-	core/java/android/accounts/IAccountAuthenticatorResponse.aidl \
-	core/java/android/app/IActivityContainer.aidl \
-	core/java/android/app/IActivityContainerCallback.aidl \
-	core/java/android/app/IActivityController.aidl \
-	core/java/android/app/IActivityPendingResult.aidl \
-	core/java/android/app/IAlarmManager.aidl \
-	core/java/android/app/IAppTask.aidl \
-	core/java/android/app/ITaskStackListener.aidl \
-	core/java/android/app/IBackupAgent.aidl \
-	core/java/android/app/IInstrumentationWatcher.aidl \
-	core/java/android/app/INotificationManager.aidl \
-	core/java/android/app/IProcessObserver.aidl \
-	core/java/android/app/ISearchManager.aidl \
-	core/java/android/app/ISearchManagerCallback.aidl \
-	core/java/android/app/IServiceConnection.aidl \
-	core/java/android/app/IStopUserCallback.aidl \
-	core/java/android/app/job/IJobCallback.aidl \
-	core/java/android/app/job/IJobScheduler.aidl \
-	core/java/android/app/job/IJobService.aidl \
-	core/java/android/app/ITransientNotification.aidl \
-	core/java/android/app/IUidObserver.aidl \
-	core/java/android/app/IUiAutomationConnection.aidl \
-	core/java/android/app/IUiModeManager.aidl \
-	core/java/android/app/IUserSwitchObserver.aidl \
-	core/java/android/app/IWallpaperManager.aidl \
-	core/java/android/app/IWallpaperManagerCallback.aidl \
-	core/java/android/app/admin/IDevicePolicyManager.aidl \
-	core/java/android/app/trust/IStrongAuthTracker.aidl \
-	core/java/android/app/trust/ITrustManager.aidl \
-	core/java/android/app/trust/ITrustListener.aidl \
-	core/java/android/app/backup/IBackupManager.aidl \
-	core/java/android/app/backup/IFullBackupRestoreObserver.aidl \
-	core/java/android/app/backup/IRestoreObserver.aidl \
-	core/java/android/app/backup/IRestoreSession.aidl \
-	core/java/android/app/usage/IUsageStatsManager.aidl \
-	core/java/android/bluetooth/IBluetooth.aidl \
-	core/java/android/bluetooth/IBluetoothA2dp.aidl \
-	core/java/android/bluetooth/IBluetoothA2dpSink.aidl \
-	core/java/android/bluetooth/IBluetoothAvrcpController.aidl \
-	core/java/android/bluetooth/IBluetoothCallback.aidl \
-	core/java/android/bluetooth/IBluetoothProfileServiceConnection.aidl \
-	core/java/android/bluetooth/IBluetoothHeadset.aidl \
-	core/java/android/bluetooth/IBluetoothHeadsetPhone.aidl \
-	core/java/android/bluetooth/IBluetoothHealth.aidl \
-	core/java/android/bluetooth/IBluetoothHealthCallback.aidl \
-	core/java/android/bluetooth/IBluetoothInputDevice.aidl \
-	core/java/android/bluetooth/IBluetoothPan.aidl \
-	core/java/android/bluetooth/IBluetoothManager.aidl \
-	core/java/android/bluetooth/IBluetoothManagerCallback.aidl \
-	core/java/android/bluetooth/IBluetoothPbap.aidl \
-	core/java/android/bluetooth/IBluetoothMap.aidl \
-	core/java/android/bluetooth/IBluetoothSap.aidl \
-	core/java/android/bluetooth/IBluetoothStateChangeCallback.aidl \
-	core/java/android/bluetooth/IBluetoothHeadsetClient.aidl \
-	core/java/android/bluetooth/IBluetoothGatt.aidl \
-	core/java/android/bluetooth/IBluetoothGattCallback.aidl \
-	core/java/android/bluetooth/IBluetoothGattServerCallback.aidl \
-	core/java/android/content/IClipboard.aidl \
-	core/java/android/content/IContentService.aidl \
-	core/java/android/content/IIntentReceiver.aidl \
-	core/java/android/content/IIntentSender.aidl \
-	core/java/android/content/IOnPrimaryClipChangedListener.aidl \
-	core/java/android/content/IRestrictionsManager.aidl \
-	core/java/android/content/ISyncAdapter.aidl \
-	core/java/android/content/ISyncContext.aidl \
-	core/java/android/content/ISyncServiceAdapter.aidl \
-	core/java/android/content/ISyncStatusObserver.aidl \
-	core/java/android/content/pm/ILauncherApps.aidl \
-	core/java/android/content/pm/IOnAppsChangedListener.aidl \
-	core/java/android/content/pm/IPackageDataObserver.aidl \
-	core/java/android/content/pm/IPackageDeleteObserver.aidl \
-	core/java/android/content/pm/IPackageDeleteObserver2.aidl \
-	core/java/android/content/pm/IPackageInstallObserver.aidl \
-	core/java/android/content/pm/IPackageInstallObserver2.aidl \
-	core/java/android/content/pm/IPackageInstaller.aidl \
-	core/java/android/content/pm/IPackageInstallerCallback.aidl \
-	core/java/android/content/pm/IPackageInstallerSession.aidl \
-	core/java/android/content/pm/IPackageManager.aidl \
-	core/java/android/content/pm/IPackageMoveObserver.aidl \
-	core/java/android/content/pm/IPackageStatsObserver.aidl \
-	core/java/android/content/pm/IOnPermissionsChangeListener.aidl \
-	core/java/android/database/IContentObserver.aidl \
-	core/java/android/hardware/ICameraService.aidl \
-	core/java/android/hardware/ICameraServiceListener.aidl \
-	core/java/android/hardware/ICameraServiceProxy.aidl \
-	core/java/android/hardware/ICamera.aidl \
-	core/java/android/hardware/ICameraClient.aidl \
-	core/java/android/hardware/IConsumerIrService.aidl \
-	core/java/android/hardware/camera2/ICameraDeviceUser.aidl \
-	core/java/android/hardware/camera2/ICameraDeviceCallbacks.aidl \
-	core/java/android/hardware/ISerialManager.aidl \
-	core/java/android/hardware/display/IDisplayManager.aidl \
-	core/java/android/hardware/display/IDisplayManagerCallback.aidl \
-	core/java/android/hardware/display/IVirtualDisplayCallback.aidl \
-	core/java/android/hardware/fingerprint/IFingerprintDaemon.aidl \
-	core/java/android/hardware/fingerprint/IFingerprintDaemonCallback.aidl \
-	core/java/android/hardware/fingerprint/IFingerprintService.aidl \
-	core/java/android/hardware/fingerprint/IFingerprintServiceLockoutResetCallback.aidl \
-	core/java/android/hardware/fingerprint/IFingerprintServiceReceiver.aidl \
-	core/java/android/hardware/hdmi/IHdmiControlCallback.aidl \
-	core/java/android/hardware/hdmi/IHdmiControlService.aidl \
-	core/java/android/hardware/hdmi/IHdmiDeviceEventListener.aidl \
-	core/java/android/hardware/hdmi/IHdmiHotplugEventListener.aidl \
-	core/java/android/hardware/hdmi/IHdmiInputChangeListener.aidl \
-	core/java/android/hardware/hdmi/IHdmiMhlVendorCommandListener.aidl \
-	core/java/android/hardware/hdmi/IHdmiRecordListener.aidl \
-	core/java/android/hardware/hdmi/IHdmiSystemAudioModeChangeListener.aidl \
-	core/java/android/hardware/hdmi/IHdmiVendorCommandListener.aidl \
-	core/java/android/hardware/input/IInputManager.aidl \
-	core/java/android/hardware/input/IInputDevicesChangedListener.aidl \
-	core/java/android/hardware/input/ITabletModeChangedListener.aidl \
-	core/java/android/hardware/location/IActivityRecognitionHardware.aidl \
-	core/java/android/hardware/location/IActivityRecognitionHardwareClient.aidl \
-	core/java/android/hardware/location/IActivityRecognitionHardwareSink.aidl \
-	core/java/android/hardware/location/IActivityRecognitionHardwareWatcher.aidl \
-	core/java/android/hardware/location/IFusedLocationHardware.aidl \
-	core/java/android/hardware/location/IFusedLocationHardwareSink.aidl \
-	core/java/android/hardware/location/IGeofenceHardware.aidl \
-	core/java/android/hardware/location/IGeofenceHardwareCallback.aidl \
-	core/java/android/hardware/location/IGeofenceHardwareMonitorCallback.aidl \
-	core/java/android/hardware/soundtrigger/IRecognitionStatusCallback.aidl \
-	core/java/android/hardware/usb/IUsbManager.aidl \
-	core/java/android/net/ICaptivePortal.aidl \
-	core/java/android/net/IConnectivityManager.aidl \
-	core/java/android/net/IEthernetManager.aidl \
-	core/java/android/net/IEthernetServiceListener.aidl \
-	core/java/android/net/INetworkManagementEventObserver.aidl \
-	core/java/android/net/INetworkPolicyListener.aidl \
-	core/java/android/net/INetworkPolicyManager.aidl \
-	core/java/android/net/INetworkScoreCache.aidl \
-	core/java/android/net/INetworkScoreService.aidl \
-	core/java/android/net/INetworkStatsService.aidl \
-	core/java/android/net/INetworkStatsSession.aidl \
-	core/java/android/net/nsd/INsdManager.aidl \
-	core/java/android/nfc/IAppCallback.aidl \
-	core/java/android/nfc/INfcAdapter.aidl \
-	core/java/android/nfc/INfcAdapterExtras.aidl \
-	core/java/android/nfc/INfcTag.aidl \
-	core/java/android/nfc/INfcCardEmulation.aidl \
-	core/java/android/nfc/INfcUnlockHandler.aidl \
-	core/java/android/os/IBatteryPropertiesListener.aidl \
-	core/java/android/os/IBatteryPropertiesRegistrar.aidl \
-	core/java/android/os/ICancellationSignal.aidl \
-	core/java/android/os/IDeviceIdleController.aidl \
-	core/java/android/os/IMessenger.aidl \
-	core/java/android/os/INetworkActivityListener.aidl \
-	core/java/android/os/INetworkManagementService.aidl \
-	core/java/android/os/IPermissionController.aidl \
-	core/java/android/os/IProcessInfoService.aidl \
-	core/java/android/os/IPowerManager.aidl \
-	core/java/android/os/IRemoteCallback.aidl \
-	core/java/android/os/ISchedulingPolicyService.aidl \
-	core/java/android/os/IUpdateLock.aidl \
-	core/java/android/os/IUserManager.aidl \
-	core/java/android/os/IVibratorService.aidl \
-	core/java/android/security/IKeystoreService.aidl \
-	core/java/android/service/carrier/ICarrierService.aidl \
-	core/java/android/service/carrier/ICarrierMessagingCallback.aidl \
-	core/java/android/service/carrier/ICarrierMessagingService.aidl \
-	core/java/android/service/gatekeeper/IGateKeeperService.aidl \
-	core/java/android/service/notification/INotificationListener.aidl \
-	core/java/android/service/notification/IStatusBarNotificationHolder.aidl \
-	core/java/android/service/notification/IConditionListener.aidl \
-	core/java/android/service/notification/IConditionProvider.aidl \
-	core/java/android/print/ILayoutResultCallback.aidl \
-	core/java/android/print/IPrinterDiscoveryObserver.aidl \
-	core/java/android/print/IPrintDocumentAdapter.aidl \
-	core/java/android/print/IPrintDocumentAdapterObserver.aidl \
-	core/java/android/print/IPrintJobStateChangeListener.aidl \
-	core/java/android/print/IPrintManager.aidl \
-	core/java/android/print/IPrintSpooler.aidl \
-	core/java/android/print/IPrintSpoolerCallbacks.aidl \
-	core/java/android/print/IPrintSpoolerClient.aidl \
-	core/java/android/print/IWriteResultCallback.aidl \
-	core/java/android/printservice/IPrintService.aidl \
-	core/java/android/printservice/IPrintServiceClient.aidl \
-	core/java/android/service/dreams/IDreamManager.aidl \
-	core/java/android/service/dreams/IDreamService.aidl \
-	core/java/android/service/persistentdata/IPersistentDataBlockService.aidl \
-	core/java/android/service/trust/ITrustAgentService.aidl \
-	core/java/android/service/trust/ITrustAgentServiceCallback.aidl \
-	core/java/android/service/voice/IVoiceInteractionService.aidl \
-	core/java/android/service/voice/IVoiceInteractionSession.aidl \
-	core/java/android/service/voice/IVoiceInteractionSessionService.aidl \
-	core/java/android/service/wallpaper/IWallpaperConnection.aidl \
-	core/java/android/service/wallpaper/IWallpaperEngine.aidl \
-	core/java/android/service/wallpaper/IWallpaperService.aidl \
-	core/java/android/service/chooser/IChooserTargetService.aidl \
-	core/java/android/service/chooser/IChooserTargetResult.aidl \
-	core/java/android/view/accessibility/IAccessibilityInteractionConnection.aidl\
-	core/java/android/view/accessibility/IAccessibilityInteractionConnectionCallback.aidl\
-	core/java/android/view/accessibility/IAccessibilityManager.aidl \
-	core/java/android/view/accessibility/IAccessibilityManagerClient.aidl \
-	core/java/android/view/IApplicationToken.aidl \
-	core/java/android/view/IAssetAtlas.aidl \
-	core/java/android/view/IGraphicsStats.aidl \
-	core/java/android/view/IInputFilter.aidl \
-	core/java/android/view/IInputFilterHost.aidl \
-	core/java/android/view/IOnKeyguardExitResult.aidl \
-	core/java/android/view/IRotationWatcher.aidl \
-	core/java/android/view/IWindow.aidl \
-	core/java/android/view/IWindowFocusObserver.aidl \
-	core/java/android/view/IWindowId.aidl \
-	core/java/android/view/IWindowManager.aidl \
-	core/java/android/view/IWindowSession.aidl \
-	core/java/android/view/IWindowSessionCallback.aidl \
-	core/java/android/webkit/IWebViewUpdateService.aidl \
-	core/java/android/speech/IRecognitionListener.aidl \
-	core/java/android/speech/IRecognitionService.aidl \
-	core/java/android/speech/tts/ITextToSpeechCallback.aidl \
-	core/java/android/speech/tts/ITextToSpeechService.aidl \
-	core/java/com/android/internal/app/IAppOpsCallback.aidl \
-	core/java/com/android/internal/app/IAppOpsService.aidl \
-	core/java/com/android/internal/app/IAssistScreenshotReceiver.aidl \
-	core/java/com/android/internal/app/IBatteryStats.aidl \
-	core/java/com/android/internal/app/IProcessStats.aidl \
-	core/java/com/android/internal/app/IVoiceInteractionManagerService.aidl \
-	core/java/com/android/internal/app/IVoiceInteractionSessionShowCallback.aidl \
-	core/java/com/android/internal/app/IVoiceInteractor.aidl \
-	core/java/com/android/internal/app/IVoiceInteractorCallback.aidl \
-	core/java/com/android/internal/app/IVoiceInteractorRequest.aidl \
-	core/java/com/android/internal/app/IMediaContainerService.aidl \
-	core/java/com/android/internal/appwidget/IAppWidgetService.aidl \
-	core/java/com/android/internal/appwidget/IAppWidgetHost.aidl \
-	core/java/com/android/internal/backup/IBackupTransport.aidl \
-	core/java/com/android/internal/backup/IObbBackupService.aidl \
-	core/java/com/android/internal/policy/IKeyguardDrawnCallback.aidl \
-	core/java/com/android/internal/policy/IKeyguardExitCallback.aidl \
-	core/java/com/android/internal/policy/IKeyguardService.aidl \
-	core/java/com/android/internal/policy/IKeyguardStateCallback.aidl \
-	core/java/com/android/internal/os/IDropBoxManagerService.aidl \
-	core/java/com/android/internal/os/IParcelFileDescriptorFactory.aidl \
-	core/java/com/android/internal/os/IResultReceiver.aidl \
-	core/java/com/android/internal/statusbar/IStatusBar.aidl \
-	core/java/com/android/internal/statusbar/IStatusBarService.aidl \
-	core/java/com/android/internal/textservice/ISpellCheckerService.aidl \
-	core/java/com/android/internal/textservice/ISpellCheckerSession.aidl \
-	core/java/com/android/internal/textservice/ISpellCheckerSessionListener.aidl \
-	core/java/com/android/internal/textservice/ITextServicesManager.aidl \
-	core/java/com/android/internal/textservice/ITextServicesSessionListener.aidl \
-	core/java/com/android/internal/view/IInputContext.aidl \
-	core/java/com/android/internal/view/IInputContextCallback.aidl \
-	core/java/com/android/internal/view/IInputMethod.aidl \
-	core/java/com/android/internal/view/IInputMethodClient.aidl \
-	core/java/com/android/internal/view/IInputMethodManager.aidl \
-	core/java/com/android/internal/view/IInputMethodSession.aidl \
-	core/java/com/android/internal/view/IInputSessionCallback.aidl \
-	core/java/com/android/internal/widget/ILockSettings.aidl \
-	core/java/com/android/internal/widget/IRemoteViewsFactory.aidl \
-	core/java/com/android/internal/widget/IRemoteViewsAdapterConnection.aidl \
-	keystore/java/android/security/IKeyChainAliasCallback.aidl \
-	keystore/java/android/security/IKeyChainService.aidl \
-	location/java/android/location/ICountryDetector.aidl \
-	location/java/android/location/ICountryListener.aidl \
-	location/java/android/location/IFusedProvider.aidl \
-	location/java/android/location/IGeocodeProvider.aidl \
-	location/java/android/location/IGeofenceProvider.aidl \
-	location/java/android/location/IGpsMeasurementsListener.aidl \
-	location/java/android/location/IGpsNavigationMessageListener.aidl \
-	location/java/android/location/IGpsStatusListener.aidl \
-	location/java/android/location/IGpsStatusProvider.aidl \
-	location/java/android/location/ILocationListener.aidl \
-	location/java/android/location/ILocationManager.aidl \
-	location/java/android/location/IFusedGeofenceHardware.aidl \
-	location/java/android/location/IGpsGeofenceHardware.aidl \
-	location/java/android/location/INetInitiatedListener.aidl \
-	location/java/com/android/internal/location/ILocationProvider.aidl \
-	media/java/android/media/IAudioService.aidl \
-	media/java/android/media/IAudioFocusDispatcher.aidl \
-	media/java/android/media/IAudioRoutesObserver.aidl \
-	media/java/android/media/IMediaHTTPConnection.aidl \
-	media/java/android/media/IMediaHTTPService.aidl \
-	media/java/android/media/IMediaRouterClient.aidl \
-	media/java/android/media/IMediaRouterService.aidl \
-	media/java/android/media/IMediaScannerListener.aidl \
-	media/java/android/media/IMediaScannerService.aidl \
-	media/java/android/media/IRemoteControlClient.aidl \
-	media/java/android/media/IRemoteControlDisplay.aidl \
-	media/java/android/media/IRemoteDisplayCallback.aidl \
-	media/java/android/media/IRemoteDisplayProvider.aidl \
-	media/java/android/media/IRemoteVolumeController.aidl \
-	media/java/android/media/IRemoteVolumeObserver.aidl \
-	media/java/android/media/IRingtonePlayer.aidl \
-	media/java/android/media/IVolumeController.aidl \
-	media/java/android/media/audiopolicy/IAudioPolicyCallback.aidl \
-	media/java/android/media/midi/IBluetoothMidiService.aidl \
-	media/java/android/media/midi/IMidiDeviceListener.aidl \
-	media/java/android/media/midi/IMidiDeviceOpenCallback.aidl \
-	media/java/android/media/midi/IMidiDeviceServer.aidl \
-	media/java/android/media/midi/IMidiManager.aidl \
-	media/java/android/media/projection/IMediaProjection.aidl \
-	media/java/android/media/projection/IMediaProjectionCallback.aidl \
-	media/java/android/media/projection/IMediaProjectionManager.aidl \
-	media/java/android/media/projection/IMediaProjectionWatcherCallback.aidl \
-	media/java/android/media/session/IActiveSessionsListener.aidl \
-	media/java/android/media/session/ISessionController.aidl \
-	media/java/android/media/session/ISessionControllerCallback.aidl \
-	media/java/android/media/session/ISession.aidl \
-	media/java/android/media/session/ISessionCallback.aidl \
-	media/java/android/media/session/ISessionManager.aidl \
-	media/java/android/media/tv/ITvInputClient.aidl \
-	media/java/android/media/tv/ITvInputHardware.aidl \
-	media/java/android/media/tv/ITvInputHardwareCallback.aidl \
-	media/java/android/media/tv/ITvInputManager.aidl \
-	media/java/android/media/tv/ITvInputManagerCallback.aidl \
-	media/java/android/media/tv/ITvInputService.aidl \
-	media/java/android/media/tv/ITvInputServiceCallback.aidl \
-	media/java/android/media/tv/ITvInputSession.aidl \
-	media/java/android/media/tv/ITvInputSessionCallback.aidl \
-	media/java/android/service/media/IMediaBrowserService.aidl \
-	media/java/android/service/media/IMediaBrowserServiceCallbacks.aidl \
-	telecomm/java/com/android/internal/telecom/IVideoCallback.aidl \
-	telecomm/java/com/android/internal/telecom/IVideoProvider.aidl \
-	telecomm/java/com/android/internal/telecom/IConnectionService.aidl \
-	telecomm/java/com/android/internal/telecom/IConnectionServiceAdapter.aidl \
-	telecomm/java/com/android/internal/telecom/IInCallAdapter.aidl \
-	telecomm/java/com/android/internal/telecom/IInCallService.aidl \
-	telecomm/java/com/android/internal/telecom/ITelecomService.aidl \
-	telecomm/java/com/android/internal/telecom/RemoteServiceCallback.aidl \
-	telephony/java/com/android/ims/internal/IImsCallSession.aidl \
-	telephony/java/com/android/ims/internal/IImsCallSessionListener.aidl \
-	telephony/java/com/android/ims/internal/IImsConfig.aidl \
-	telephony/java/com/android/ims/internal/IImsRegistrationListener.aidl \
-	telephony/java/com/android/ims/internal/IImsEcbm.aidl \
-	telephony/java/com/android/ims/internal/IImsEcbmListener.aidl \
-	telephony/java/com/android/ims/internal/IImsService.aidl \
-	telephony/java/com/android/ims/internal/IImsStreamMediaSession.aidl \
-	telephony/java/com/android/ims/internal/IImsUt.aidl \
-	telephony/java/com/android/ims/internal/IImsUtListener.aidl \
-	telephony/java/com/android/ims/internal/IImsVideoCallCallback.aidl \
-	telephony/java/com/android/ims/internal/IImsVideoCallProvider.aidl \
-	telephony/java/com/android/ims/ImsConfigListener.aidl \
-	telephony/java/com/android/internal/telephony/ICarrierConfigLoader.aidl \
-	telephony/java/com/android/internal/telephony/IMms.aidl \
-	telephony/java/com/android/internal/telephony/IOnSubscriptionsChangedListener.aidl \
-	telephony/java/com/android/internal/telephony/IPhoneStateListener.aidl \
-	telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
-	telephony/java/com/android/internal/telephony/ISms.aidl \
-	telephony/java/com/android/internal/telephony/ISub.aidl \
-	telephony/java/com/android/internal/telephony/ITelephony.aidl \
-	telephony/java/com/android/internal/telephony/ITelephonyRegistry.aidl \
-	telephony/java/com/android/internal/telephony/IWapPushManager.aidl \
-        telephony/java/com/android/internal/telephony/IExtTelephony.aidl \
-	wifi/java/android/net/wifi/IWifiManager.aidl \
-	wifi/java/android/net/wifi/passpoint/IWifiPasspointManager.aidl \
-	wifi/java/android/net/wifi/p2p/IWifiP2pManager.aidl \
-	wifi/java/android/net/wifi/IWifiScanner.aidl \
-	wifi/java/android/net/wifi/IRttManager.aidl \
-	packages/services/PacProcessor/com/android/net/IProxyService.aidl \
-	packages/services/Proxy/com/android/net/IProxyCallback.aidl \
-	packages/services/Proxy/com/android/net/IProxyPortListener.aidl \
-
-# FRAMEWORKS_BASE_JAVA_SRC_DIRS comes from build/core/pathmap.mk
-LOCAL_AIDL_INCLUDES += $(FRAMEWORKS_BASE_JAVA_SRC_DIRS)
-
-LOCAL_INTERMEDIATE_SOURCES := \
-			$(framework_res_source_path)/android/R.java \
-			$(framework_res_source_path)/android/Manifest.java \
-			$(framework_res_source_path)/com/android/internal/R.java
-
-LOCAL_NO_STANDARD_LIBRARIES := true
-LOCAL_JAVA_LIBRARIES := core-libart conscrypt okhttp core-junit bouncycastle ext
-
-LOCAL_MODULE := framework
-
-LOCAL_DX_FLAGS := --core-library --multi-dex
-LOCAL_JACK_FLAGS := --multi-dex native
-
-LOCAL_RMTYPEDEFS := true
-
-include $(BUILD_JAVA_LIBRARY)
-framework_module := $(LOCAL_INSTALLED_MODULE)
-
-# Make sure that R.java and Manifest.java are built before we build
-# the source for this library.
-framework_res_R_stamp := \
-	$(call intermediates-dir-for,APPS,framework-res,,COMMON)/src/R.stamp
-$(full_classes_compiled_jar): $(framework_res_R_stamp)
-$(built_dex_intermediate): $(framework_res_R_stamp)
-
-$(framework_module): | $(dir $(framework_module))framework-res.apk
-
-framework_built := $(call java-lib-deps,framework)
-
-# Copy AIDL files to be preprocessed and included in the SDK,
-# specified relative to the root of the build tree.
-# ============================================================
-include $(CLEAR_VARS)
-
-aidl_files := \
-	frameworks/base/telephony/java/android/telephony/ServiceState.aidl \
-	frameworks/base/telephony/java/android/telephony/SubscriptionInfo.aidl \
-	frameworks/base/telephony/java/android/telephony/CellInfo.aidl \
-	frameworks/base/telephony/java/android/telephony/SignalStrength.aidl \
-	frameworks/base/telephony/java/android/telephony/IccOpenLogicalChannelResponse.aidl \
-	frameworks/base/telephony/java/android/telephony/NeighboringCellInfo.aidl \
-	frameworks/base/telephony/java/android/telephony/ModemActivityInfo.aidl \
-	frameworks/base/location/java/android/location/Location.aidl \
-	frameworks/base/location/java/android/location/Address.aidl \
-	frameworks/base/location/java/android/location/Criteria.aidl \
-	frameworks/base/media/java/android/media/MediaMetadata.aidl \
-	frameworks/base/media/java/android/media/MediaDescription.aidl \
-	frameworks/base/media/java/android/media/Rating.aidl \
-	frameworks/base/media/java/android/media/AudioAttributes.aidl \
-	frameworks/base/media/java/android/media/AudioFocusInfo.aidl \
-	frameworks/base/media/java/android/media/session/PlaybackState.aidl \
-	frameworks/base/media/java/android/media/session/MediaSession.aidl \
-	frameworks/base/media/java/android/media/tv/TvInputInfo.aidl \
-	frameworks/base/media/java/android/media/tv/TvTrackInfo.aidl \
-	frameworks/base/media/java/android/media/browse/MediaBrowser.aidl \
-	frameworks/base/wifi/java/android/net/wifi/ScanSettings.aidl \
-	frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pInfo.aidl \
-	frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pDeviceList.aidl \
-	frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pConfig.aidl \
-	frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pDevice.aidl \
-	frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pGroup.aidl \
-	frameworks/base/wifi/java/android/net/wifi/p2p/nsd/WifiP2pServiceRequest.aidl \
-	frameworks/base/wifi/java/android/net/wifi/p2p/nsd/WifiP2pServiceInfo.aidl \
-	frameworks/base/wifi/java/android/net/wifi/WpsInfo.aidl \
-	frameworks/base/wifi/java/android/net/wifi/ScanResult.aidl \
-	frameworks/base/wifi/java/android/net/wifi/WifiEnterpriseConfig.aidl \
-	frameworks/base/wifi/java/android/net/wifi/WifiConfiguration.aidl \
-	frameworks/base/wifi/java/android/net/wifi/WifiInfo.aidl \
-	frameworks/base/graphics/java/android/graphics/Region.aidl \
-	frameworks/base/graphics/java/android/graphics/Bitmap.aidl \
-	frameworks/base/graphics/java/android/graphics/Point.aidl \
-	frameworks/base/graphics/java/android/graphics/PointF.aidl \
-	frameworks/base/graphics/java/android/graphics/RectF.aidl \
-	frameworks/base/graphics/java/android/graphics/Rect.aidl \
-	frameworks/base/core/java/android/accounts/AuthenticatorDescription.aidl \
-	frameworks/base/core/java/android/accounts/Account.aidl \
-	frameworks/base/core/java/android/app/admin/SystemUpdatePolicy.aidl \
-	frameworks/base/core/java/android/print/PrintDocumentInfo.aidl \
-	frameworks/base/core/java/android/print/PageRange.aidl \
-	frameworks/base/core/java/android/print/PrintAttributes.aidl \
-	frameworks/base/core/java/android/print/PrinterCapabilitiesInfo.aidl \
-	frameworks/base/core/java/android/print/PrinterId.aidl \
-	frameworks/base/core/java/android/print/PrintJobInfo.aidl \
-	frameworks/base/core/java/android/print/PrinterInfo.aidl \
-	frameworks/base/core/java/android/print/PrintJobId.aidl \
-	frameworks/base/core/java/android/hardware/usb/UsbDevice.aidl \
-	frameworks/base/core/java/android/hardware/usb/UsbInterface.aidl \
-	frameworks/base/core/java/android/hardware/usb/UsbEndpoint.aidl \
-	frameworks/base/core/java/android/hardware/usb/UsbAccessory.aidl \
-	frameworks/base/core/java/android/os/Messenger.aidl \
-	frameworks/base/core/java/android/os/PatternMatcher.aidl \
-	frameworks/base/core/java/android/os/Message.aidl \
-	frameworks/base/core/java/android/os/UserHandle.aidl \
-	frameworks/base/core/java/android/os/ParcelUuid.aidl \
-	frameworks/base/core/java/android/os/ParcelFileDescriptor.aidl \
-	frameworks/base/core/java/android/os/ResultReceiver.aidl \
-	frameworks/base/core/java/android/os/PersistableBundle.aidl \
-	frameworks/base/core/java/android/os/WorkSource.aidl \
-	frameworks/base/core/java/android/os/DropBoxManager.aidl \
-	frameworks/base/core/java/android/os/Bundle.aidl \
-	frameworks/base/core/java/android/accessibilityservice/AccessibilityServiceInfo.aidl \
-	frameworks/base/core/java/android/net/Network.aidl \
-	frameworks/base/core/java/android/net/RouteInfo.aidl \
-	frameworks/base/core/java/android/net/NetworkInfo.aidl \
-	frameworks/base/core/java/android/net/IpPrefix.aidl \
-	frameworks/base/core/java/android/net/NetworkCapabilities.aidl \
-	frameworks/base/core/java/android/net/DhcpInfo.aidl \
-	frameworks/base/core/java/android/net/ProxyInfo.aidl \
-	frameworks/base/core/java/android/net/LinkProperties.aidl \
-	frameworks/base/core/java/android/net/Uri.aidl \
-	frameworks/base/core/java/android/net/NetworkRequest.aidl \
-	frameworks/base/core/java/android/net/LinkAddress.aidl \
-	frameworks/base/core/java/android/view/Display.aidl \
-	frameworks/base/core/java/android/view/InputDevice.aidl \
-	frameworks/base/core/java/android/view/InputEvent.aidl \
-	frameworks/base/core/java/android/view/Surface.aidl \
-	frameworks/base/core/java/android/view/WindowContentFrameStats.aidl \
-	frameworks/base/core/java/android/view/inputmethod/InputMethodSubtype.aidl \
-	frameworks/base/core/java/android/view/inputmethod/CursorAnchorInfo.aidl \
-	frameworks/base/core/java/android/view/inputmethod/CompletionInfo.aidl \
-	frameworks/base/core/java/android/view/inputmethod/ExtractedText.aidl \
-	frameworks/base/core/java/android/view/inputmethod/EditorInfo.aidl \
-	frameworks/base/core/java/android/view/inputmethod/InputMethodInfo.aidl \
-	frameworks/base/core/java/android/view/inputmethod/CorrectionInfo.aidl \
-	frameworks/base/core/java/android/view/inputmethod/InputBinding.aidl \
-	frameworks/base/core/java/android/view/inputmethod/ExtractedTextRequest.aidl \
-	frameworks/base/core/java/android/view/DragEvent.aidl \
-	frameworks/base/core/java/android/view/KeyEvent.aidl \
-	frameworks/base/core/java/android/view/WindowManager.aidl \
-	frameworks/base/core/java/android/view/WindowAnimationFrameStats.aidl \
-	frameworks/base/core/java/android/view/MotionEvent.aidl \
-	frameworks/base/core/java/android/view/accessibility/AccessibilityNodeInfo.aidl \
-	frameworks/base/core/java/android/view/accessibility/AccessibilityRecord.aidl \
-	frameworks/base/core/java/android/view/accessibility/AccessibilityWindowInfo.aidl \
-	frameworks/base/core/java/android/view/accessibility/AccessibilityEvent.aidl \
-	frameworks/base/core/java/android/view/textservice/SpellCheckerSubtype.aidl \
-	frameworks/base/core/java/android/view/textservice/TextInfo.aidl \
-	frameworks/base/core/java/android/view/textservice/SpellCheckerInfo.aidl \
-	frameworks/base/core/java/android/view/textservice/SentenceSuggestionsInfo.aidl \
-	frameworks/base/core/java/android/view/textservice/SuggestionsInfo.aidl \
-	frameworks/base/core/java/android/service/carrier/CarrierIdentifier.aidl \
-	frameworks/base/core/java/android/service/carrier/MessagePdu.aidl \
-	frameworks/base/core/java/android/service/notification/StatusBarNotification.aidl \
-	frameworks/base/core/java/android/service/chooser/ChooserTarget.aidl \
-	frameworks/base/core/java/android/speech/tts/Voice.aidl \
-	frameworks/base/core/java/android/app/usage/UsageEvents.aidl \
-	frameworks/base/core/java/android/app/Notification.aidl \
-	frameworks/base/core/java/android/app/NotificationManager.aidl \
-	frameworks/base/core/java/android/app/WallpaperInfo.aidl \
-	frameworks/base/core/java/android/app/AppOpsManager.aidl \
-	frameworks/base/core/java/android/app/ActivityManager.aidl \
-	frameworks/base/core/java/android/app/PendingIntent.aidl \
-	frameworks/base/core/java/android/app/AlarmManager.aidl \
-	frameworks/base/core/java/android/app/SearchableInfo.aidl \
-	frameworks/base/core/java/android/app/VoiceInteractor.aidl \
-	frameworks/base/core/java/android/app/assist/AssistContent.aidl \
-	frameworks/base/core/java/android/app/assist/AssistStructure.aidl \
-	frameworks/base/core/java/android/app/job/JobParameters.aidl \
-	frameworks/base/core/java/android/app/job/JobInfo.aidl \
-	frameworks/base/core/java/android/appwidget/AppWidgetProviderInfo.aidl \
-	frameworks/base/core/java/android/content/ClipDescription.aidl \
-	frameworks/base/core/java/android/content/IntentFilter.aidl \
-	frameworks/base/core/java/android/content/Intent.aidl \
-	frameworks/base/core/java/android/content/res/Configuration.aidl \
-	frameworks/base/core/java/android/content/res/ObbInfo.aidl \
-	frameworks/base/core/java/android/content/RestrictionEntry.aidl \
-	frameworks/base/core/java/android/content/ClipData.aidl \
-	frameworks/base/core/java/android/content/SyncAdapterType.aidl \
-	frameworks/base/core/java/android/content/SyncRequest.aidl \
-	frameworks/base/core/java/android/content/PeriodicSync.aidl \
-	frameworks/base/core/java/android/content/SyncResult.aidl \
-	frameworks/base/core/java/android/content/pm/FeatureInfo.aidl \
-	frameworks/base/core/java/android/content/pm/InstrumentationInfo.aidl \
-	frameworks/base/core/java/android/content/pm/PackageInstaller.aidl \
-	frameworks/base/core/java/android/content/pm/ServiceInfo.aidl \
-	frameworks/base/core/java/android/content/pm/Signature.aidl \
-	frameworks/base/core/java/android/content/pm/ApplicationInfo.aidl \
-	frameworks/base/core/java/android/content/pm/PermissionInfo.aidl \
-	frameworks/base/core/java/android/content/pm/ActivityInfo.aidl \
-	frameworks/base/core/java/android/content/pm/PackageInfo.aidl \
-	frameworks/base/core/java/android/content/pm/ResolveInfo.aidl \
-	frameworks/base/core/java/android/content/pm/ProviderInfo.aidl \
-	frameworks/base/core/java/android/content/pm/PackageStats.aidl \
-	frameworks/base/core/java/android/content/pm/PermissionGroupInfo.aidl \
-	frameworks/base/core/java/android/content/pm/LabeledIntent.aidl \
-	frameworks/base/core/java/android/content/ComponentName.aidl \
-	frameworks/base/core/java/android/content/SyncStats.aidl \
-	frameworks/base/core/java/android/content/ContentValues.aidl \
-	frameworks/base/core/java/android/content/SyncInfo.aidl \
-	frameworks/base/core/java/android/content/IntentSender.aidl \
-	frameworks/base/core/java/android/widget/RemoteViews.aidl \
-	frameworks/base/core/java/android/text/style/SuggestionSpan.aidl \
-	frameworks/base/core/java/android/nfc/Tag.aidl \
-	frameworks/base/core/java/android/nfc/NdefRecord.aidl \
-	frameworks/base/core/java/android/nfc/NdefMessage.aidl \
-	frameworks/base/core/java/android/bluetooth/BluetoothHealthAppConfiguration.aidl \
-	frameworks/base/core/java/android/bluetooth/le/AdvertiseSettings.aidl \
-	frameworks/base/core/java/android/bluetooth/le/ScanSettings.aidl \
-	frameworks/base/core/java/android/bluetooth/le/AdvertiseData.aidl \
-	frameworks/base/core/java/android/bluetooth/le/ScanFilter.aidl \
-	frameworks/base/core/java/android/bluetooth/le/ScanResult.aidl \
-	frameworks/base/core/java/android/bluetooth/BluetoothDevice.aidl \
-	frameworks/base/core/java/android/database/CursorWindow.aidl \
-
-gen := $(TARGET_OUT_COMMON_INTERMEDIATES)/framework.aidl
-$(gen): PRIVATE_SRC_FILES := $(aidl_files)
-ALL_SDK_FILES += $(gen)
-$(gen): $(aidl_files) | $(AIDL)
-		@echo Aidl Preprocess: $@
-		$(hide) $(AIDL) --preprocess $@ $(PRIVATE_SRC_FILES)
-
-# the documentation
-# ============================================================
-
-# TODO: deal with com/google/android/googleapps
-packages_to_document := \
-	android \
-	javax/microedition/khronos \
-	org/apache/http/conn \
-	org/apache/http/params
-
-
-# Search through the base framework dirs for these packages.
-# The result will be relative to frameworks/base.
-fwbase_dirs_to_document := \
-	test-runner/src \
-	$(patsubst $(LOCAL_PATH)/%,%, \
-	  $(wildcard \
-	    $(foreach dir, $(FRAMEWORKS_BASE_JAVA_SRC_DIRS), \
-	      $(addprefix $(dir)/, $(packages_to_document)) \
-	     ) \
-	   ) \
-	 )
-
-# include definition of libcore_to_document
-include libcore/Docs.mk
-
-# include definition of junit_to_document
-include external/junit/Common.mk
-
-non_base_dirs := \
-	../opt/telephony/src/java/android/provider \
-	../opt/telephony/src/java/android/telephony \
-	../opt/telephony/src/java/android/telephony/gsm \
-	../opt/net/voip/src/java/android/net/rtp \
-	../opt/net/voip/src/java/android/net/sip
-
-# These are relative to frameworks/base
-dirs_to_check_apis := \
-  $(fwbase_dirs_to_document) \
-	$(non_base_dirs)
-
-# These are relative to frameworks/base
-# FRAMEWORKS_BASE_SUBDIRS comes from build/core/pathmap.mk
-dirs_to_document := \
-	$(dirs_to_check_apis) \
-  $(addprefix ../../, $(FRAMEWORKS_DATA_BINDING_JAVA_SRC_DIRS)) \
-  $(addprefix ../../, $(FRAMEWORKS_SUPPORT_JAVA_SRC_DIRS)) \
-
-# These are relative to frameworks/base
-html_dirs := \
-	$(FRAMEWORKS_BASE_SUBDIRS) \
-	$(non_base_dirs)
-
-# Common sources for doc check and api check
-common_src_files := \
-	$(call find-other-html-files, $(html_dirs)) \
-	$(addprefix ../../libcore/, $(libcore_to_document)) \
-	$(addprefix ../../external/junit/, $(junit_to_document))
-
-# These are relative to frameworks/base
-framework_docs_LOCAL_SRC_FILES := \
-	$(call find-other-java-files, $(dirs_to_document)) \
-	$(common_src_files)
-
-# These are relative to frameworks/base
-framework_docs_LOCAL_API_CHECK_SRC_FILES := \
-	$(call find-other-java-files, $(dirs_to_check_apis)) \
-	$(common_src_files)
-
-# This is used by ide.mk as the list of source files that are
-# always included.
-INTERNAL_SDK_SOURCE_DIRS := $(addprefix $(LOCAL_PATH)/,$(dirs_to_document))
-
-framework_docs_LOCAL_DROIDDOC_SOURCE_PATH := \
-	$(FRAMEWORKS_BASE_JAVA_SRC_DIRS)
-
-framework_docs_LOCAL_INTERMEDIATE_SOURCES := \
-	$(framework_res_source_path)/android/R.java \
-	$(framework_res_source_path)/android/Manifest.java \
-	$(framework_res_source_path)/com/android/internal/R.java
-
-framework_docs_LOCAL_API_CHECK_JAVA_LIBRARIES := \
-	core-libart \
-	conscrypt \
-	bouncycastle \
-	okhttp \
-	ext \
-	framework \
-	telephony-common \
-	voip-common
-
-framework_docs_LOCAL_JAVA_LIBRARIES := \
-	$(framework_docs_LOCAL_API_CHECK_JAVA_LIBRARIES) \
-	$(FRAMEWORKS_SUPPORT_JAVA_LIBRARIES)
-
-framework_docs_LOCAL_MODULE_CLASS := JAVA_LIBRARIES
-framework_docs_LOCAL_DROIDDOC_HTML_DIR := docs/html
-# The since flag (-since N.xml API_LEVEL) is used to add API Level information
-# to the reference documentation. Must be in order of oldest to newest.
-#
-# Conscrypt (com.android.org.conscrypt) is an implementation detail and should
-# not be referenced in the documentation.
-framework_docs_LOCAL_DROIDDOC_OPTIONS := \
-    -knowntags ./frameworks/base/docs/knowntags.txt \
-    -hidePackage com.android.org.conscrypt \
-    -since $(SRC_API_DIR)/1.xml 1 \
-    -since $(SRC_API_DIR)/2.xml 2 \
-    -since $(SRC_API_DIR)/3.xml 3 \
-    -since $(SRC_API_DIR)/4.xml 4 \
-    -since $(SRC_API_DIR)/5.xml 5 \
-    -since $(SRC_API_DIR)/6.xml 6 \
-    -since $(SRC_API_DIR)/7.xml 7 \
-    -since $(SRC_API_DIR)/8.xml 8 \
-    -since $(SRC_API_DIR)/9.xml 9 \
-    -since $(SRC_API_DIR)/10.xml 10 \
-    -since $(SRC_API_DIR)/11.xml 11 \
-    -since $(SRC_API_DIR)/12.xml 12 \
-    -since $(SRC_API_DIR)/13.xml 13 \
-    -since $(SRC_API_DIR)/14.txt 14 \
-    -since $(SRC_API_DIR)/15.txt 15 \
-    -since $(SRC_API_DIR)/16.txt 16 \
-    -since $(SRC_API_DIR)/17.txt 17 \
-    -since $(SRC_API_DIR)/18.txt 18 \
-    -since $(SRC_API_DIR)/19.txt 19 \
-    -since $(SRC_API_DIR)/20.txt 20 \
-    -since $(SRC_API_DIR)/21.txt 21 \
-    -since $(SRC_API_DIR)/22.txt 22 \
-    -since $(SRC_API_DIR)/23.txt 23 \
-		-werror -hide 111 -hide 113 \
-		-overview $(LOCAL_PATH)/core/java/overview.html
-
-framework_docs_LOCAL_API_CHECK_ADDITIONAL_JAVA_DIR:= \
-	$(call intermediates-dir-for,JAVA_LIBRARIES,framework,,COMMON)
-
-framework_docs_LOCAL_ADDITIONAL_JAVA_DIR:= \
-	$(framework_docs_LOCAL_API_CHECK_ADDITIONAL_JAVA_DIR) \
-	$(foreach lib,$(FRAMEWORKS_SUPPORT_JAVA_LIBRARIES),$(call intermediates-dir-for,JAVA_LIBRARIES,$(lib),,COMMON)) \
-	$(foreach lib,$(FRAMEWORKS_SUPPORT_JAVA_LIBRARIES),$(call intermediates-dir-for,JAVA_LIBRARIES,$(lib)-res,,COMMON))
-
-framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES := \
-    frameworks/base/docs/knowntags.txt
-
-samples_dir := development/samples/browseable
-
-# Whitelist of valid groups, used for default TOC grouping. Each sample must
-# belong to one (and only one) group. Assign samples to groups by setting
-# a sample.group var to one of these groups in the sample's _index.jd.
-sample_groups := -samplegroup Admin \
-                 -samplegroup Background \
-                 -samplegroup Connectivity \
-                 -samplegroup Content \
-                 -samplegroup Input \
-                 -samplegroup Media \
-                 -samplegroup Notification \
-                 -samplegroup RenderScript \
-                 -samplegroup Security \
-                 -samplegroup Sensors \
-                 -samplegroup System \
-                 -samplegroup Testing \
-                 -samplegroup UI \
-                 -samplegroup Views \
-                 -samplegroup Wearable
-
-## SDK version identifiers used in the published docs
-  # major[.minor] version for current SDK. (full releases only)
-framework_docs_SDK_VERSION:=6.0
-  # release version (ie "Release x")  (full releases only)
-framework_docs_SDK_REL_ID:=1
-
-framework_docs_LOCAL_DROIDDOC_OPTIONS += \
-		-hdf sdk.version $(framework_docs_SDK_VERSION) \
-		-hdf sdk.rel.id $(framework_docs_SDK_REL_ID) \
-		-hdf sdk.preview 0
-
-# ====  the api stubs and current.xml ===========================
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:=$(framework_docs_LOCAL_API_CHECK_SRC_FILES)
-LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
-LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_API_CHECK_JAVA_LIBRARIES)
-LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
-LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
-LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
-LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_API_CHECK_ADDITIONAL_JAVA_DIR)
-LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
-
-LOCAL_MODULE := api-stubs
-
-LOCAL_DROIDDOC_OPTIONS:=\
-		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
-		-stubs $(TARGET_OUT_COMMON_INTERMEDIATES)/JAVA_LIBRARIES/android_stubs_current_intermediates/src \
-		-api $(INTERNAL_PLATFORM_API_FILE) \
-		-removedApi $(INTERNAL_PLATFORM_REMOVED_API_FILE) \
-		-nodocs
-
-LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
-
-LOCAL_UNINSTALLABLE_MODULE := true
-
-include $(BUILD_DROIDDOC)
-
-# $(gen), i.e. framework.aidl, is also needed while building against the current stub.
-$(full_target): $(framework_built) $(gen)
-$(INTERNAL_PLATFORM_API_FILE): $(full_target)
-$(call dist-for-goals,sdk,$(INTERNAL_PLATFORM_API_FILE))
-
-# ====  the system api stubs ===================================
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:=$(framework_docs_LOCAL_API_CHECK_SRC_FILES)
-LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
-LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_API_CHECK_JAVA_LIBRARIES)
-LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
-LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
-LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
-LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_API_CHECK_ADDITIONAL_JAVA_DIR)
-LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
-
-LOCAL_MODULE := system-api-stubs
-
-LOCAL_DROIDDOC_OPTIONS:=\
-		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
-		-stubs $(TARGET_OUT_COMMON_INTERMEDIATES)/JAVA_LIBRARIES/android_system_stubs_current_intermediates/src \
-		-showAnnotation android.annotation.SystemApi \
-		-api $(INTERNAL_PLATFORM_SYSTEM_API_FILE) \
-		-removedApi $(INTERNAL_PLATFORM_SYSTEM_REMOVED_API_FILE) \
-		-nodocs
-
-LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
-
-LOCAL_UNINSTALLABLE_MODULE := true
-
-include $(BUILD_DROIDDOC)
-
-# $(gen), i.e. framework.aidl, is also needed while building against the current stub.
-$(full_target): $(framework_built) $(gen)
-$(INTERNAL_PLATFORM_SYSTEM_API_FILE): $(full_target)
-$(call dist-for-goals,sdk,$(INTERNAL_PLATFORM_SYSTEM_API_FILE))
-
-# ====  check javadoc comments but don't generate docs ========
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
-LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
-LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
-LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
-LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
-LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
-LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_ADDITIONAL_JAVA_DIR)
-LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
-
-LOCAL_MODULE := doc-comment-check
-
-LOCAL_DROIDDOC_OPTIONS:=\
-		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
-		-parsecomments
-
-LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
-
-LOCAL_UNINSTALLABLE_MODULE := true
-
-include $(BUILD_DROIDDOC)
-
-# $(gen), i.e. framework.aidl, is also needed while building against the current stub.
-$(full_target): $(framework_built) $(gen)
-
-# Run this for checkbuild
-checkbuild: doc-comment-check-docs
-# Check comment when you are updating the API
-update-api: doc-comment-check-docs
-
-# ====  static html in the sdk ==================================
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
-LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
-LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
-LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
-LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
-LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
-LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_ADDITIONAL_JAVA_DIR)
-LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
-
-LOCAL_MODULE := offline-sdk
-
-LOCAL_DROIDDOC_OPTIONS:=\
-		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
-		-offlinemode \
-		-title "Android SDK" \
-		-proofread $(OUT_DOCS)/$(LOCAL_MODULE)-proofread.txt \
-		-todo $(OUT_DOCS)/$(LOCAL_MODULE)-docs-todo.html \
-		-sdkvalues $(OUT_DOCS) \
-		-hdf android.whichdoc offline
-
-LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
-
-include $(BUILD_DROIDDOC)
-
-static_doc_index_redirect := $(out_dir)/index.html
-$(static_doc_index_redirect): \
-	$(LOCAL_PATH)/docs/docs-documentation-redirect.html | $(ACP)
-	$(hide) mkdir -p $(dir $@)
-	$(hide) $(ACP) $< $@
-
-$(full_target): $(static_doc_index_redirect)
-$(full_target): $(framework_built)
-
-# ==== docs for the web (on the androiddevdocs app engine server) =======================
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
-LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
-LOCAL_STATIC_JAVA_LIBRARIES:=$(framework_docs_LOCAL_STATIC_JAVA_LIBRARIES)
-LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
-LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
-LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
-LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
-LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_ADDITIONAL_JAVA_DIR)
-LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
-LOCAL_ADDITIONAL_HTML_DIR:=docs/html-intl /
-
-LOCAL_MODULE := online-sdk
-
-LOCAL_DROIDDOC_OPTIONS:= \
-		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
-		-toroot / \
-		-hdf android.whichdoc online \
-		$(sample_groups) \
-		-hdf android.hasSamples true \
-		-samplesdir $(samples_dir)
-
-LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
-
-include $(BUILD_DROIDDOC)
-
-# ==== docs for the web (on the androiddevdocs app engine server) =======================
-# TODO: Fix the System API docs build.
-ifneq ($(filter online-system-api-sdk-docs,$(MAKECMDGOALS)),)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
-LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
-LOCAL_STATIC_JAVA_LIBRARIES:=$(framework_docs_LOCAL_STATIC_JAVA_LIBRARIES)
-LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
-LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
-LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
-LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
-LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_ADDITIONAL_JAVA_DIR)
-LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
-LOCAL_ADDITIONAL_HTML_DIR:=docs/html-intl /
-
-LOCAL_MODULE := online-system-api-sdk
-
-LOCAL_DROIDDOC_OPTIONS:= \
-		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
-		-showAnnotation android.annotation.SystemApi \
-		-title "Android SDK - Including system APIs." \
-		-toroot / \
-		-hdf android.whichdoc online \
-		$(sample_groups) \
-		-hdf android.hasSamples true \
-		-samplesdir $(samples_dir)
-
-LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
-# Don't build by default
-LOCAL_UNINSTALLABLE_MODULE := true
-
-include $(BUILD_DROIDDOC)
-endif  # online-system-api-sdk-docs in make command line.
-
-# ==== docs for the web (on the devsite app engine server) =======================
-include $(CLEAR_VARS)
-LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
-LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
-LOCAL_STATIC_JAVA_LIBRARIES:=$(framework_docs_LOCAL_STATIC_JAVA_LIBRARIES)
-LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
-LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
-LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
-LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
-LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_ADDITIONAL_JAVA_DIR)
-LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
-# specify a second html input dir and an output path relative to OUT_DIR)
-LOCAL_ADDITIONAL_HTML_DIR:=docs/html-intl/intl /
-
-LOCAL_MODULE := ds
-
-LOCAL_DROIDDOC_OPTIONS:= \
-		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
-		-devsite \
-		-toroot / \
-		-hdf android.whichdoc online \
-		-hdf devsite true
-
-LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
-
-include $(BUILD_DROIDDOC)
-
-# ==== docs for the ndk =======================
-include $(CLEAR_VARS)
-LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
-LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
-LOCAL_STATIC_JAVA_LIBRARIES:=$(framework_docs_LOCAL_STATIC_JAVA_LIBRARIES)
-LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
-LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
-LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
-LOCAL_DROIDDOC_HTML_DIR:=docs/html-ndk
-LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_ADDITIONAL_JAVA_DIR)
-LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
-# specify a second html input dir and an output path relative to OUT_DIR)
-LOCAL_ADDITIONAL_HTML_DIR:=docs/html-intl/intl /
-
-LOCAL_MODULE := online-ndk
-
-LOCAL_DROIDDOC_OPTIONS:= \
-		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
-		-toroot / \
-		-hdf android.whichdoc online \
-		$(sample_groups) \
-		-hdf android.hasSamples true \
-		-samplesdir $(samples_dir)
-
-LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
-
-include $(BUILD_DROIDDOC)
-
-
-# ==== docs that have all of the stuff that's @hidden =======================
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
-LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
-LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
-LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
-LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
-LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
-LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_ADDITIONAL_JAVA_DIR)
-LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
-
-LOCAL_MODULE := hidden
-LOCAL_DROIDDOC_OPTIONS:=\
-		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
-		-title "Android SDK - Including hidden APIs."
-#		-hidden
-
-LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
-
-include $(BUILD_DROIDDOC)
-
-# Build ext.jar
-# ============================================================
-
-ext_dirs := \
-	../../external/nist-sip/java \
-	../../external/tagsoup/src \
-
-ext_src_files := $(call all-java-files-under,$(ext_dirs))
-
-# ====  the library  =========================================
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES := $(ext_src_files)
-
-LOCAL_NO_STANDARD_LIBRARIES := true
-LOCAL_JAVA_LIBRARIES := core-libart
-LOCAL_STATIC_JAVA_LIBRARIES := libphonenumber-platform
-LOCAL_MODULE_TAGS := optional
-LOCAL_MODULE := ext
-
-LOCAL_DX_FLAGS := --core-library
-
-include $(BUILD_JAVA_LIBRARY)
-
-
-# Include subdirectory makefiles
-# ============================================================
-
-# If we're building with ONE_SHOT_MAKEFILE (mm, mmm), then what the framework
-# team really wants is to build the stuff defined by this makefile.
-ifeq (,$(ONE_SHOT_MAKEFILE))
-include $(call first-makefiles-under,$(LOCAL_PATH))
-endif
-
-endif # ANDROID_BUILD_EMBEDDED
+#
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+LOCAL_PATH := $(call my-dir)
+
+# We have a special case here where we build the library's resources
+# independently from its code, so we need to find where the resource
+# class source got placed in the course of building the resources.
+# Thus, the magic here.
+# Also, this module cannot depend directly on the R.java file; if it
+# did, the PRIVATE_* vars for R.java wouldn't be guaranteed to be correct.
+# Instead, it depends on the R.stamp file, which lists the corresponding
+# R.java file as a prerequisite.
+# TODO: find a more appropriate way to do this.
+framework_res_source_path := APPS/framework-res_intermediates/src
+
+# Build the master framework library.
+# The framework contains too many method references (>64K) for poor old DEX.
+# So we first build the framework as a monolithic static library then split it
+# up into smaller pieces.
+# ============================================================
+
+# embedded builds use nothing in frameworks/base
+ifneq ($(ANDROID_BUILD_EMBEDDED),true)
+
+include $(CLEAR_VARS)
+
+# FRAMEWORKS_BASE_SUBDIRS comes from build/core/pathmap.mk
+LOCAL_SRC_FILES := $(call find-other-java-files,$(FRAMEWORKS_BASE_SUBDIRS))
+
+# EventLogTags files.
+LOCAL_SRC_FILES += \
+       core/java/android/content/EventLogTags.logtags \
+       core/java/android/speech/tts/EventLogTags.logtags \
+       core/java/android/webkit/EventLogTags.logtags \
+       core/java/com/android/internal/logging/EventLogTags.logtags \
+
+## READ ME: ########################################################
+##
+## When updating this list of aidl files, consider if that aidl is
+## part of the SDK API.  If it is, also add it to the list below that
+## is preprocessed and distributed with the SDK.  This list should
+## not contain any aidl files for parcelables, but the one below should
+## if you intend for 3rd parties to be able to send those objects
+## across process boundaries.
+##
+## READ ME: ########################################################
+LOCAL_SRC_FILES += \
+	core/java/android/accessibilityservice/IAccessibilityServiceConnection.aidl \
+	core/java/android/accessibilityservice/IAccessibilityServiceClient.aidl \
+	core/java/android/accounts/IAccountManager.aidl \
+	core/java/android/accounts/IAccountManagerResponse.aidl \
+	core/java/android/accounts/IAccountAuthenticator.aidl \
+	core/java/android/accounts/IAccountAuthenticatorResponse.aidl \
+	core/java/android/app/IActivityContainer.aidl \
+	core/java/android/app/IActivityContainerCallback.aidl \
+	core/java/android/app/IActivityController.aidl \
+	core/java/android/app/IActivityPendingResult.aidl \
+	core/java/android/app/IAlarmManager.aidl \
+	core/java/android/app/IAppTask.aidl \
+	core/java/android/app/ITaskStackListener.aidl \
+	core/java/android/app/IBackupAgent.aidl \
+	core/java/android/app/IInstrumentationWatcher.aidl \
+	core/java/android/app/INotificationManager.aidl \
+	core/java/android/app/IProcessObserver.aidl \
+	core/java/android/app/ISearchManager.aidl \
+	core/java/android/app/ISearchManagerCallback.aidl \
+	core/java/android/app/IServiceConnection.aidl \
+	core/java/android/app/IStopUserCallback.aidl \
+	core/java/android/app/job/IJobCallback.aidl \
+	core/java/android/app/job/IJobScheduler.aidl \
+	core/java/android/app/job/IJobService.aidl \
+	core/java/android/app/ITransientNotification.aidl \
+	core/java/android/app/IUidObserver.aidl \
+	core/java/android/app/IUiAutomationConnection.aidl \
+	core/java/android/app/IUiModeManager.aidl \
+	core/java/android/app/IUserSwitchObserver.aidl \
+	core/java/android/app/IWallpaperManager.aidl \
+	core/java/android/app/IWallpaperManagerCallback.aidl \
+	core/java/android/app/admin/IDevicePolicyManager.aidl \
+	core/java/android/app/trust/IStrongAuthTracker.aidl \
+	core/java/android/app/trust/ITrustManager.aidl \
+	core/java/android/app/trust/ITrustListener.aidl \
+	core/java/android/app/backup/IBackupManager.aidl \
+	core/java/android/app/backup/IFullBackupRestoreObserver.aidl \
+	core/java/android/app/backup/IRestoreObserver.aidl \
+	core/java/android/app/backup/IRestoreSession.aidl \
+	core/java/android/app/usage/IUsageStatsManager.aidl \
+	core/java/android/bluetooth/IBluetooth.aidl \
+	core/java/android/bluetooth/IBluetoothA2dp.aidl \
+	core/java/android/bluetooth/IBluetoothA2dpSink.aidl \
+	core/java/android/bluetooth/IBluetoothAvrcpController.aidl \
+	core/java/android/bluetooth/IBluetoothCallback.aidl \
+	core/java/android/bluetooth/IBluetoothProfileServiceConnection.aidl \
+	core/java/android/bluetooth/IBluetoothHeadset.aidl \
+	core/java/android/bluetooth/IBluetoothHeadsetPhone.aidl \
+	core/java/android/bluetooth/IBluetoothHealth.aidl \
+	core/java/android/bluetooth/IBluetoothHealthCallback.aidl \
+	core/java/android/bluetooth/IBluetoothInputDevice.aidl \
+	core/java/android/bluetooth/IBluetoothPan.aidl \
+	core/java/android/bluetooth/IBluetoothManager.aidl \
+	core/java/android/bluetooth/IBluetoothManagerCallback.aidl \
+	core/java/android/bluetooth/IBluetoothPbap.aidl \
+	core/java/android/bluetooth/IBluetoothMap.aidl \
+	core/java/android/bluetooth/IBluetoothSap.aidl \
+	core/java/android/bluetooth/IBluetoothStateChangeCallback.aidl \
+	core/java/android/bluetooth/IBluetoothHeadsetClient.aidl \
+	core/java/android/bluetooth/IBluetoothGatt.aidl \
+	core/java/android/bluetooth/IBluetoothGattCallback.aidl \
+	core/java/android/bluetooth/IBluetoothGattServerCallback.aidl \
+	core/java/android/content/IClipboard.aidl \
+	core/java/android/content/IContentService.aidl \
+	core/java/android/content/IIntentReceiver.aidl \
+	core/java/android/content/IIntentSender.aidl \
+	core/java/android/content/IOnPrimaryClipChangedListener.aidl \
+	core/java/android/content/IRestrictionsManager.aidl \
+	core/java/android/content/ISyncAdapter.aidl \
+	core/java/android/content/ISyncContext.aidl \
+	core/java/android/content/ISyncServiceAdapter.aidl \
+	core/java/android/content/ISyncStatusObserver.aidl \
+	core/java/android/content/pm/ILauncherApps.aidl \
+	core/java/android/content/pm/IOnAppsChangedListener.aidl \
+	core/java/android/content/pm/IPackageDataObserver.aidl \
+	core/java/android/content/pm/IPackageDeleteObserver.aidl \
+	core/java/android/content/pm/IPackageDeleteObserver2.aidl \
+	core/java/android/content/pm/IPackageInstallObserver.aidl \
+	core/java/android/content/pm/IPackageInstallObserver2.aidl \
+	core/java/android/content/pm/IPackageInstaller.aidl \
+	core/java/android/content/pm/IPackageInstallerCallback.aidl \
+	core/java/android/content/pm/IPackageInstallerSession.aidl \
+	core/java/android/content/pm/IPackageManager.aidl \
+	core/java/android/content/pm/IPackageMoveObserver.aidl \
+	core/java/android/content/pm/IPackageStatsObserver.aidl \
+	core/java/android/content/pm/IOnPermissionsChangeListener.aidl \
+	core/java/android/database/IContentObserver.aidl \
+	core/java/android/hardware/ICameraService.aidl \
+	core/java/android/hardware/ICameraServiceListener.aidl \
+	core/java/android/hardware/ICameraServiceProxy.aidl \
+	core/java/android/hardware/ICamera.aidl \
+	core/java/android/hardware/ICameraClient.aidl \
+	core/java/android/hardware/IConsumerIrService.aidl \
+	core/java/android/hardware/camera2/ICameraDeviceUser.aidl \
+	core/java/android/hardware/camera2/ICameraDeviceCallbacks.aidl \
+	core/java/android/hardware/ISerialManager.aidl \
+	core/java/android/hardware/display/IDisplayManager.aidl \
+	core/java/android/hardware/display/IDisplayManagerCallback.aidl \
+	core/java/android/hardware/display/IVirtualDisplayCallback.aidl \
+	core/java/android/hardware/fingerprint/IFingerprintDaemon.aidl \
+	core/java/android/hardware/fingerprint/IFingerprintDaemonCallback.aidl \
+	core/java/android/hardware/fingerprint/IFingerprintService.aidl \
+	core/java/android/hardware/fingerprint/IFingerprintServiceLockoutResetCallback.aidl \
+	core/java/android/hardware/fingerprint/IFingerprintServiceReceiver.aidl \
+	core/java/android/hardware/hdmi/IHdmiControlCallback.aidl \
+	core/java/android/hardware/hdmi/IHdmiControlService.aidl \
+	core/java/android/hardware/hdmi/IHdmiDeviceEventListener.aidl \
+	core/java/android/hardware/hdmi/IHdmiHotplugEventListener.aidl \
+	core/java/android/hardware/hdmi/IHdmiInputChangeListener.aidl \
+	core/java/android/hardware/hdmi/IHdmiMhlVendorCommandListener.aidl \
+	core/java/android/hardware/hdmi/IHdmiRecordListener.aidl \
+	core/java/android/hardware/hdmi/IHdmiSystemAudioModeChangeListener.aidl \
+	core/java/android/hardware/hdmi/IHdmiVendorCommandListener.aidl \
+	core/java/android/hardware/input/IInputManager.aidl \
+	core/java/android/hardware/input/IInputDevicesChangedListener.aidl \
+	core/java/android/hardware/input/ITabletModeChangedListener.aidl \
+	core/java/android/hardware/location/IActivityRecognitionHardware.aidl \
+	core/java/android/hardware/location/IActivityRecognitionHardwareClient.aidl \
+	core/java/android/hardware/location/IActivityRecognitionHardwareSink.aidl \
+	core/java/android/hardware/location/IActivityRecognitionHardwareWatcher.aidl \
+	core/java/android/hardware/location/IFusedLocationHardware.aidl \
+	core/java/android/hardware/location/IFusedLocationHardwareSink.aidl \
+	core/java/android/hardware/location/IGeofenceHardware.aidl \
+	core/java/android/hardware/location/IGeofenceHardwareCallback.aidl \
+	core/java/android/hardware/location/IGeofenceHardwareMonitorCallback.aidl \
+	core/java/android/hardware/soundtrigger/IRecognitionStatusCallback.aidl \
+	core/java/android/hardware/usb/IUsbManager.aidl \
+	core/java/android/net/ICaptivePortal.aidl \
+	core/java/android/net/IConnectivityManager.aidl \
+	core/java/android/net/IEthernetManager.aidl \
+	core/java/android/net/IEthernetServiceListener.aidl \
+	core/java/android/net/INetworkManagementEventObserver.aidl \
+	core/java/android/net/INetworkPolicyListener.aidl \
+	core/java/android/net/INetworkPolicyManager.aidl \
+	core/java/android/net/INetworkScoreCache.aidl \
+	core/java/android/net/INetworkScoreService.aidl \
+	core/java/android/net/INetworkStatsService.aidl \
+	core/java/android/net/INetworkStatsSession.aidl \
+	core/java/android/net/nsd/INsdManager.aidl \
+	core/java/android/nfc/IAppCallback.aidl \
+	core/java/android/nfc/INfcAdapter.aidl \
+	core/java/android/nfc/INfcAdapterExtras.aidl \
+	core/java/android/nfc/INfcTag.aidl \
+	core/java/android/nfc/INfcCardEmulation.aidl \
+	core/java/android/nfc/INfcUnlockHandler.aidl \
+	core/java/android/os/IBatteryPropertiesListener.aidl \
+	core/java/android/os/IBatteryPropertiesRegistrar.aidl \
+	core/java/android/os/ICancellationSignal.aidl \
+	core/java/android/os/IDeviceIdleController.aidl \
+	core/java/android/os/IMessenger.aidl \
+	core/java/android/os/INetworkActivityListener.aidl \
+	core/java/android/os/INetworkManagementService.aidl \
+	core/java/android/os/IPermissionController.aidl \
+	core/java/android/os/IProcessInfoService.aidl \
+	core/java/android/os/IPowerManager.aidl \
+	core/java/android/os/IRemoteCallback.aidl \
+	core/java/android/os/ISchedulingPolicyService.aidl \
+	core/java/android/os/IUpdateLock.aidl \
+	core/java/android/os/IUserManager.aidl \
+	core/java/android/os/IVibratorService.aidl \
+	core/java/android/security/IKeystoreService.aidl \
+	core/java/android/service/carrier/ICarrierService.aidl \
+	core/java/android/service/carrier/ICarrierMessagingCallback.aidl \
+	core/java/android/service/carrier/ICarrierMessagingService.aidl \
+	core/java/android/service/gatekeeper/IGateKeeperService.aidl \
+	core/java/android/service/notification/INotificationListener.aidl \
+	core/java/android/service/notification/IStatusBarNotificationHolder.aidl \
+	core/java/android/service/notification/IConditionListener.aidl \
+	core/java/android/service/notification/IConditionProvider.aidl \
+	core/java/android/print/ILayoutResultCallback.aidl \
+	core/java/android/print/IPrinterDiscoveryObserver.aidl \
+	core/java/android/print/IPrintDocumentAdapter.aidl \
+	core/java/android/print/IPrintDocumentAdapterObserver.aidl \
+	core/java/android/print/IPrintJobStateChangeListener.aidl \
+	core/java/android/print/IPrintManager.aidl \
+	core/java/android/print/IPrintSpooler.aidl \
+	core/java/android/print/IPrintSpoolerCallbacks.aidl \
+	core/java/android/print/IPrintSpoolerClient.aidl \
+	core/java/android/print/IWriteResultCallback.aidl \
+	core/java/android/printservice/IPrintService.aidl \
+	core/java/android/printservice/IPrintServiceClient.aidl \
+	core/java/android/service/dreams/IDreamManager.aidl \
+	core/java/android/service/dreams/IDreamService.aidl \
+	core/java/android/service/persistentdata/IPersistentDataBlockService.aidl \
+	core/java/android/service/trust/ITrustAgentService.aidl \
+	core/java/android/service/trust/ITrustAgentServiceCallback.aidl \
+	core/java/android/service/voice/IVoiceInteractionService.aidl \
+	core/java/android/service/voice/IVoiceInteractionSession.aidl \
+	core/java/android/service/voice/IVoiceInteractionSessionService.aidl \
+	core/java/android/service/wallpaper/IWallpaperConnection.aidl \
+	core/java/android/service/wallpaper/IWallpaperEngine.aidl \
+	core/java/android/service/wallpaper/IWallpaperService.aidl \
+	core/java/android/service/chooser/IChooserTargetService.aidl \
+	core/java/android/service/chooser/IChooserTargetResult.aidl \
+	core/java/android/view/accessibility/IAccessibilityInteractionConnection.aidl\
+	core/java/android/view/accessibility/IAccessibilityInteractionConnectionCallback.aidl\
+	core/java/android/view/accessibility/IAccessibilityManager.aidl \
+	core/java/android/view/accessibility/IAccessibilityManagerClient.aidl \
+	core/java/android/view/IApplicationToken.aidl \
+	core/java/android/view/IAssetAtlas.aidl \
+	core/java/android/view/IGraphicsStats.aidl \
+	core/java/android/view/IInputFilter.aidl \
+	core/java/android/view/IInputFilterHost.aidl \
+	core/java/android/view/IOnKeyguardExitResult.aidl \
+	core/java/android/view/IRotationWatcher.aidl \
+	core/java/android/view/IWindow.aidl \
+	core/java/android/view/IWindowFocusObserver.aidl \
+	core/java/android/view/IWindowId.aidl \
+	core/java/android/view/IWindowManager.aidl \
+	core/java/android/view/IWindowSession.aidl \
+	core/java/android/view/IWindowSessionCallback.aidl \
+	core/java/android/webkit/IWebViewUpdateService.aidl \
+	core/java/android/speech/IRecognitionListener.aidl \
+	core/java/android/speech/IRecognitionService.aidl \
+	core/java/android/speech/tts/ITextToSpeechCallback.aidl \
+	core/java/android/speech/tts/ITextToSpeechService.aidl \
+	core/java/com/android/internal/app/IAppOpsCallback.aidl \
+	core/java/com/android/internal/app/IAppOpsService.aidl \
+	core/java/com/android/internal/app/IAssistScreenshotReceiver.aidl \
+	core/java/com/android/internal/app/IBatteryStats.aidl \
+	core/java/com/android/internal/app/IProcessStats.aidl \
+	core/java/com/android/internal/app/IVoiceInteractionManagerService.aidl \
+	core/java/com/android/internal/app/IVoiceInteractionSessionShowCallback.aidl \
+	core/java/com/android/internal/app/IVoiceInteractor.aidl \
+	core/java/com/android/internal/app/IVoiceInteractorCallback.aidl \
+	core/java/com/android/internal/app/IVoiceInteractorRequest.aidl \
+	core/java/com/android/internal/app/IMediaContainerService.aidl \
+	core/java/com/android/internal/appwidget/IAppWidgetService.aidl \
+	core/java/com/android/internal/appwidget/IAppWidgetHost.aidl \
+	core/java/com/android/internal/backup/IBackupTransport.aidl \
+	core/java/com/android/internal/backup/IObbBackupService.aidl \
+	core/java/com/android/internal/policy/IKeyguardDrawnCallback.aidl \
+	core/java/com/android/internal/policy/IKeyguardExitCallback.aidl \
+	core/java/com/android/internal/policy/IKeyguardService.aidl \
+	core/java/com/android/internal/policy/IKeyguardStateCallback.aidl \
+	core/java/com/android/internal/os/IDropBoxManagerService.aidl \
+	core/java/com/android/internal/os/IParcelFileDescriptorFactory.aidl \
+	core/java/com/android/internal/os/IResultReceiver.aidl \
+	core/java/com/android/internal/statusbar/IStatusBar.aidl \
+	core/java/com/android/internal/statusbar/IStatusBarService.aidl \
+	core/java/com/android/internal/textservice/ISpellCheckerService.aidl \
+	core/java/com/android/internal/textservice/ISpellCheckerSession.aidl \
+	core/java/com/android/internal/textservice/ISpellCheckerSessionListener.aidl \
+	core/java/com/android/internal/textservice/ITextServicesManager.aidl \
+	core/java/com/android/internal/textservice/ITextServicesSessionListener.aidl \
+	core/java/com/android/internal/view/IInputContext.aidl \
+	core/java/com/android/internal/view/IInputContextCallback.aidl \
+	core/java/com/android/internal/view/IInputMethod.aidl \
+	core/java/com/android/internal/view/IInputMethodClient.aidl \
+	core/java/com/android/internal/view/IInputMethodManager.aidl \
+	core/java/com/android/internal/view/IInputMethodSession.aidl \
+	core/java/com/android/internal/view/IInputSessionCallback.aidl \
+	core/java/com/android/internal/widget/ILockSettings.aidl \
+	core/java/com/android/internal/widget/IRemoteViewsFactory.aidl \
+	core/java/com/android/internal/widget/IRemoteViewsAdapterConnection.aidl \
+	keystore/java/android/security/IKeyChainAliasCallback.aidl \
+	keystore/java/android/security/IKeyChainService.aidl \
+	location/java/android/location/ICountryDetector.aidl \
+	location/java/android/location/ICountryListener.aidl \
+	location/java/android/location/IFusedProvider.aidl \
+	location/java/android/location/IGeocodeProvider.aidl \
+	location/java/android/location/IGeofenceProvider.aidl \
+	location/java/android/location/IGpsMeasurementsListener.aidl \
+	location/java/android/location/IGpsNavigationMessageListener.aidl \
+	location/java/android/location/IGpsStatusListener.aidl \
+	location/java/android/location/IGpsStatusProvider.aidl \
+	location/java/android/location/ILocationListener.aidl \
+	location/java/android/location/ILocationManager.aidl \
+	location/java/android/location/IFusedGeofenceHardware.aidl \
+	location/java/android/location/IGpsGeofenceHardware.aidl \
+	location/java/android/location/INetInitiatedListener.aidl \
+	location/java/com/android/internal/location/ILocationProvider.aidl \
+	media/java/android/media/IAudioService.aidl \
+	media/java/android/media/IAudioFocusDispatcher.aidl \
+	media/java/android/media/IAudioRoutesObserver.aidl \
+	media/java/android/media/IMediaHTTPConnection.aidl \
+	media/java/android/media/IMediaHTTPService.aidl \
+	media/java/android/media/IMediaRouterClient.aidl \
+	media/java/android/media/IMediaRouterService.aidl \
+	media/java/android/media/IMediaScannerListener.aidl \
+	media/java/android/media/IMediaScannerService.aidl \
+	media/java/android/media/IRemoteControlClient.aidl \
+	media/java/android/media/IRemoteControlDisplay.aidl \
+	media/java/android/media/IRemoteDisplayCallback.aidl \
+	media/java/android/media/IRemoteDisplayProvider.aidl \
+	media/java/android/media/IRemoteVolumeController.aidl \
+	media/java/android/media/IRemoteVolumeObserver.aidl \
+	media/java/android/media/IRingtonePlayer.aidl \
+	media/java/android/media/IVolumeController.aidl \
+	media/java/android/media/audiopolicy/IAudioPolicyCallback.aidl \
+	media/java/android/media/midi/IBluetoothMidiService.aidl \
+	media/java/android/media/midi/IMidiDeviceListener.aidl \
+	media/java/android/media/midi/IMidiDeviceOpenCallback.aidl \
+	media/java/android/media/midi/IMidiDeviceServer.aidl \
+	media/java/android/media/midi/IMidiManager.aidl \
+	media/java/android/media/projection/IMediaProjection.aidl \
+	media/java/android/media/projection/IMediaProjectionCallback.aidl \
+	media/java/android/media/projection/IMediaProjectionManager.aidl \
+	media/java/android/media/projection/IMediaProjectionWatcherCallback.aidl \
+	media/java/android/media/session/IActiveSessionsListener.aidl \
+	media/java/android/media/session/ISessionController.aidl \
+	media/java/android/media/session/ISessionControllerCallback.aidl \
+	media/java/android/media/session/ISession.aidl \
+	media/java/android/media/session/ISessionCallback.aidl \
+	media/java/android/media/session/ISessionManager.aidl \
+	media/java/android/media/tv/ITvInputClient.aidl \
+	media/java/android/media/tv/ITvInputHardware.aidl \
+	media/java/android/media/tv/ITvInputHardwareCallback.aidl \
+	media/java/android/media/tv/ITvInputManager.aidl \
+	media/java/android/media/tv/ITvInputManagerCallback.aidl \
+	media/java/android/media/tv/ITvInputService.aidl \
+	media/java/android/media/tv/ITvInputServiceCallback.aidl \
+	media/java/android/media/tv/ITvInputSession.aidl \
+	media/java/android/media/tv/ITvInputSessionCallback.aidl \
+	media/java/android/service/media/IMediaBrowserService.aidl \
+	media/java/android/service/media/IMediaBrowserServiceCallbacks.aidl \
+	telecomm/java/com/android/internal/telecom/IVideoCallback.aidl \
+	telecomm/java/com/android/internal/telecom/IVideoProvider.aidl \
+	telecomm/java/com/android/internal/telecom/IConnectionService.aidl \
+	telecomm/java/com/android/internal/telecom/IConnectionServiceAdapter.aidl \
+	telecomm/java/com/android/internal/telecom/IInCallAdapter.aidl \
+	telecomm/java/com/android/internal/telecom/IInCallService.aidl \
+	telecomm/java/com/android/internal/telecom/ITelecomService.aidl \
+	telecomm/java/com/android/internal/telecom/RemoteServiceCallback.aidl \
+	telephony/java/com/android/ims/internal/IImsCallSession.aidl \
+	telephony/java/com/android/ims/internal/IImsCallSessionListener.aidl \
+	telephony/java/com/android/ims/internal/IImsConfig.aidl \
+	telephony/java/com/android/ims/internal/IImsRegistrationListener.aidl \
+	telephony/java/com/android/ims/internal/IImsEcbm.aidl \
+	telephony/java/com/android/ims/internal/IImsEcbmListener.aidl \
+	telephony/java/com/android/ims/internal/IImsService.aidl \
+	telephony/java/com/android/ims/internal/IImsStreamMediaSession.aidl \
+	telephony/java/com/android/ims/internal/IImsUt.aidl \
+	telephony/java/com/android/ims/internal/IImsUtListener.aidl \
+	telephony/java/com/android/ims/internal/IImsVideoCallCallback.aidl \
+	telephony/java/com/android/ims/internal/IImsVideoCallProvider.aidl \
+	telephony/java/com/android/ims/ImsConfigListener.aidl \
+	telephony/java/com/android/internal/telephony/ICarrierConfigLoader.aidl \
+	telephony/java/com/android/internal/telephony/IMms.aidl \
+	telephony/java/com/android/internal/telephony/IOnSubscriptionsChangedListener.aidl \
+	telephony/java/com/android/internal/telephony/IPhoneStateListener.aidl \
+	telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
+	telephony/java/com/android/internal/telephony/ISms.aidl \
+	telephony/java/com/android/internal/telephony/ISub.aidl \
+	telephony/java/com/android/internal/telephony/ITelephony.aidl \
+	telephony/java/com/android/internal/telephony/ITelephonyRegistry.aidl \
+	telephony/java/com/android/internal/telephony/IWapPushManager.aidl \
+        telephony/java/com/android/internal/telephony/IExtTelephony.aidl \
+	wifi/java/android/net/wifi/IWifiManager.aidl \
+	wifi/java/android/net/wifi/passpoint/IWifiPasspointManager.aidl \
+	wifi/java/android/net/wifi/p2p/IWifiP2pManager.aidl \
+	wifi/java/android/net/wifi/IWifiScanner.aidl \
+	wifi/java/android/net/wifi/IRttManager.aidl \
+	packages/services/PacProcessor/com/android/net/IProxyService.aidl \
+	packages/services/Proxy/com/android/net/IProxyCallback.aidl \
+	packages/services/Proxy/com/android/net/IProxyPortListener.aidl \
+
+	core/java/com/mediatek/gba/IGbaService.aidl \	telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl \ 	telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallCallback.aidl \    	telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallProvider.aidl \
+
+# FRAMEWORKS_BASE_JAVA_SRC_DIRS comes from build/core/pathmap.mk
+LOCAL_AIDL_INCLUDES += $(FRAMEWORKS_BASE_JAVA_SRC_DIRS)
+
+LOCAL_INTERMEDIATE_SOURCES := \
+			$(framework_res_source_path)/android/R.java \
+			$(framework_res_source_path)/android/Manifest.java \
+			$(framework_res_source_path)/com/android/internal/R.java
+
+LOCAL_NO_STANDARD_LIBRARIES := true
+LOCAL_JAVA_LIBRARIES := core-libart conscrypt okhttp core-junit bouncycastle ext
+
+LOCAL_MODULE := framework
+
+LOCAL_DX_FLAGS := --core-library --multi-dex
+LOCAL_JACK_FLAGS := --multi-dex native
+
+LOCAL_RMTYPEDEFS := true
+
+include $(BUILD_JAVA_LIBRARY)
+framework_module := $(LOCAL_INSTALLED_MODULE)
+
+# Make sure that R.java and Manifest.java are built before we build
+# the source for this library.
+framework_res_R_stamp := \
+	$(call intermediates-dir-for,APPS,framework-res,,COMMON)/src/R.stamp
+$(full_classes_compiled_jar): $(framework_res_R_stamp)
+$(built_dex_intermediate): $(framework_res_R_stamp)
+
+$(framework_module): | $(dir $(framework_module))framework-res.apk
+
+framework_built := $(call java-lib-deps,framework)
+
+# Copy AIDL files to be preprocessed and included in the SDK,
+# specified relative to the root of the build tree.
+# ============================================================
+include $(CLEAR_VARS)
+
+aidl_files := \
+	frameworks/base/telephony/java/android/telephony/ServiceState.aidl \
+	frameworks/base/telephony/java/android/telephony/SubscriptionInfo.aidl \
+	frameworks/base/telephony/java/android/telephony/CellInfo.aidl \
+	frameworks/base/telephony/java/android/telephony/SignalStrength.aidl \
+	frameworks/base/telephony/java/android/telephony/IccOpenLogicalChannelResponse.aidl \
+	frameworks/base/telephony/java/android/telephony/NeighboringCellInfo.aidl \
+	frameworks/base/telephony/java/android/telephony/ModemActivityInfo.aidl \
+	frameworks/base/location/java/android/location/Location.aidl \
+	frameworks/base/location/java/android/location/Address.aidl \
+	frameworks/base/location/java/android/location/Criteria.aidl \
+	frameworks/base/media/java/android/media/MediaMetadata.aidl \
+	frameworks/base/media/java/android/media/MediaDescription.aidl \
+	frameworks/base/media/java/android/media/Rating.aidl \
+	frameworks/base/media/java/android/media/AudioAttributes.aidl \
+	frameworks/base/media/java/android/media/AudioFocusInfo.aidl \
+	frameworks/base/media/java/android/media/session/PlaybackState.aidl \
+	frameworks/base/media/java/android/media/session/MediaSession.aidl \
+	frameworks/base/media/java/android/media/tv/TvInputInfo.aidl \
+	frameworks/base/media/java/android/media/tv/TvTrackInfo.aidl \
+	frameworks/base/media/java/android/media/browse/MediaBrowser.aidl \
+	frameworks/base/wifi/java/android/net/wifi/ScanSettings.aidl \
+	frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pInfo.aidl \
+	frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pDeviceList.aidl \
+	frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pConfig.aidl \
+	frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pDevice.aidl \
+	frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pGroup.aidl \
+	frameworks/base/wifi/java/android/net/wifi/p2p/nsd/WifiP2pServiceRequest.aidl \
+	frameworks/base/wifi/java/android/net/wifi/p2p/nsd/WifiP2pServiceInfo.aidl \
+	frameworks/base/wifi/java/android/net/wifi/WpsInfo.aidl \
+	frameworks/base/wifi/java/android/net/wifi/ScanResult.aidl \
+	frameworks/base/wifi/java/android/net/wifi/WifiEnterpriseConfig.aidl \
+	frameworks/base/wifi/java/android/net/wifi/WifiConfiguration.aidl \
+	frameworks/base/wifi/java/android/net/wifi/WifiInfo.aidl \
+	frameworks/base/graphics/java/android/graphics/Region.aidl \
+	frameworks/base/graphics/java/android/graphics/Bitmap.aidl \
+	frameworks/base/graphics/java/android/graphics/Point.aidl \
+	frameworks/base/graphics/java/android/graphics/PointF.aidl \
+	frameworks/base/graphics/java/android/graphics/RectF.aidl \
+	frameworks/base/graphics/java/android/graphics/Rect.aidl \
+	frameworks/base/core/java/android/accounts/AuthenticatorDescription.aidl \
+	frameworks/base/core/java/android/accounts/Account.aidl \
+	frameworks/base/core/java/android/app/admin/SystemUpdatePolicy.aidl \
+	frameworks/base/core/java/android/print/PrintDocumentInfo.aidl \
+	frameworks/base/core/java/android/print/PageRange.aidl \
+	frameworks/base/core/java/android/print/PrintAttributes.aidl \
+	frameworks/base/core/java/android/print/PrinterCapabilitiesInfo.aidl \
+	frameworks/base/core/java/android/print/PrinterId.aidl \
+	frameworks/base/core/java/android/print/PrintJobInfo.aidl \
+	frameworks/base/core/java/android/print/PrinterInfo.aidl \
+	frameworks/base/core/java/android/print/PrintJobId.aidl \
+	frameworks/base/core/java/android/hardware/usb/UsbDevice.aidl \
+	frameworks/base/core/java/android/hardware/usb/UsbInterface.aidl \
+	frameworks/base/core/java/android/hardware/usb/UsbEndpoint.aidl \
+	frameworks/base/core/java/android/hardware/usb/UsbAccessory.aidl \
+	frameworks/base/core/java/android/os/Messenger.aidl \
+	frameworks/base/core/java/android/os/PatternMatcher.aidl \
+	frameworks/base/core/java/android/os/Message.aidl \
+	frameworks/base/core/java/android/os/UserHandle.aidl \
+	frameworks/base/core/java/android/os/ParcelUuid.aidl \
+	frameworks/base/core/java/android/os/ParcelFileDescriptor.aidl \
+	frameworks/base/core/java/android/os/ResultReceiver.aidl \
+	frameworks/base/core/java/android/os/PersistableBundle.aidl \
+	frameworks/base/core/java/android/os/WorkSource.aidl \
+	frameworks/base/core/java/android/os/DropBoxManager.aidl \
+	frameworks/base/core/java/android/os/Bundle.aidl \
+	frameworks/base/core/java/android/accessibilityservice/AccessibilityServiceInfo.aidl \
+	frameworks/base/core/java/android/net/Network.aidl \
+	frameworks/base/core/java/android/net/RouteInfo.aidl \
+	frameworks/base/core/java/android/net/NetworkInfo.aidl \
+	frameworks/base/core/java/android/net/IpPrefix.aidl \
+	frameworks/base/core/java/android/net/NetworkCapabilities.aidl \
+	frameworks/base/core/java/android/net/DhcpInfo.aidl \
+	frameworks/base/core/java/android/net/ProxyInfo.aidl \
+	frameworks/base/core/java/android/net/LinkProperties.aidl \
+	frameworks/base/core/java/android/net/Uri.aidl \
+	frameworks/base/core/java/android/net/NetworkRequest.aidl \
+	frameworks/base/core/java/android/net/LinkAddress.aidl \
+	frameworks/base/core/java/android/view/Display.aidl \
+	frameworks/base/core/java/android/view/InputDevice.aidl \
+	frameworks/base/core/java/android/view/InputEvent.aidl \
+	frameworks/base/core/java/android/view/Surface.aidl \
+	frameworks/base/core/java/android/view/WindowContentFrameStats.aidl \
+	frameworks/base/core/java/android/view/inputmethod/InputMethodSubtype.aidl \
+	frameworks/base/core/java/android/view/inputmethod/CursorAnchorInfo.aidl \
+	frameworks/base/core/java/android/view/inputmethod/CompletionInfo.aidl \
+	frameworks/base/core/java/android/view/inputmethod/ExtractedText.aidl \
+	frameworks/base/core/java/android/view/inputmethod/EditorInfo.aidl \
+	frameworks/base/core/java/android/view/inputmethod/InputMethodInfo.aidl \
+	frameworks/base/core/java/android/view/inputmethod/CorrectionInfo.aidl \
+	frameworks/base/core/java/android/view/inputmethod/InputBinding.aidl \
+	frameworks/base/core/java/android/view/inputmethod/ExtractedTextRequest.aidl \
+	frameworks/base/core/java/android/view/DragEvent.aidl \
+	frameworks/base/core/java/android/view/KeyEvent.aidl \
+	frameworks/base/core/java/android/view/WindowManager.aidl \
+	frameworks/base/core/java/android/view/WindowAnimationFrameStats.aidl \
+	frameworks/base/core/java/android/view/MotionEvent.aidl \
+	frameworks/base/core/java/android/view/accessibility/AccessibilityNodeInfo.aidl \
+	frameworks/base/core/java/android/view/accessibility/AccessibilityRecord.aidl \
+	frameworks/base/core/java/android/view/accessibility/AccessibilityWindowInfo.aidl \
+	frameworks/base/core/java/android/view/accessibility/AccessibilityEvent.aidl \
+	frameworks/base/core/java/android/view/textservice/SpellCheckerSubtype.aidl \
+	frameworks/base/core/java/android/view/textservice/TextInfo.aidl \
+	frameworks/base/core/java/android/view/textservice/SpellCheckerInfo.aidl \
+	frameworks/base/core/java/android/view/textservice/SentenceSuggestionsInfo.aidl \
+	frameworks/base/core/java/android/view/textservice/SuggestionsInfo.aidl \
+	frameworks/base/core/java/android/service/carrier/CarrierIdentifier.aidl \
+	frameworks/base/core/java/android/service/carrier/MessagePdu.aidl \
+	frameworks/base/core/java/android/service/notification/StatusBarNotification.aidl \
+	frameworks/base/core/java/android/service/chooser/ChooserTarget.aidl \
+	frameworks/base/core/java/android/speech/tts/Voice.aidl \
+	frameworks/base/core/java/android/app/usage/UsageEvents.aidl \
+	frameworks/base/core/java/android/app/Notification.aidl \
+	frameworks/base/core/java/android/app/NotificationManager.aidl \
+	frameworks/base/core/java/android/app/WallpaperInfo.aidl \
+	frameworks/base/core/java/android/app/AppOpsManager.aidl \
+	frameworks/base/core/java/android/app/ActivityManager.aidl \
+	frameworks/base/core/java/android/app/PendingIntent.aidl \
+	frameworks/base/core/java/android/app/AlarmManager.aidl \
+	frameworks/base/core/java/android/app/SearchableInfo.aidl \
+	frameworks/base/core/java/android/app/VoiceInteractor.aidl \
+	frameworks/base/core/java/android/app/assist/AssistContent.aidl \
+	frameworks/base/core/java/android/app/assist/AssistStructure.aidl \
+	frameworks/base/core/java/android/app/job/JobParameters.aidl \
+	frameworks/base/core/java/android/app/job/JobInfo.aidl \
+	frameworks/base/core/java/android/appwidget/AppWidgetProviderInfo.aidl \
+	frameworks/base/core/java/android/content/ClipDescription.aidl \
+	frameworks/base/core/java/android/content/IntentFilter.aidl \
+	frameworks/base/core/java/android/content/Intent.aidl \
+	frameworks/base/core/java/android/content/res/Configuration.aidl \
+	frameworks/base/core/java/android/content/res/ObbInfo.aidl \
+	frameworks/base/core/java/android/content/RestrictionEntry.aidl \
+	frameworks/base/core/java/android/content/ClipData.aidl \
+	frameworks/base/core/java/android/content/SyncAdapterType.aidl \
+	frameworks/base/core/java/android/content/SyncRequest.aidl \
+	frameworks/base/core/java/android/content/PeriodicSync.aidl \
+	frameworks/base/core/java/android/content/SyncResult.aidl \
+	frameworks/base/core/java/android/content/pm/FeatureInfo.aidl \
+	frameworks/base/core/java/android/content/pm/InstrumentationInfo.aidl \
+	frameworks/base/core/java/android/content/pm/PackageInstaller.aidl \
+	frameworks/base/core/java/android/content/pm/ServiceInfo.aidl \
+	frameworks/base/core/java/android/content/pm/Signature.aidl \
+	frameworks/base/core/java/android/content/pm/ApplicationInfo.aidl \
+	frameworks/base/core/java/android/content/pm/PermissionInfo.aidl \
+	frameworks/base/core/java/android/content/pm/ActivityInfo.aidl \
+	frameworks/base/core/java/android/content/pm/PackageInfo.aidl \
+	frameworks/base/core/java/android/content/pm/ResolveInfo.aidl \
+	frameworks/base/core/java/android/content/pm/ProviderInfo.aidl \
+	frameworks/base/core/java/android/content/pm/PackageStats.aidl \
+	frameworks/base/core/java/android/content/pm/PermissionGroupInfo.aidl \
+	frameworks/base/core/java/android/content/pm/LabeledIntent.aidl \
+	frameworks/base/core/java/android/content/ComponentName.aidl \
+	frameworks/base/core/java/android/content/SyncStats.aidl \
+	frameworks/base/core/java/android/content/ContentValues.aidl \
+	frameworks/base/core/java/android/content/SyncInfo.aidl \
+	frameworks/base/core/java/android/content/IntentSender.aidl \
+	frameworks/base/core/java/android/widget/RemoteViews.aidl \
+	frameworks/base/core/java/android/text/style/SuggestionSpan.aidl \
+	frameworks/base/core/java/android/nfc/Tag.aidl \
+	frameworks/base/core/java/android/nfc/NdefRecord.aidl \
+	frameworks/base/core/java/android/nfc/NdefMessage.aidl \
+	frameworks/base/core/java/android/bluetooth/BluetoothHealthAppConfiguration.aidl \
+	frameworks/base/core/java/android/bluetooth/le/AdvertiseSettings.aidl \
+	frameworks/base/core/java/android/bluetooth/le/ScanSettings.aidl \
+	frameworks/base/core/java/android/bluetooth/le/AdvertiseData.aidl \
+	frameworks/base/core/java/android/bluetooth/le/ScanFilter.aidl \
+	frameworks/base/core/java/android/bluetooth/le/ScanResult.aidl \
+	frameworks/base/core/java/android/bluetooth/BluetoothDevice.aidl \
+	frameworks/base/core/java/android/database/CursorWindow.aidl \
+
+gen := $(TARGET_OUT_COMMON_INTERMEDIATES)/framework.aidl
+$(gen): PRIVATE_SRC_FILES := $(aidl_files)
+ALL_SDK_FILES += $(gen)
+$(gen): $(aidl_files) | $(AIDL)
+		@echo Aidl Preprocess: $@
+		$(hide) $(AIDL) --preprocess $@ $(PRIVATE_SRC_FILES)
+
+# the documentation
+# ============================================================
+
+# TODO: deal with com/google/android/googleapps
+packages_to_document := \
+	android \
+	javax/microedition/khronos \
+	org/apache/http/conn \
+	org/apache/http/params
+
+
+# Search through the base framework dirs for these packages.
+# The result will be relative to frameworks/base.
+fwbase_dirs_to_document := \
+	test-runner/src \
+	$(patsubst $(LOCAL_PATH)/%,%, \
+	  $(wildcard \
+	    $(foreach dir, $(FRAMEWORKS_BASE_JAVA_SRC_DIRS), \
+	      $(addprefix $(dir)/, $(packages_to_document)) \
+	     ) \
+	   ) \
+	 )
+
+# include definition of libcore_to_document
+include libcore/Docs.mk
+
+# include definition of junit_to_document
+include external/junit/Common.mk
+
+non_base_dirs := \
+	../opt/telephony/src/java/android/provider \
+	../opt/telephony/src/java/android/telephony \
+	../opt/telephony/src/java/android/telephony/gsm \
+	../opt/net/voip/src/java/android/net/rtp \
+	../opt/net/voip/src/java/android/net/sip
+
+# These are relative to frameworks/base
+dirs_to_check_apis := \
+  $(fwbase_dirs_to_document) \
+	$(non_base_dirs)
+
+# These are relative to frameworks/base
+# FRAMEWORKS_BASE_SUBDIRS comes from build/core/pathmap.mk
+dirs_to_document := \
+	$(dirs_to_check_apis) \
+  $(addprefix ../../, $(FRAMEWORKS_DATA_BINDING_JAVA_SRC_DIRS)) \
+  $(addprefix ../../, $(FRAMEWORKS_SUPPORT_JAVA_SRC_DIRS)) \
+
+# These are relative to frameworks/base
+html_dirs := \
+	$(FRAMEWORKS_BASE_SUBDIRS) \
+	$(non_base_dirs)
+
+# Common sources for doc check and api check
+common_src_files := \
+	$(call find-other-html-files, $(html_dirs)) \
+	$(addprefix ../../libcore/, $(libcore_to_document)) \
+	$(addprefix ../../external/junit/, $(junit_to_document))
+
+# These are relative to frameworks/base
+framework_docs_LOCAL_SRC_FILES := \
+	$(call find-other-java-files, $(dirs_to_document)) \
+	$(common_src_files)
+
+# These are relative to frameworks/base
+framework_docs_LOCAL_API_CHECK_SRC_FILES := \
+	$(call find-other-java-files, $(dirs_to_check_apis)) \
+	$(common_src_files)
+
+# This is used by ide.mk as the list of source files that are
+# always included.
+INTERNAL_SDK_SOURCE_DIRS := $(addprefix $(LOCAL_PATH)/,$(dirs_to_document))
+
+framework_docs_LOCAL_DROIDDOC_SOURCE_PATH := \
+	$(FRAMEWORKS_BASE_JAVA_SRC_DIRS)
+
+framework_docs_LOCAL_INTERMEDIATE_SOURCES := \
+	$(framework_res_source_path)/android/R.java \
+	$(framework_res_source_path)/android/Manifest.java \
+	$(framework_res_source_path)/com/android/internal/R.java
+
+framework_docs_LOCAL_API_CHECK_JAVA_LIBRARIES := \
+	core-libart \
+	conscrypt \
+	bouncycastle \
+	okhttp \
+	ext \
+	framework \
+	telephony-common \
+	voip-common
+
+framework_docs_LOCAL_JAVA_LIBRARIES := \
+	$(framework_docs_LOCAL_API_CHECK_JAVA_LIBRARIES) \
+	$(FRAMEWORKS_SUPPORT_JAVA_LIBRARIES)
+
+framework_docs_LOCAL_MODULE_CLASS := JAVA_LIBRARIES
+framework_docs_LOCAL_DROIDDOC_HTML_DIR := docs/html
+# The since flag (-since N.xml API_LEVEL) is used to add API Level information
+# to the reference documentation. Must be in order of oldest to newest.
+#
+# Conscrypt (com.android.org.conscrypt) is an implementation detail and should
+# not be referenced in the documentation.
+framework_docs_LOCAL_DROIDDOC_OPTIONS := \
+    -knowntags ./frameworks/base/docs/knowntags.txt \
+    -hidePackage com.android.org.conscrypt \
+    -since $(SRC_API_DIR)/1.xml 1 \
+    -since $(SRC_API_DIR)/2.xml 2 \
+    -since $(SRC_API_DIR)/3.xml 3 \
+    -since $(SRC_API_DIR)/4.xml 4 \
+    -since $(SRC_API_DIR)/5.xml 5 \
+    -since $(SRC_API_DIR)/6.xml 6 \
+    -since $(SRC_API_DIR)/7.xml 7 \
+    -since $(SRC_API_DIR)/8.xml 8 \
+    -since $(SRC_API_DIR)/9.xml 9 \
+    -since $(SRC_API_DIR)/10.xml 10 \
+    -since $(SRC_API_DIR)/11.xml 11 \
+    -since $(SRC_API_DIR)/12.xml 12 \
+    -since $(SRC_API_DIR)/13.xml 13 \
+    -since $(SRC_API_DIR)/14.txt 14 \
+    -since $(SRC_API_DIR)/15.txt 15 \
+    -since $(SRC_API_DIR)/16.txt 16 \
+    -since $(SRC_API_DIR)/17.txt 17 \
+    -since $(SRC_API_DIR)/18.txt 18 \
+    -since $(SRC_API_DIR)/19.txt 19 \
+    -since $(SRC_API_DIR)/20.txt 20 \
+    -since $(SRC_API_DIR)/21.txt 21 \
+    -since $(SRC_API_DIR)/22.txt 22 \
+    -since $(SRC_API_DIR)/23.txt 23 \
+		-werror -hide 111 -hide 113 \
+		-overview $(LOCAL_PATH)/core/java/overview.html
+
+framework_docs_LOCAL_API_CHECK_ADDITIONAL_JAVA_DIR:= \
+	$(call intermediates-dir-for,JAVA_LIBRARIES,framework,,COMMON)
+
+framework_docs_LOCAL_ADDITIONAL_JAVA_DIR:= \
+	$(framework_docs_LOCAL_API_CHECK_ADDITIONAL_JAVA_DIR) \
+	$(foreach lib,$(FRAMEWORKS_SUPPORT_JAVA_LIBRARIES),$(call intermediates-dir-for,JAVA_LIBRARIES,$(lib),,COMMON)) \
+	$(foreach lib,$(FRAMEWORKS_SUPPORT_JAVA_LIBRARIES),$(call intermediates-dir-for,JAVA_LIBRARIES,$(lib)-res,,COMMON))
+
+framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES := \
+    frameworks/base/docs/knowntags.txt
+
+samples_dir := development/samples/browseable
+
+# Whitelist of valid groups, used for default TOC grouping. Each sample must
+# belong to one (and only one) group. Assign samples to groups by setting
+# a sample.group var to one of these groups in the sample's _index.jd.
+sample_groups := -samplegroup Admin \
+                 -samplegroup Background \
+                 -samplegroup Connectivity \
+                 -samplegroup Content \
+                 -samplegroup Input \
+                 -samplegroup Media \
+                 -samplegroup Notification \
+                 -samplegroup RenderScript \
+                 -samplegroup Security \
+                 -samplegroup Sensors \
+                 -samplegroup System \
+                 -samplegroup Testing \
+                 -samplegroup UI \
+                 -samplegroup Views \
+                 -samplegroup Wearable
+
+## SDK version identifiers used in the published docs
+  # major[.minor] version for current SDK. (full releases only)
+framework_docs_SDK_VERSION:=6.0
+  # release version (ie "Release x")  (full releases only)
+framework_docs_SDK_REL_ID:=1
+
+framework_docs_LOCAL_DROIDDOC_OPTIONS += \
+		-hdf sdk.version $(framework_docs_SDK_VERSION) \
+		-hdf sdk.rel.id $(framework_docs_SDK_REL_ID) \
+		-hdf sdk.preview 0
+
+# ====  the api stubs and current.xml ===========================
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:=$(framework_docs_LOCAL_API_CHECK_SRC_FILES)
+LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
+LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_API_CHECK_JAVA_LIBRARIES)
+LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
+LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
+LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
+LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_API_CHECK_ADDITIONAL_JAVA_DIR)
+LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
+
+LOCAL_MODULE := api-stubs
+
+LOCAL_DROIDDOC_OPTIONS:=\
+		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
+		-stubs $(TARGET_OUT_COMMON_INTERMEDIATES)/JAVA_LIBRARIES/android_stubs_current_intermediates/src \
+		-api $(INTERNAL_PLATFORM_API_FILE) \
+		-removedApi $(INTERNAL_PLATFORM_REMOVED_API_FILE) \
+		-nodocs
+
+LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
+
+LOCAL_UNINSTALLABLE_MODULE := true
+
+include $(BUILD_DROIDDOC)
+
+# $(gen), i.e. framework.aidl, is also needed while building against the current stub.
+$(full_target): $(framework_built) $(gen)
+$(INTERNAL_PLATFORM_API_FILE): $(full_target)
+$(call dist-for-goals,sdk,$(INTERNAL_PLATFORM_API_FILE))
+
+# ====  the system api stubs ===================================
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:=$(framework_docs_LOCAL_API_CHECK_SRC_FILES)
+LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
+LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_API_CHECK_JAVA_LIBRARIES)
+LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
+LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
+LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
+LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_API_CHECK_ADDITIONAL_JAVA_DIR)
+LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
+
+LOCAL_MODULE := system-api-stubs
+
+LOCAL_DROIDDOC_OPTIONS:=\
+		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
+		-stubs $(TARGET_OUT_COMMON_INTERMEDIATES)/JAVA_LIBRARIES/android_system_stubs_current_intermediates/src \
+		-showAnnotation android.annotation.SystemApi \
+		-api $(INTERNAL_PLATFORM_SYSTEM_API_FILE) \
+		-removedApi $(INTERNAL_PLATFORM_SYSTEM_REMOVED_API_FILE) \
+		-nodocs
+
+LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
+
+LOCAL_UNINSTALLABLE_MODULE := true
+
+include $(BUILD_DROIDDOC)
+
+# $(gen), i.e. framework.aidl, is also needed while building against the current stub.
+$(full_target): $(framework_built) $(gen)
+$(INTERNAL_PLATFORM_SYSTEM_API_FILE): $(full_target)
+$(call dist-for-goals,sdk,$(INTERNAL_PLATFORM_SYSTEM_API_FILE))
+
+# ====  check javadoc comments but don't generate docs ========
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
+LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
+LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
+LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
+LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
+LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
+LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_ADDITIONAL_JAVA_DIR)
+LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
+
+LOCAL_MODULE := doc-comment-check
+
+LOCAL_DROIDDOC_OPTIONS:=\
+		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
+		-parsecomments
+
+LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
+
+LOCAL_UNINSTALLABLE_MODULE := true
+
+include $(BUILD_DROIDDOC)
+
+# $(gen), i.e. framework.aidl, is also needed while building against the current stub.
+$(full_target): $(framework_built) $(gen)
+
+# Run this for checkbuild
+checkbuild: doc-comment-check-docs
+# Check comment when you are updating the API
+update-api: doc-comment-check-docs
+
+# ====  static html in the sdk ==================================
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
+LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
+LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
+LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
+LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
+LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
+LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_ADDITIONAL_JAVA_DIR)
+LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
+
+LOCAL_MODULE := offline-sdk
+
+LOCAL_DROIDDOC_OPTIONS:=\
+		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
+		-offlinemode \
+		-title "Android SDK" \
+		-proofread $(OUT_DOCS)/$(LOCAL_MODULE)-proofread.txt \
+		-todo $(OUT_DOCS)/$(LOCAL_MODULE)-docs-todo.html \
+		-sdkvalues $(OUT_DOCS) \
+		-hdf android.whichdoc offline
+
+LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
+
+include $(BUILD_DROIDDOC)
+
+static_doc_index_redirect := $(out_dir)/index.html
+$(static_doc_index_redirect): \
+	$(LOCAL_PATH)/docs/docs-documentation-redirect.html | $(ACP)
+	$(hide) mkdir -p $(dir $@)
+	$(hide) $(ACP) $< $@
+
+$(full_target): $(static_doc_index_redirect)
+$(full_target): $(framework_built)
+
+# ==== docs for the web (on the androiddevdocs app engine server) =======================
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
+LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
+LOCAL_STATIC_JAVA_LIBRARIES:=$(framework_docs_LOCAL_STATIC_JAVA_LIBRARIES)
+LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
+LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
+LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
+LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
+LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_ADDITIONAL_JAVA_DIR)
+LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
+LOCAL_ADDITIONAL_HTML_DIR:=docs/html-intl /
+
+LOCAL_MODULE := online-sdk
+
+LOCAL_DROIDDOC_OPTIONS:= \
+		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
+		-toroot / \
+		-hdf android.whichdoc online \
+		$(sample_groups) \
+		-hdf android.hasSamples true \
+		-samplesdir $(samples_dir)
+
+LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
+
+include $(BUILD_DROIDDOC)
+
+# ==== docs for the web (on the androiddevdocs app engine server) =======================
+# TODO: Fix the System API docs build.
+ifneq ($(filter online-system-api-sdk-docs,$(MAKECMDGOALS)),)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
+LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
+LOCAL_STATIC_JAVA_LIBRARIES:=$(framework_docs_LOCAL_STATIC_JAVA_LIBRARIES)
+LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
+LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
+LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
+LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
+LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_ADDITIONAL_JAVA_DIR)
+LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
+LOCAL_ADDITIONAL_HTML_DIR:=docs/html-intl /
+
+LOCAL_MODULE := online-system-api-sdk
+
+LOCAL_DROIDDOC_OPTIONS:= \
+		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
+		-showAnnotation android.annotation.SystemApi \
+		-title "Android SDK - Including system APIs." \
+		-toroot / \
+		-hdf android.whichdoc online \
+		$(sample_groups) \
+		-hdf android.hasSamples true \
+		-samplesdir $(samples_dir)
+
+LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
+# Don't build by default
+LOCAL_UNINSTALLABLE_MODULE := true
+
+include $(BUILD_DROIDDOC)
+endif  # online-system-api-sdk-docs in make command line.
+
+# ==== docs for the web (on the devsite app engine server) =======================
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
+LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
+LOCAL_STATIC_JAVA_LIBRARIES:=$(framework_docs_LOCAL_STATIC_JAVA_LIBRARIES)
+LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
+LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
+LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
+LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
+LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_ADDITIONAL_JAVA_DIR)
+LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
+# specify a second html input dir and an output path relative to OUT_DIR)
+LOCAL_ADDITIONAL_HTML_DIR:=docs/html-intl/intl /
+
+LOCAL_MODULE := ds
+
+LOCAL_DROIDDOC_OPTIONS:= \
+		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
+		-devsite \
+		-toroot / \
+		-hdf android.whichdoc online \
+		-hdf devsite true
+
+LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
+
+include $(BUILD_DROIDDOC)
+
+# ==== docs for the ndk =======================
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
+LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
+LOCAL_STATIC_JAVA_LIBRARIES:=$(framework_docs_LOCAL_STATIC_JAVA_LIBRARIES)
+LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
+LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
+LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
+LOCAL_DROIDDOC_HTML_DIR:=docs/html-ndk
+LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_ADDITIONAL_JAVA_DIR)
+LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
+# specify a second html input dir and an output path relative to OUT_DIR)
+LOCAL_ADDITIONAL_HTML_DIR:=docs/html-intl/intl /
+
+LOCAL_MODULE := online-ndk
+
+LOCAL_DROIDDOC_OPTIONS:= \
+		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
+		-toroot / \
+		-hdf android.whichdoc online \
+		$(sample_groups) \
+		-hdf android.hasSamples true \
+		-samplesdir $(samples_dir)
+
+LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
+
+include $(BUILD_DROIDDOC)
+
+
+# ==== docs that have all of the stuff that's @hidden =======================
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:=$(framework_docs_LOCAL_SRC_FILES)
+LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
+LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
+LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
+LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
+LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
+LOCAL_ADDITIONAL_JAVA_DIR:=$(framework_docs_LOCAL_ADDITIONAL_JAVA_DIR)
+LOCAL_ADDITIONAL_DEPENDENCIES:=$(framework_docs_LOCAL_ADDITIONAL_DEPENDENCIES)
+
+LOCAL_MODULE := hidden
+LOCAL_DROIDDOC_OPTIONS:=\
+		$(framework_docs_LOCAL_DROIDDOC_OPTIONS) \
+		-title "Android SDK - Including hidden APIs."
+#		-hidden
+
+LOCAL_DROIDDOC_CUSTOM_TEMPLATE_DIR:=build/tools/droiddoc/templates-sdk
+
+include $(BUILD_DROIDDOC)
+
+# Build ext.jar
+# ============================================================
+
+ext_dirs := \
+	../../external/nist-sip/java \
+	../../external/tagsoup/src \
+
+ext_src_files := $(call all-java-files-under,$(ext_dirs))
+
+# ====  the library  =========================================
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := $(ext_src_files)
+
+LOCAL_NO_STANDARD_LIBRARIES := true
+LOCAL_JAVA_LIBRARIES := core-libart
+LOCAL_STATIC_JAVA_LIBRARIES := libphonenumber-platform
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE := ext
+
+LOCAL_DX_FLAGS := --core-library
+
+include $(BUILD_JAVA_LIBRARY)
+
+
+# Include subdirectory makefiles
+# ============================================================
+
+# If we're building with ONE_SHOT_MAKEFILE (mm, mmm), then what the framework
+# team really wants is to build the stuff defined by this makefile.
+ifeq (,$(ONE_SHOT_MAKEFILE))
+include $(call first-makefiles-under,$(LOCAL_PATH))
+endif
+
+endif # ANDROID_BUILD_EMBEDDED
diff --git a/core/java/android/content/Context.java b/core/java/android/content/Context.java
index 758b6ff..a0710e8 100644
--- a/core/java/android/content/Context.java
+++ b/core/java/android/content/Context.java
@@ -1,3927 +1,3940 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.content;
-
-import android.annotation.AttrRes;
-import android.annotation.CheckResult;
-import android.annotation.IntDef;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.annotation.StringDef;
-import android.annotation.StringRes;
-import android.annotation.StyleRes;
-import android.annotation.StyleableRes;
-import android.annotation.SystemApi;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageManager;
-import android.content.res.AssetManager;
-import android.content.res.ColorStateList;
-import android.content.res.Configuration;
-import android.content.res.Resources;
-import android.content.res.TypedArray;
-import android.database.DatabaseErrorHandler;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteDatabase.CursorFactory;
-import android.graphics.Bitmap;
-import android.graphics.drawable.Drawable;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.Environment;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.Looper;
-import android.os.StatFs;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.provider.MediaStore;
-import android.util.AttributeSet;
-import android.view.DisplayAdjustments;
-import android.view.Display;
-import android.view.ViewDebug;
-import android.view.WindowManager;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-
-/**
- * Interface to global information about an application environment.  This is
- * an abstract class whose implementation is provided by
- * the Android system.  It
- * allows access to application-specific resources and classes, as well as
- * up-calls for application-level operations such as launching activities,
- * broadcasting and receiving intents, etc.
- */
-public abstract class Context {
-    /**
-     * File creation mode: the default mode, where the created file can only
-     * be accessed by the calling application (or all applications sharing the
-     * same user ID).
-     * @see #MODE_WORLD_READABLE
-     * @see #MODE_WORLD_WRITEABLE
-     */
-    public static final int MODE_PRIVATE = 0x0000;
-    /**
-     * @deprecated Creating world-readable files is very dangerous, and likely
-     * to cause security holes in applications.  It is strongly discouraged;
-     * instead, applications should use more formal mechanism for interactions
-     * such as {@link ContentProvider}, {@link BroadcastReceiver}, and
-     * {@link android.app.Service}.  There are no guarantees that this
-     * access mode will remain on a file, such as when it goes through a
-     * backup and restore.
-     * File creation mode: allow all other applications to have read access
-     * to the created file.
-     * @see #MODE_PRIVATE
-     * @see #MODE_WORLD_WRITEABLE
-     */
-    @Deprecated
-    public static final int MODE_WORLD_READABLE = 0x0001;
-    /**
-     * @deprecated Creating world-writable files is very dangerous, and likely
-     * to cause security holes in applications.  It is strongly discouraged;
-     * instead, applications should use more formal mechanism for interactions
-     * such as {@link ContentProvider}, {@link BroadcastReceiver}, and
-     * {@link android.app.Service}.  There are no guarantees that this
-     * access mode will remain on a file, such as when it goes through a
-     * backup and restore.
-     * File creation mode: allow all other applications to have write access
-     * to the created file.
-     * @see #MODE_PRIVATE
-     * @see #MODE_WORLD_READABLE
-     */
-    @Deprecated
-    public static final int MODE_WORLD_WRITEABLE = 0x0002;
-    /**
-     * File creation mode: for use with {@link #openFileOutput}, if the file
-     * already exists then write data to the end of the existing file
-     * instead of erasing it.
-     * @see #openFileOutput
-     */
-    public static final int MODE_APPEND = 0x8000;
-
-    /**
-     * SharedPreference loading flag: when set, the file on disk will
-     * be checked for modification even if the shared preferences
-     * instance is already loaded in this process.  This behavior is
-     * sometimes desired in cases where the application has multiple
-     * processes, all writing to the same SharedPreferences file.
-     * Generally there are better forms of communication between
-     * processes, though.
-     *
-     * <p>This was the legacy (but undocumented) behavior in and
-     * before Gingerbread (Android 2.3) and this flag is implied when
-     * targetting such releases.  For applications targetting SDK
-     * versions <em>greater than</em> Android 2.3, this flag must be
-     * explicitly set if desired.
-     *
-     * @see #getSharedPreferences
-     *
-     * @deprecated MODE_MULTI_PROCESS does not work reliably in
-     * some versions of Android, and furthermore does not provide any
-     * mechanism for reconciling concurrent modifications across
-     * processes.  Applications should not attempt to use it.  Instead,
-     * they should use an explicit cross-process data management
-     * approach such as {@link android.content.ContentProvider ContentProvider}.
-     */
-    @Deprecated
-    public static final int MODE_MULTI_PROCESS = 0x0004;
-
-    /**
-     * Database open flag: when set, the database is opened with write-ahead
-     * logging enabled by default.
-     *
-     * @see #openOrCreateDatabase(String, int, CursorFactory)
-     * @see #openOrCreateDatabase(String, int, CursorFactory, DatabaseErrorHandler)
-     * @see SQLiteDatabase#enableWriteAheadLogging
-     */
-    public static final int MODE_ENABLE_WRITE_AHEAD_LOGGING = 0x0008;
-
-    /** @hide */
-    @IntDef(flag = true,
-            value = {
-                BIND_AUTO_CREATE,
-                BIND_DEBUG_UNBIND,
-                BIND_NOT_FOREGROUND,
-                BIND_ABOVE_CLIENT,
-                BIND_ALLOW_OOM_MANAGEMENT,
-                BIND_WAIVE_PRIORITY,
-                BIND_IMPORTANT,
-                BIND_ADJUST_WITH_ACTIVITY
-            })
-    @Retention(RetentionPolicy.SOURCE)
-    public @interface BindServiceFlags {}
-
-    /**
-     * Flag for {@link #bindService}: automatically create the service as long
-     * as the binding exists.  Note that while this will create the service,
-     * its {@link android.app.Service#onStartCommand}
-     * method will still only be called due to an
-     * explicit call to {@link #startService}.  Even without that, though,
-     * this still provides you with access to the service object while the
-     * service is created.
-     *
-     * <p>Note that prior to {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH},
-     * not supplying this flag would also impact how important the system
-     * consider's the target service's process to be.  When set, the only way
-     * for it to be raised was by binding from a service in which case it will
-     * only be important when that activity is in the foreground.  Now to
-     * achieve this behavior you must explicitly supply the new flag
-     * {@link #BIND_ADJUST_WITH_ACTIVITY}.  For compatibility, old applications
-     * that don't specify {@link #BIND_AUTO_CREATE} will automatically have
-     * the flags {@link #BIND_WAIVE_PRIORITY} and
-     * {@link #BIND_ADJUST_WITH_ACTIVITY} set for them in order to achieve
-     * the same result.
-     */
-    public static final int BIND_AUTO_CREATE = 0x0001;
-
-    /**
-     * Flag for {@link #bindService}: include debugging help for mismatched
-     * calls to unbind.  When this flag is set, the callstack of the following
-     * {@link #unbindService} call is retained, to be printed if a later
-     * incorrect unbind call is made.  Note that doing this requires retaining
-     * information about the binding that was made for the lifetime of the app,
-     * resulting in a leak -- this should only be used for debugging.
-     */
-    public static final int BIND_DEBUG_UNBIND = 0x0002;
-
-    /**
-     * Flag for {@link #bindService}: don't allow this binding to raise
-     * the target service's process to the foreground scheduling priority.
-     * It will still be raised to at least the same memory priority
-     * as the client (so that its process will not be killable in any
-     * situation where the client is not killable), but for CPU scheduling
-     * purposes it may be left in the background.  This only has an impact
-     * in the situation where the binding client is a foreground process
-     * and the target service is in a background process.
-     */
-    public static final int BIND_NOT_FOREGROUND = 0x0004;
-
-    /**
-     * Flag for {@link #bindService}: indicates that the client application
-     * binding to this service considers the service to be more important than
-     * the app itself.  When set, the platform will try to have the out of
-     * memory killer kill the app before it kills the service it is bound to, though
-     * this is not guaranteed to be the case.
-     */
-    public static final int BIND_ABOVE_CLIENT = 0x0008;
-
-    /**
-     * Flag for {@link #bindService}: allow the process hosting the bound
-     * service to go through its normal memory management.  It will be
-     * treated more like a running service, allowing the system to
-     * (temporarily) expunge the process if low on memory or for some other
-     * whim it may have, and being more aggressive about making it a candidate
-     * to be killed (and restarted) if running for a long time.
-     */
-    public static final int BIND_ALLOW_OOM_MANAGEMENT = 0x0010;
-
-    /**
-     * Flag for {@link #bindService}: don't impact the scheduling or
-     * memory management priority of the target service's hosting process.
-     * Allows the service's process to be managed on the background LRU list
-     * just like a regular application process in the background.
-     */
-    public static final int BIND_WAIVE_PRIORITY = 0x0020;
-
-    /**
-     * Flag for {@link #bindService}: this service is very important to
-     * the client, so should be brought to the foreground process level
-     * when the client is.  Normally a process can only be raised to the
-     * visibility level by a client, even if that client is in the foreground.
-     */
-    public static final int BIND_IMPORTANT = 0x0040;
-
-    /**
-     * Flag for {@link #bindService}: If binding from an activity, allow the
-     * target service's process importance to be raised based on whether the
-     * activity is visible to the user, regardless whether another flag is
-     * used to reduce the amount that the client process's overall importance
-     * is used to impact it.
-     */
-    public static final int BIND_ADJUST_WITH_ACTIVITY = 0x0080;
-
-    /**
-     * @hide Flag for {@link #bindService}: Like {@link #BIND_FOREGROUND_SERVICE},
-     * but only applies while the device is awake.
-     */
-    public static final int BIND_FOREGROUND_SERVICE_WHILE_AWAKE = 0x02000000;
-
-    /**
-     * @hide Flag for {@link #bindService}: For only the case where the binding
-     * is coming from the system, set the process state to FOREGROUND_SERVICE
-     * instead of the normal maximum of IMPORTANT_FOREGROUND.  That is, this is
-     * saying that the process shouldn't participate in the normal power reduction
-     * modes (removing network access etc).
-     */
-    public static final int BIND_FOREGROUND_SERVICE = 0x04000000;
-
-    /**
-     * @hide Flag for {@link #bindService}: Treat the binding as hosting
-     * an activity, an unbinding as the activity going in the background.
-     * That is, when unbinding, the process when empty will go on the activity
-     * LRU list instead of the regular one, keeping it around more aggressively
-     * than it otherwise would be.  This is intended for use with IMEs to try
-     * to keep IME processes around for faster keyboard switching.
-     */
-    public static final int BIND_TREAT_LIKE_ACTIVITY = 0x08000000;
-
-    /**
-     * @hide An idea that is not yet implemented.
-     * Flag for {@link #bindService}: If binding from an activity, consider
-     * this service to be visible like the binding activity is.  That is,
-     * it will be treated as something more important to keep around than
-     * invisible background activities.  This will impact the number of
-     * recent activities the user can switch between without having them
-     * restart.  There is no guarantee this will be respected, as the system
-     * tries to balance such requests from one app vs. the importantance of
-     * keeping other apps around.
-     */
-    public static final int BIND_VISIBLE = 0x10000000;
-
-    /**
-     * @hide
-     * Flag for {@link #bindService}: Consider this binding to be causing the target
-     * process to be showing UI, so it will be do a UI_HIDDEN memory trim when it goes
-     * away.
-     */
-    public static final int BIND_SHOWING_UI = 0x20000000;
-
-    /**
-     * Flag for {@link #bindService}: Don't consider the bound service to be
-     * visible, even if the caller is visible.
-     * @hide
-     */
-    public static final int BIND_NOT_VISIBLE = 0x40000000;
-
-    /** Return an AssetManager instance for your application's package. */
-    public abstract AssetManager getAssets();
-
-    /** Return a Resources instance for your application's package. */
-    public abstract Resources getResources();
-
-    /** Return PackageManager instance to find global package information. */
-    public abstract PackageManager getPackageManager();
-
-    /** Return a ContentResolver instance for your application's package. */
-    public abstract ContentResolver getContentResolver();
-
-    /**
-     * Return the Looper for the main thread of the current process.  This is
-     * the thread used to dispatch calls to application components (activities,
-     * services, etc).
-     * <p>
-     * By definition, this method returns the same result as would be obtained
-     * by calling {@link Looper#getMainLooper() Looper.getMainLooper()}.
-     * </p>
-     *
-     * @return The main looper.
-     */
-    public abstract Looper getMainLooper();
-
-    /**
-     * Return the context of the single, global Application object of the
-     * current process.  This generally should only be used if you need a
-     * Context whose lifecycle is separate from the current context, that is
-     * tied to the lifetime of the process rather than the current component.
-     *
-     * <p>Consider for example how this interacts with
-     * {@link #registerReceiver(BroadcastReceiver, IntentFilter)}:
-     * <ul>
-     * <li> <p>If used from an Activity context, the receiver is being registered
-     * within that activity.  This means that you are expected to unregister
-     * before the activity is done being destroyed; in fact if you do not do
-     * so, the framework will clean up your leaked registration as it removes
-     * the activity and log an error.  Thus, if you use the Activity context
-     * to register a receiver that is static (global to the process, not
-     * associated with an Activity instance) then that registration will be
-     * removed on you at whatever point the activity you used is destroyed.
-     * <li> <p>If used from the Context returned here, the receiver is being
-     * registered with the global state associated with your application.  Thus
-     * it will never be unregistered for you.  This is necessary if the receiver
-     * is associated with static data, not a particular component.  However
-     * using the ApplicationContext elsewhere can easily lead to serious leaks
-     * if you forget to unregister, unbind, etc.
-     * </ul>
-     */
-    public abstract Context getApplicationContext();
-
-    /**
-     * Add a new {@link ComponentCallbacks} to the base application of the
-     * Context, which will be called at the same times as the ComponentCallbacks
-     * methods of activities and other components are called.  Note that you
-     * <em>must</em> be sure to use {@link #unregisterComponentCallbacks} when
-     * appropriate in the future; this will not be removed for you.
-     *
-     * @param callback The interface to call.  This can be either a
-     * {@link ComponentCallbacks} or {@link ComponentCallbacks2} interface.
-     */
-    public void registerComponentCallbacks(ComponentCallbacks callback) {
-        getApplicationContext().registerComponentCallbacks(callback);
-    }
-
-    /**
-     * Remove a {@link ComponentCallbacks} object that was previously registered
-     * with {@link #registerComponentCallbacks(ComponentCallbacks)}.
-     */
-    public void unregisterComponentCallbacks(ComponentCallbacks callback) {
-        getApplicationContext().unregisterComponentCallbacks(callback);
-    }
-
-    /**
-     * Return a localized, styled CharSequence from the application's package's
-     * default string table.
-     *
-     * @param resId Resource id for the CharSequence text
-     */
-    public final CharSequence getText(@StringRes int resId) {
-        return getResources().getText(resId);
-    }
-
-    /**
-     * Returns a localized string from the application's package's
-     * default string table.
-     *
-     * @param resId Resource id for the string
-     * @return The string data associated with the resource, stripped of styled
-     *         text information.
-     */
-    @NonNull
-    public final String getString(@StringRes int resId) {
-        return getResources().getString(resId);
-    }
-
-    /**
-     * Returns a localized formatted string from the application's package's
-     * default string table, substituting the format arguments as defined in
-     * {@link java.util.Formatter} and {@link java.lang.String#format}.
-     *
-     * @param resId Resource id for the format string
-     * @param formatArgs The format arguments that will be used for
-     *                   substitution.
-     * @return The string data associated with the resource, formatted and
-     *         stripped of styled text information.
-     */
-    @NonNull
-    public final String getString(@StringRes int resId, Object... formatArgs) {
-        return getResources().getString(resId, formatArgs);
-    }
-
-    /**
-     * Returns a color associated with a particular resource ID and styled for
-     * the current theme.
-     *
-     * @param id The desired resource identifier, as generated by the aapt
-     *           tool. This integer encodes the package, type, and resource
-     *           entry. The value 0 is an invalid identifier.
-     * @return A single color value in the form 0xAARRGGBB.
-     * @throws android.content.res.Resources.NotFoundException if the given ID
-     *         does not exist.
-     */
-    @Nullable
-    public final int getColor(int id) {
-        return getResources().getColor(id, getTheme());
-    }
-
-    /**
-     * Returns a drawable object associated with a particular resource ID and
-     * styled for the current theme.
-     *
-     * @param id The desired resource identifier, as generated by the aapt
-     *           tool. This integer encodes the package, type, and resource
-     *           entry. The value 0 is an invalid identifier.
-     * @return An object that can be used to draw this resource, or
-     *         {@code null} if the resource could not be resolved.
-     * @throws android.content.res.Resources.NotFoundException if the given ID
-     *         does not exist.
-     */
-    @Nullable
-    public final Drawable getDrawable(int id) {
-        return getResources().getDrawable(id, getTheme());
-    }
-
-    /**
-     * Returns a color state list associated with a particular resource ID and
-     * styled for the current theme.
-     *
-     * @param id The desired resource identifier, as generated by the aapt
-     *           tool. This integer encodes the package, type, and resource
-     *           entry. The value 0 is an invalid identifier.
-     * @return A color state list, or {@code null} if the resource could not be
-     *         resolved.
-     * @throws android.content.res.Resources.NotFoundException if the given ID
-     *         does not exist.
-     */
-    @Nullable
-    public final ColorStateList getColorStateList(int id) {
-        return getResources().getColorStateList(id, getTheme());
-    }
-
-     /**
-     * Set the base theme for this context.  Note that this should be called
-     * before any views are instantiated in the Context (for example before
-     * calling {@link android.app.Activity#setContentView} or
-     * {@link android.view.LayoutInflater#inflate}).
-     *
-     * @param resid The style resource describing the theme.
-     */
-    public abstract void setTheme(@StyleRes int resid);
-
-    /** @hide Needed for some internal implementation...  not public because
-     * you can't assume this actually means anything. */
-    public int getThemeResId() {
-        return 0;
-    }
-
-    /**
-     * Return the Theme object associated with this Context.
-     */
-    @ViewDebug.ExportedProperty(deepExport = true)
-    public abstract Resources.Theme getTheme();
-
-    /**
-     * Retrieve styled attribute information in this Context's theme.  See
-     * {@link android.content.res.Resources.Theme#obtainStyledAttributes(int[])}
-     * for more information.
-     *
-     * @see android.content.res.Resources.Theme#obtainStyledAttributes(int[])
-     */
-    public final TypedArray obtainStyledAttributes(@StyleableRes int[] attrs) {
-        return getTheme().obtainStyledAttributes(attrs);
-    }
-
-    /**
-     * Retrieve styled attribute information in this Context's theme.  See
-     * {@link android.content.res.Resources.Theme#obtainStyledAttributes(int, int[])}
-     * for more information.
-     *
-     * @see android.content.res.Resources.Theme#obtainStyledAttributes(int, int[])
-     */
-    public final TypedArray obtainStyledAttributes(
-            @StyleRes int resid, @StyleableRes int[] attrs) throws Resources.NotFoundException {
-        return getTheme().obtainStyledAttributes(resid, attrs);
-    }
-
-    /**
-     * Retrieve styled attribute information in this Context's theme.  See
-     * {@link android.content.res.Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)}
-     * for more information.
-     *
-     * @see android.content.res.Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
-     */
-    public final TypedArray obtainStyledAttributes(
-            AttributeSet set, @StyleableRes int[] attrs) {
-        return getTheme().obtainStyledAttributes(set, attrs, 0, 0);
-    }
-
-    /**
-     * Retrieve styled attribute information in this Context's theme.  See
-     * {@link android.content.res.Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)}
-     * for more information.
-     *
-     * @see android.content.res.Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
-     */
-    public final TypedArray obtainStyledAttributes(
-            AttributeSet set, @StyleableRes int[] attrs, @AttrRes int defStyleAttr,
-            @StyleRes int defStyleRes) {
-        return getTheme().obtainStyledAttributes(
-            set, attrs, defStyleAttr, defStyleRes);
-    }
-
-    /**
-     * Return a class loader you can use to retrieve classes in this package.
-     */
-    public abstract ClassLoader getClassLoader();
-
-    /** Return the name of this application's package. */
-    public abstract String getPackageName();
-
-    /** @hide Return the name of the base context this context is derived from. */
-    public abstract String getBasePackageName();
-
-    /** @hide Return the package name that should be used for app ops calls from
-     * this context.  This is the same as {@link #getBasePackageName()} except in
-     * cases where system components are loaded into other app processes, in which
-     * case this will be the name of the primary package in that process (so that app
-     * ops uid verification will work with the name). */
-    public abstract String getOpPackageName();
-
-    /** Return the full application info for this context's package. */
-    public abstract ApplicationInfo getApplicationInfo();
-
-    /**
-     * Return the full path to this context's primary Android package.
-     * The Android package is a ZIP file which contains the application's
-     * primary resources.
-     *
-     * <p>Note: this is not generally useful for applications, since they should
-     * not be directly accessing the file system.
-     *
-     * @return String Path to the resources.
-     */
-    public abstract String getPackageResourcePath();
-
-    /**
-     * Return the full path to this context's primary Android package.
-     * The Android package is a ZIP file which contains application's
-     * primary code and assets.
-     *
-     * <p>Note: this is not generally useful for applications, since they should
-     * not be directly accessing the file system.
-     *
-     * @return String Path to the code and assets.
-     */
-    public abstract String getPackageCodePath();
-
-    /**
-     * {@hide}
-     * Return the full path to the shared prefs file for the given prefs group name.
-     *
-     * <p>Note: this is not generally useful for applications, since they should
-     * not be directly accessing the file system.
-     */
-    public abstract File getSharedPrefsFile(String name);
-
-    /**
-     * Retrieve and hold the contents of the preferences file 'name', returning
-     * a SharedPreferences through which you can retrieve and modify its
-     * values.  Only one instance of the SharedPreferences object is returned
-     * to any callers for the same name, meaning they will see each other's
-     * edits as soon as they are made.
-     *
-     * @param name Desired preferences file. If a preferences file by this name
-     * does not exist, it will be created when you retrieve an
-     * editor (SharedPreferences.edit()) and then commit changes (Editor.commit()).
-     * @param mode Operating mode.  Use 0 or {@link #MODE_PRIVATE} for the
-     * default operation, {@link #MODE_WORLD_READABLE}
-     * and {@link #MODE_WORLD_WRITEABLE} to control permissions.
-     *
-     * @return The single {@link SharedPreferences} instance that can be used
-     *         to retrieve and modify the preference values.
-     *
-     * @see #MODE_PRIVATE
-     * @see #MODE_WORLD_READABLE
-     * @see #MODE_WORLD_WRITEABLE
-     */
-    public abstract SharedPreferences getSharedPreferences(String name,
-            int mode);
-
-    /**
-     * Open a private file associated with this Context's application package
-     * for reading.
-     *
-     * @param name The name of the file to open; can not contain path
-     *             separators.
-     *
-     * @return The resulting {@link FileInputStream}.
-     *
-     * @see #openFileOutput
-     * @see #fileList
-     * @see #deleteFile
-     * @see java.io.FileInputStream#FileInputStream(String)
-     */
-    public abstract FileInputStream openFileInput(String name)
-        throws FileNotFoundException;
-
-    /**
-     * Open a private file associated with this Context's application package
-     * for writing. Creates the file if it doesn't already exist.
-     * <p>
-     * No additional permissions are required for the calling app to read or
-     * write the returned file.
-     *
-     * @param name The name of the file to open; can not contain path
-     *            separators.
-     * @param mode Operating mode. Use 0 or {@link #MODE_PRIVATE} for the
-     *            default operation, {@link #MODE_APPEND} to append to an
-     *            existing file, {@link #MODE_WORLD_READABLE} and
-     *            {@link #MODE_WORLD_WRITEABLE} to control permissions.
-     * @return The resulting {@link FileOutputStream}.
-     * @see #MODE_APPEND
-     * @see #MODE_PRIVATE
-     * @see #MODE_WORLD_READABLE
-     * @see #MODE_WORLD_WRITEABLE
-     * @see #openFileInput
-     * @see #fileList
-     * @see #deleteFile
-     * @see java.io.FileOutputStream#FileOutputStream(String)
-     */
-    public abstract FileOutputStream openFileOutput(String name, int mode)
-        throws FileNotFoundException;
-
-    /**
-     * Delete the given private file associated with this Context's
-     * application package.
-     *
-     * @param name The name of the file to delete; can not contain path
-     *             separators.
-     *
-     * @return {@code true} if the file was successfully deleted; else
-     *         {@code false}.
-     *
-     * @see #openFileInput
-     * @see #openFileOutput
-     * @see #fileList
-     * @see java.io.File#delete()
-     */
-    public abstract boolean deleteFile(String name);
-
-    /**
-     * Returns the absolute path on the filesystem where a file created with
-     * {@link #openFileOutput} is stored.
-     * <p>
-     * The returned path may change over time if the calling app is moved to an
-     * adopted storage device, so only relative paths should be persisted.
-     *
-     * @param name The name of the file for which you would like to get
-     *          its path.
-     *
-     * @return An absolute path to the given file.
-     *
-     * @see #openFileOutput
-     * @see #getFilesDir
-     * @see #getDir
-     */
-    public abstract File getFileStreamPath(String name);
-
-    /**
-     * Returns the absolute path to the directory on the filesystem where files
-     * created with {@link #openFileOutput} are stored.
-     * <p>
-     * The returned path may change over time if the calling app is moved to an
-     * adopted storage device, so only relative paths should be persisted.
-     * <p>
-     * No additional permissions are required for the calling app to read or
-     * write files under the returned path.
-     *
-     * @return The path of the directory holding application files.
-     * @see #openFileOutput
-     * @see #getFileStreamPath
-     * @see #getDir
-     */
-    public abstract File getFilesDir();
-
-    /**
-     * Returns the absolute path to the directory on the filesystem similar to
-     * {@link #getFilesDir()}. The difference is that files placed under this
-     * directory will be excluded from automatic backup to remote storage. See
-     * {@link android.app.backup.BackupAgent BackupAgent} for a full discussion
-     * of the automatic backup mechanism in Android.
-     * <p>
-     * The returned path may change over time if the calling app is moved to an
-     * adopted storage device, so only relative paths should be persisted.
-     * <p>
-     * No additional permissions are required for the calling app to read or
-     * write files under the returned path.
-     *
-     * @return The path of the directory holding application files that will not
-     *         be automatically backed up to remote storage.
-     * @see #openFileOutput
-     * @see #getFileStreamPath
-     * @see #getDir
-     * @see android.app.backup.BackupAgent
-     */
-    public abstract File getNoBackupFilesDir();
-
-    /**
-     * Returns the absolute path to the directory on the primary shared/external
-     * storage device where the application can place persistent files it owns.
-     * These files are internal to the applications, and not typically visible
-     * to the user as media.
-     * <p>
-     * This is like {@link #getFilesDir()} in that these files will be deleted
-     * when the application is uninstalled, however there are some important
-     * differences:
-     * <ul>
-     * <li>Shared storage may not always be available, since removable media can
-     * be ejected by the user. Media state can be checked using
-     * {@link Environment#getExternalStorageState(File)}.
-     * <li>There is no security enforced with these files. For example, any
-     * application holding
-     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to
-     * these files.
-     * </ul>
-     * <p>
-     * If a shared storage device is emulated (as determined by
-     * {@link Environment#isExternalStorageEmulated(File)}), it's contents are
-     * backed by a private user data partition, which means there is little
-     * benefit to storing data here instead of the private directories returned
-     * by {@link #getFilesDir()}, etc.
-     * <p>
-     * Starting in {@link android.os.Build.VERSION_CODES#KITKAT}, no permissions
-     * are required to read or write to the returned path; it's always
-     * accessible to the calling app. This only applies to paths generated for
-     * package name of the calling application. To access paths belonging to
-     * other packages,
-     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} and/or
-     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} are required.
-     * <p>
-     * On devices with multiple users (as described by {@link UserManager}),
-     * each user has their own isolated shared storage. Applications only have
-     * access to the shared storage for the user they're running as.
-     * <p>
-     * The returned path may change over time if different shared storage media
-     * is inserted, so only relative paths should be persisted.
-     * <p>
-     * Here is an example of typical code to manipulate a file in an
-     * application's shared storage:
-     * </p>
-     * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
-     * private_file}
-     * <p>
-     * If you supply a non-null <var>type</var> to this function, the returned
-     * file will be a path to a sub-directory of the given type. Though these
-     * files are not automatically scanned by the media scanner, you can
-     * explicitly add them to the media database with
-     * {@link android.media.MediaScannerConnection#scanFile(Context, String[], String[], android.media.MediaScannerConnection.OnScanCompletedListener)
-     * MediaScannerConnection.scanFile}. Note that this is not the same as
-     * {@link android.os.Environment#getExternalStoragePublicDirectory
-     * Environment.getExternalStoragePublicDirectory()}, which provides
-     * directories of media shared by all applications. The directories returned
-     * here are owned by the application, and their contents will be removed
-     * when the application is uninstalled. Unlike
-     * {@link android.os.Environment#getExternalStoragePublicDirectory
-     * Environment.getExternalStoragePublicDirectory()}, the directory returned
-     * here will be automatically created for you.
-     * <p>
-     * Here is an example of typical code to manipulate a picture in an
-     * application's shared storage and add it to the media database:
-     * </p>
-     * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
-     * private_picture}
-     *
-     * @param type The type of files directory to return. May be {@code null}
-     *            for the root of the files directory or one of the following
-     *            constants for a subdirectory:
-     *            {@link android.os.Environment#DIRECTORY_MUSIC},
-     *            {@link android.os.Environment#DIRECTORY_PODCASTS},
-     *            {@link android.os.Environment#DIRECTORY_RINGTONES},
-     *            {@link android.os.Environment#DIRECTORY_ALARMS},
-     *            {@link android.os.Environment#DIRECTORY_NOTIFICATIONS},
-     *            {@link android.os.Environment#DIRECTORY_PICTURES}, or
-     *            {@link android.os.Environment#DIRECTORY_MOVIES}.
-     * @return the absolute path to application-specific directory. May return
-     *         {@code null} if shared storage is not currently available.
-     * @see #getFilesDir
-     * @see #getExternalFilesDirs(String)
-     * @see Environment#getExternalStorageState(File)
-     * @see Environment#isExternalStorageEmulated(File)
-     * @see Environment#isExternalStorageRemovable(File)
-     */
-    @Nullable
-    public abstract File getExternalFilesDir(@Nullable String type);
-
-    /**
-     * Returns absolute paths to application-specific directories on all
-     * shared/external storage devices where the application can place
-     * persistent files it owns. These files are internal to the application,
-     * and not typically visible to the user as media.
-     * <p>
-     * This is like {@link #getFilesDir()} in that these files will be deleted
-     * when the application is uninstalled, however there are some important
-     * differences:
-     * <ul>
-     * <li>Shared storage may not always be available, since removable media can
-     * be ejected by the user. Media state can be checked using
-     * {@link Environment#getExternalStorageState(File)}.
-     * <li>There is no security enforced with these files. For example, any
-     * application holding
-     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to
-     * these files.
-     * </ul>
-     * <p>
-     * If a shared storage device is emulated (as determined by
-     * {@link Environment#isExternalStorageEmulated(File)}), it's contents are
-     * backed by a private user data partition, which means there is little
-     * benefit to storing data here instead of the private directories returned
-     * by {@link #getFilesDir()}, etc.
-     * <p>
-     * Shared storage devices returned here are considered a stable part of the
-     * device, including physical media slots under a protective cover. The
-     * returned paths do not include transient devices, such as USB flash drives
-     * connected to handheld devices.
-     * <p>
-     * An application may store data on any or all of the returned devices. For
-     * example, an app may choose to store large files on the device with the
-     * most available space, as measured by {@link StatFs}.
-     * <p>
-     * No additional permissions are required for the calling app to read or
-     * write files under the returned path. Write access outside of these paths
-     * on secondary external storage devices is not available.
-     * <p>
-     * The returned path may change over time if different shared storage media
-     * is inserted, so only relative paths should be persisted.
-     *
-     * @param type The type of files directory to return. May be {@code null}
-     *            for the root of the files directory or one of the following
-     *            constants for a subdirectory:
-     *            {@link android.os.Environment#DIRECTORY_MUSIC},
-     *            {@link android.os.Environment#DIRECTORY_PODCASTS},
-     *            {@link android.os.Environment#DIRECTORY_RINGTONES},
-     *            {@link android.os.Environment#DIRECTORY_ALARMS},
-     *            {@link android.os.Environment#DIRECTORY_NOTIFICATIONS},
-     *            {@link android.os.Environment#DIRECTORY_PICTURES}, or
-     *            {@link android.os.Environment#DIRECTORY_MOVIES}.
-     * @return the absolute paths to application-specific directories. Some
-     *         individual paths may be {@code null} if that shared storage is
-     *         not currently available. The first path returned is the same as
-     *         {@link #getExternalFilesDir(String)}.
-     * @see #getExternalFilesDir(String)
-     * @see Environment#getExternalStorageState(File)
-     * @see Environment#isExternalStorageEmulated(File)
-     * @see Environment#isExternalStorageRemovable(File)
-     */
-    public abstract File[] getExternalFilesDirs(String type);
-
-    /**
-     * Return the primary shared/external storage directory where this
-     * application's OBB files (if there are any) can be found. Note if the
-     * application does not have any OBB files, this directory may not exist.
-     * <p>
-     * This is like {@link #getFilesDir()} in that these files will be deleted
-     * when the application is uninstalled, however there are some important
-     * differences:
-     * <ul>
-     * <li>Shared storage may not always be available, since removable media can
-     * be ejected by the user. Media state can be checked using
-     * {@link Environment#getExternalStorageState(File)}.
-     * <li>There is no security enforced with these files. For example, any
-     * application holding
-     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to
-     * these files.
-     * </ul>
-     * <p>
-     * Starting in {@link android.os.Build.VERSION_CODES#KITKAT}, no permissions
-     * are required to read or write to the returned path; it's always
-     * accessible to the calling app. This only applies to paths generated for
-     * package name of the calling application. To access paths belonging to
-     * other packages,
-     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} and/or
-     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} are required.
-     * <p>
-     * On devices with multiple users (as described by {@link UserManager}),
-     * multiple users may share the same OBB storage location. Applications
-     * should ensure that multiple instances running under different users don't
-     * interfere with each other.
-     *
-     * @return the absolute path to application-specific directory. May return
-     *         {@code null} if shared storage is not currently available.
-     * @see #getObbDirs()
-     * @see Environment#getExternalStorageState(File)
-     * @see Environment#isExternalStorageEmulated(File)
-     * @see Environment#isExternalStorageRemovable(File)
-     */
-    public abstract File getObbDir();
-
-    /**
-     * Returns absolute paths to application-specific directories on all
-     * shared/external storage devices where the application's OBB files (if
-     * there are any) can be found. Note if the application does not have any
-     * OBB files, these directories may not exist.
-     * <p>
-     * This is like {@link #getFilesDir()} in that these files will be deleted
-     * when the application is uninstalled, however there are some important
-     * differences:
-     * <ul>
-     * <li>Shared storage may not always be available, since removable media can
-     * be ejected by the user. Media state can be checked using
-     * {@link Environment#getExternalStorageState(File)}.
-     * <li>There is no security enforced with these files. For example, any
-     * application holding
-     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to
-     * these files.
-     * </ul>
-     * <p>
-     * Shared storage devices returned here are considered a stable part of the
-     * device, including physical media slots under a protective cover. The
-     * returned paths do not include transient devices, such as USB flash drives
-     * connected to handheld devices.
-     * <p>
-     * An application may store data on any or all of the returned devices. For
-     * example, an app may choose to store large files on the device with the
-     * most available space, as measured by {@link StatFs}.
-     * <p>
-     * No additional permissions are required for the calling app to read or
-     * write files under the returned path. Write access outside of these paths
-     * on secondary external storage devices is not available.
-     *
-     * @return the absolute paths to application-specific directories. Some
-     *         individual paths may be {@code null} if that shared storage is
-     *         not currently available. The first path returned is the same as
-     *         {@link #getObbDir()}
-     * @see #getObbDir()
-     * @see Environment#getExternalStorageState(File)
-     * @see Environment#isExternalStorageEmulated(File)
-     * @see Environment#isExternalStorageRemovable(File)
-     */
-    public abstract File[] getObbDirs();
-
-    /**
-     * Returns the absolute path to the application specific cache directory on
-     * the filesystem. These files will be ones that get deleted first when the
-     * device runs low on storage. There is no guarantee when these files will
-     * be deleted.
-     * <p>
-     * <strong>Note: you should not <em>rely</em> on the system deleting these
-     * files for you; you should always have a reasonable maximum, such as 1 MB,
-     * for the amount of space you consume with cache files, and prune those
-     * files when exceeding that space.</strong>
-     * <p>
-     * The returned path may change over time if the calling app is moved to an
-     * adopted storage device, so only relative paths should be persisted.
-     * <p>
-     * Apps require no extra permissions to read or write to the returned path,
-     * since this path lives in their private storage.
-     *
-     * @return The path of the directory holding application cache files.
-     * @see #openFileOutput
-     * @see #getFileStreamPath
-     * @see #getDir
-     */
-    public abstract File getCacheDir();
-
-    /**
-     * Returns the absolute path to the application specific cache directory on
-     * the filesystem designed for storing cached code. The system will delete
-     * any files stored in this location both when your specific application is
-     * upgraded, and when the entire platform is upgraded.
-     * <p>
-     * This location is optimal for storing compiled or optimized code generated
-     * by your application at runtime.
-     * <p>
-     * The returned path may change over time if the calling app is moved to an
-     * adopted storage device, so only relative paths should be persisted.
-     * <p>
-     * Apps require no extra permissions to read or write to the returned path,
-     * since this path lives in their private storage.
-     *
-     * @return The path of the directory holding application code cache files.
-     */
-    public abstract File getCodeCacheDir();
-
-    /**
-     * Returns absolute path to application-specific directory on the primary
-     * shared/external storage device where the application can place cache
-     * files it owns. These files are internal to the application, and not
-     * typically visible to the user as media.
-     * <p>
-     * This is like {@link #getCacheDir()} in that these files will be deleted
-     * when the application is uninstalled, however there are some important
-     * differences:
-     * <ul>
-     * <li>The platform does not always monitor the space available in shared
-     * storage, and thus may not automatically delete these files. Apps should
-     * always manage the maximum space used in this location. Currently the only
-     * time files here will be deleted by the platform is when running on
-     * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} or later and
-     * {@link Environment#isExternalStorageEmulated(File)} returns true.
-     * <li>Shared storage may not always be available, since removable media can
-     * be ejected by the user. Media state can be checked using
-     * {@link Environment#getExternalStorageState(File)}.
-     * <li>There is no security enforced with these files. For example, any
-     * application holding
-     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to
-     * these files.
-     * </ul>
-     * <p>
-     * If a shared storage device is emulated (as determined by
-     * {@link Environment#isExternalStorageEmulated(File)}), it's contents are
-     * backed by a private user data partition, which means there is little
-     * benefit to storing data here instead of the private directory returned by
-     * {@link #getCacheDir()}.
-     * <p>
-     * Starting in {@link android.os.Build.VERSION_CODES#KITKAT}, no permissions
-     * are required to read or write to the returned path; it's always
-     * accessible to the calling app. This only applies to paths generated for
-     * package name of the calling application. To access paths belonging to
-     * other packages,
-     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} and/or
-     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} are required.
-     * <p>
-     * On devices with multiple users (as described by {@link UserManager}),
-     * each user has their own isolated shared storage. Applications only have
-     * access to the shared storage for the user they're running as.
-     * <p>
-     * The returned path may change over time if different shared storage media
-     * is inserted, so only relative paths should be persisted.
-     *
-     * @return the absolute path to application-specific directory. May return
-     *         {@code null} if shared storage is not currently available.
-     * @see #getCacheDir
-     * @see #getExternalCacheDirs()
-     * @see Environment#getExternalStorageState(File)
-     * @see Environment#isExternalStorageEmulated(File)
-     * @see Environment#isExternalStorageRemovable(File)
-     */
-    @Nullable
-    public abstract File getExternalCacheDir();
-
-    /**
-     * Returns absolute paths to application-specific directories on all
-     * shared/external storage devices where the application can place cache
-     * files it owns. These files are internal to the application, and not
-     * typically visible to the user as media.
-     * <p>
-     * This is like {@link #getCacheDir()} in that these files will be deleted
-     * when the application is uninstalled, however there are some important
-     * differences:
-     * <ul>
-     * <li>The platform does not always monitor the space available in shared
-     * storage, and thus may not automatically delete these files. Apps should
-     * always manage the maximum space used in this location. Currently the only
-     * time files here will be deleted by the platform is when running on
-     * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} or later and
-     * {@link Environment#isExternalStorageEmulated(File)} returns true.
-     * <li>Shared storage may not always be available, since removable media can
-     * be ejected by the user. Media state can be checked using
-     * {@link Environment#getExternalStorageState(File)}.
-     * <li>There is no security enforced with these files. For example, any
-     * application holding
-     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to
-     * these files.
-     * </ul>
-     * <p>
-     * If a shared storage device is emulated (as determined by
-     * {@link Environment#isExternalStorageEmulated(File)}), it's contents are
-     * backed by a private user data partition, which means there is little
-     * benefit to storing data here instead of the private directory returned by
-     * {@link #getCacheDir()}.
-     * <p>
-     * Shared storage devices returned here are considered a stable part of the
-     * device, including physical media slots under a protective cover. The
-     * returned paths do not include transient devices, such as USB flash drives
-     * connected to handheld devices.
-     * <p>
-     * An application may store data on any or all of the returned devices. For
-     * example, an app may choose to store large files on the device with the
-     * most available space, as measured by {@link StatFs}.
-     * <p>
-     * No additional permissions are required for the calling app to read or
-     * write files under the returned path. Write access outside of these paths
-     * on secondary external storage devices is not available.
-     * <p>
-     * The returned paths may change over time if different shared storage media
-     * is inserted, so only relative paths should be persisted.
-     *
-     * @return the absolute paths to application-specific directories. Some
-     *         individual paths may be {@code null} if that shared storage is
-     *         not currently available. The first path returned is the same as
-     *         {@link #getExternalCacheDir()}.
-     * @see #getExternalCacheDir()
-     * @see Environment#getExternalStorageState(File)
-     * @see Environment#isExternalStorageEmulated(File)
-     * @see Environment#isExternalStorageRemovable(File)
-     */
-    public abstract File[] getExternalCacheDirs();
-
-    /**
-     * Returns absolute paths to application-specific directories on all
-     * shared/external storage devices where the application can place media
-     * files. These files are scanned and made available to other apps through
-     * {@link MediaStore}.
-     * <p>
-     * This is like {@link #getExternalFilesDirs} in that these files will be
-     * deleted when the application is uninstalled, however there are some
-     * important differences:
-     * <ul>
-     * <li>Shared storage may not always be available, since removable media can
-     * be ejected by the user. Media state can be checked using
-     * {@link Environment#getExternalStorageState(File)}.
-     * <li>There is no security enforced with these files. For example, any
-     * application holding
-     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to
-     * these files.
-     * </ul>
-     * <p>
-     * Shared storage devices returned here are considered a stable part of the
-     * device, including physical media slots under a protective cover. The
-     * returned paths do not include transient devices, such as USB flash drives
-     * connected to handheld devices.
-     * <p>
-     * An application may store data on any or all of the returned devices. For
-     * example, an app may choose to store large files on the device with the
-     * most available space, as measured by {@link StatFs}.
-     * <p>
-     * No additional permissions are required for the calling app to read or
-     * write files under the returned path. Write access outside of these paths
-     * on secondary external storage devices is not available.
-     * <p>
-     * The returned paths may change over time if different shared storage media
-     * is inserted, so only relative paths should be persisted.
-     *
-     * @return the absolute paths to application-specific directories. Some
-     *         individual paths may be {@code null} if that shared storage is
-     *         not currently available.
-     * @see Environment#getExternalStorageState(File)
-     * @see Environment#isExternalStorageEmulated(File)
-     * @see Environment#isExternalStorageRemovable(File)
-     */
-    public abstract File[] getExternalMediaDirs();
-
-    /**
-     * Returns an array of strings naming the private files associated with
-     * this Context's application package.
-     *
-     * @return Array of strings naming the private files.
-     *
-     * @see #openFileInput
-     * @see #openFileOutput
-     * @see #deleteFile
-     */
-    public abstract String[] fileList();
-
-    /**
-     * Retrieve, creating if needed, a new directory in which the application
-     * can place its own custom data files.  You can use the returned File
-     * object to create and access files in this directory.  Note that files
-     * created through a File object will only be accessible by your own
-     * application; you can only set the mode of the entire directory, not
-     * of individual files.
-     * <p>
-     * The returned path may change over time if the calling app is moved to an
-     * adopted storage device, so only relative paths should be persisted.
-     * <p>
-     * Apps require no extra permissions to read or write to the returned path,
-     * since this path lives in their private storage.
-     *
-     * @param name Name of the directory to retrieve.  This is a directory
-     * that is created as part of your application data.
-     * @param mode Operating mode.  Use 0 or {@link #MODE_PRIVATE} for the
-     * default operation, {@link #MODE_WORLD_READABLE} and
-     * {@link #MODE_WORLD_WRITEABLE} to control permissions.
-     *
-     * @return A {@link File} object for the requested directory.  The directory
-     * will have been created if it does not already exist.
-     *
-     * @see #openFileOutput(String, int)
-     */
-    public abstract File getDir(String name, int mode);
-
-    /**
-     * Open a new private SQLiteDatabase associated with this Context's
-     * application package.  Create the database file if it doesn't exist.
-     *
-     * @param name The name (unique in the application package) of the database.
-     * @param mode Operating mode.  Use 0 or {@link #MODE_PRIVATE} for the
-     *     default operation, {@link #MODE_WORLD_READABLE}
-     *     and {@link #MODE_WORLD_WRITEABLE} to control permissions.
-     *     Use {@link #MODE_ENABLE_WRITE_AHEAD_LOGGING} to enable write-ahead logging by default.
-     * @param factory An optional factory class that is called to instantiate a
-     *     cursor when query is called.
-     *
-     * @return The contents of a newly created database with the given name.
-     * @throws android.database.sqlite.SQLiteException if the database file could not be opened.
-     *
-     * @see #MODE_PRIVATE
-     * @see #MODE_WORLD_READABLE
-     * @see #MODE_WORLD_WRITEABLE
-     * @see #MODE_ENABLE_WRITE_AHEAD_LOGGING
-     * @see #deleteDatabase
-     */
-    public abstract SQLiteDatabase openOrCreateDatabase(String name,
-            int mode, CursorFactory factory);
-
-    /**
-     * Open a new private SQLiteDatabase associated with this Context's
-     * application package.  Creates the database file if it doesn't exist.
-     *
-     * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
-     * used to handle corruption when sqlite reports database corruption.</p>
-     *
-     * @param name The name (unique in the application package) of the database.
-     * @param mode Operating mode.  Use 0 or {@link #MODE_PRIVATE} for the
-     *     default operation, {@link #MODE_WORLD_READABLE}
-     *     and {@link #MODE_WORLD_WRITEABLE} to control permissions.
-     *     Use {@link #MODE_ENABLE_WRITE_AHEAD_LOGGING} to enable write-ahead logging by default.
-     * @param factory An optional factory class that is called to instantiate a
-     *     cursor when query is called.
-     * @param errorHandler the {@link DatabaseErrorHandler} to be used when sqlite reports database
-     * corruption. if null, {@link android.database.DefaultDatabaseErrorHandler} is assumed.
-     * @return The contents of a newly created database with the given name.
-     * @throws android.database.sqlite.SQLiteException if the database file could not be opened.
-     *
-     * @see #MODE_PRIVATE
-     * @see #MODE_WORLD_READABLE
-     * @see #MODE_WORLD_WRITEABLE
-     * @see #MODE_ENABLE_WRITE_AHEAD_LOGGING
-     * @see #deleteDatabase
-     */
-    public abstract SQLiteDatabase openOrCreateDatabase(String name,
-            int mode, CursorFactory factory,
-            @Nullable DatabaseErrorHandler errorHandler);
-
-    /**
-     * Delete an existing private SQLiteDatabase associated with this Context's
-     * application package.
-     *
-     * @param name The name (unique in the application package) of the
-     *             database.
-     *
-     * @return {@code true} if the database was successfully deleted; else {@code false}.
-     *
-     * @see #openOrCreateDatabase
-     */
-    public abstract boolean deleteDatabase(String name);
-
-    /**
-     * Returns the absolute path on the filesystem where a database created with
-     * {@link #openOrCreateDatabase} is stored.
-     * <p>
-     * The returned path may change over time if the calling app is moved to an
-     * adopted storage device, so only relative paths should be persisted.
-     *
-     * @param name The name of the database for which you would like to get
-     *          its path.
-     *
-     * @return An absolute path to the given database.
-     *
-     * @see #openOrCreateDatabase
-     */
-    public abstract File getDatabasePath(String name);
-
-    /**
-     * Returns an array of strings naming the private databases associated with
-     * this Context's application package.
-     *
-     * @return Array of strings naming the private databases.
-     *
-     * @see #openOrCreateDatabase
-     * @see #deleteDatabase
-     */
-    public abstract String[] databaseList();
-
-    /**
-     * @deprecated Use {@link android.app.WallpaperManager#getDrawable
-     * WallpaperManager.get()} instead.
-     */
-    @Deprecated
-    public abstract Drawable getWallpaper();
-
-    /**
-     * @deprecated Use {@link android.app.WallpaperManager#peekDrawable
-     * WallpaperManager.peek()} instead.
-     */
-    @Deprecated
-    public abstract Drawable peekWallpaper();
-
-    /**
-     * @deprecated Use {@link android.app.WallpaperManager#getDesiredMinimumWidth()
-     * WallpaperManager.getDesiredMinimumWidth()} instead.
-     */
-    @Deprecated
-    public abstract int getWallpaperDesiredMinimumWidth();
-
-    /**
-     * @deprecated Use {@link android.app.WallpaperManager#getDesiredMinimumHeight()
-     * WallpaperManager.getDesiredMinimumHeight()} instead.
-     */
-    @Deprecated
-    public abstract int getWallpaperDesiredMinimumHeight();
-
-    /**
-     * @deprecated Use {@link android.app.WallpaperManager#setBitmap(Bitmap)
-     * WallpaperManager.set()} instead.
-     * <p>This method requires the caller to hold the permission
-     * {@link android.Manifest.permission#SET_WALLPAPER}.
-     */
-    @Deprecated
-    public abstract void setWallpaper(Bitmap bitmap) throws IOException;
-
-    /**
-     * @deprecated Use {@link android.app.WallpaperManager#setStream(InputStream)
-     * WallpaperManager.set()} instead.
-     * <p>This method requires the caller to hold the permission
-     * {@link android.Manifest.permission#SET_WALLPAPER}.
-     */
-    @Deprecated
-    public abstract void setWallpaper(InputStream data) throws IOException;
-
-    /**
-     * @deprecated Use {@link android.app.WallpaperManager#clear
-     * WallpaperManager.clear()} instead.
-     * <p>This method requires the caller to hold the permission
-     * {@link android.Manifest.permission#SET_WALLPAPER}.
-     */
-    @Deprecated
-    public abstract void clearWallpaper() throws IOException;
-
-    /**
-     * Same as {@link #startActivity(Intent, Bundle)} with no options
-     * specified.
-     *
-     * @param intent The description of the activity to start.
-     *
-     * @throws ActivityNotFoundException &nbsp;
-     *`
-     * @see #startActivity(Intent, Bundle)
-     * @see PackageManager#resolveActivity
-     */
-    public abstract void startActivity(Intent intent);
-
-    /**
-     * Version of {@link #startActivity(Intent)} that allows you to specify the
-     * user the activity will be started for.  This is not available to applications
-     * that are not pre-installed on the system image.  Using it requires holding
-     * the INTERACT_ACROSS_USERS_FULL permission.
-     * @param intent The description of the activity to start.
-     * @param user The UserHandle of the user to start this activity for.
-     * @throws ActivityNotFoundException &nbsp;
-     * @hide
-     */
-    public void startActivityAsUser(Intent intent, UserHandle user) {
-        throw new RuntimeException("Not implemented. Must override in a subclass.");
-    }
-
-    /**
-     * Launch a new activity.  You will not receive any information about when
-     * the activity exits.
-     *
-     * <p>Note that if this method is being called from outside of an
-     * {@link android.app.Activity} Context, then the Intent must include
-     * the {@link Intent#FLAG_ACTIVITY_NEW_TASK} launch flag.  This is because,
-     * without being started from an existing Activity, there is no existing
-     * task in which to place the new activity and thus it needs to be placed
-     * in its own separate task.
-     *
-     * <p>This method throws {@link ActivityNotFoundException}
-     * if there was no Activity found to run the given Intent.
-     *
-     * @param intent The description of the activity to start.
-     * @param options Additional options for how the Activity should be started.
-     * May be null if there are no options.  See {@link android.app.ActivityOptions}
-     * for how to build the Bundle supplied here; there are no supported definitions
-     * for building it manually.
-     *
-     * @throws ActivityNotFoundException &nbsp;
-     *
-     * @see #startActivity(Intent)
-     * @see PackageManager#resolveActivity
-     */
-    public abstract void startActivity(Intent intent, @Nullable Bundle options);
-
-    /**
-     * Version of {@link #startActivity(Intent, Bundle)} that allows you to specify the
-     * user the activity will be started for.  This is not available to applications
-     * that are not pre-installed on the system image.  Using it requires holding
-     * the INTERACT_ACROSS_USERS_FULL permission.
-     * @param intent The description of the activity to start.
-     * @param options Additional options for how the Activity should be started.
-     * May be null if there are no options.  See {@link android.app.ActivityOptions}
-     * for how to build the Bundle supplied here; there are no supported definitions
-     * for building it manually.
-     * @param userId The UserHandle of the user to start this activity for.
-     * @throws ActivityNotFoundException &nbsp;
-     * @hide
-     */
-    public void startActivityAsUser(Intent intent, @Nullable Bundle options, UserHandle userId) {
-        throw new RuntimeException("Not implemented. Must override in a subclass.");
-    }
-
-    /**
-     * Version of {@link #startActivity(Intent, Bundle)} that returns a result to the caller. This
-     * is only supported for Views and Fragments.
-     * @param who The identifier for the calling element that will receive the result.
-     * @param intent The intent to start.
-     * @param requestCode The code that will be returned with onActivityResult() identifying this
-     *          request.
-     * @param options Additional options for how the Activity should be started.
-     *          May be null if there are no options.  See {@link android.app.ActivityOptions}
-     *          for how to build the Bundle supplied here; there are no supported definitions
-     *          for building it manually.
-     * @hide
-     */
-    public void startActivityForResult(
-            @NonNull String who, Intent intent, int requestCode, @Nullable Bundle options) {
-        throw new RuntimeException("This method is only implemented for Activity-based Contexts. "
-                + "Check canStartActivityForResult() before calling.");
-    }
-
-    /**
-     * Identifies whether this Context instance will be able to process calls to
-     * {@link #startActivityForResult(String, Intent, int, Bundle)}.
-     * @hide
-     */
-    public boolean canStartActivityForResult() {
-        return false;
-    }
-
-    /**
-     * Same as {@link #startActivities(Intent[], Bundle)} with no options
-     * specified.
-     *
-     * @param intents An array of Intents to be started.
-     *
-     * @throws ActivityNotFoundException &nbsp;
-     *
-     * @see #startActivities(Intent[], Bundle)
-     * @see PackageManager#resolveActivity
-     */
-    public abstract void startActivities(Intent[] intents);
-
-    /**
-     * Launch multiple new activities.  This is generally the same as calling
-     * {@link #startActivity(Intent)} for the first Intent in the array,
-     * that activity during its creation calling {@link #startActivity(Intent)}
-     * for the second entry, etc.  Note that unlike that approach, generally
-     * none of the activities except the last in the array will be created
-     * at this point, but rather will be created when the user first visits
-     * them (due to pressing back from the activity on top).
-     *
-     * <p>This method throws {@link ActivityNotFoundException}
-     * if there was no Activity found for <em>any</em> given Intent.  In this
-     * case the state of the activity stack is undefined (some Intents in the
-     * list may be on it, some not), so you probably want to avoid such situations.
-     *
-     * @param intents An array of Intents to be started.
-     * @param options Additional options for how the Activity should be started.
-     * See {@link android.content.Context#startActivity(Intent, Bundle)
-     * Context.startActivity(Intent, Bundle)} for more details.
-     *
-     * @throws ActivityNotFoundException &nbsp;
-     *
-     * @see #startActivities(Intent[])
-     * @see PackageManager#resolveActivity
-     */
-    public abstract void startActivities(Intent[] intents, Bundle options);
-
-    /**
-     * @hide
-     * Launch multiple new activities.  This is generally the same as calling
-     * {@link #startActivity(Intent)} for the first Intent in the array,
-     * that activity during its creation calling {@link #startActivity(Intent)}
-     * for the second entry, etc.  Note that unlike that approach, generally
-     * none of the activities except the last in the array will be created
-     * at this point, but rather will be created when the user first visits
-     * them (due to pressing back from the activity on top).
-     *
-     * <p>This method throws {@link ActivityNotFoundException}
-     * if there was no Activity found for <em>any</em> given Intent.  In this
-     * case the state of the activity stack is undefined (some Intents in the
-     * list may be on it, some not), so you probably want to avoid such situations.
-     *
-     * @param intents An array of Intents to be started.
-     * @param options Additional options for how the Activity should be started.
-     * @param userHandle The user for whom to launch the activities
-     * See {@link android.content.Context#startActivity(Intent, Bundle)
-     * Context.startActivity(Intent, Bundle)} for more details.
-     *
-     * @throws ActivityNotFoundException &nbsp;
-     *
-     * @see #startActivities(Intent[])
-     * @see PackageManager#resolveActivity
-     */
-    public void startActivitiesAsUser(Intent[] intents, Bundle options, UserHandle userHandle) {
-        throw new RuntimeException("Not implemented. Must override in a subclass.");
-    }
-
-    /**
-     * Same as {@link #startIntentSender(IntentSender, Intent, int, int, int, Bundle)}
-     * with no options specified.
-     *
-     * @param intent The IntentSender to launch.
-     * @param fillInIntent If non-null, this will be provided as the
-     * intent parameter to {@link IntentSender#sendIntent}.
-     * @param flagsMask Intent flags in the original IntentSender that you
-     * would like to change.
-     * @param flagsValues Desired values for any bits set in
-     * <var>flagsMask</var>
-     * @param extraFlags Always set to 0.
-     *
-     * @see #startActivity(Intent)
-     * @see #startIntentSender(IntentSender, Intent, int, int, int, Bundle)
-     */
-    public abstract void startIntentSender(IntentSender intent,
-            Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)
-            throws IntentSender.SendIntentException;
-
-    /**
-     * Like {@link #startActivity(Intent, Bundle)}, but taking a IntentSender
-     * to start.  If the IntentSender is for an activity, that activity will be started
-     * as if you had called the regular {@link #startActivity(Intent)}
-     * here; otherwise, its associated action will be executed (such as
-     * sending a broadcast) as if you had called
-     * {@link IntentSender#sendIntent IntentSender.sendIntent} on it.
-     *
-     * @param intent The IntentSender to launch.
-     * @param fillInIntent If non-null, this will be provided as the
-     * intent parameter to {@link IntentSender#sendIntent}.
-     * @param flagsMask Intent flags in the original IntentSender that you
-     * would like to change.
-     * @param flagsValues Desired values for any bits set in
-     * <var>flagsMask</var>
-     * @param extraFlags Always set to 0.
-     * @param options Additional options for how the Activity should be started.
-     * See {@link android.content.Context#startActivity(Intent, Bundle)
-     * Context.startActivity(Intent, Bundle)} for more details.  If options
-     * have also been supplied by the IntentSender, options given here will
-     * override any that conflict with those given by the IntentSender.
-     *
-     * @see #startActivity(Intent, Bundle)
-     * @see #startIntentSender(IntentSender, Intent, int, int, int)
-     */
-    public abstract void startIntentSender(IntentSender intent,
-            @Nullable Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags,
-            Bundle options) throws IntentSender.SendIntentException;
-
-    /**
-     * Broadcast the given intent to all interested BroadcastReceivers.  This
-     * call is asynchronous; it returns immediately, and you will continue
-     * executing while the receivers are run.  No results are propagated from
-     * receivers and receivers can not abort the broadcast. If you want
-     * to allow receivers to propagate results or abort the broadcast, you must
-     * send an ordered broadcast using
-     * {@link #sendOrderedBroadcast(Intent, String)}.
-     *
-     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
-     *
-     * @param intent The Intent to broadcast; all receivers matching this
-     *               Intent will receive the broadcast.
-     *
-     * @see android.content.BroadcastReceiver
-     * @see #registerReceiver
-     * @see #sendBroadcast(Intent, String)
-     * @see #sendOrderedBroadcast(Intent, String)
-     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
-     */
-    public abstract void sendBroadcast(Intent intent);
-
-    /**
-     * Broadcast the given intent to all interested BroadcastReceivers, allowing
-     * an optional required permission to be enforced.  This
-     * call is asynchronous; it returns immediately, and you will continue
-     * executing while the receivers are run.  No results are propagated from
-     * receivers and receivers can not abort the broadcast. If you want
-     * to allow receivers to propagate results or abort the broadcast, you must
-     * send an ordered broadcast using
-     * {@link #sendOrderedBroadcast(Intent, String)}.
-     *
-     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
-     *
-     * @param intent The Intent to broadcast; all receivers matching this
-     *               Intent will receive the broadcast.
-     * @param receiverPermission (optional) String naming a permission that
-     *               a receiver must hold in order to receive your broadcast.
-     *               If null, no permission is required.
-     *
-     * @see android.content.BroadcastReceiver
-     * @see #registerReceiver
-     * @see #sendBroadcast(Intent)
-     * @see #sendOrderedBroadcast(Intent, String)
-     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
-     */
-    public abstract void sendBroadcast(Intent intent,
-            @Nullable String receiverPermission);
-
-
-    /**
-     * Broadcast the given intent to all interested BroadcastReceivers, allowing
-     * an array of required permissions to be enforced.  This call is asynchronous; it returns
-     * immediately, and you will continue executing while the receivers are run.  No results are
-     * propagated from receivers and receivers can not abort the broadcast. If you want to allow
-     * receivers to propagate results or abort the broadcast, you must send an ordered broadcast
-     * using {@link #sendOrderedBroadcast(Intent, String)}.
-     *
-     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
-     *
-     * @param intent The Intent to broadcast; all receivers matching this
-     *               Intent will receive the broadcast.
-     * @param receiverPermissions Array of names of permissions that a receiver must hold
-     *                            in order to receive your broadcast.
-     *                            If null or empty, no permissions are required.
-     *
-     * @see android.content.BroadcastReceiver
-     * @see #registerReceiver
-     * @see #sendBroadcast(Intent)
-     * @see #sendOrderedBroadcast(Intent, String)
-     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
-     * @hide
-     */
-    public abstract void sendBroadcastMultiplePermissions(Intent intent,
-            String[] receiverPermissions);
-
-    /**
-     * Broadcast the given intent to all interested BroadcastReceivers, allowing
-     * an optional required permission to be enforced.  This
-     * call is asynchronous; it returns immediately, and you will continue
-     * executing while the receivers are run.  No results are propagated from
-     * receivers and receivers can not abort the broadcast. If you want
-     * to allow receivers to propagate results or abort the broadcast, you must
-     * send an ordered broadcast using
-     * {@link #sendOrderedBroadcast(Intent, String)}.
-     *
-     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
-     *
-     * @param intent The Intent to broadcast; all receivers matching this
-     *               Intent will receive the broadcast.
-     * @param receiverPermission (optional) String naming a permission that
-     *               a receiver must hold in order to receive your broadcast.
-     *               If null, no permission is required.
-     * @param options (optional) Additional sending options, generated from a
-     * {@link android.app.BroadcastOptions}.
-     *
-     * @see android.content.BroadcastReceiver
-     * @see #registerReceiver
-     * @see #sendBroadcast(Intent)
-     * @see #sendOrderedBroadcast(Intent, String)
-     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
-     * @hide
-     */
-    @SystemApi
-    public abstract void sendBroadcast(Intent intent,
-            @Nullable String receiverPermission,
-            @Nullable Bundle options);
-
-    /**
-     * Like {@link #sendBroadcast(Intent, String)}, but also allows specification
-     * of an associated app op as per {@link android.app.AppOpsManager}.
-     * @hide
-     */
-    public abstract void sendBroadcast(Intent intent,
-            String receiverPermission, int appOp);
-
-    /**
-     * Broadcast the given intent to all interested BroadcastReceivers, delivering
-     * them one at a time to allow more preferred receivers to consume the
-     * broadcast before it is delivered to less preferred receivers.  This
-     * call is asynchronous; it returns immediately, and you will continue
-     * executing while the receivers are run.
-     *
-     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
-     *
-     * @param intent The Intent to broadcast; all receivers matching this
-     *               Intent will receive the broadcast.
-     * @param receiverPermission (optional) String naming a permissions that
-     *               a receiver must hold in order to receive your broadcast.
-     *               If null, no permission is required.
-     *
-     * @see android.content.BroadcastReceiver
-     * @see #registerReceiver
-     * @see #sendBroadcast(Intent)
-     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
-     */
-    public abstract void sendOrderedBroadcast(Intent intent,
-            @Nullable String receiverPermission);
-
-    /**
-     * Version of {@link #sendBroadcast(Intent)} that allows you to
-     * receive data back from the broadcast.  This is accomplished by
-     * supplying your own BroadcastReceiver when calling, which will be
-     * treated as a final receiver at the end of the broadcast -- its
-     * {@link BroadcastReceiver#onReceive} method will be called with
-     * the result values collected from the other receivers.  The broadcast will
-     * be serialized in the same way as calling
-     * {@link #sendOrderedBroadcast(Intent, String)}.
-     *
-     * <p>Like {@link #sendBroadcast(Intent)}, this method is
-     * asynchronous; it will return before
-     * resultReceiver.onReceive() is called.
-     *
-     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
-     *
-     * @param intent The Intent to broadcast; all receivers matching this
-     *               Intent will receive the broadcast.
-     * @param receiverPermission String naming a permissions that
-     *               a receiver must hold in order to receive your broadcast.
-     *               If null, no permission is required.
-     * @param resultReceiver Your own BroadcastReceiver to treat as the final
-     *                       receiver of the broadcast.
-     * @param scheduler A custom Handler with which to schedule the
-     *                  resultReceiver callback; if null it will be
-     *                  scheduled in the Context's main thread.
-     * @param initialCode An initial value for the result code.  Often
-     *                    Activity.RESULT_OK.
-     * @param initialData An initial value for the result data.  Often
-     *                    null.
-     * @param initialExtras An initial value for the result extras.  Often
-     *                      null.
-     *
-     * @see #sendBroadcast(Intent)
-     * @see #sendBroadcast(Intent, String)
-     * @see #sendOrderedBroadcast(Intent, String)
-     * @see android.content.BroadcastReceiver
-     * @see #registerReceiver
-     * @see android.app.Activity#RESULT_OK
-     */
-    public abstract void sendOrderedBroadcast(@NonNull Intent intent,
-            @Nullable String receiverPermission, @Nullable BroadcastReceiver resultReceiver,
-            @Nullable Handler scheduler, int initialCode, @Nullable String initialData,
-            @Nullable Bundle initialExtras);
-
-    /**
-     * Version of {@link #sendBroadcast(Intent)} that allows you to
-     * receive data back from the broadcast.  This is accomplished by
-     * supplying your own BroadcastReceiver when calling, which will be
-     * treated as a final receiver at the end of the broadcast -- its
-     * {@link BroadcastReceiver#onReceive} method will be called with
-     * the result values collected from the other receivers.  The broadcast will
-     * be serialized in the same way as calling
-     * {@link #sendOrderedBroadcast(Intent, String)}.
-     *
-     * <p>Like {@link #sendBroadcast(Intent)}, this method is
-     * asynchronous; it will return before
-     * resultReceiver.onReceive() is called.
-     *
-     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
-     *
-     *
-     * @param intent The Intent to broadcast; all receivers matching this
-     *               Intent will receive the broadcast.
-     * @param receiverPermission String naming a permissions that
-     *               a receiver must hold in order to receive your broadcast.
-     *               If null, no permission is required.
-     * @param options (optional) Additional sending options, generated from a
-     * {@link android.app.BroadcastOptions}.
-     * @param resultReceiver Your own BroadcastReceiver to treat as the final
-     *                       receiver of the broadcast.
-     * @param scheduler A custom Handler with which to schedule the
-     *                  resultReceiver callback; if null it will be
-     *                  scheduled in the Context's main thread.
-     * @param initialCode An initial value for the result code.  Often
-     *                    Activity.RESULT_OK.
-     * @param initialData An initial value for the result data.  Often
-     *                    null.
-     * @param initialExtras An initial value for the result extras.  Often
-     *                      null.
-     * @see #sendBroadcast(Intent)
-     * @see #sendBroadcast(Intent, String)
-     * @see #sendOrderedBroadcast(Intent, String)
-     * @see android.content.BroadcastReceiver
-     * @see #registerReceiver
-     * @see android.app.Activity#RESULT_OK
-     * @hide
-     */
-    @SystemApi
-    public abstract void sendOrderedBroadcast(@NonNull Intent intent,
-            @Nullable String receiverPermission, @Nullable Bundle options,
-            @Nullable BroadcastReceiver resultReceiver, @Nullable Handler scheduler,
-            int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras);
-
-    /**
-     * Like {@link #sendOrderedBroadcast(Intent, String, BroadcastReceiver, android.os.Handler,
-     * int, String, android.os.Bundle)}, but also allows specification
-     * of an associated app op as per {@link android.app.AppOpsManager}.
-     * @hide
-     */
-    public abstract void sendOrderedBroadcast(Intent intent,
-            String receiverPermission, int appOp, BroadcastReceiver resultReceiver,
-            Handler scheduler, int initialCode, String initialData,
-            Bundle initialExtras);
-
-    /**
-     * Version of {@link #sendBroadcast(Intent)} that allows you to specify the
-     * user the broadcast will be sent to.  This is not available to applications
-     * that are not pre-installed on the system image.  Using it requires holding
-     * the INTERACT_ACROSS_USERS permission.
-     * @param intent The intent to broadcast
-     * @param user UserHandle to send the intent to.
-     * @see #sendBroadcast(Intent)
-     */
-    public abstract void sendBroadcastAsUser(Intent intent, UserHandle user);
-
-    /**
-     * Version of {@link #sendBroadcast(Intent, String)} that allows you to specify the
-     * user the broadcast will be sent to.  This is not available to applications
-     * that are not pre-installed on the system image.  Using it requires holding
-     * the INTERACT_ACROSS_USERS permission.
-     *
-     * @param intent The Intent to broadcast; all receivers matching this
-     *               Intent will receive the broadcast.
-     * @param user UserHandle to send the intent to.
-     * @param receiverPermission (optional) String naming a permission that
-     *               a receiver must hold in order to receive your broadcast.
-     *               If null, no permission is required.
-     *
-     * @see #sendBroadcast(Intent, String)
-     */
-    public abstract void sendBroadcastAsUser(Intent intent, UserHandle user,
-            @Nullable String receiverPermission);
-
-
-    /**
-     * Version of {@link #sendBroadcast(Intent, String)} that allows you to specify the
-     * user the broadcast will be sent to.  This is not available to applications
-     * that are not pre-installed on the system image.  Using it requires holding
-     * the INTERACT_ACROSS_USERS permission.
-     *
-     * @param intent The Intent to broadcast; all receivers matching this
-     *               Intent will receive the broadcast.
-     * @param user UserHandle to send the intent to.
-     * @param receiverPermission (optional) String naming a permission that
-     *               a receiver must hold in order to receive your broadcast.
-     *               If null, no permission is required.
-     * @param appOp The app op associated with the broadcast.
-     *
-     * @see #sendBroadcast(Intent, String)
-     *
-     * @hide
-     */
-    public abstract void sendBroadcastAsUser(Intent intent, UserHandle user,
-            @Nullable String receiverPermission, int appOp);
-
-    /**
-     * Version of
-     * {@link #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)}
-     * that allows you to specify the
-     * user the broadcast will be sent to.  This is not available to applications
-     * that are not pre-installed on the system image.  Using it requires holding
-     * the INTERACT_ACROSS_USERS permission.
-     *
-     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
-     *
-     * @param intent The Intent to broadcast; all receivers matching this
-     *               Intent will receive the broadcast.
-     * @param user UserHandle to send the intent to.
-     * @param receiverPermission String naming a permissions that
-     *               a receiver must hold in order to receive your broadcast.
-     *               If null, no permission is required.
-     * @param resultReceiver Your own BroadcastReceiver to treat as the final
-     *                       receiver of the broadcast.
-     * @param scheduler A custom Handler with which to schedule the
-     *                  resultReceiver callback; if null it will be
-     *                  scheduled in the Context's main thread.
-     * @param initialCode An initial value for the result code.  Often
-     *                    Activity.RESULT_OK.
-     * @param initialData An initial value for the result data.  Often
-     *                    null.
-     * @param initialExtras An initial value for the result extras.  Often
-     *                      null.
-     *
-     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
-     */
-    public abstract void sendOrderedBroadcastAsUser(Intent intent, UserHandle user,
-            @Nullable String receiverPermission, BroadcastReceiver resultReceiver,
-            @Nullable Handler scheduler, int initialCode, @Nullable String initialData,
-            @Nullable  Bundle initialExtras);
-
-    /**
-     * Similar to above but takes an appOp as well, to enforce restrictions.
-     * @see #sendOrderedBroadcastAsUser(Intent, UserHandle, String,
-     *       BroadcastReceiver, Handler, int, String, Bundle)
-     * @hide
-     */
-    public abstract void sendOrderedBroadcastAsUser(Intent intent, UserHandle user,
-            @Nullable String receiverPermission, int appOp, BroadcastReceiver resultReceiver,
-            @Nullable Handler scheduler, int initialCode, @Nullable String initialData,
-            @Nullable  Bundle initialExtras);
-
-    /**
-     * Similar to above but takes an appOp as well, to enforce restrictions, and an options Bundle.
-     * @see #sendOrderedBroadcastAsUser(Intent, UserHandle, String,
-     *       BroadcastReceiver, Handler, int, String, Bundle)
-     * @hide
-     */
-    public abstract void sendOrderedBroadcastAsUser(Intent intent, UserHandle user,
-            @Nullable String receiverPermission, int appOp, @Nullable Bundle options,
-            BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode,
-            @Nullable String initialData, @Nullable  Bundle initialExtras);
-
-    /**
-     * <p>Perform a {@link #sendBroadcast(Intent)} that is "sticky," meaning the
-     * Intent you are sending stays around after the broadcast is complete,
-     * so that others can quickly retrieve that data through the return
-     * value of {@link #registerReceiver(BroadcastReceiver, IntentFilter)}.  In
-     * all other ways, this behaves the same as
-     * {@link #sendBroadcast(Intent)}.
-     *
-     * <p>You must hold the {@link android.Manifest.permission#BROADCAST_STICKY}
-     * permission in order to use this API.  If you do not hold that
-     * permission, {@link SecurityException} will be thrown.
-     *
-     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone
-     * can access them), no protection (anyone can modify them), and many other problems.
-     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>
-     * has changed, with another mechanism for apps to retrieve the current value whenever
-     * desired.
-     *
-     * @param intent The Intent to broadcast; all receivers matching this
-     * Intent will receive the broadcast, and the Intent will be held to
-     * be re-broadcast to future receivers.
-     *
-     * @see #sendBroadcast(Intent)
-     * @see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
-     */
-    @Deprecated
-    public abstract void sendStickyBroadcast(Intent intent);
-
-    /**
-     * <p>Version of {@link #sendStickyBroadcast} that allows you to
-     * receive data back from the broadcast.  This is accomplished by
-     * supplying your own BroadcastReceiver when calling, which will be
-     * treated as a final receiver at the end of the broadcast -- its
-     * {@link BroadcastReceiver#onReceive} method will be called with
-     * the result values collected from the other receivers.  The broadcast will
-     * be serialized in the same way as calling
-     * {@link #sendOrderedBroadcast(Intent, String)}.
-     *
-     * <p>Like {@link #sendBroadcast(Intent)}, this method is
-     * asynchronous; it will return before
-     * resultReceiver.onReceive() is called.  Note that the sticky data
-     * stored is only the data you initially supply to the broadcast, not
-     * the result of any changes made by the receivers.
-     *
-     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
-     *
-     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone
-     * can access them), no protection (anyone can modify them), and many other problems.
-     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>
-     * has changed, with another mechanism for apps to retrieve the current value whenever
-     * desired.
-     *
-     * @param intent The Intent to broadcast; all receivers matching this
-     *               Intent will receive the broadcast.
-     * @param resultReceiver Your own BroadcastReceiver to treat as the final
-     *                       receiver of the broadcast.
-     * @param scheduler A custom Handler with which to schedule the
-     *                  resultReceiver callback; if null it will be
-     *                  scheduled in the Context's main thread.
-     * @param initialCode An initial value for the result code.  Often
-     *                    Activity.RESULT_OK.
-     * @param initialData An initial value for the result data.  Often
-     *                    null.
-     * @param initialExtras An initial value for the result extras.  Often
-     *                      null.
-     *
-     * @see #sendBroadcast(Intent)
-     * @see #sendBroadcast(Intent, String)
-     * @see #sendOrderedBroadcast(Intent, String)
-     * @see #sendStickyBroadcast(Intent)
-     * @see android.content.BroadcastReceiver
-     * @see #registerReceiver
-     * @see android.app.Activity#RESULT_OK
-     */
-    @Deprecated
-    public abstract void sendStickyOrderedBroadcast(Intent intent,
-            BroadcastReceiver resultReceiver,
-            @Nullable Handler scheduler, int initialCode, @Nullable String initialData,
-            @Nullable Bundle initialExtras);
-
-    /**
-     * <p>Remove the data previously sent with {@link #sendStickyBroadcast},
-     * so that it is as if the sticky broadcast had never happened.
-     *
-     * <p>You must hold the {@link android.Manifest.permission#BROADCAST_STICKY}
-     * permission in order to use this API.  If you do not hold that
-     * permission, {@link SecurityException} will be thrown.
-     *
-     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone
-     * can access them), no protection (anyone can modify them), and many other problems.
-     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>
-     * has changed, with another mechanism for apps to retrieve the current value whenever
-     * desired.
-     *
-     * @param intent The Intent that was previously broadcast.
-     *
-     * @see #sendStickyBroadcast
-     */
-    @Deprecated
-    public abstract void removeStickyBroadcast(Intent intent);
-
-    /**
-     * <p>Version of {@link #sendStickyBroadcast(Intent)} that allows you to specify the
-     * user the broadcast will be sent to.  This is not available to applications
-     * that are not pre-installed on the system image.  Using it requires holding
-     * the INTERACT_ACROSS_USERS permission.
-     *
-     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone
-     * can access them), no protection (anyone can modify them), and many other problems.
-     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>
-     * has changed, with another mechanism for apps to retrieve the current value whenever
-     * desired.
-     *
-     * @param intent The Intent to broadcast; all receivers matching this
-     * Intent will receive the broadcast, and the Intent will be held to
-     * be re-broadcast to future receivers.
-     * @param user UserHandle to send the intent to.
-     *
-     * @see #sendBroadcast(Intent)
-     */
-    @Deprecated
-    public abstract void sendStickyBroadcastAsUser(Intent intent, UserHandle user);
-
-    /**
-     * <p>Version of
-     * {@link #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)}
-     * that allows you to specify the
-     * user the broadcast will be sent to.  This is not available to applications
-     * that are not pre-installed on the system image.  Using it requires holding
-     * the INTERACT_ACROSS_USERS permission.
-     *
-     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
-     *
-     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone
-     * can access them), no protection (anyone can modify them), and many other problems.
-     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>
-     * has changed, with another mechanism for apps to retrieve the current value whenever
-     * desired.
-     *
-     * @param intent The Intent to broadcast; all receivers matching this
-     *               Intent will receive the broadcast.
-     * @param user UserHandle to send the intent to.
-     * @param resultReceiver Your own BroadcastReceiver to treat as the final
-     *                       receiver of the broadcast.
-     * @param scheduler A custom Handler with which to schedule the
-     *                  resultReceiver callback; if null it will be
-     *                  scheduled in the Context's main thread.
-     * @param initialCode An initial value for the result code.  Often
-     *                    Activity.RESULT_OK.
-     * @param initialData An initial value for the result data.  Often
-     *                    null.
-     * @param initialExtras An initial value for the result extras.  Often
-     *                      null.
-     *
-     * @see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
-     */
-    @Deprecated
-    public abstract void sendStickyOrderedBroadcastAsUser(Intent intent,
-            UserHandle user, BroadcastReceiver resultReceiver,
-            @Nullable Handler scheduler, int initialCode, @Nullable String initialData,
-            @Nullable Bundle initialExtras);
-
-    /**
-     * <p>Version of {@link #removeStickyBroadcast(Intent)} that allows you to specify the
-     * user the broadcast will be sent to.  This is not available to applications
-     * that are not pre-installed on the system image.  Using it requires holding
-     * the INTERACT_ACROSS_USERS permission.
-     *
-     * <p>You must hold the {@link android.Manifest.permission#BROADCAST_STICKY}
-     * permission in order to use this API.  If you do not hold that
-     * permission, {@link SecurityException} will be thrown.
-     *
-     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone
-     * can access them), no protection (anyone can modify them), and many other problems.
-     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>
-     * has changed, with another mechanism for apps to retrieve the current value whenever
-     * desired.
-     *
-     * @param intent The Intent that was previously broadcast.
-     * @param user UserHandle to remove the sticky broadcast from.
-     *
-     * @see #sendStickyBroadcastAsUser
-     */
-    @Deprecated
-    public abstract void removeStickyBroadcastAsUser(Intent intent, UserHandle user);
-
-    /**
-     * Register a BroadcastReceiver to be run in the main activity thread.  The
-     * <var>receiver</var> will be called with any broadcast Intent that
-     * matches <var>filter</var>, in the main application thread.
-     *
-     * <p>The system may broadcast Intents that are "sticky" -- these stay
-     * around after the broadcast as finished, to be sent to any later
-     * registrations. If your IntentFilter matches one of these sticky
-     * Intents, that Intent will be returned by this function
-     * <strong>and</strong> sent to your <var>receiver</var> as if it had just
-     * been broadcast.
-     *
-     * <p>There may be multiple sticky Intents that match <var>filter</var>,
-     * in which case each of these will be sent to <var>receiver</var>.  In
-     * this case, only one of these can be returned directly by the function;
-     * which of these that is returned is arbitrarily decided by the system.
-     *
-     * <p>If you know the Intent your are registering for is sticky, you can
-     * supply null for your <var>receiver</var>.  In this case, no receiver is
-     * registered -- the function simply returns the sticky Intent that
-     * matches <var>filter</var>.  In the case of multiple matches, the same
-     * rules as described above apply.
-     *
-     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
-     *
-     * <p>As of {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH}, receivers
-     * registered with this method will correctly respect the
-     * {@link Intent#setPackage(String)} specified for an Intent being broadcast.
-     * Prior to that, it would be ignored and delivered to all matching registered
-     * receivers.  Be careful if using this for security.</p>
-     *
-     * <p class="note">Note: this method <em>cannot be called from a
-     * {@link BroadcastReceiver} component;</em> that is, from a BroadcastReceiver
-     * that is declared in an application's manifest.  It is okay, however, to call
-     * this method from another BroadcastReceiver that has itself been registered
-     * at run time with {@link #registerReceiver}, since the lifetime of such a
-     * registered BroadcastReceiver is tied to the object that registered it.</p>
-     *
-     * @param receiver The BroadcastReceiver to handle the broadcast.
-     * @param filter Selects the Intent broadcasts to be received.
-     *
-     * @return The first sticky intent found that matches <var>filter</var>,
-     *         or null if there are none.
-     *
-     * @see #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)
-     * @see #sendBroadcast
-     * @see #unregisterReceiver
-     */
-    @Nullable
-    public abstract Intent registerReceiver(@Nullable BroadcastReceiver receiver,
-                                            IntentFilter filter);
-
-    /**
-     * Register to receive intent broadcasts, to run in the context of
-     * <var>scheduler</var>.  See
-     * {@link #registerReceiver(BroadcastReceiver, IntentFilter)} for more
-     * information.  This allows you to enforce permissions on who can
-     * broadcast intents to your receiver, or have the receiver run in
-     * a different thread than the main application thread.
-     *
-     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
-     *
-     * <p>As of {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH}, receivers
-     * registered with this method will correctly respect the
-     * {@link Intent#setPackage(String)} specified for an Intent being broadcast.
-     * Prior to that, it would be ignored and delivered to all matching registered
-     * receivers.  Be careful if using this for security.</p>
-     *
-     * @param receiver The BroadcastReceiver to handle the broadcast.
-     * @param filter Selects the Intent broadcasts to be received.
-     * @param broadcastPermission String naming a permissions that a
-     *      broadcaster must hold in order to send an Intent to you.  If null,
-     *      no permission is required.
-     * @param scheduler Handler identifying the thread that will receive
-     *      the Intent.  If null, the main thread of the process will be used.
-     *
-     * @return The first sticky intent found that matches <var>filter</var>,
-     *         or null if there are none.
-     *
-     * @see #registerReceiver(BroadcastReceiver, IntentFilter)
-     * @see #sendBroadcast
-     * @see #unregisterReceiver
-     */
-    @Nullable
-    public abstract Intent registerReceiver(BroadcastReceiver receiver,
-            IntentFilter filter, @Nullable String broadcastPermission,
-            @Nullable Handler scheduler);
-
-    /**
-     * @hide
-     * Same as {@link #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)
-     * but for a specific user.  This receiver will receiver broadcasts that
-     * are sent to the requested user.  It
-     * requires holding the {@link android.Manifest.permission#INTERACT_ACROSS_USERS_FULL}
-     * permission.
-     *
-     * @param receiver The BroadcastReceiver to handle the broadcast.
-     * @param user UserHandle to send the intent to.
-     * @param filter Selects the Intent broadcasts to be received.
-     * @param broadcastPermission String naming a permissions that a
-     *      broadcaster must hold in order to send an Intent to you.  If null,
-     *      no permission is required.
-     * @param scheduler Handler identifying the thread that will receive
-     *      the Intent.  If null, the main thread of the process will be used.
-     *
-     * @return The first sticky intent found that matches <var>filter</var>,
-     *         or null if there are none.
-     *
-     * @see #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)
-     * @see #sendBroadcast
-     * @see #unregisterReceiver
-     */
-    @Nullable
-    public abstract Intent registerReceiverAsUser(BroadcastReceiver receiver,
-            UserHandle user, IntentFilter filter, @Nullable String broadcastPermission,
-            @Nullable Handler scheduler);
-
-    /**
-     * Unregister a previously registered BroadcastReceiver.  <em>All</em>
-     * filters that have been registered for this BroadcastReceiver will be
-     * removed.
-     *
-     * @param receiver The BroadcastReceiver to unregister.
-     *
-     * @see #registerReceiver
-     */
-    public abstract void unregisterReceiver(BroadcastReceiver receiver);
-
-    /**
-     * Request that a given application service be started.  The Intent
-     * should contain either contain the complete class name of a specific service
-     * implementation to start or a specific package name to target.  If the
-     * Intent is less specified, it log a warning about this and which of the
-     * multiple matching services it finds and uses will be undefined.  If this service
-     * is not already running, it will be instantiated and started (creating a
-     * process for it if needed); if it is running then it remains running.
-     *
-     * <p>Every call to this method will result in a corresponding call to
-     * the target service's {@link android.app.Service#onStartCommand} method,
-     * with the <var>intent</var> given here.  This provides a convenient way
-     * to submit jobs to a service without having to bind and call on to its
-     * interface.
-     *
-     * <p>Using startService() overrides the default service lifetime that is
-     * managed by {@link #bindService}: it requires the service to remain
-     * running until {@link #stopService} is called, regardless of whether
-     * any clients are connected to it.  Note that calls to startService()
-     * are not nesting: no matter how many times you call startService(),
-     * a single call to {@link #stopService} will stop it.
-     *
-     * <p>The system attempts to keep running services around as much as
-     * possible.  The only time they should be stopped is if the current
-     * foreground application is using so many resources that the service needs
-     * to be killed.  If any errors happen in the service's process, it will
-     * automatically be restarted.
-     *
-     * <p>This function will throw {@link SecurityException} if you do not
-     * have permission to start the given service.
-     *
-     * @param service Identifies the service to be started.  The Intent must be either
-     *      fully explicit (supplying a component name) or specify a specific package
-     *      name it is targetted to.  Additional values
-     *      may be included in the Intent extras to supply arguments along with
-     *      this specific start call.
-     *
-     * @return If the service is being started or is already running, the
-     * {@link ComponentName} of the actual service that was started is
-     * returned; else if the service does not exist null is returned.
-     *
-     * @throws SecurityException &nbsp;
-     *
-     * @see #stopService
-     * @see #bindService
-     */
-    @Nullable
-    public abstract ComponentName startService(Intent service);
-
-    /**
-     * Request that a given application service be stopped.  If the service is
-     * not running, nothing happens.  Otherwise it is stopped.  Note that calls
-     * to startService() are not counted -- this stops the service no matter
-     * how many times it was started.
-     *
-     * <p>Note that if a stopped service still has {@link ServiceConnection}
-     * objects bound to it with the {@link #BIND_AUTO_CREATE} set, it will
-     * not be destroyed until all of these bindings are removed.  See
-     * the {@link android.app.Service} documentation for more details on a
-     * service's lifecycle.
-     *
-     * <p>This function will throw {@link SecurityException} if you do not
-     * have permission to stop the given service.
-     *
-     * @param service Description of the service to be stopped.  The Intent must be either
-     *      fully explicit (supplying a component name) or specify a specific package
-     *      name it is targetted to.
-     *
-     * @return If there is a service matching the given Intent that is already
-     * running, then it is stopped and {@code true} is returned; else {@code false} is returned.
-     *
-     * @throws SecurityException &nbsp;
-     *
-     * @see #startService
-     */
-    public abstract boolean stopService(Intent service);
-
-    /**
-     * @hide like {@link #startService(Intent)} but for a specific user.
-     */
-    public abstract ComponentName startServiceAsUser(Intent service, UserHandle user);
-
-    /**
-     * @hide like {@link #stopService(Intent)} but for a specific user.
-     */
-    public abstract boolean stopServiceAsUser(Intent service, UserHandle user);
-
-    /**
-     * Connect to an application service, creating it if needed.  This defines
-     * a dependency between your application and the service.  The given
-     * <var>conn</var> will receive the service object when it is created and be
-     * told if it dies and restarts.  The service will be considered required
-     * by the system only for as long as the calling context exists.  For
-     * example, if this Context is an Activity that is stopped, the service will
-     * not be required to continue running until the Activity is resumed.
-     *
-     * <p>This function will throw {@link SecurityException} if you do not
-     * have permission to bind to the given service.
-     *
-     * <p class="note">Note: this method <em>can not be called from a
-     * {@link BroadcastReceiver} component</em>.  A pattern you can use to
-     * communicate from a BroadcastReceiver to a Service is to call
-     * {@link #startService} with the arguments containing the command to be
-     * sent, with the service calling its
-     * {@link android.app.Service#stopSelf(int)} method when done executing
-     * that command.  See the API demo App/Service/Service Start Arguments
-     * Controller for an illustration of this.  It is okay, however, to use
-     * this method from a BroadcastReceiver that has been registered with
-     * {@link #registerReceiver}, since the lifetime of this BroadcastReceiver
-     * is tied to another object (the one that registered it).</p>
-     *
-     * @param service Identifies the service to connect to.  The Intent may
-     *      specify either an explicit component name, or a logical
-     *      description (action, category, etc) to match an
-     *      {@link IntentFilter} published by a service.
-     * @param conn Receives information as the service is started and stopped.
-     *      This must be a valid ServiceConnection object; it must not be null.
-     * @param flags Operation options for the binding.  May be 0,
-     *          {@link #BIND_AUTO_CREATE}, {@link #BIND_DEBUG_UNBIND},
-     *          {@link #BIND_NOT_FOREGROUND}, {@link #BIND_ABOVE_CLIENT},
-     *          {@link #BIND_ALLOW_OOM_MANAGEMENT}, or
-     *          {@link #BIND_WAIVE_PRIORITY}.
-     * @return If you have successfully bound to the service, {@code true} is returned;
-     *         {@code false} is returned if the connection is not made so you will not
-     *         receive the service object.
-     *
-     * @throws SecurityException &nbsp;
-     *
-     * @see #unbindService
-     * @see #startService
-     * @see #BIND_AUTO_CREATE
-     * @see #BIND_DEBUG_UNBIND
-     * @see #BIND_NOT_FOREGROUND
-     */
-    public abstract boolean bindService(Intent service, @NonNull ServiceConnection conn,
-            @BindServiceFlags int flags);
-
-    /**
-     * Same as {@link #bindService(Intent, ServiceConnection, int)}, but with an explicit userHandle
-     * argument for use by system server and other multi-user aware code.
-     * @hide
-     */
-    @SystemApi
-    @SuppressWarnings("unused")
-    public boolean bindServiceAsUser(Intent service, ServiceConnection conn,
-            int flags, UserHandle user) {
-        throw new RuntimeException("Not implemented. Must override in a subclass.");
-    }
-
-    /**
-     * Disconnect from an application service.  You will no longer receive
-     * calls as the service is restarted, and the service is now allowed to
-     * stop at any time.
-     *
-     * @param conn The connection interface previously supplied to
-     *             bindService().  This parameter must not be null.
-     *
-     * @see #bindService
-     */
-    public abstract void unbindService(@NonNull ServiceConnection conn);
-
-    /**
-     * Start executing an {@link android.app.Instrumentation} class.  The given
-     * Instrumentation component will be run by killing its target application
-     * (if currently running), starting the target process, instantiating the
-     * instrumentation component, and then letting it drive the application.
-     *
-     * <p>This function is not synchronous -- it returns as soon as the
-     * instrumentation has started and while it is running.
-     *
-     * <p>Instrumentation is normally only allowed to run against a package
-     * that is either unsigned or signed with a signature that the
-     * the instrumentation package is also signed with (ensuring the target
-     * trusts the instrumentation).
-     *
-     * @param className Name of the Instrumentation component to be run.
-     * @param profileFile Optional path to write profiling data as the
-     * instrumentation runs, or null for no profiling.
-     * @param arguments Additional optional arguments to pass to the
-     * instrumentation, or null.
-     *
-     * @return {@code true} if the instrumentation was successfully started,
-     * else {@code false} if it could not be found.
-     */
-    public abstract boolean startInstrumentation(@NonNull ComponentName className,
-            @Nullable String profileFile, @Nullable Bundle arguments);
-
-    /** @hide */
-    @StringDef({
-            POWER_SERVICE,
-            WINDOW_SERVICE,
-            LAYOUT_INFLATER_SERVICE,
-            ACCOUNT_SERVICE,
-            ACTIVITY_SERVICE,
-            ALARM_SERVICE,
-            NOTIFICATION_SERVICE,
-            ACCESSIBILITY_SERVICE,
-            CAPTIONING_SERVICE,
-            KEYGUARD_SERVICE,
-            LOCATION_SERVICE,
-            //@hide: COUNTRY_DETECTOR,
-            SEARCH_SERVICE,
-            SENSOR_SERVICE,
-            STORAGE_SERVICE,
-            WALLPAPER_SERVICE,
-            VIBRATOR_SERVICE,
-            //@hide: STATUS_BAR_SERVICE,
-            CONNECTIVITY_SERVICE,
-            //@hide: UPDATE_LOCK_SERVICE,
-            //@hide: NETWORKMANAGEMENT_SERVICE,
-            NETWORK_STATS_SERVICE,
-            //@hide: NETWORK_POLICY_SERVICE,
-            WIFI_SERVICE,
-            WIFI_PASSPOINT_SERVICE,
-            WIFI_P2P_SERVICE,
-            WIFI_SCANNING_SERVICE,
-            //@hide: WIFI_RTT_SERVICE,
-            //@hide: ETHERNET_SERVICE,
-            WIFI_RTT_SERVICE,
-            NSD_SERVICE,
-            AUDIO_SERVICE,
-            FINGERPRINT_SERVICE,
-            MEDIA_ROUTER_SERVICE,
-            TELEPHONY_SERVICE,
-            TELEPHONY_SUBSCRIPTION_SERVICE,
-            CARRIER_CONFIG_SERVICE,
-            TELECOM_SERVICE,
-            CLIPBOARD_SERVICE,
-            INPUT_METHOD_SERVICE,
-            TEXT_SERVICES_MANAGER_SERVICE,
-            APPWIDGET_SERVICE,
-            //@hide: VOICE_INTERACTION_MANAGER_SERVICE,
-            //@hide: BACKUP_SERVICE,
-            DROPBOX_SERVICE,
-            //@hide: DEVICE_IDLE_CONTROLLER,
-            DEVICE_POLICY_SERVICE,
-            UI_MODE_SERVICE,
-            DOWNLOAD_SERVICE,
-            NFC_SERVICE,
-            BLUETOOTH_SERVICE,
-            //@hide: SIP_SERVICE,
-            USB_SERVICE,
-            LAUNCHER_APPS_SERVICE,
-            //@hide: SERIAL_SERVICE,
-            //@hide: HDMI_CONTROL_SERVICE,
-            INPUT_SERVICE,
-            DISPLAY_SERVICE,
-            USER_SERVICE,
-            RESTRICTIONS_SERVICE,
-            APP_OPS_SERVICE,
-            CAMERA_SERVICE,
-            PRINT_SERVICE,
-            CONSUMER_IR_SERVICE,
-            //@hide: TRUST_SERVICE,
-            TV_INPUT_SERVICE,
-            //@hide: NETWORK_SCORE_SERVICE,
-            USAGE_STATS_SERVICE,
-            MEDIA_SESSION_SERVICE,
-            BATTERY_SERVICE,
-            JOB_SCHEDULER_SERVICE,
-            //@hide: PERSISTENT_DATA_BLOCK_SERVICE,
-            MEDIA_PROJECTION_SERVICE,
-            MIDI_SERVICE,
-            RADIO_SERVICE,
-    })
-    @Retention(RetentionPolicy.SOURCE)
-    public @interface ServiceName {}
-
-    /**
-     * Return the handle to a system-level service by name. The class of the
-     * returned object varies by the requested name. Currently available names
-     * are:
-     *
-     * <dl>
-     *  <dt> {@link #WINDOW_SERVICE} ("window")
-     *  <dd> The top-level window manager in which you can place custom
-     *  windows.  The returned object is a {@link android.view.WindowManager}.
-     *  <dt> {@link #LAYOUT_INFLATER_SERVICE} ("layout_inflater")
-     *  <dd> A {@link android.view.LayoutInflater} for inflating layout resources
-     *  in this context.
-     *  <dt> {@link #ACTIVITY_SERVICE} ("activity")
-     *  <dd> A {@link android.app.ActivityManager} for interacting with the
-     *  global activity state of the system.
-     *  <dt> {@link #POWER_SERVICE} ("power")
-     *  <dd> A {@link android.os.PowerManager} for controlling power
-     *  management.
-     *  <dt> {@link #ALARM_SERVICE} ("alarm")
-     *  <dd> A {@link android.app.AlarmManager} for receiving intents at the
-     *  time of your choosing.
-     *  <dt> {@link #NOTIFICATION_SERVICE} ("notification")
-     *  <dd> A {@link android.app.NotificationManager} for informing the user
-     *   of background events.
-     *  <dt> {@link #KEYGUARD_SERVICE} ("keyguard")
-     *  <dd> A {@link android.app.KeyguardManager} for controlling keyguard.
-     *  <dt> {@link #LOCATION_SERVICE} ("location")
-     *  <dd> A {@link android.location.LocationManager} for controlling location
-     *   (e.g., GPS) updates.
-     *  <dt> {@link #SEARCH_SERVICE} ("search")
-     *  <dd> A {@link android.app.SearchManager} for handling search.
-     *  <dt> {@link #VIBRATOR_SERVICE} ("vibrator")
-     *  <dd> A {@link android.os.Vibrator} for interacting with the vibrator
-     *  hardware.
-     *  <dt> {@link #CONNECTIVITY_SERVICE} ("connection")
-     *  <dd> A {@link android.net.ConnectivityManager ConnectivityManager} for
-     *  handling management of network connections.
-     *  <dt> {@link #WIFI_SERVICE} ("wifi")
-     *  <dd> A {@link android.net.wifi.WifiManager WifiManager} for management of
-     * Wi-Fi connectivity.
-     *  <dt> {@link #WIFI_P2P_SERVICE} ("wifip2p")
-     *  <dd> A {@link android.net.wifi.p2p.WifiP2pManager WifiP2pManager} for management of
-     * Wi-Fi Direct connectivity.
-     * <dt> {@link #INPUT_METHOD_SERVICE} ("input_method")
-     * <dd> An {@link android.view.inputmethod.InputMethodManager InputMethodManager}
-     * for management of input methods.
-     * <dt> {@link #UI_MODE_SERVICE} ("uimode")
-     * <dd> An {@link android.app.UiModeManager} for controlling UI modes.
-     * <dt> {@link #DOWNLOAD_SERVICE} ("download")
-     * <dd> A {@link android.app.DownloadManager} for requesting HTTP downloads
-     * <dt> {@link #BATTERY_SERVICE} ("batterymanager")
-     * <dd> A {@link android.os.BatteryManager} for managing battery state
-     * <dt> {@link #JOB_SCHEDULER_SERVICE} ("taskmanager")
-     * <dd>  A {@link android.app.job.JobScheduler} for managing scheduled tasks
-     * <dt> {@link #NETWORK_STATS_SERVICE} ("netstats")
-     * <dd> A {@link android.app.usage.NetworkStatsManager NetworkStatsManager} for querying network
-     * usage statistics.
-     * </dl>
-     *
-     * <p>Note:  System services obtained via this API may be closely associated with
-     * the Context in which they are obtained from.  In general, do not share the
-     * service objects between various different contexts (Activities, Applications,
-     * Services, Providers, etc.)
-     *
-     * @param name The name of the desired service.
-     *
-     * @return The service or null if the name does not exist.
-     *
-     * @see #WINDOW_SERVICE
-     * @see android.view.WindowManager
-     * @see #LAYOUT_INFLATER_SERVICE
-     * @see android.view.LayoutInflater
-     * @see #ACTIVITY_SERVICE
-     * @see android.app.ActivityManager
-     * @see #POWER_SERVICE
-     * @see android.os.PowerManager
-     * @see #ALARM_SERVICE
-     * @see android.app.AlarmManager
-     * @see #NOTIFICATION_SERVICE
-     * @see android.app.NotificationManager
-     * @see #KEYGUARD_SERVICE
-     * @see android.app.KeyguardManager
-     * @see #LOCATION_SERVICE
-     * @see android.location.LocationManager
-     * @see #SEARCH_SERVICE
-     * @see android.app.SearchManager
-     * @see #SENSOR_SERVICE
-     * @see android.hardware.SensorManager
-     * @see #STORAGE_SERVICE
-     * @see android.os.storage.StorageManager
-     * @see #VIBRATOR_SERVICE
-     * @see android.os.Vibrator
-     * @see #CONNECTIVITY_SERVICE
-     * @see android.net.ConnectivityManager
-     * @see #WIFI_SERVICE
-     * @see android.net.wifi.WifiManager
-     * @see #AUDIO_SERVICE
-     * @see android.media.AudioManager
-     * @see #MEDIA_ROUTER_SERVICE
-     * @see android.media.MediaRouter
-     * @see #TELEPHONY_SERVICE
-     * @see android.telephony.TelephonyManager
-     * @see #TELEPHONY_SUBSCRIPTION_SERVICE
-     * @see android.telephony.SubscriptionManager
-     * @see #CARRIER_CONFIG_SERVICE
-     * @see android.telephony.CarrierConfigManager
-     * @see #INPUT_METHOD_SERVICE
-     * @see android.view.inputmethod.InputMethodManager
-     * @see #UI_MODE_SERVICE
-     * @see android.app.UiModeManager
-     * @see #DOWNLOAD_SERVICE
-     * @see android.app.DownloadManager
-     * @see #BATTERY_SERVICE
-     * @see android.os.BatteryManager
-     * @see #JOB_SCHEDULER_SERVICE
-     * @see android.app.job.JobScheduler
-     * @see #NETWORK_STATS_SERVICE
-     * @see android.app.usage.NetworkStatsManager
-     */
-    public abstract Object getSystemService(@ServiceName @NonNull String name);
-
-    /**
-     * Return the handle to a system-level service by class.
-     * <p>
-     * Currently available classes are:
-     * {@link android.view.WindowManager}, {@link android.view.LayoutInflater},
-     * {@link android.app.ActivityManager}, {@link android.os.PowerManager},
-     * {@link android.app.AlarmManager}, {@link android.app.NotificationManager},
-     * {@link android.app.KeyguardManager}, {@link android.location.LocationManager},
-     * {@link android.app.SearchManager}, {@link android.os.Vibrator},
-     * {@link android.net.ConnectivityManager},
-     * {@link android.net.wifi.WifiManager},
-     * {@link android.media.AudioManager}, {@link android.media.MediaRouter},
-     * {@link android.telephony.TelephonyManager}, {@link android.telephony.SubscriptionManager},
-     * {@link android.view.inputmethod.InputMethodManager},
-     * {@link android.app.UiModeManager}, {@link android.app.DownloadManager},
-     * {@link android.os.BatteryManager}, {@link android.app.job.JobScheduler},
-     * {@link android.app.usage.NetworkStatsManager}.
-     * </p><p>
-     * Note: System services obtained via this API may be closely associated with
-     * the Context in which they are obtained from.  In general, do not share the
-     * service objects between various different contexts (Activities, Applications,
-     * Services, Providers, etc.)
-     * </p>
-     *
-     * @param serviceClass The class of the desired service.
-     * @return The service or null if the class is not a supported system service.
-     */
-    @SuppressWarnings("unchecked")
-    public final <T> T getSystemService(Class<T> serviceClass) {
-        // Because subclasses may override getSystemService(String) we cannot
-        // perform a lookup by class alone.  We must first map the class to its
-        // service name then invoke the string-based method.
-        String serviceName = getSystemServiceName(serviceClass);
-        return serviceName != null ? (T)getSystemService(serviceName) : null;
-    }
-
-    /**
-     * Gets the name of the system-level service that is represented by the specified class.
-     *
-     * @param serviceClass The class of the desired service.
-     * @return The service name or null if the class is not a supported system service.
-     */
-    public abstract String getSystemServiceName(Class<?> serviceClass);
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.os.PowerManager} for controlling power management,
-     * including "wake locks," which let you keep the device on while
-     * you're running long tasks.
-     */
-    public static final String POWER_SERVICE = "power";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.view.WindowManager} for accessing the system's window
-     * manager.
-     *
-     * @see #getSystemService
-     * @see android.view.WindowManager
-     */
-    public static final String WINDOW_SERVICE = "window";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.view.LayoutInflater} for inflating layout resources in this
-     * context.
-     *
-     * @see #getSystemService
-     * @see android.view.LayoutInflater
-     */
-    public static final String LAYOUT_INFLATER_SERVICE = "layout_inflater";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.accounts.AccountManager} for receiving intents at a
-     * time of your choosing.
-     *
-     * @see #getSystemService
-     * @see android.accounts.AccountManager
-     */
-    public static final String ACCOUNT_SERVICE = "account";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.app.ActivityManager} for interacting with the global
-     * system state.
-     *
-     * @see #getSystemService
-     * @see android.app.ActivityManager
-     */
-    public static final String ACTIVITY_SERVICE = "activity";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.app.AlarmManager} for receiving intents at a
-     * time of your choosing.
-     *
-     * @see #getSystemService
-     * @see android.app.AlarmManager
-     */
-    public static final String ALARM_SERVICE = "alarm";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.app.NotificationManager} for informing the user of
-     * background events.
-     *
-     * @see #getSystemService
-     * @see android.app.NotificationManager
-     */
-    public static final String NOTIFICATION_SERVICE = "notification";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.view.accessibility.AccessibilityManager} for giving the user
-     * feedback for UI events through the registered event listeners.
-     *
-     * @see #getSystemService
-     * @see android.view.accessibility.AccessibilityManager
-     */
-    public static final String ACCESSIBILITY_SERVICE = "accessibility";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.view.accessibility.CaptioningManager} for obtaining
-     * captioning properties and listening for changes in captioning
-     * preferences.
-     *
-     * @see #getSystemService
-     * @see android.view.accessibility.CaptioningManager
-     */
-    public static final String CAPTIONING_SERVICE = "captioning";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.app.NotificationManager} for controlling keyguard.
-     *
-     * @see #getSystemService
-     * @see android.app.KeyguardManager
-     */
-    public static final String KEYGUARD_SERVICE = "keyguard";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.location.LocationManager} for controlling location
-     * updates.
-     *
-     * @see #getSystemService
-     * @see android.location.LocationManager
-     */
-    public static final String LOCATION_SERVICE = "location";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.location.CountryDetector} for detecting the country that
-     * the user is in.
-     *
-     * @hide
-     */
-    public static final String COUNTRY_DETECTOR = "country_detector";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.app.SearchManager} for handling searches.
-     *
-     * @see #getSystemService
-     * @see android.app.SearchManager
-     */
-    public static final String SEARCH_SERVICE = "search";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.hardware.SensorManager} for accessing sensors.
-     *
-     * @see #getSystemService
-     * @see android.hardware.SensorManager
-     */
-    public static final String SENSOR_SERVICE = "sensor";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.os.storage.StorageManager} for accessing system storage
-     * functions.
-     *
-     * @see #getSystemService
-     * @see android.os.storage.StorageManager
-     */
-    public static final String STORAGE_SERVICE = "storage";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * com.android.server.WallpaperService for accessing wallpapers.
-     *
-     * @see #getSystemService
-     */
-    public static final String WALLPAPER_SERVICE = "wallpaper";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.os.Vibrator} for interacting with the vibration hardware.
-     *
-     * @see #getSystemService
-     * @see android.os.Vibrator
-     */
-    public static final String VIBRATOR_SERVICE = "vibrator";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.app.StatusBarManager} for interacting with the status bar.
-     *
-     * @see #getSystemService
-     * @see android.app.StatusBarManager
-     * @hide
-     */
-    public static final String STATUS_BAR_SERVICE = "statusbar";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.net.ConnectivityManager} for handling management of
-     * network connections.
-     *
-     * @see #getSystemService
-     * @see android.net.ConnectivityManager
-     */
-    public static final String CONNECTIVITY_SERVICE = "connectivity";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.os.IUpdateLock} for managing runtime sequences that
-     * must not be interrupted by headless OTA application or similar.
-     *
-     * @hide
-     * @see #getSystemService
-     * @see android.os.UpdateLock
-     */
-    public static final String UPDATE_LOCK_SERVICE = "updatelock";
-
-    /**
-     * Constant for the internal network management service, not really a Context service.
-     * @hide
-     */
-    public static final String NETWORKMANAGEMENT_SERVICE = "network_management";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.app.usage.NetworkStatsManager} for querying network usage stats.
-     *
-     * @see #getSystemService
-     * @see android.app.usage.NetworkStatsManager
-     */
-    public static final String NETWORK_STATS_SERVICE = "netstats";
-    /** {@hide} */
-    public static final String NETWORK_POLICY_SERVICE = "netpolicy";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.net.wifi.WifiManager} for handling management of
-     * Wi-Fi access.
-     *
-     * @see #getSystemService
-     * @see android.net.wifi.WifiManager
-     */
-    public static final String WIFI_SERVICE = "wifi";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.net.wifi.passpoint.WifiPasspointManager} for handling management of
-     * Wi-Fi passpoint access.
-     *
-     * @see #getSystemService
-     * @see android.net.wifi.passpoint.WifiPasspointManager
-     * @hide
-     */
-    public static final String WIFI_PASSPOINT_SERVICE = "wifipasspoint";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.net.wifi.p2p.WifiP2pManager} for handling management of
-     * Wi-Fi peer-to-peer connections.
-     *
-     * @see #getSystemService
-     * @see android.net.wifi.p2p.WifiP2pManager
-     */
-    public static final String WIFI_P2P_SERVICE = "wifip2p";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.net.wifi.WifiScanner} for scanning the wifi universe
-     *
-     * @see #getSystemService
-     * @see android.net.wifi.WifiScanner
-     * @hide
-     */
-    @SystemApi
-    public static final String WIFI_SCANNING_SERVICE = "wifiscanner";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.net.wifi.RttManager} for ranging devices with wifi
-     *
-     * @see #getSystemService
-     * @see android.net.wifi.RttManager
-     * @hide
-     */
-    @SystemApi
-    public static final String WIFI_RTT_SERVICE = "rttmanager";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.net.EthernetManager} for handling management of
-     * Ethernet access.
-     *
-     * @see #getSystemService
-     * @see android.net.EthernetManager
-     *
-     * @hide
-     */
-    public static final String ETHERNET_SERVICE = "ethernet";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.net.nsd.NsdManager} for handling management of network service
-     * discovery
-     *
-     * @see #getSystemService
-     * @see android.net.nsd.NsdManager
-     */
-    public static final String NSD_SERVICE = "servicediscovery";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.media.AudioManager} for handling management of volume,
-     * ringer modes and audio routing.
-     *
-     * @see #getSystemService
-     * @see android.media.AudioManager
-     */
-    public static final String AUDIO_SERVICE = "audio";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.hardware.fingerprint.FingerprintManager} for handling management
-     * of fingerprints.
-     *
-     * @see #getSystemService
-     * @see android.hardware.fingerprint.FingerprintManager
-     */
-    public static final String FINGERPRINT_SERVICE = "fingerprint";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.media.MediaRouter} for controlling and managing
-     * routing of media.
-     *
-     * @see #getSystemService
-     * @see android.media.MediaRouter
-     */
-    public static final String MEDIA_ROUTER_SERVICE = "media_router";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.media.session.MediaSessionManager} for managing media Sessions.
-     *
-     * @see #getSystemService
-     * @see android.media.session.MediaSessionManager
-     */
-    public static final String MEDIA_SESSION_SERVICE = "media_session";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.telephony.TelephonyManager} for handling management the
-     * telephony features of the device.
-     *
-     * @see #getSystemService
-     * @see android.telephony.TelephonyManager
-     */
-    public static final String TELEPHONY_SERVICE = "phone";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.telephony.SubscriptionManager} for handling management the
-     * telephony subscriptions of the device.
-     *
-     * @see #getSystemService
-     * @see android.telephony.SubscriptionManager
-     */
-    public static final String TELEPHONY_SUBSCRIPTION_SERVICE = "telephony_subscription_service";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.telecom.TelecomManager} to manage telecom-related features
-     * of the device.
-     *
-     * @see #getSystemService
-     * @see android.telecom.TelecomManager
-     */
-    public static final String TELECOM_SERVICE = "telecom";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.telephony.CarrierConfigManager} for reading carrier configuration values.
-     *
-     * @see #getSystemService
-     * @see android.telephony.CarrierConfigManager
-     */
-    public static final String CARRIER_CONFIG_SERVICE = "carrier_config";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.text.ClipboardManager} for accessing and modifying
-     * {@link android.content.ClipboardManager} for accessing and modifying
-     * the contents of the global clipboard.
-     *
-     * @see #getSystemService
-     * @see android.content.ClipboardManager
-     */
-    public static final String CLIPBOARD_SERVICE = "clipboard";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.view.inputmethod.InputMethodManager} for accessing input
-     * methods.
-     *
-     * @see #getSystemService
-     */
-    public static final String INPUT_METHOD_SERVICE = "input_method";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.view.textservice.TextServicesManager} for accessing
-     * text services.
-     *
-     * @see #getSystemService
-     */
-    public static final String TEXT_SERVICES_MANAGER_SERVICE = "textservices";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.appwidget.AppWidgetManager} for accessing AppWidgets.
-     *
-     * @see #getSystemService
-     */
-    public static final String APPWIDGET_SERVICE = "appwidget";
-
-    /**
-     * Official published name of the (internal) voice interaction manager service.
-     *
-     * @hide
-     * @see #getSystemService
-     */
-    public static final String VOICE_INTERACTION_MANAGER_SERVICE = "voiceinteraction";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve an
-     * {@link android.app.backup.IBackupManager IBackupManager} for communicating
-     * with the backup mechanism.
-     * @hide
-     *
-     * @see #getSystemService
-     */
-    @SystemApi
-    public static final String BACKUP_SERVICE = "backup";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.os.DropBoxManager} instance for recording
-     * diagnostic logs.
-     * @see #getSystemService
-     */
-    public static final String DROPBOX_SERVICE = "dropbox";
-
-    /**
-     * System service name for the DeviceIdleController.  There is no Java API for this.
-     * @see #getSystemService
-     * @hide
-     */
-    public static final String DEVICE_IDLE_CONTROLLER = "deviceidle";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.app.admin.DevicePolicyManager} for working with global
-     * device policy management.
-     *
-     * @see #getSystemService
-     */
-    public static final String DEVICE_POLICY_SERVICE = "device_policy";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.app.UiModeManager} for controlling UI modes.
-     *
-     * @see #getSystemService
-     */
-    public static final String UI_MODE_SERVICE = "uimode";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.app.DownloadManager} for requesting HTTP downloads.
-     *
-     * @see #getSystemService
-     */
-    public static final String DOWNLOAD_SERVICE = "download";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.os.BatteryManager} for managing battery state.
-     *
-     * @see #getSystemService
-     */
-    public static final String BATTERY_SERVICE = "batterymanager";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.nfc.NfcManager} for using NFC.
-     *
-     * @see #getSystemService
-     */
-    public static final String NFC_SERVICE = "nfc";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.bluetooth.BluetoothManager} for using Bluetooth.
-     *
-     * @see #getSystemService
-     */
-    public static final String BLUETOOTH_SERVICE = "bluetooth";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.net.sip.SipManager} for accessing the SIP related service.
-     *
-     * @see #getSystemService
-     */
-    /** @hide */
-    public static final String SIP_SERVICE = "sip";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.hardware.usb.UsbManager} for access to USB devices (as a USB host)
-     * and for controlling this device's behavior as a USB device.
-     *
-     * @see #getSystemService
-     * @see android.hardware.usb.UsbManager
-     */
-    public static final String USB_SERVICE = "usb";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.hardware.SerialManager} for access to serial ports.
-     *
-     * @see #getSystemService
-     * @see android.hardware.SerialManager
-     *
-     * @hide
-     */
-    public static final String SERIAL_SERVICE = "serial";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.hardware.hdmi.HdmiControlManager} for controlling and managing
-     * HDMI-CEC protocol.
-     *
-     * @see #getSystemService
-     * @see android.hardware.hdmi.HdmiControlManager
-     * @hide
-     */
-    @SystemApi
-    public static final String HDMI_CONTROL_SERVICE = "hdmi_control";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.hardware.input.InputManager} for interacting with input devices.
-     *
-     * @see #getSystemService
-     * @see android.hardware.input.InputManager
-     */
-    public static final String INPUT_SERVICE = "input";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.hardware.display.DisplayManager} for interacting with display devices.
-     *
-     * @see #getSystemService
-     * @see android.hardware.display.DisplayManager
-     */
-    public static final String DISPLAY_SERVICE = "display";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.os.UserManager} for managing users on devices that support multiple users.
-     *
-     * @see #getSystemService
-     * @see android.os.UserManager
-     */
-    public static final String USER_SERVICE = "user";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.content.pm.LauncherApps} for querying and monitoring launchable apps across
-     * profiles of a user.
-     *
-     * @see #getSystemService
-     * @see android.content.pm.LauncherApps
-     */
-    public static final String LAUNCHER_APPS_SERVICE = "launcherapps";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.content.RestrictionsManager} for retrieving application restrictions
-     * and requesting permissions for restricted operations.
-     * @see #getSystemService
-     * @see android.content.RestrictionsManager
-     */
-    public static final String RESTRICTIONS_SERVICE = "restrictions";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.app.AppOpsManager} for tracking application operations
-     * on the device.
-     *
-     * @see #getSystemService
-     * @see android.app.AppOpsManager
-     */
-    public static final String APP_OPS_SERVICE = "appops";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.hardware.camera2.CameraManager} for interacting with
-     * camera devices.
-     *
-     * @see #getSystemService
-     * @see android.hardware.camera2.CameraManager
-     */
-    public static final String CAMERA_SERVICE = "camera";
-
-    /**
-     * {@link android.print.PrintManager} for printing and managing
-     * printers and print tasks.
-     *
-     * @see #getSystemService
-     * @see android.print.PrintManager
-     */
-    public static final String PRINT_SERVICE = "print";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.hardware.ConsumerIrManager} for transmitting infrared
-     * signals from the device.
-     *
-     * @see #getSystemService
-     * @see android.hardware.ConsumerIrManager
-     */
-    public static final String CONSUMER_IR_SERVICE = "consumer_ir";
-
-    /**
-     * {@link android.app.trust.TrustManager} for managing trust agents.
-     * @see #getSystemService
-     * @see android.app.trust.TrustManager
-     * @hide
-     */
-    public static final String TRUST_SERVICE = "trust";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.media.tv.TvInputManager} for interacting with TV inputs
-     * on the device.
-     *
-     * @see #getSystemService
-     * @see android.media.tv.TvInputManager
-     */
-    public static final String TV_INPUT_SERVICE = "tv_input";
-
-    /**
-     * {@link android.net.NetworkScoreManager} for managing network scoring.
-     * @see #getSystemService
-     * @see android.net.NetworkScoreManager
-     * @hide
-     */
-    @SystemApi
-    public static final String NETWORK_SCORE_SERVICE = "network_score";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.app.usage.UsageStatsManager} for querying device usage stats.
-     *
-     * @see #getSystemService
-     * @see android.app.usage.UsageStatsManager
-     */
-    public static final String USAGE_STATS_SERVICE = "usagestats";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.app.job.JobScheduler} instance for managing occasional
-     * background tasks.
-     * @see #getSystemService
-     * @see android.app.job.JobScheduler
-     */
-    public static final String JOB_SCHEDULER_SERVICE = "jobscheduler";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.service.persistentdata.PersistentDataBlockManager} instance
-     * for interacting with a storage device that lives across factory resets.
-     *
-     * @see #getSystemService
-     * @see android.service.persistentdata.PersistentDataBlockManager
-     * @hide
-     */
-    @SystemApi
-    public static final String PERSISTENT_DATA_BLOCK_SERVICE = "persistent_data_block";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a {@link
-     * android.media.projection.MediaProjectionManager} instance for managing
-     * media projection sessions.
-     * @see #getSystemService
-     * @see android.media.projection.MediaProjectionManager
-     */
-    public static final String MEDIA_PROJECTION_SERVICE = "media_projection";
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.media.midi.MidiManager} for accessing the MIDI service.
-     *
-     * @see #getSystemService
-     */
-    public static final String MIDI_SERVICE = "midi";
-
-
-    /**
-     * Use with {@link #getSystemService} to retrieve a
-     * {@link android.hardware.radio.RadioManager} for accessing the broadcast radio service.
-     *
-     * @see #getSystemService
-     * @hide
-     */
-    public static final String RADIO_SERVICE = "radio";
-
-    /**
-     * Determine whether the given permission is allowed for a particular
-     * process and user ID running in the system.
-     *
-     * @param permission The name of the permission being checked.
-     * @param pid The process ID being checked against.  Must be > 0.
-     * @param uid The user ID being checked against.  A uid of 0 is the root
-     * user, which will pass every permission check.
-     *
-     * @return {@link PackageManager#PERMISSION_GRANTED} if the given
-     * pid/uid is allowed that permission, or
-     * {@link PackageManager#PERMISSION_DENIED} if it is not.
-     *
-     * @see PackageManager#checkPermission(String, String)
-     * @see #checkCallingPermission
-     */
-    @CheckResult(suggest="#enforcePermission(String,int,int,String)")
-    @PackageManager.PermissionResult
-    public abstract int checkPermission(@NonNull String permission, int pid, int uid);
-
-    /** @hide */
-    @PackageManager.PermissionResult
-    public abstract int checkPermission(@NonNull String permission, int pid, int uid,
-            IBinder callerToken);
-
-    /**
-     * Determine whether the calling process of an IPC you are handling has been
-     * granted a particular permission.  This is basically the same as calling
-     * {@link #checkPermission(String, int, int)} with the pid and uid returned
-     * by {@link android.os.Binder#getCallingPid} and
-     * {@link android.os.Binder#getCallingUid}.  One important difference
-     * is that if you are not currently processing an IPC, this function
-     * will always fail.  This is done to protect against accidentally
-     * leaking permissions; you can use {@link #checkCallingOrSelfPermission}
-     * to avoid this protection.
-     *
-     * @param permission The name of the permission being checked.
-     *
-     * @return {@link PackageManager#PERMISSION_GRANTED} if the calling
-     * pid/uid is allowed that permission, or
-     * {@link PackageManager#PERMISSION_DENIED} if it is not.
-     *
-     * @see PackageManager#checkPermission(String, String)
-     * @see #checkPermission
-     * @see #checkCallingOrSelfPermission
-     */
-    @CheckResult(suggest="#enforceCallingPermission(String,String)")
-    @PackageManager.PermissionResult
-    public abstract int checkCallingPermission(@NonNull String permission);
-
-    /**
-     * Determine whether the calling process of an IPC <em>or you</em> have been
-     * granted a particular permission.  This is the same as
-     * {@link #checkCallingPermission}, except it grants your own permissions
-     * if you are not currently processing an IPC.  Use with care!
-     *
-     * @param permission The name of the permission being checked.
-     *
-     * @return {@link PackageManager#PERMISSION_GRANTED} if the calling
-     * pid/uid is allowed that permission, or
-     * {@link PackageManager#PERMISSION_DENIED} if it is not.
-     *
-     * @see PackageManager#checkPermission(String, String)
-     * @see #checkPermission
-     * @see #checkCallingPermission
-     */
-    @CheckResult(suggest="#enforceCallingOrSelfPermission(String,String)")
-    @PackageManager.PermissionResult
-    public abstract int checkCallingOrSelfPermission(@NonNull String permission);
-
-    /**
-     * Determine whether <em>you</em> have been granted a particular permission.
-     *
-     * @param permission The name of the permission being checked.
-     *
-     * @return {@link PackageManager#PERMISSION_GRANTED} if you have the
-     * permission, or {@link PackageManager#PERMISSION_DENIED} if not.
-     *
-     * @see PackageManager#checkPermission(String, String)
-     * @see #checkCallingPermission(String)
-     */
-    @PackageManager.PermissionResult
-    public abstract int checkSelfPermission(@NonNull String permission);
-
-    /**
-     * If the given permission is not allowed for a particular process
-     * and user ID running in the system, throw a {@link SecurityException}.
-     *
-     * @param permission The name of the permission being checked.
-     * @param pid The process ID being checked against.  Must be &gt; 0.
-     * @param uid The user ID being checked against.  A uid of 0 is the root
-     * user, which will pass every permission check.
-     * @param message A message to include in the exception if it is thrown.
-     *
-     * @see #checkPermission(String, int, int)
-     */
-    public abstract void enforcePermission(
-            @NonNull String permission, int pid, int uid, @Nullable String message);
-
-    /**
-     * If the calling process of an IPC you are handling has not been
-     * granted a particular permission, throw a {@link
-     * SecurityException}.  This is basically the same as calling
-     * {@link #enforcePermission(String, int, int, String)} with the
-     * pid and uid returned by {@link android.os.Binder#getCallingPid}
-     * and {@link android.os.Binder#getCallingUid}.  One important
-     * difference is that if you are not currently processing an IPC,
-     * this function will always throw the SecurityException.  This is
-     * done to protect against accidentally leaking permissions; you
-     * can use {@link #enforceCallingOrSelfPermission} to avoid this
-     * protection.
-     *
-     * @param permission The name of the permission being checked.
-     * @param message A message to include in the exception if it is thrown.
-     *
-     * @see #checkCallingPermission(String)
-     */
-    public abstract void enforceCallingPermission(
-            @NonNull String permission, @Nullable String message);
-
-    /**
-     * If neither you nor the calling process of an IPC you are
-     * handling has been granted a particular permission, throw a
-     * {@link SecurityException}.  This is the same as {@link
-     * #enforceCallingPermission}, except it grants your own
-     * permissions if you are not currently processing an IPC.  Use
-     * with care!
-     *
-     * @param permission The name of the permission being checked.
-     * @param message A message to include in the exception if it is thrown.
-     *
-     * @see #checkCallingOrSelfPermission(String)
-     */
-    public abstract void enforceCallingOrSelfPermission(
-            @NonNull String permission, @Nullable String message);
-
-    /**
-     * Grant permission to access a specific Uri to another package, regardless
-     * of whether that package has general permission to access the Uri's
-     * content provider.  This can be used to grant specific, temporary
-     * permissions, typically in response to user interaction (such as the
-     * user opening an attachment that you would like someone else to
-     * display).
-     *
-     * <p>Normally you should use {@link Intent#FLAG_GRANT_READ_URI_PERMISSION
-     * Intent.FLAG_GRANT_READ_URI_PERMISSION} or
-     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION
-     * Intent.FLAG_GRANT_WRITE_URI_PERMISSION} with the Intent being used to
-     * start an activity instead of this function directly.  If you use this
-     * function directly, you should be sure to call
-     * {@link #revokeUriPermission} when the target should no longer be allowed
-     * to access it.
-     *
-     * <p>To succeed, the content provider owning the Uri must have set the
-     * {@link android.R.styleable#AndroidManifestProvider_grantUriPermissions
-     * grantUriPermissions} attribute in its manifest or included the
-     * {@link android.R.styleable#AndroidManifestGrantUriPermission
-     * &lt;grant-uri-permissions&gt;} tag.
-     *
-     * @param toPackage The package you would like to allow to access the Uri.
-     * @param uri The Uri you would like to grant access to.
-     * @param modeFlags The desired access modes.  Any combination of
-     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION
-     * Intent.FLAG_GRANT_READ_URI_PERMISSION},
-     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION
-     * Intent.FLAG_GRANT_WRITE_URI_PERMISSION},
-     * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION
-     * Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION}, or
-     * {@link Intent#FLAG_GRANT_PREFIX_URI_PERMISSION
-     * Intent.FLAG_GRANT_PREFIX_URI_PERMISSION}.
-     *
-     * @see #revokeUriPermission
-     */
-    public abstract void grantUriPermission(String toPackage, Uri uri,
-            @Intent.GrantUriMode int modeFlags);
-
-    /**
-     * Remove all permissions to access a particular content provider Uri
-     * that were previously added with {@link #grantUriPermission}.  The given
-     * Uri will match all previously granted Uris that are the same or a
-     * sub-path of the given Uri.  That is, revoking "content://foo/target" will
-     * revoke both "content://foo/target" and "content://foo/target/sub", but not
-     * "content://foo".  It will not remove any prefix grants that exist at a
-     * higher level.
-     *
-     * <p>Prior to {@link android.os.Build.VERSION_CODES#LOLLIPOP}, if you did not have
-     * regular permission access to a Uri, but had received access to it through
-     * a specific Uri permission grant, you could not revoke that grant with this
-     * function and a {@link SecurityException} would be thrown.  As of
-     * {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this function will not throw a security exception,
-     * but will remove whatever permission grants to the Uri had been given to the app
-     * (or none).</p>
-     *
-     * @param uri The Uri you would like to revoke access to.
-     * @param modeFlags The desired access modes.  Any combination of
-     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION
-     * Intent.FLAG_GRANT_READ_URI_PERMISSION} or
-     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION
-     * Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
-     *
-     * @see #grantUriPermission
-     */
-    public abstract void revokeUriPermission(Uri uri, @Intent.AccessUriMode int modeFlags);
-
-    /**
-     * Determine whether a particular process and user ID has been granted
-     * permission to access a specific URI.  This only checks for permissions
-     * that have been explicitly granted -- if the given process/uid has
-     * more general access to the URI's content provider then this check will
-     * always fail.
-     *
-     * @param uri The uri that is being checked.
-     * @param pid The process ID being checked against.  Must be &gt; 0.
-     * @param uid The user ID being checked against.  A uid of 0 is the root
-     * user, which will pass every permission check.
-     * @param modeFlags The type of access to grant.  May be one or both of
-     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
-     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
-     *
-     * @return {@link PackageManager#PERMISSION_GRANTED} if the given
-     * pid/uid is allowed to access that uri, or
-     * {@link PackageManager#PERMISSION_DENIED} if it is not.
-     *
-     * @see #checkCallingUriPermission
-     */
-    @CheckResult(suggest="#enforceUriPermission(Uri,int,int,String)")
-    public abstract int checkUriPermission(Uri uri, int pid, int uid,
-            @Intent.AccessUriMode int modeFlags);
-
-    /** @hide */
-    public abstract int checkUriPermission(Uri uri, int pid, int uid,
-            @Intent.AccessUriMode int modeFlags, IBinder callerToken);
-
-    /**
-     * Determine whether the calling process and user ID has been
-     * granted permission to access a specific URI.  This is basically
-     * the same as calling {@link #checkUriPermission(Uri, int, int,
-     * int)} with the pid and uid returned by {@link
-     * android.os.Binder#getCallingPid} and {@link
-     * android.os.Binder#getCallingUid}.  One important difference is
-     * that if you are not currently processing an IPC, this function
-     * will always fail.
-     *
-     * @param uri The uri that is being checked.
-     * @param modeFlags The type of access to grant.  May be one or both of
-     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
-     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
-     *
-     * @return {@link PackageManager#PERMISSION_GRANTED} if the caller
-     * is allowed to access that uri, or
-     * {@link PackageManager#PERMISSION_DENIED} if it is not.
-     *
-     * @see #checkUriPermission(Uri, int, int, int)
-     */
-    @CheckResult(suggest="#enforceCallingUriPermission(Uri,int,String)")
-    public abstract int checkCallingUriPermission(Uri uri, @Intent.AccessUriMode int modeFlags);
-
-    /**
-     * Determine whether the calling process of an IPC <em>or you</em> has been granted
-     * permission to access a specific URI.  This is the same as
-     * {@link #checkCallingUriPermission}, except it grants your own permissions
-     * if you are not currently processing an IPC.  Use with care!
-     *
-     * @param uri The uri that is being checked.
-     * @param modeFlags The type of access to grant.  May be one or both of
-     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
-     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
-     *
-     * @return {@link PackageManager#PERMISSION_GRANTED} if the caller
-     * is allowed to access that uri, or
-     * {@link PackageManager#PERMISSION_DENIED} if it is not.
-     *
-     * @see #checkCallingUriPermission
-     */
-    @CheckResult(suggest="#enforceCallingOrSelfUriPermission(Uri,int,String)")
-    public abstract int checkCallingOrSelfUriPermission(Uri uri,
-            @Intent.AccessUriMode int modeFlags);
-
-    /**
-     * Check both a Uri and normal permission.  This allows you to perform
-     * both {@link #checkPermission} and {@link #checkUriPermission} in one
-     * call.
-     *
-     * @param uri The Uri whose permission is to be checked, or null to not
-     * do this check.
-     * @param readPermission The permission that provides overall read access,
-     * or null to not do this check.
-     * @param writePermission The permission that provides overall write
-     * access, or null to not do this check.
-     * @param pid The process ID being checked against.  Must be &gt; 0.
-     * @param uid The user ID being checked against.  A uid of 0 is the root
-     * user, which will pass every permission check.
-     * @param modeFlags The type of access to grant.  May be one or both of
-     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
-     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
-     *
-     * @return {@link PackageManager#PERMISSION_GRANTED} if the caller
-     * is allowed to access that uri or holds one of the given permissions, or
-     * {@link PackageManager#PERMISSION_DENIED} if it is not.
-     */
-    @CheckResult(suggest="#enforceUriPermission(Uri,String,String,int,int,int,String)")
-    public abstract int checkUriPermission(@Nullable Uri uri, @Nullable String readPermission,
-            @Nullable String writePermission, int pid, int uid,
-            @Intent.AccessUriMode int modeFlags);
-
-    /**
-     * If a particular process and user ID has not been granted
-     * permission to access a specific URI, throw {@link
-     * SecurityException}.  This only checks for permissions that have
-     * been explicitly granted -- if the given process/uid has more
-     * general access to the URI's content provider then this check
-     * will always fail.
-     *
-     * @param uri The uri that is being checked.
-     * @param pid The process ID being checked against.  Must be &gt; 0.
-     * @param uid The user ID being checked against.  A uid of 0 is the root
-     * user, which will pass every permission check.
-     * @param modeFlags The type of access to grant.  May be one or both of
-     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
-     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
-     * @param message A message to include in the exception if it is thrown.
-     *
-     * @see #checkUriPermission(Uri, int, int, int)
-     */
-    public abstract void enforceUriPermission(
-            Uri uri, int pid, int uid, @Intent.AccessUriMode int modeFlags, String message);
-
-    /**
-     * If the calling process and user ID has not been granted
-     * permission to access a specific URI, throw {@link
-     * SecurityException}.  This is basically the same as calling
-     * {@link #enforceUriPermission(Uri, int, int, int, String)} with
-     * the pid and uid returned by {@link
-     * android.os.Binder#getCallingPid} and {@link
-     * android.os.Binder#getCallingUid}.  One important difference is
-     * that if you are not currently processing an IPC, this function
-     * will always throw a SecurityException.
-     *
-     * @param uri The uri that is being checked.
-     * @param modeFlags The type of access to grant.  May be one or both of
-     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
-     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
-     * @param message A message to include in the exception if it is thrown.
-     *
-     * @see #checkCallingUriPermission(Uri, int)
-     */
-    public abstract void enforceCallingUriPermission(
-            Uri uri, @Intent.AccessUriMode int modeFlags, String message);
-
-    /**
-     * If the calling process of an IPC <em>or you</em> has not been
-     * granted permission to access a specific URI, throw {@link
-     * SecurityException}.  This is the same as {@link
-     * #enforceCallingUriPermission}, except it grants your own
-     * permissions if you are not currently processing an IPC.  Use
-     * with care!
-     *
-     * @param uri The uri that is being checked.
-     * @param modeFlags The type of access to grant.  May be one or both of
-     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
-     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
-     * @param message A message to include in the exception if it is thrown.
-     *
-     * @see #checkCallingOrSelfUriPermission(Uri, int)
-     */
-    public abstract void enforceCallingOrSelfUriPermission(
-            Uri uri, @Intent.AccessUriMode int modeFlags, String message);
-
-    /**
-     * Enforce both a Uri and normal permission.  This allows you to perform
-     * both {@link #enforcePermission} and {@link #enforceUriPermission} in one
-     * call.
-     *
-     * @param uri The Uri whose permission is to be checked, or null to not
-     * do this check.
-     * @param readPermission The permission that provides overall read access,
-     * or null to not do this check.
-     * @param writePermission The permission that provides overall write
-     * access, or null to not do this check.
-     * @param pid The process ID being checked against.  Must be &gt; 0.
-     * @param uid The user ID being checked against.  A uid of 0 is the root
-     * user, which will pass every permission check.
-     * @param modeFlags The type of access to grant.  May be one or both of
-     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
-     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
-     * @param message A message to include in the exception if it is thrown.
-     *
-     * @see #checkUriPermission(Uri, String, String, int, int, int)
-     */
-    public abstract void enforceUriPermission(
-            @Nullable Uri uri, @Nullable String readPermission,
-            @Nullable String writePermission, int pid, int uid, @Intent.AccessUriMode int modeFlags,
-            @Nullable String message);
-
-    /** @hide */
-    @IntDef(flag = true,
-            value = {CONTEXT_INCLUDE_CODE, CONTEXT_IGNORE_SECURITY, CONTEXT_RESTRICTED})
-    @Retention(RetentionPolicy.SOURCE)
-    public @interface CreatePackageOptions {}
-
-    /**
-     * Flag for use with {@link #createPackageContext}: include the application
-     * code with the context.  This means loading code into the caller's
-     * process, so that {@link #getClassLoader()} can be used to instantiate
-     * the application's classes.  Setting this flags imposes security
-     * restrictions on what application context you can access; if the
-     * requested application can not be safely loaded into your process,
-     * java.lang.SecurityException will be thrown.  If this flag is not set,
-     * there will be no restrictions on the packages that can be loaded,
-     * but {@link #getClassLoader} will always return the default system
-     * class loader.
-     */
-    public static final int CONTEXT_INCLUDE_CODE = 0x00000001;
-
-    /**
-     * Flag for use with {@link #createPackageContext}: ignore any security
-     * restrictions on the Context being requested, allowing it to always
-     * be loaded.  For use with {@link #CONTEXT_INCLUDE_CODE} to allow code
-     * to be loaded into a process even when it isn't safe to do so.  Use
-     * with extreme care!
-     */
-    public static final int CONTEXT_IGNORE_SECURITY = 0x00000002;
-
-    /**
-     * Flag for use with {@link #createPackageContext}: a restricted context may
-     * disable specific features. For instance, a View associated with a restricted
-     * context would ignore particular XML attributes.
-     */
-    public static final int CONTEXT_RESTRICTED = 0x00000004;
-
-    /**
-     * @hide Used to indicate we should tell the activity manager about the process
-     * loading this code.
-     */
-    public static final int CONTEXT_REGISTER_PACKAGE = 0x40000000;
-
-    /**
-     * Return a new Context object for the given application name.  This
-     * Context is the same as what the named application gets when it is
-     * launched, containing the same resources and class loader.  Each call to
-     * this method returns a new instance of a Context object; Context objects
-     * are not shared, however they share common state (Resources, ClassLoader,
-     * etc) so the Context instance itself is fairly lightweight.
-     *
-     * <p>Throws {@link android.content.pm.PackageManager.NameNotFoundException} if there is no
-     * application with the given package name.
-     *
-     * <p>Throws {@link java.lang.SecurityException} if the Context requested
-     * can not be loaded into the caller's process for security reasons (see
-     * {@link #CONTEXT_INCLUDE_CODE} for more information}.
-     *
-     * @param packageName Name of the application's package.
-     * @param flags Option flags, one of {@link #CONTEXT_INCLUDE_CODE}
-     *              or {@link #CONTEXT_IGNORE_SECURITY}.
-     *
-     * @return A {@link Context} for the application.
-     *
-     * @throws SecurityException &nbsp;
-     * @throws PackageManager.NameNotFoundException if there is no application with
-     * the given package name.
-     */
-    public abstract Context createPackageContext(String packageName,
-            @CreatePackageOptions int flags) throws PackageManager.NameNotFoundException;
-
-    /**
-     * Similar to {@link #createPackageContext(String, int)}, but with a
-     * different {@link UserHandle}. For example, {@link #getContentResolver()}
-     * will open any {@link Uri} as the given user.
-     *
-     * @hide
-     */
-    public abstract Context createPackageContextAsUser(
-            String packageName, int flags, UserHandle user)
-            throws PackageManager.NameNotFoundException;
-
-    /**
-     * Creates a context given an {@link android.content.pm.ApplicationInfo}.
-     *
-     * @hide
-     */
-    public abstract Context createApplicationContext(ApplicationInfo application,
-            int flags) throws PackageManager.NameNotFoundException;
-
-    /**
-     * Get the userId associated with this context
-     * @return user id
-     *
-     * @hide
-     */
-    public abstract int getUserId();
-
-    /**
-     * Return a new Context object for the current Context but whose resources
-     * are adjusted to match the given Configuration.  Each call to this method
-     * returns a new instance of a Context object; Context objects are not
-     * shared, however common state (ClassLoader, other Resources for the
-     * same configuration) may be so the Context itself can be fairly lightweight.
-     *
-     * @param overrideConfiguration A {@link Configuration} specifying what
-     * values to modify in the base Configuration of the original Context's
-     * resources.  If the base configuration changes (such as due to an
-     * orientation change), the resources of this context will also change except
-     * for those that have been explicitly overridden with a value here.
-     *
-     * @return A {@link Context} with the given configuration override.
-     */
-    public abstract Context createConfigurationContext(
-            @NonNull Configuration overrideConfiguration);
-
-    /**
-     * Return a new Context object for the current Context but whose resources
-     * are adjusted to match the metrics of the given Display.  Each call to this method
-     * returns a new instance of a Context object; Context objects are not
-     * shared, however common state (ClassLoader, other Resources for the
-     * same configuration) may be so the Context itself can be fairly lightweight.
-     *
-     * The returned display Context provides a {@link WindowManager}
-     * (see {@link #getSystemService(String)}) that is configured to show windows
-     * on the given display.  The WindowManager's {@link WindowManager#getDefaultDisplay}
-     * method can be used to retrieve the Display from the returned Context.
-     *
-     * @param display A {@link Display} object specifying the display
-     * for whose metrics the Context's resources should be tailored and upon which
-     * new windows should be shown.
-     *
-     * @return A {@link Context} for the display.
-     */
-    public abstract Context createDisplayContext(@NonNull Display display);
-
-    /**
-     * Gets the display adjustments holder for this context.  This information
-     * is provided on a per-application or activity basis and is used to simulate lower density
-     * display metrics for legacy applications and restricted screen sizes.
-     *
-     * @param displayId The display id for which to get compatibility info.
-     * @return The compatibility info holder, or null if not required by the application.
-     * @hide
-     */
-    public abstract DisplayAdjustments getDisplayAdjustments(int displayId);
-
-    /**
-     * Indicates whether this Context is restricted.
-     *
-     * @return {@code true} if this Context is restricted, {@code false} otherwise.
-     *
-     * @see #CONTEXT_RESTRICTED
-     */
-    public boolean isRestricted() {
-        return false;
-    }
-}
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.content;
+
+import android.annotation.AttrRes;
+import android.annotation.CheckResult;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.annotation.StringDef;
+import android.annotation.StringRes;
+import android.annotation.StyleRes;
+import android.annotation.StyleableRes;
+import android.annotation.SystemApi;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.content.res.AssetManager;
+import android.content.res.ColorStateList;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.database.DatabaseErrorHandler;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.StatFs;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.provider.MediaStore;
+import android.util.AttributeSet;
+import android.view.DisplayAdjustments;
+import android.view.Display;
+import android.view.ViewDebug;
+import android.view.WindowManager;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Interface to global information about an application environment.  This is
+ * an abstract class whose implementation is provided by
+ * the Android system.  It
+ * allows access to application-specific resources and classes, as well as
+ * up-calls for application-level operations such as launching activities,
+ * broadcasting and receiving intents, etc.
+ */
+public abstract class Context {
+    /**
+     * File creation mode: the default mode, where the created file can only
+     * be accessed by the calling application (or all applications sharing the
+     * same user ID).
+     * @see #MODE_WORLD_READABLE
+     * @see #MODE_WORLD_WRITEABLE
+     */
+    public static final int MODE_PRIVATE = 0x0000;
+    /**
+     * @deprecated Creating world-readable files is very dangerous, and likely
+     * to cause security holes in applications.  It is strongly discouraged;
+     * instead, applications should use more formal mechanism for interactions
+     * such as {@link ContentProvider}, {@link BroadcastReceiver}, and
+     * {@link android.app.Service}.  There are no guarantees that this
+     * access mode will remain on a file, such as when it goes through a
+     * backup and restore.
+     * File creation mode: allow all other applications to have read access
+     * to the created file.
+     * @see #MODE_PRIVATE
+     * @see #MODE_WORLD_WRITEABLE
+     */
+    @Deprecated
+    public static final int MODE_WORLD_READABLE = 0x0001;
+    /**
+     * @deprecated Creating world-writable files is very dangerous, and likely
+     * to cause security holes in applications.  It is strongly discouraged;
+     * instead, applications should use more formal mechanism for interactions
+     * such as {@link ContentProvider}, {@link BroadcastReceiver}, and
+     * {@link android.app.Service}.  There are no guarantees that this
+     * access mode will remain on a file, such as when it goes through a
+     * backup and restore.
+     * File creation mode: allow all other applications to have write access
+     * to the created file.
+     * @see #MODE_PRIVATE
+     * @see #MODE_WORLD_READABLE
+     */
+    @Deprecated
+    public static final int MODE_WORLD_WRITEABLE = 0x0002;
+    /**
+     * File creation mode: for use with {@link #openFileOutput}, if the file
+     * already exists then write data to the end of the existing file
+     * instead of erasing it.
+     * @see #openFileOutput
+     */
+    public static final int MODE_APPEND = 0x8000;
+
+    /**
+     * SharedPreference loading flag: when set, the file on disk will
+     * be checked for modification even if the shared preferences
+     * instance is already loaded in this process.  This behavior is
+     * sometimes desired in cases where the application has multiple
+     * processes, all writing to the same SharedPreferences file.
+     * Generally there are better forms of communication between
+     * processes, though.
+     *
+     * <p>This was the legacy (but undocumented) behavior in and
+     * before Gingerbread (Android 2.3) and this flag is implied when
+     * targetting such releases.  For applications targetting SDK
+     * versions <em>greater than</em> Android 2.3, this flag must be
+     * explicitly set if desired.
+     *
+     * @see #getSharedPreferences
+     *
+     * @deprecated MODE_MULTI_PROCESS does not work reliably in
+     * some versions of Android, and furthermore does not provide any
+     * mechanism for reconciling concurrent modifications across
+     * processes.  Applications should not attempt to use it.  Instead,
+     * they should use an explicit cross-process data management
+     * approach such as {@link android.content.ContentProvider ContentProvider}.
+     */
+    @Deprecated
+    public static final int MODE_MULTI_PROCESS = 0x0004;
+
+    /**
+     * Database open flag: when set, the database is opened with write-ahead
+     * logging enabled by default.
+     *
+     * @see #openOrCreateDatabase(String, int, CursorFactory)
+     * @see #openOrCreateDatabase(String, int, CursorFactory, DatabaseErrorHandler)
+     * @see SQLiteDatabase#enableWriteAheadLogging
+     */
+    public static final int MODE_ENABLE_WRITE_AHEAD_LOGGING = 0x0008;
+
+    /** @hide */
+    @IntDef(flag = true,
+            value = {
+                BIND_AUTO_CREATE,
+                BIND_DEBUG_UNBIND,
+                BIND_NOT_FOREGROUND,
+                BIND_ABOVE_CLIENT,
+                BIND_ALLOW_OOM_MANAGEMENT,
+                BIND_WAIVE_PRIORITY,
+                BIND_IMPORTANT,
+                BIND_ADJUST_WITH_ACTIVITY
+            })
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface BindServiceFlags {}
+
+    /**
+     * Flag for {@link #bindService}: automatically create the service as long
+     * as the binding exists.  Note that while this will create the service,
+     * its {@link android.app.Service#onStartCommand}
+     * method will still only be called due to an
+     * explicit call to {@link #startService}.  Even without that, though,
+     * this still provides you with access to the service object while the
+     * service is created.
+     *
+     * <p>Note that prior to {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH},
+     * not supplying this flag would also impact how important the system
+     * consider's the target service's process to be.  When set, the only way
+     * for it to be raised was by binding from a service in which case it will
+     * only be important when that activity is in the foreground.  Now to
+     * achieve this behavior you must explicitly supply the new flag
+     * {@link #BIND_ADJUST_WITH_ACTIVITY}.  For compatibility, old applications
+     * that don't specify {@link #BIND_AUTO_CREATE} will automatically have
+     * the flags {@link #BIND_WAIVE_PRIORITY} and
+     * {@link #BIND_ADJUST_WITH_ACTIVITY} set for them in order to achieve
+     * the same result.
+     */
+    public static final int BIND_AUTO_CREATE = 0x0001;
+
+    /**
+     * Flag for {@link #bindService}: include debugging help for mismatched
+     * calls to unbind.  When this flag is set, the callstack of the following
+     * {@link #unbindService} call is retained, to be printed if a later
+     * incorrect unbind call is made.  Note that doing this requires retaining
+     * information about the binding that was made for the lifetime of the app,
+     * resulting in a leak -- this should only be used for debugging.
+     */
+    public static final int BIND_DEBUG_UNBIND = 0x0002;
+
+    /**
+     * Flag for {@link #bindService}: don't allow this binding to raise
+     * the target service's process to the foreground scheduling priority.
+     * It will still be raised to at least the same memory priority
+     * as the client (so that its process will not be killable in any
+     * situation where the client is not killable), but for CPU scheduling
+     * purposes it may be left in the background.  This only has an impact
+     * in the situation where the binding client is a foreground process
+     * and the target service is in a background process.
+     */
+    public static final int BIND_NOT_FOREGROUND = 0x0004;
+
+    /**
+     * Flag for {@link #bindService}: indicates that the client application
+     * binding to this service considers the service to be more important than
+     * the app itself.  When set, the platform will try to have the out of
+     * memory killer kill the app before it kills the service it is bound to, though
+     * this is not guaranteed to be the case.
+     */
+    public static final int BIND_ABOVE_CLIENT = 0x0008;
+
+    /**
+     * Flag for {@link #bindService}: allow the process hosting the bound
+     * service to go through its normal memory management.  It will be
+     * treated more like a running service, allowing the system to
+     * (temporarily) expunge the process if low on memory or for some other
+     * whim it may have, and being more aggressive about making it a candidate
+     * to be killed (and restarted) if running for a long time.
+     */
+    public static final int BIND_ALLOW_OOM_MANAGEMENT = 0x0010;
+
+    /**
+     * Flag for {@link #bindService}: don't impact the scheduling or
+     * memory management priority of the target service's hosting process.
+     * Allows the service's process to be managed on the background LRU list
+     * just like a regular application process in the background.
+     */
+    public static final int BIND_WAIVE_PRIORITY = 0x0020;
+
+    /**
+     * Flag for {@link #bindService}: this service is very important to
+     * the client, so should be brought to the foreground process level
+     * when the client is.  Normally a process can only be raised to the
+     * visibility level by a client, even if that client is in the foreground.
+     */
+    public static final int BIND_IMPORTANT = 0x0040;
+
+    /**
+     * Flag for {@link #bindService}: If binding from an activity, allow the
+     * target service's process importance to be raised based on whether the
+     * activity is visible to the user, regardless whether another flag is
+     * used to reduce the amount that the client process's overall importance
+     * is used to impact it.
+     */
+    public static final int BIND_ADJUST_WITH_ACTIVITY = 0x0080;
+
+    /**
+     * @hide Flag for {@link #bindService}: Like {@link #BIND_FOREGROUND_SERVICE},
+     * but only applies while the device is awake.
+     */
+    public static final int BIND_FOREGROUND_SERVICE_WHILE_AWAKE = 0x02000000;
+
+    /**
+     * @hide Flag for {@link #bindService}: For only the case where the binding
+     * is coming from the system, set the process state to FOREGROUND_SERVICE
+     * instead of the normal maximum of IMPORTANT_FOREGROUND.  That is, this is
+     * saying that the process shouldn't participate in the normal power reduction
+     * modes (removing network access etc).
+     */
+    public static final int BIND_FOREGROUND_SERVICE = 0x04000000;
+
+    /**
+     * @hide Flag for {@link #bindService}: Treat the binding as hosting
+     * an activity, an unbinding as the activity going in the background.
+     * That is, when unbinding, the process when empty will go on the activity
+     * LRU list instead of the regular one, keeping it around more aggressively
+     * than it otherwise would be.  This is intended for use with IMEs to try
+     * to keep IME processes around for faster keyboard switching.
+     */
+    public static final int BIND_TREAT_LIKE_ACTIVITY = 0x08000000;
+
+    /**
+     * @hide An idea that is not yet implemented.
+     * Flag for {@link #bindService}: If binding from an activity, consider
+     * this service to be visible like the binding activity is.  That is,
+     * it will be treated as something more important to keep around than
+     * invisible background activities.  This will impact the number of
+     * recent activities the user can switch between without having them
+     * restart.  There is no guarantee this will be respected, as the system
+     * tries to balance such requests from one app vs. the importantance of
+     * keeping other apps around.
+     */
+    public static final int BIND_VISIBLE = 0x10000000;
+
+    /**
+     * @hide
+     * Flag for {@link #bindService}: Consider this binding to be causing the target
+     * process to be showing UI, so it will be do a UI_HIDDEN memory trim when it goes
+     * away.
+     */
+    public static final int BIND_SHOWING_UI = 0x20000000;
+
+    /**
+     * Flag for {@link #bindService}: Don't consider the bound service to be
+     * visible, even if the caller is visible.
+     * @hide
+     */
+    public static final int BIND_NOT_VISIBLE = 0x40000000;
+
+    /** Return an AssetManager instance for your application's package. */
+    public abstract AssetManager getAssets();
+
+    /** Return a Resources instance for your application's package. */
+    public abstract Resources getResources();
+
+    /** Return PackageManager instance to find global package information. */
+    public abstract PackageManager getPackageManager();
+
+    /** Return a ContentResolver instance for your application's package. */
+    public abstract ContentResolver getContentResolver();
+
+    /**
+     * Return the Looper for the main thread of the current process.  This is
+     * the thread used to dispatch calls to application components (activities,
+     * services, etc).
+     * <p>
+     * By definition, this method returns the same result as would be obtained
+     * by calling {@link Looper#getMainLooper() Looper.getMainLooper()}.
+     * </p>
+     *
+     * @return The main looper.
+     */
+    public abstract Looper getMainLooper();
+
+    /**
+     * Return the context of the single, global Application object of the
+     * current process.  This generally should only be used if you need a
+     * Context whose lifecycle is separate from the current context, that is
+     * tied to the lifetime of the process rather than the current component.
+     *
+     * <p>Consider for example how this interacts with
+     * {@link #registerReceiver(BroadcastReceiver, IntentFilter)}:
+     * <ul>
+     * <li> <p>If used from an Activity context, the receiver is being registered
+     * within that activity.  This means that you are expected to unregister
+     * before the activity is done being destroyed; in fact if you do not do
+     * so, the framework will clean up your leaked registration as it removes
+     * the activity and log an error.  Thus, if you use the Activity context
+     * to register a receiver that is static (global to the process, not
+     * associated with an Activity instance) then that registration will be
+     * removed on you at whatever point the activity you used is destroyed.
+     * <li> <p>If used from the Context returned here, the receiver is being
+     * registered with the global state associated with your application.  Thus
+     * it will never be unregistered for you.  This is necessary if the receiver
+     * is associated with static data, not a particular component.  However
+     * using the ApplicationContext elsewhere can easily lead to serious leaks
+     * if you forget to unregister, unbind, etc.
+     * </ul>
+     */
+    public abstract Context getApplicationContext();
+
+    /**
+     * Add a new {@link ComponentCallbacks} to the base application of the
+     * Context, which will be called at the same times as the ComponentCallbacks
+     * methods of activities and other components are called.  Note that you
+     * <em>must</em> be sure to use {@link #unregisterComponentCallbacks} when
+     * appropriate in the future; this will not be removed for you.
+     *
+     * @param callback The interface to call.  This can be either a
+     * {@link ComponentCallbacks} or {@link ComponentCallbacks2} interface.
+     */
+    public void registerComponentCallbacks(ComponentCallbacks callback) {
+        getApplicationContext().registerComponentCallbacks(callback);
+    }
+
+    /**
+     * Remove a {@link ComponentCallbacks} object that was previously registered
+     * with {@link #registerComponentCallbacks(ComponentCallbacks)}.
+     */
+    public void unregisterComponentCallbacks(ComponentCallbacks callback) {
+        getApplicationContext().unregisterComponentCallbacks(callback);
+    }
+
+    /**
+     * Return a localized, styled CharSequence from the application's package's
+     * default string table.
+     *
+     * @param resId Resource id for the CharSequence text
+     */
+    public final CharSequence getText(@StringRes int resId) {
+        return getResources().getText(resId);
+    }
+
+    /**
+     * Returns a localized string from the application's package's
+     * default string table.
+     *
+     * @param resId Resource id for the string
+     * @return The string data associated with the resource, stripped of styled
+     *         text information.
+     */
+    @NonNull
+    public final String getString(@StringRes int resId) {
+        return getResources().getString(resId);
+    }
+
+    /**
+     * Returns a localized formatted string from the application's package's
+     * default string table, substituting the format arguments as defined in
+     * {@link java.util.Formatter} and {@link java.lang.String#format}.
+     *
+     * @param resId Resource id for the format string
+     * @param formatArgs The format arguments that will be used for
+     *                   substitution.
+     * @return The string data associated with the resource, formatted and
+     *         stripped of styled text information.
+     */
+    @NonNull
+    public final String getString(@StringRes int resId, Object... formatArgs) {
+        return getResources().getString(resId, formatArgs);
+    }
+
+    /**
+     * Returns a color associated with a particular resource ID and styled for
+     * the current theme.
+     *
+     * @param id The desired resource identifier, as generated by the aapt
+     *           tool. This integer encodes the package, type, and resource
+     *           entry. The value 0 is an invalid identifier.
+     * @return A single color value in the form 0xAARRGGBB.
+     * @throws android.content.res.Resources.NotFoundException if the given ID
+     *         does not exist.
+     */
+    @Nullable
+    public final int getColor(int id) {
+        return getResources().getColor(id, getTheme());
+    }
+
+    /**
+     * Returns a drawable object associated with a particular resource ID and
+     * styled for the current theme.
+     *
+     * @param id The desired resource identifier, as generated by the aapt
+     *           tool. This integer encodes the package, type, and resource
+     *           entry. The value 0 is an invalid identifier.
+     * @return An object that can be used to draw this resource, or
+     *         {@code null} if the resource could not be resolved.
+     * @throws android.content.res.Resources.NotFoundException if the given ID
+     *         does not exist.
+     */
+    @Nullable
+    public final Drawable getDrawable(int id) {
+        return getResources().getDrawable(id, getTheme());
+    }
+
+    /**
+     * Returns a color state list associated with a particular resource ID and
+     * styled for the current theme.
+     *
+     * @param id The desired resource identifier, as generated by the aapt
+     *           tool. This integer encodes the package, type, and resource
+     *           entry. The value 0 is an invalid identifier.
+     * @return A color state list, or {@code null} if the resource could not be
+     *         resolved.
+     * @throws android.content.res.Resources.NotFoundException if the given ID
+     *         does not exist.
+     */
+    @Nullable
+    public final ColorStateList getColorStateList(int id) {
+        return getResources().getColorStateList(id, getTheme());
+    }
+
+     /**
+     * Set the base theme for this context.  Note that this should be called
+     * before any views are instantiated in the Context (for example before
+     * calling {@link android.app.Activity#setContentView} or
+     * {@link android.view.LayoutInflater#inflate}).
+     *
+     * @param resid The style resource describing the theme.
+     */
+    public abstract void setTheme(@StyleRes int resid);
+
+    /** @hide Needed for some internal implementation...  not public because
+     * you can't assume this actually means anything. */
+    public int getThemeResId() {
+        return 0;
+    }
+
+    /**
+     * Return the Theme object associated with this Context.
+     */
+    @ViewDebug.ExportedProperty(deepExport = true)
+    public abstract Resources.Theme getTheme();
+
+    /**
+     * Retrieve styled attribute information in this Context's theme.  See
+     * {@link android.content.res.Resources.Theme#obtainStyledAttributes(int[])}
+     * for more information.
+     *
+     * @see android.content.res.Resources.Theme#obtainStyledAttributes(int[])
+     */
+    public final TypedArray obtainStyledAttributes(@StyleableRes int[] attrs) {
+        return getTheme().obtainStyledAttributes(attrs);
+    }
+
+    /**
+     * Retrieve styled attribute information in this Context's theme.  See
+     * {@link android.content.res.Resources.Theme#obtainStyledAttributes(int, int[])}
+     * for more information.
+     *
+     * @see android.content.res.Resources.Theme#obtainStyledAttributes(int, int[])
+     */
+    public final TypedArray obtainStyledAttributes(
+            @StyleRes int resid, @StyleableRes int[] attrs) throws Resources.NotFoundException {
+        return getTheme().obtainStyledAttributes(resid, attrs);
+    }
+
+    /**
+     * Retrieve styled attribute information in this Context's theme.  See
+     * {@link android.content.res.Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)}
+     * for more information.
+     *
+     * @see android.content.res.Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
+     */
+    public final TypedArray obtainStyledAttributes(
+            AttributeSet set, @StyleableRes int[] attrs) {
+        return getTheme().obtainStyledAttributes(set, attrs, 0, 0);
+    }
+
+    /**
+     * Retrieve styled attribute information in this Context's theme.  See
+     * {@link android.content.res.Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)}
+     * for more information.
+     *
+     * @see android.content.res.Resources.Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
+     */
+    public final TypedArray obtainStyledAttributes(
+            AttributeSet set, @StyleableRes int[] attrs, @AttrRes int defStyleAttr,
+            @StyleRes int defStyleRes) {
+        return getTheme().obtainStyledAttributes(
+            set, attrs, defStyleAttr, defStyleRes);
+    }
+
+    /**
+     * Return a class loader you can use to retrieve classes in this package.
+     */
+    public abstract ClassLoader getClassLoader();
+
+    /** Return the name of this application's package. */
+    public abstract String getPackageName();
+
+    /** @hide Return the name of the base context this context is derived from. */
+    public abstract String getBasePackageName();
+
+    /** @hide Return the package name that should be used for app ops calls from
+     * this context.  This is the same as {@link #getBasePackageName()} except in
+     * cases where system components are loaded into other app processes, in which
+     * case this will be the name of the primary package in that process (so that app
+     * ops uid verification will work with the name). */
+    public abstract String getOpPackageName();
+
+    /** Return the full application info for this context's package. */
+    public abstract ApplicationInfo getApplicationInfo();
+
+    /**
+     * Return the full path to this context's primary Android package.
+     * The Android package is a ZIP file which contains the application's
+     * primary resources.
+     *
+     * <p>Note: this is not generally useful for applications, since they should
+     * not be directly accessing the file system.
+     *
+     * @return String Path to the resources.
+     */
+    public abstract String getPackageResourcePath();
+
+    /**
+     * Return the full path to this context's primary Android package.
+     * The Android package is a ZIP file which contains application's
+     * primary code and assets.
+     *
+     * <p>Note: this is not generally useful for applications, since they should
+     * not be directly accessing the file system.
+     *
+     * @return String Path to the code and assets.
+     */
+    public abstract String getPackageCodePath();
+
+    /**
+     * {@hide}
+     * Return the full path to the shared prefs file for the given prefs group name.
+     *
+     * <p>Note: this is not generally useful for applications, since they should
+     * not be directly accessing the file system.
+     */
+    public abstract File getSharedPrefsFile(String name);
+
+    /**
+     * Retrieve and hold the contents of the preferences file 'name', returning
+     * a SharedPreferences through which you can retrieve and modify its
+     * values.  Only one instance of the SharedPreferences object is returned
+     * to any callers for the same name, meaning they will see each other's
+     * edits as soon as they are made.
+     *
+     * @param name Desired preferences file. If a preferences file by this name
+     * does not exist, it will be created when you retrieve an
+     * editor (SharedPreferences.edit()) and then commit changes (Editor.commit()).
+     * @param mode Operating mode.  Use 0 or {@link #MODE_PRIVATE} for the
+     * default operation, {@link #MODE_WORLD_READABLE}
+     * and {@link #MODE_WORLD_WRITEABLE} to control permissions.
+     *
+     * @return The single {@link SharedPreferences} instance that can be used
+     *         to retrieve and modify the preference values.
+     *
+     * @see #MODE_PRIVATE
+     * @see #MODE_WORLD_READABLE
+     * @see #MODE_WORLD_WRITEABLE
+     */
+    public abstract SharedPreferences getSharedPreferences(String name,
+            int mode);
+
+    /**
+     * Open a private file associated with this Context's application package
+     * for reading.
+     *
+     * @param name The name of the file to open; can not contain path
+     *             separators.
+     *
+     * @return The resulting {@link FileInputStream}.
+     *
+     * @see #openFileOutput
+     * @see #fileList
+     * @see #deleteFile
+     * @see java.io.FileInputStream#FileInputStream(String)
+     */
+    public abstract FileInputStream openFileInput(String name)
+        throws FileNotFoundException;
+
+    /**
+     * Open a private file associated with this Context's application package
+     * for writing. Creates the file if it doesn't already exist.
+     * <p>
+     * No additional permissions are required for the calling app to read or
+     * write the returned file.
+     *
+     * @param name The name of the file to open; can not contain path
+     *            separators.
+     * @param mode Operating mode. Use 0 or {@link #MODE_PRIVATE} for the
+     *            default operation, {@link #MODE_APPEND} to append to an
+     *            existing file, {@link #MODE_WORLD_READABLE} and
+     *            {@link #MODE_WORLD_WRITEABLE} to control permissions.
+     * @return The resulting {@link FileOutputStream}.
+     * @see #MODE_APPEND
+     * @see #MODE_PRIVATE
+     * @see #MODE_WORLD_READABLE
+     * @see #MODE_WORLD_WRITEABLE
+     * @see #openFileInput
+     * @see #fileList
+     * @see #deleteFile
+     * @see java.io.FileOutputStream#FileOutputStream(String)
+     */
+    public abstract FileOutputStream openFileOutput(String name, int mode)
+        throws FileNotFoundException;
+
+    /**
+     * Delete the given private file associated with this Context's
+     * application package.
+     *
+     * @param name The name of the file to delete; can not contain path
+     *             separators.
+     *
+     * @return {@code true} if the file was successfully deleted; else
+     *         {@code false}.
+     *
+     * @see #openFileInput
+     * @see #openFileOutput
+     * @see #fileList
+     * @see java.io.File#delete()
+     */
+    public abstract boolean deleteFile(String name);
+
+    /**
+     * Returns the absolute path on the filesystem where a file created with
+     * {@link #openFileOutput} is stored.
+     * <p>
+     * The returned path may change over time if the calling app is moved to an
+     * adopted storage device, so only relative paths should be persisted.
+     *
+     * @param name The name of the file for which you would like to get
+     *          its path.
+     *
+     * @return An absolute path to the given file.
+     *
+     * @see #openFileOutput
+     * @see #getFilesDir
+     * @see #getDir
+     */
+    public abstract File getFileStreamPath(String name);
+
+    /**
+     * Returns the absolute path to the directory on the filesystem where files
+     * created with {@link #openFileOutput} are stored.
+     * <p>
+     * The returned path may change over time if the calling app is moved to an
+     * adopted storage device, so only relative paths should be persisted.
+     * <p>
+     * No additional permissions are required for the calling app to read or
+     * write files under the returned path.
+     *
+     * @return The path of the directory holding application files.
+     * @see #openFileOutput
+     * @see #getFileStreamPath
+     * @see #getDir
+     */
+    public abstract File getFilesDir();
+
+    /**
+     * Returns the absolute path to the directory on the filesystem similar to
+     * {@link #getFilesDir()}. The difference is that files placed under this
+     * directory will be excluded from automatic backup to remote storage. See
+     * {@link android.app.backup.BackupAgent BackupAgent} for a full discussion
+     * of the automatic backup mechanism in Android.
+     * <p>
+     * The returned path may change over time if the calling app is moved to an
+     * adopted storage device, so only relative paths should be persisted.
+     * <p>
+     * No additional permissions are required for the calling app to read or
+     * write files under the returned path.
+     *
+     * @return The path of the directory holding application files that will not
+     *         be automatically backed up to remote storage.
+     * @see #openFileOutput
+     * @see #getFileStreamPath
+     * @see #getDir
+     * @see android.app.backup.BackupAgent
+     */
+    public abstract File getNoBackupFilesDir();
+
+    /**
+     * Returns the absolute path to the directory on the primary shared/external
+     * storage device where the application can place persistent files it owns.
+     * These files are internal to the applications, and not typically visible
+     * to the user as media.
+     * <p>
+     * This is like {@link #getFilesDir()} in that these files will be deleted
+     * when the application is uninstalled, however there are some important
+     * differences:
+     * <ul>
+     * <li>Shared storage may not always be available, since removable media can
+     * be ejected by the user. Media state can be checked using
+     * {@link Environment#getExternalStorageState(File)}.
+     * <li>There is no security enforced with these files. For example, any
+     * application holding
+     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to
+     * these files.
+     * </ul>
+     * <p>
+     * If a shared storage device is emulated (as determined by
+     * {@link Environment#isExternalStorageEmulated(File)}), it's contents are
+     * backed by a private user data partition, which means there is little
+     * benefit to storing data here instead of the private directories returned
+     * by {@link #getFilesDir()}, etc.
+     * <p>
+     * Starting in {@link android.os.Build.VERSION_CODES#KITKAT}, no permissions
+     * are required to read or write to the returned path; it's always
+     * accessible to the calling app. This only applies to paths generated for
+     * package name of the calling application. To access paths belonging to
+     * other packages,
+     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} and/or
+     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} are required.
+     * <p>
+     * On devices with multiple users (as described by {@link UserManager}),
+     * each user has their own isolated shared storage. Applications only have
+     * access to the shared storage for the user they're running as.
+     * <p>
+     * The returned path may change over time if different shared storage media
+     * is inserted, so only relative paths should be persisted.
+     * <p>
+     * Here is an example of typical code to manipulate a file in an
+     * application's shared storage:
+     * </p>
+     * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
+     * private_file}
+     * <p>
+     * If you supply a non-null <var>type</var> to this function, the returned
+     * file will be a path to a sub-directory of the given type. Though these
+     * files are not automatically scanned by the media scanner, you can
+     * explicitly add them to the media database with
+     * {@link android.media.MediaScannerConnection#scanFile(Context, String[], String[], android.media.MediaScannerConnection.OnScanCompletedListener)
+     * MediaScannerConnection.scanFile}. Note that this is not the same as
+     * {@link android.os.Environment#getExternalStoragePublicDirectory
+     * Environment.getExternalStoragePublicDirectory()}, which provides
+     * directories of media shared by all applications. The directories returned
+     * here are owned by the application, and their contents will be removed
+     * when the application is uninstalled. Unlike
+     * {@link android.os.Environment#getExternalStoragePublicDirectory
+     * Environment.getExternalStoragePublicDirectory()}, the directory returned
+     * here will be automatically created for you.
+     * <p>
+     * Here is an example of typical code to manipulate a picture in an
+     * application's shared storage and add it to the media database:
+     * </p>
+     * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
+     * private_picture}
+     *
+     * @param type The type of files directory to return. May be {@code null}
+     *            for the root of the files directory or one of the following
+     *            constants for a subdirectory:
+     *            {@link android.os.Environment#DIRECTORY_MUSIC},
+     *            {@link android.os.Environment#DIRECTORY_PODCASTS},
+     *            {@link android.os.Environment#DIRECTORY_RINGTONES},
+     *            {@link android.os.Environment#DIRECTORY_ALARMS},
+     *            {@link android.os.Environment#DIRECTORY_NOTIFICATIONS},
+     *            {@link android.os.Environment#DIRECTORY_PICTURES}, or
+     *            {@link android.os.Environment#DIRECTORY_MOVIES}.
+     * @return the absolute path to application-specific directory. May return
+     *         {@code null} if shared storage is not currently available.
+     * @see #getFilesDir
+     * @see #getExternalFilesDirs(String)
+     * @see Environment#getExternalStorageState(File)
+     * @see Environment#isExternalStorageEmulated(File)
+     * @see Environment#isExternalStorageRemovable(File)
+     */
+    @Nullable
+    public abstract File getExternalFilesDir(@Nullable String type);
+
+    /**
+     * Returns absolute paths to application-specific directories on all
+     * shared/external storage devices where the application can place
+     * persistent files it owns. These files are internal to the application,
+     * and not typically visible to the user as media.
+     * <p>
+     * This is like {@link #getFilesDir()} in that these files will be deleted
+     * when the application is uninstalled, however there are some important
+     * differences:
+     * <ul>
+     * <li>Shared storage may not always be available, since removable media can
+     * be ejected by the user. Media state can be checked using
+     * {@link Environment#getExternalStorageState(File)}.
+     * <li>There is no security enforced with these files. For example, any
+     * application holding
+     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to
+     * these files.
+     * </ul>
+     * <p>
+     * If a shared storage device is emulated (as determined by
+     * {@link Environment#isExternalStorageEmulated(File)}), it's contents are
+     * backed by a private user data partition, which means there is little
+     * benefit to storing data here instead of the private directories returned
+     * by {@link #getFilesDir()}, etc.
+     * <p>
+     * Shared storage devices returned here are considered a stable part of the
+     * device, including physical media slots under a protective cover. The
+     * returned paths do not include transient devices, such as USB flash drives
+     * connected to handheld devices.
+     * <p>
+     * An application may store data on any or all of the returned devices. For
+     * example, an app may choose to store large files on the device with the
+     * most available space, as measured by {@link StatFs}.
+     * <p>
+     * No additional permissions are required for the calling app to read or
+     * write files under the returned path. Write access outside of these paths
+     * on secondary external storage devices is not available.
+     * <p>
+     * The returned path may change over time if different shared storage media
+     * is inserted, so only relative paths should be persisted.
+     *
+     * @param type The type of files directory to return. May be {@code null}
+     *            for the root of the files directory or one of the following
+     *            constants for a subdirectory:
+     *            {@link android.os.Environment#DIRECTORY_MUSIC},
+     *            {@link android.os.Environment#DIRECTORY_PODCASTS},
+     *            {@link android.os.Environment#DIRECTORY_RINGTONES},
+     *            {@link android.os.Environment#DIRECTORY_ALARMS},
+     *            {@link android.os.Environment#DIRECTORY_NOTIFICATIONS},
+     *            {@link android.os.Environment#DIRECTORY_PICTURES}, or
+     *            {@link android.os.Environment#DIRECTORY_MOVIES}.
+     * @return the absolute paths to application-specific directories. Some
+     *         individual paths may be {@code null} if that shared storage is
+     *         not currently available. The first path returned is the same as
+     *         {@link #getExternalFilesDir(String)}.
+     * @see #getExternalFilesDir(String)
+     * @see Environment#getExternalStorageState(File)
+     * @see Environment#isExternalStorageEmulated(File)
+     * @see Environment#isExternalStorageRemovable(File)
+     */
+    public abstract File[] getExternalFilesDirs(String type);
+
+    /**
+     * Return the primary shared/external storage directory where this
+     * application's OBB files (if there are any) can be found. Note if the
+     * application does not have any OBB files, this directory may not exist.
+     * <p>
+     * This is like {@link #getFilesDir()} in that these files will be deleted
+     * when the application is uninstalled, however there are some important
+     * differences:
+     * <ul>
+     * <li>Shared storage may not always be available, since removable media can
+     * be ejected by the user. Media state can be checked using
+     * {@link Environment#getExternalStorageState(File)}.
+     * <li>There is no security enforced with these files. For example, any
+     * application holding
+     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to
+     * these files.
+     * </ul>
+     * <p>
+     * Starting in {@link android.os.Build.VERSION_CODES#KITKAT}, no permissions
+     * are required to read or write to the returned path; it's always
+     * accessible to the calling app. This only applies to paths generated for
+     * package name of the calling application. To access paths belonging to
+     * other packages,
+     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} and/or
+     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} are required.
+     * <p>
+     * On devices with multiple users (as described by {@link UserManager}),
+     * multiple users may share the same OBB storage location. Applications
+     * should ensure that multiple instances running under different users don't
+     * interfere with each other.
+     *
+     * @return the absolute path to application-specific directory. May return
+     *         {@code null} if shared storage is not currently available.
+     * @see #getObbDirs()
+     * @see Environment#getExternalStorageState(File)
+     * @see Environment#isExternalStorageEmulated(File)
+     * @see Environment#isExternalStorageRemovable(File)
+     */
+    public abstract File getObbDir();
+
+    /**
+     * Returns absolute paths to application-specific directories on all
+     * shared/external storage devices where the application's OBB files (if
+     * there are any) can be found. Note if the application does not have any
+     * OBB files, these directories may not exist.
+     * <p>
+     * This is like {@link #getFilesDir()} in that these files will be deleted
+     * when the application is uninstalled, however there are some important
+     * differences:
+     * <ul>
+     * <li>Shared storage may not always be available, since removable media can
+     * be ejected by the user. Media state can be checked using
+     * {@link Environment#getExternalStorageState(File)}.
+     * <li>There is no security enforced with these files. For example, any
+     * application holding
+     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to
+     * these files.
+     * </ul>
+     * <p>
+     * Shared storage devices returned here are considered a stable part of the
+     * device, including physical media slots under a protective cover. The
+     * returned paths do not include transient devices, such as USB flash drives
+     * connected to handheld devices.
+     * <p>
+     * An application may store data on any or all of the returned devices. For
+     * example, an app may choose to store large files on the device with the
+     * most available space, as measured by {@link StatFs}.
+     * <p>
+     * No additional permissions are required for the calling app to read or
+     * write files under the returned path. Write access outside of these paths
+     * on secondary external storage devices is not available.
+     *
+     * @return the absolute paths to application-specific directories. Some
+     *         individual paths may be {@code null} if that shared storage is
+     *         not currently available. The first path returned is the same as
+     *         {@link #getObbDir()}
+     * @see #getObbDir()
+     * @see Environment#getExternalStorageState(File)
+     * @see Environment#isExternalStorageEmulated(File)
+     * @see Environment#isExternalStorageRemovable(File)
+     */
+    public abstract File[] getObbDirs();
+
+    /**
+     * Returns the absolute path to the application specific cache directory on
+     * the filesystem. These files will be ones that get deleted first when the
+     * device runs low on storage. There is no guarantee when these files will
+     * be deleted.
+     * <p>
+     * <strong>Note: you should not <em>rely</em> on the system deleting these
+     * files for you; you should always have a reasonable maximum, such as 1 MB,
+     * for the amount of space you consume with cache files, and prune those
+     * files when exceeding that space.</strong>
+     * <p>
+     * The returned path may change over time if the calling app is moved to an
+     * adopted storage device, so only relative paths should be persisted.
+     * <p>
+     * Apps require no extra permissions to read or write to the returned path,
+     * since this path lives in their private storage.
+     *
+     * @return The path of the directory holding application cache files.
+     * @see #openFileOutput
+     * @see #getFileStreamPath
+     * @see #getDir
+     */
+    public abstract File getCacheDir();
+
+    /**
+     * Returns the absolute path to the application specific cache directory on
+     * the filesystem designed for storing cached code. The system will delete
+     * any files stored in this location both when your specific application is
+     * upgraded, and when the entire platform is upgraded.
+     * <p>
+     * This location is optimal for storing compiled or optimized code generated
+     * by your application at runtime.
+     * <p>
+     * The returned path may change over time if the calling app is moved to an
+     * adopted storage device, so only relative paths should be persisted.
+     * <p>
+     * Apps require no extra permissions to read or write to the returned path,
+     * since this path lives in their private storage.
+     *
+     * @return The path of the directory holding application code cache files.
+     */
+    public abstract File getCodeCacheDir();
+
+    /**
+     * Returns absolute path to application-specific directory on the primary
+     * shared/external storage device where the application can place cache
+     * files it owns. These files are internal to the application, and not
+     * typically visible to the user as media.
+     * <p>
+     * This is like {@link #getCacheDir()} in that these files will be deleted
+     * when the application is uninstalled, however there are some important
+     * differences:
+     * <ul>
+     * <li>The platform does not always monitor the space available in shared
+     * storage, and thus may not automatically delete these files. Apps should
+     * always manage the maximum space used in this location. Currently the only
+     * time files here will be deleted by the platform is when running on
+     * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} or later and
+     * {@link Environment#isExternalStorageEmulated(File)} returns true.
+     * <li>Shared storage may not always be available, since removable media can
+     * be ejected by the user. Media state can be checked using
+     * {@link Environment#getExternalStorageState(File)}.
+     * <li>There is no security enforced with these files. For example, any
+     * application holding
+     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to
+     * these files.
+     * </ul>
+     * <p>
+     * If a shared storage device is emulated (as determined by
+     * {@link Environment#isExternalStorageEmulated(File)}), it's contents are
+     * backed by a private user data partition, which means there is little
+     * benefit to storing data here instead of the private directory returned by
+     * {@link #getCacheDir()}.
+     * <p>
+     * Starting in {@link android.os.Build.VERSION_CODES#KITKAT}, no permissions
+     * are required to read or write to the returned path; it's always
+     * accessible to the calling app. This only applies to paths generated for
+     * package name of the calling application. To access paths belonging to
+     * other packages,
+     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} and/or
+     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} are required.
+     * <p>
+     * On devices with multiple users (as described by {@link UserManager}),
+     * each user has their own isolated shared storage. Applications only have
+     * access to the shared storage for the user they're running as.
+     * <p>
+     * The returned path may change over time if different shared storage media
+     * is inserted, so only relative paths should be persisted.
+     *
+     * @return the absolute path to application-specific directory. May return
+     *         {@code null} if shared storage is not currently available.
+     * @see #getCacheDir
+     * @see #getExternalCacheDirs()
+     * @see Environment#getExternalStorageState(File)
+     * @see Environment#isExternalStorageEmulated(File)
+     * @see Environment#isExternalStorageRemovable(File)
+     */
+    @Nullable
+    public abstract File getExternalCacheDir();
+
+    /**
+     * Returns absolute paths to application-specific directories on all
+     * shared/external storage devices where the application can place cache
+     * files it owns. These files are internal to the application, and not
+     * typically visible to the user as media.
+     * <p>
+     * This is like {@link #getCacheDir()} in that these files will be deleted
+     * when the application is uninstalled, however there are some important
+     * differences:
+     * <ul>
+     * <li>The platform does not always monitor the space available in shared
+     * storage, and thus may not automatically delete these files. Apps should
+     * always manage the maximum space used in this location. Currently the only
+     * time files here will be deleted by the platform is when running on
+     * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} or later and
+     * {@link Environment#isExternalStorageEmulated(File)} returns true.
+     * <li>Shared storage may not always be available, since removable media can
+     * be ejected by the user. Media state can be checked using
+     * {@link Environment#getExternalStorageState(File)}.
+     * <li>There is no security enforced with these files. For example, any
+     * application holding
+     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to
+     * these files.
+     * </ul>
+     * <p>
+     * If a shared storage device is emulated (as determined by
+     * {@link Environment#isExternalStorageEmulated(File)}), it's contents are
+     * backed by a private user data partition, which means there is little
+     * benefit to storing data here instead of the private directory returned by
+     * {@link #getCacheDir()}.
+     * <p>
+     * Shared storage devices returned here are considered a stable part of the
+     * device, including physical media slots under a protective cover. The
+     * returned paths do not include transient devices, such as USB flash drives
+     * connected to handheld devices.
+     * <p>
+     * An application may store data on any or all of the returned devices. For
+     * example, an app may choose to store large files on the device with the
+     * most available space, as measured by {@link StatFs}.
+     * <p>
+     * No additional permissions are required for the calling app to read or
+     * write files under the returned path. Write access outside of these paths
+     * on secondary external storage devices is not available.
+     * <p>
+     * The returned paths may change over time if different shared storage media
+     * is inserted, so only relative paths should be persisted.
+     *
+     * @return the absolute paths to application-specific directories. Some
+     *         individual paths may be {@code null} if that shared storage is
+     *         not currently available. The first path returned is the same as
+     *         {@link #getExternalCacheDir()}.
+     * @see #getExternalCacheDir()
+     * @see Environment#getExternalStorageState(File)
+     * @see Environment#isExternalStorageEmulated(File)
+     * @see Environment#isExternalStorageRemovable(File)
+     */
+    public abstract File[] getExternalCacheDirs();
+
+    /**
+     * Returns absolute paths to application-specific directories on all
+     * shared/external storage devices where the application can place media
+     * files. These files are scanned and made available to other apps through
+     * {@link MediaStore}.
+     * <p>
+     * This is like {@link #getExternalFilesDirs} in that these files will be
+     * deleted when the application is uninstalled, however there are some
+     * important differences:
+     * <ul>
+     * <li>Shared storage may not always be available, since removable media can
+     * be ejected by the user. Media state can be checked using
+     * {@link Environment#getExternalStorageState(File)}.
+     * <li>There is no security enforced with these files. For example, any
+     * application holding
+     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} can write to
+     * these files.
+     * </ul>
+     * <p>
+     * Shared storage devices returned here are considered a stable part of the
+     * device, including physical media slots under a protective cover. The
+     * returned paths do not include transient devices, such as USB flash drives
+     * connected to handheld devices.
+     * <p>
+     * An application may store data on any or all of the returned devices. For
+     * example, an app may choose to store large files on the device with the
+     * most available space, as measured by {@link StatFs}.
+     * <p>
+     * No additional permissions are required for the calling app to read or
+     * write files under the returned path. Write access outside of these paths
+     * on secondary external storage devices is not available.
+     * <p>
+     * The returned paths may change over time if different shared storage media
+     * is inserted, so only relative paths should be persisted.
+     *
+     * @return the absolute paths to application-specific directories. Some
+     *         individual paths may be {@code null} if that shared storage is
+     *         not currently available.
+     * @see Environment#getExternalStorageState(File)
+     * @see Environment#isExternalStorageEmulated(File)
+     * @see Environment#isExternalStorageRemovable(File)
+     */
+    public abstract File[] getExternalMediaDirs();
+
+    /**
+     * Returns an array of strings naming the private files associated with
+     * this Context's application package.
+     *
+     * @return Array of strings naming the private files.
+     *
+     * @see #openFileInput
+     * @see #openFileOutput
+     * @see #deleteFile
+     */
+    public abstract String[] fileList();
+
+    /**
+     * Retrieve, creating if needed, a new directory in which the application
+     * can place its own custom data files.  You can use the returned File
+     * object to create and access files in this directory.  Note that files
+     * created through a File object will only be accessible by your own
+     * application; you can only set the mode of the entire directory, not
+     * of individual files.
+     * <p>
+     * The returned path may change over time if the calling app is moved to an
+     * adopted storage device, so only relative paths should be persisted.
+     * <p>
+     * Apps require no extra permissions to read or write to the returned path,
+     * since this path lives in their private storage.
+     *
+     * @param name Name of the directory to retrieve.  This is a directory
+     * that is created as part of your application data.
+     * @param mode Operating mode.  Use 0 or {@link #MODE_PRIVATE} for the
+     * default operation, {@link #MODE_WORLD_READABLE} and
+     * {@link #MODE_WORLD_WRITEABLE} to control permissions.
+     *
+     * @return A {@link File} object for the requested directory.  The directory
+     * will have been created if it does not already exist.
+     *
+     * @see #openFileOutput(String, int)
+     */
+    public abstract File getDir(String name, int mode);
+
+    /**
+     * Open a new private SQLiteDatabase associated with this Context's
+     * application package.  Create the database file if it doesn't exist.
+     *
+     * @param name The name (unique in the application package) of the database.
+     * @param mode Operating mode.  Use 0 or {@link #MODE_PRIVATE} for the
+     *     default operation, {@link #MODE_WORLD_READABLE}
+     *     and {@link #MODE_WORLD_WRITEABLE} to control permissions.
+     *     Use {@link #MODE_ENABLE_WRITE_AHEAD_LOGGING} to enable write-ahead logging by default.
+     * @param factory An optional factory class that is called to instantiate a
+     *     cursor when query is called.
+     *
+     * @return The contents of a newly created database with the given name.
+     * @throws android.database.sqlite.SQLiteException if the database file could not be opened.
+     *
+     * @see #MODE_PRIVATE
+     * @see #MODE_WORLD_READABLE
+     * @see #MODE_WORLD_WRITEABLE
+     * @see #MODE_ENABLE_WRITE_AHEAD_LOGGING
+     * @see #deleteDatabase
+     */
+    public abstract SQLiteDatabase openOrCreateDatabase(String name,
+            int mode, CursorFactory factory);
+
+    /**
+     * Open a new private SQLiteDatabase associated with this Context's
+     * application package.  Creates the database file if it doesn't exist.
+     *
+     * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
+     * used to handle corruption when sqlite reports database corruption.</p>
+     *
+     * @param name The name (unique in the application package) of the database.
+     * @param mode Operating mode.  Use 0 or {@link #MODE_PRIVATE} for the
+     *     default operation, {@link #MODE_WORLD_READABLE}
+     *     and {@link #MODE_WORLD_WRITEABLE} to control permissions.
+     *     Use {@link #MODE_ENABLE_WRITE_AHEAD_LOGGING} to enable write-ahead logging by default.
+     * @param factory An optional factory class that is called to instantiate a
+     *     cursor when query is called.
+     * @param errorHandler the {@link DatabaseErrorHandler} to be used when sqlite reports database
+     * corruption. if null, {@link android.database.DefaultDatabaseErrorHandler} is assumed.
+     * @return The contents of a newly created database with the given name.
+     * @throws android.database.sqlite.SQLiteException if the database file could not be opened.
+     *
+     * @see #MODE_PRIVATE
+     * @see #MODE_WORLD_READABLE
+     * @see #MODE_WORLD_WRITEABLE
+     * @see #MODE_ENABLE_WRITE_AHEAD_LOGGING
+     * @see #deleteDatabase
+     */
+    public abstract SQLiteDatabase openOrCreateDatabase(String name,
+            int mode, CursorFactory factory,
+            @Nullable DatabaseErrorHandler errorHandler);
+
+    /**
+     * Delete an existing private SQLiteDatabase associated with this Context's
+     * application package.
+     *
+     * @param name The name (unique in the application package) of the
+     *             database.
+     *
+     * @return {@code true} if the database was successfully deleted; else {@code false}.
+     *
+     * @see #openOrCreateDatabase
+     */
+    public abstract boolean deleteDatabase(String name);
+
+    /**
+     * Returns the absolute path on the filesystem where a database created with
+     * {@link #openOrCreateDatabase} is stored.
+     * <p>
+     * The returned path may change over time if the calling app is moved to an
+     * adopted storage device, so only relative paths should be persisted.
+     *
+     * @param name The name of the database for which you would like to get
+     *          its path.
+     *
+     * @return An absolute path to the given database.
+     *
+     * @see #openOrCreateDatabase
+     */
+    public abstract File getDatabasePath(String name);
+
+    /**
+     * Returns an array of strings naming the private databases associated with
+     * this Context's application package.
+     *
+     * @return Array of strings naming the private databases.
+     *
+     * @see #openOrCreateDatabase
+     * @see #deleteDatabase
+     */
+    public abstract String[] databaseList();
+
+    /**
+     * @deprecated Use {@link android.app.WallpaperManager#getDrawable
+     * WallpaperManager.get()} instead.
+     */
+    @Deprecated
+    public abstract Drawable getWallpaper();
+
+    /**
+     * @deprecated Use {@link android.app.WallpaperManager#peekDrawable
+     * WallpaperManager.peek()} instead.
+     */
+    @Deprecated
+    public abstract Drawable peekWallpaper();
+
+    /**
+     * @deprecated Use {@link android.app.WallpaperManager#getDesiredMinimumWidth()
+     * WallpaperManager.getDesiredMinimumWidth()} instead.
+     */
+    @Deprecated
+    public abstract int getWallpaperDesiredMinimumWidth();
+
+    /**
+     * @deprecated Use {@link android.app.WallpaperManager#getDesiredMinimumHeight()
+     * WallpaperManager.getDesiredMinimumHeight()} instead.
+     */
+    @Deprecated
+    public abstract int getWallpaperDesiredMinimumHeight();
+
+    /**
+     * @deprecated Use {@link android.app.WallpaperManager#setBitmap(Bitmap)
+     * WallpaperManager.set()} instead.
+     * <p>This method requires the caller to hold the permission
+     * {@link android.Manifest.permission#SET_WALLPAPER}.
+     */
+    @Deprecated
+    public abstract void setWallpaper(Bitmap bitmap) throws IOException;
+
+    /**
+     * @deprecated Use {@link android.app.WallpaperManager#setStream(InputStream)
+     * WallpaperManager.set()} instead.
+     * <p>This method requires the caller to hold the permission
+     * {@link android.Manifest.permission#SET_WALLPAPER}.
+     */
+    @Deprecated
+    public abstract void setWallpaper(InputStream data) throws IOException;
+
+    /**
+     * @deprecated Use {@link android.app.WallpaperManager#clear
+     * WallpaperManager.clear()} instead.
+     * <p>This method requires the caller to hold the permission
+     * {@link android.Manifest.permission#SET_WALLPAPER}.
+     */
+    @Deprecated
+    public abstract void clearWallpaper() throws IOException;
+
+    /**
+     * Same as {@link #startActivity(Intent, Bundle)} with no options
+     * specified.
+     *
+     * @param intent The description of the activity to start.
+     *
+     * @throws ActivityNotFoundException &nbsp;
+     *`
+     * @see #startActivity(Intent, Bundle)
+     * @see PackageManager#resolveActivity
+     */
+    public abstract void startActivity(Intent intent);
+
+    /**
+     * Version of {@link #startActivity(Intent)} that allows you to specify the
+     * user the activity will be started for.  This is not available to applications
+     * that are not pre-installed on the system image.  Using it requires holding
+     * the INTERACT_ACROSS_USERS_FULL permission.
+     * @param intent The description of the activity to start.
+     * @param user The UserHandle of the user to start this activity for.
+     * @throws ActivityNotFoundException &nbsp;
+     * @hide
+     */
+    public void startActivityAsUser(Intent intent, UserHandle user) {
+        throw new RuntimeException("Not implemented. Must override in a subclass.");
+    }
+
+    /**
+     * Launch a new activity.  You will not receive any information about when
+     * the activity exits.
+     *
+     * <p>Note that if this method is being called from outside of an
+     * {@link android.app.Activity} Context, then the Intent must include
+     * the {@link Intent#FLAG_ACTIVITY_NEW_TASK} launch flag.  This is because,
+     * without being started from an existing Activity, there is no existing
+     * task in which to place the new activity and thus it needs to be placed
+     * in its own separate task.
+     *
+     * <p>This method throws {@link ActivityNotFoundException}
+     * if there was no Activity found to run the given Intent.
+     *
+     * @param intent The description of the activity to start.
+     * @param options Additional options for how the Activity should be started.
+     * May be null if there are no options.  See {@link android.app.ActivityOptions}
+     * for how to build the Bundle supplied here; there are no supported definitions
+     * for building it manually.
+     *
+     * @throws ActivityNotFoundException &nbsp;
+     *
+     * @see #startActivity(Intent)
+     * @see PackageManager#resolveActivity
+     */
+    public abstract void startActivity(Intent intent, @Nullable Bundle options);
+
+    /**
+     * Version of {@link #startActivity(Intent, Bundle)} that allows you to specify the
+     * user the activity will be started for.  This is not available to applications
+     * that are not pre-installed on the system image.  Using it requires holding
+     * the INTERACT_ACROSS_USERS_FULL permission.
+     * @param intent The description of the activity to start.
+     * @param options Additional options for how the Activity should be started.
+     * May be null if there are no options.  See {@link android.app.ActivityOptions}
+     * for how to build the Bundle supplied here; there are no supported definitions
+     * for building it manually.
+     * @param userId The UserHandle of the user to start this activity for.
+     * @throws ActivityNotFoundException &nbsp;
+     * @hide
+     */
+    public void startActivityAsUser(Intent intent, @Nullable Bundle options, UserHandle userId) {
+        throw new RuntimeException("Not implemented. Must override in a subclass.");
+    }
+
+    /**
+     * Version of {@link #startActivity(Intent, Bundle)} that returns a result to the caller. This
+     * is only supported for Views and Fragments.
+     * @param who The identifier for the calling element that will receive the result.
+     * @param intent The intent to start.
+     * @param requestCode The code that will be returned with onActivityResult() identifying this
+     *          request.
+     * @param options Additional options for how the Activity should be started.
+     *          May be null if there are no options.  See {@link android.app.ActivityOptions}
+     *          for how to build the Bundle supplied here; there are no supported definitions
+     *          for building it manually.
+     * @hide
+     */
+    public void startActivityForResult(
+            @NonNull String who, Intent intent, int requestCode, @Nullable Bundle options) {
+        throw new RuntimeException("This method is only implemented for Activity-based Contexts. "
+                + "Check canStartActivityForResult() before calling.");
+    }
+
+    /**
+     * Identifies whether this Context instance will be able to process calls to
+     * {@link #startActivityForResult(String, Intent, int, Bundle)}.
+     * @hide
+     */
+    public boolean canStartActivityForResult() {
+        return false;
+    }
+
+    /**
+     * Same as {@link #startActivities(Intent[], Bundle)} with no options
+     * specified.
+     *
+     * @param intents An array of Intents to be started.
+     *
+     * @throws ActivityNotFoundException &nbsp;
+     *
+     * @see #startActivities(Intent[], Bundle)
+     * @see PackageManager#resolveActivity
+     */
+    public abstract void startActivities(Intent[] intents);
+
+    /**
+     * Launch multiple new activities.  This is generally the same as calling
+     * {@link #startActivity(Intent)} for the first Intent in the array,
+     * that activity during its creation calling {@link #startActivity(Intent)}
+     * for the second entry, etc.  Note that unlike that approach, generally
+     * none of the activities except the last in the array will be created
+     * at this point, but rather will be created when the user first visits
+     * them (due to pressing back from the activity on top).
+     *
+     * <p>This method throws {@link ActivityNotFoundException}
+     * if there was no Activity found for <em>any</em> given Intent.  In this
+     * case the state of the activity stack is undefined (some Intents in the
+     * list may be on it, some not), so you probably want to avoid such situations.
+     *
+     * @param intents An array of Intents to be started.
+     * @param options Additional options for how the Activity should be started.
+     * See {@link android.content.Context#startActivity(Intent, Bundle)
+     * Context.startActivity(Intent, Bundle)} for more details.
+     *
+     * @throws ActivityNotFoundException &nbsp;
+     *
+     * @see #startActivities(Intent[])
+     * @see PackageManager#resolveActivity
+     */
+    public abstract void startActivities(Intent[] intents, Bundle options);
+
+    /**
+     * @hide
+     * Launch multiple new activities.  This is generally the same as calling
+     * {@link #startActivity(Intent)} for the first Intent in the array,
+     * that activity during its creation calling {@link #startActivity(Intent)}
+     * for the second entry, etc.  Note that unlike that approach, generally
+     * none of the activities except the last in the array will be created
+     * at this point, but rather will be created when the user first visits
+     * them (due to pressing back from the activity on top).
+     *
+     * <p>This method throws {@link ActivityNotFoundException}
+     * if there was no Activity found for <em>any</em> given Intent.  In this
+     * case the state of the activity stack is undefined (some Intents in the
+     * list may be on it, some not), so you probably want to avoid such situations.
+     *
+     * @param intents An array of Intents to be started.
+     * @param options Additional options for how the Activity should be started.
+     * @param userHandle The user for whom to launch the activities
+     * See {@link android.content.Context#startActivity(Intent, Bundle)
+     * Context.startActivity(Intent, Bundle)} for more details.
+     *
+     * @throws ActivityNotFoundException &nbsp;
+     *
+     * @see #startActivities(Intent[])
+     * @see PackageManager#resolveActivity
+     */
+    public void startActivitiesAsUser(Intent[] intents, Bundle options, UserHandle userHandle) {
+        throw new RuntimeException("Not implemented. Must override in a subclass.");
+    }
+
+    /**
+     * Same as {@link #startIntentSender(IntentSender, Intent, int, int, int, Bundle)}
+     * with no options specified.
+     *
+     * @param intent The IntentSender to launch.
+     * @param fillInIntent If non-null, this will be provided as the
+     * intent parameter to {@link IntentSender#sendIntent}.
+     * @param flagsMask Intent flags in the original IntentSender that you
+     * would like to change.
+     * @param flagsValues Desired values for any bits set in
+     * <var>flagsMask</var>
+     * @param extraFlags Always set to 0.
+     *
+     * @see #startActivity(Intent)
+     * @see #startIntentSender(IntentSender, Intent, int, int, int, Bundle)
+     */
+    public abstract void startIntentSender(IntentSender intent,
+            Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)
+            throws IntentSender.SendIntentException;
+
+    /**
+     * Like {@link #startActivity(Intent, Bundle)}, but taking a IntentSender
+     * to start.  If the IntentSender is for an activity, that activity will be started
+     * as if you had called the regular {@link #startActivity(Intent)}
+     * here; otherwise, its associated action will be executed (such as
+     * sending a broadcast) as if you had called
+     * {@link IntentSender#sendIntent IntentSender.sendIntent} on it.
+     *
+     * @param intent The IntentSender to launch.
+     * @param fillInIntent If non-null, this will be provided as the
+     * intent parameter to {@link IntentSender#sendIntent}.
+     * @param flagsMask Intent flags in the original IntentSender that you
+     * would like to change.
+     * @param flagsValues Desired values for any bits set in
+     * <var>flagsMask</var>
+     * @param extraFlags Always set to 0.
+     * @param options Additional options for how the Activity should be started.
+     * See {@link android.content.Context#startActivity(Intent, Bundle)
+     * Context.startActivity(Intent, Bundle)} for more details.  If options
+     * have also been supplied by the IntentSender, options given here will
+     * override any that conflict with those given by the IntentSender.
+     *
+     * @see #startActivity(Intent, Bundle)
+     * @see #startIntentSender(IntentSender, Intent, int, int, int)
+     */
+    public abstract void startIntentSender(IntentSender intent,
+            @Nullable Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags,
+            Bundle options) throws IntentSender.SendIntentException;
+
+    /**
+     * Broadcast the given intent to all interested BroadcastReceivers.  This
+     * call is asynchronous; it returns immediately, and you will continue
+     * executing while the receivers are run.  No results are propagated from
+     * receivers and receivers can not abort the broadcast. If you want
+     * to allow receivers to propagate results or abort the broadcast, you must
+     * send an ordered broadcast using
+     * {@link #sendOrderedBroadcast(Intent, String)}.
+     *
+     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
+     *
+     * @param intent The Intent to broadcast; all receivers matching this
+     *               Intent will receive the broadcast.
+     *
+     * @see android.content.BroadcastReceiver
+     * @see #registerReceiver
+     * @see #sendBroadcast(Intent, String)
+     * @see #sendOrderedBroadcast(Intent, String)
+     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
+     */
+    public abstract void sendBroadcast(Intent intent);
+
+    /**
+     * Broadcast the given intent to all interested BroadcastReceivers, allowing
+     * an optional required permission to be enforced.  This
+     * call is asynchronous; it returns immediately, and you will continue
+     * executing while the receivers are run.  No results are propagated from
+     * receivers and receivers can not abort the broadcast. If you want
+     * to allow receivers to propagate results or abort the broadcast, you must
+     * send an ordered broadcast using
+     * {@link #sendOrderedBroadcast(Intent, String)}.
+     *
+     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
+     *
+     * @param intent The Intent to broadcast; all receivers matching this
+     *               Intent will receive the broadcast.
+     * @param receiverPermission (optional) String naming a permission that
+     *               a receiver must hold in order to receive your broadcast.
+     *               If null, no permission is required.
+     *
+     * @see android.content.BroadcastReceiver
+     * @see #registerReceiver
+     * @see #sendBroadcast(Intent)
+     * @see #sendOrderedBroadcast(Intent, String)
+     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
+     */
+    public abstract void sendBroadcast(Intent intent,
+            @Nullable String receiverPermission);
+
+
+    /**
+     * Broadcast the given intent to all interested BroadcastReceivers, allowing
+     * an array of required permissions to be enforced.  This call is asynchronous; it returns
+     * immediately, and you will continue executing while the receivers are run.  No results are
+     * propagated from receivers and receivers can not abort the broadcast. If you want to allow
+     * receivers to propagate results or abort the broadcast, you must send an ordered broadcast
+     * using {@link #sendOrderedBroadcast(Intent, String)}.
+     *
+     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
+     *
+     * @param intent The Intent to broadcast; all receivers matching this
+     *               Intent will receive the broadcast.
+     * @param receiverPermissions Array of names of permissions that a receiver must hold
+     *                            in order to receive your broadcast.
+     *                            If null or empty, no permissions are required.
+     *
+     * @see android.content.BroadcastReceiver
+     * @see #registerReceiver
+     * @see #sendBroadcast(Intent)
+     * @see #sendOrderedBroadcast(Intent, String)
+     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
+     * @hide
+     */
+    public abstract void sendBroadcastMultiplePermissions(Intent intent,
+            String[] receiverPermissions);
+
+    /**
+     * Broadcast the given intent to all interested BroadcastReceivers, allowing
+     * an optional required permission to be enforced.  This
+     * call is asynchronous; it returns immediately, and you will continue
+     * executing while the receivers are run.  No results are propagated from
+     * receivers and receivers can not abort the broadcast. If you want
+     * to allow receivers to propagate results or abort the broadcast, you must
+     * send an ordered broadcast using
+     * {@link #sendOrderedBroadcast(Intent, String)}.
+     *
+     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
+     *
+     * @param intent The Intent to broadcast; all receivers matching this
+     *               Intent will receive the broadcast.
+     * @param receiverPermission (optional) String naming a permission that
+     *               a receiver must hold in order to receive your broadcast.
+     *               If null, no permission is required.
+     * @param options (optional) Additional sending options, generated from a
+     * {@link android.app.BroadcastOptions}.
+     *
+     * @see android.content.BroadcastReceiver
+     * @see #registerReceiver
+     * @see #sendBroadcast(Intent)
+     * @see #sendOrderedBroadcast(Intent, String)
+     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
+     * @hide
+     */
+    @SystemApi
+    public abstract void sendBroadcast(Intent intent,
+            @Nullable String receiverPermission,
+            @Nullable Bundle options);
+
+    /**
+     * Like {@link #sendBroadcast(Intent, String)}, but also allows specification
+     * of an associated app op as per {@link android.app.AppOpsManager}.
+     * @hide
+     */
+    public abstract void sendBroadcast(Intent intent,
+            String receiverPermission, int appOp);
+
+    /**
+     * Broadcast the given intent to all interested BroadcastReceivers, delivering
+     * them one at a time to allow more preferred receivers to consume the
+     * broadcast before it is delivered to less preferred receivers.  This
+     * call is asynchronous; it returns immediately, and you will continue
+     * executing while the receivers are run.
+     *
+     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
+     *
+     * @param intent The Intent to broadcast; all receivers matching this
+     *               Intent will receive the broadcast.
+     * @param receiverPermission (optional) String naming a permissions that
+     *               a receiver must hold in order to receive your broadcast.
+     *               If null, no permission is required.
+     *
+     * @see android.content.BroadcastReceiver
+     * @see #registerReceiver
+     * @see #sendBroadcast(Intent)
+     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
+     */
+    public abstract void sendOrderedBroadcast(Intent intent,
+            @Nullable String receiverPermission);
+
+    /**
+     * Version of {@link #sendBroadcast(Intent)} that allows you to
+     * receive data back from the broadcast.  This is accomplished by
+     * supplying your own BroadcastReceiver when calling, which will be
+     * treated as a final receiver at the end of the broadcast -- its
+     * {@link BroadcastReceiver#onReceive} method will be called with
+     * the result values collected from the other receivers.  The broadcast will
+     * be serialized in the same way as calling
+     * {@link #sendOrderedBroadcast(Intent, String)}.
+     *
+     * <p>Like {@link #sendBroadcast(Intent)}, this method is
+     * asynchronous; it will return before
+     * resultReceiver.onReceive() is called.
+     *
+     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
+     *
+     * @param intent The Intent to broadcast; all receivers matching this
+     *               Intent will receive the broadcast.
+     * @param receiverPermission String naming a permissions that
+     *               a receiver must hold in order to receive your broadcast.
+     *               If null, no permission is required.
+     * @param resultReceiver Your own BroadcastReceiver to treat as the final
+     *                       receiver of the broadcast.
+     * @param scheduler A custom Handler with which to schedule the
+     *                  resultReceiver callback; if null it will be
+     *                  scheduled in the Context's main thread.
+     * @param initialCode An initial value for the result code.  Often
+     *                    Activity.RESULT_OK.
+     * @param initialData An initial value for the result data.  Often
+     *                    null.
+     * @param initialExtras An initial value for the result extras.  Often
+     *                      null.
+     *
+     * @see #sendBroadcast(Intent)
+     * @see #sendBroadcast(Intent, String)
+     * @see #sendOrderedBroadcast(Intent, String)
+     * @see android.content.BroadcastReceiver
+     * @see #registerReceiver
+     * @see android.app.Activity#RESULT_OK
+     */
+    public abstract void sendOrderedBroadcast(@NonNull Intent intent,
+            @Nullable String receiverPermission, @Nullable BroadcastReceiver resultReceiver,
+            @Nullable Handler scheduler, int initialCode, @Nullable String initialData,
+            @Nullable Bundle initialExtras);
+
+    /**
+     * Version of {@link #sendBroadcast(Intent)} that allows you to
+     * receive data back from the broadcast.  This is accomplished by
+     * supplying your own BroadcastReceiver when calling, which will be
+     * treated as a final receiver at the end of the broadcast -- its
+     * {@link BroadcastReceiver#onReceive} method will be called with
+     * the result values collected from the other receivers.  The broadcast will
+     * be serialized in the same way as calling
+     * {@link #sendOrderedBroadcast(Intent, String)}.
+     *
+     * <p>Like {@link #sendBroadcast(Intent)}, this method is
+     * asynchronous; it will return before
+     * resultReceiver.onReceive() is called.
+     *
+     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
+     *
+     *
+     * @param intent The Intent to broadcast; all receivers matching this
+     *               Intent will receive the broadcast.
+     * @param receiverPermission String naming a permissions that
+     *               a receiver must hold in order to receive your broadcast.
+     *               If null, no permission is required.
+     * @param options (optional) Additional sending options, generated from a
+     * {@link android.app.BroadcastOptions}.
+     * @param resultReceiver Your own BroadcastReceiver to treat as the final
+     *                       receiver of the broadcast.
+     * @param scheduler A custom Handler with which to schedule the
+     *                  resultReceiver callback; if null it will be
+     *                  scheduled in the Context's main thread.
+     * @param initialCode An initial value for the result code.  Often
+     *                    Activity.RESULT_OK.
+     * @param initialData An initial value for the result data.  Often
+     *                    null.
+     * @param initialExtras An initial value for the result extras.  Often
+     *                      null.
+     * @see #sendBroadcast(Intent)
+     * @see #sendBroadcast(Intent, String)
+     * @see #sendOrderedBroadcast(Intent, String)
+     * @see android.content.BroadcastReceiver
+     * @see #registerReceiver
+     * @see android.app.Activity#RESULT_OK
+     * @hide
+     */
+    @SystemApi
+    public abstract void sendOrderedBroadcast(@NonNull Intent intent,
+            @Nullable String receiverPermission, @Nullable Bundle options,
+            @Nullable BroadcastReceiver resultReceiver, @Nullable Handler scheduler,
+            int initialCode, @Nullable String initialData, @Nullable Bundle initialExtras);
+
+    /**
+     * Like {@link #sendOrderedBroadcast(Intent, String, BroadcastReceiver, android.os.Handler,
+     * int, String, android.os.Bundle)}, but also allows specification
+     * of an associated app op as per {@link android.app.AppOpsManager}.
+     * @hide
+     */
+    public abstract void sendOrderedBroadcast(Intent intent,
+            String receiverPermission, int appOp, BroadcastReceiver resultReceiver,
+            Handler scheduler, int initialCode, String initialData,
+            Bundle initialExtras);
+
+    /**
+     * Version of {@link #sendBroadcast(Intent)} that allows you to specify the
+     * user the broadcast will be sent to.  This is not available to applications
+     * that are not pre-installed on the system image.  Using it requires holding
+     * the INTERACT_ACROSS_USERS permission.
+     * @param intent The intent to broadcast
+     * @param user UserHandle to send the intent to.
+     * @see #sendBroadcast(Intent)
+     */
+    public abstract void sendBroadcastAsUser(Intent intent, UserHandle user);
+
+    /**
+     * Version of {@link #sendBroadcast(Intent, String)} that allows you to specify the
+     * user the broadcast will be sent to.  This is not available to applications
+     * that are not pre-installed on the system image.  Using it requires holding
+     * the INTERACT_ACROSS_USERS permission.
+     *
+     * @param intent The Intent to broadcast; all receivers matching this
+     *               Intent will receive the broadcast.
+     * @param user UserHandle to send the intent to.
+     * @param receiverPermission (optional) String naming a permission that
+     *               a receiver must hold in order to receive your broadcast.
+     *               If null, no permission is required.
+     *
+     * @see #sendBroadcast(Intent, String)
+     */
+    public abstract void sendBroadcastAsUser(Intent intent, UserHandle user,
+            @Nullable String receiverPermission);
+
+
+    /**
+     * Version of {@link #sendBroadcast(Intent, String)} that allows you to specify the
+     * user the broadcast will be sent to.  This is not available to applications
+     * that are not pre-installed on the system image.  Using it requires holding
+     * the INTERACT_ACROSS_USERS permission.
+     *
+     * @param intent The Intent to broadcast; all receivers matching this
+     *               Intent will receive the broadcast.
+     * @param user UserHandle to send the intent to.
+     * @param receiverPermission (optional) String naming a permission that
+     *               a receiver must hold in order to receive your broadcast.
+     *               If null, no permission is required.
+     * @param appOp The app op associated with the broadcast.
+     *
+     * @see #sendBroadcast(Intent, String)
+     *
+     * @hide
+     */
+    public abstract void sendBroadcastAsUser(Intent intent, UserHandle user,
+            @Nullable String receiverPermission, int appOp);
+
+    /**
+     * Version of
+     * {@link #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)}
+     * that allows you to specify the
+     * user the broadcast will be sent to.  This is not available to applications
+     * that are not pre-installed on the system image.  Using it requires holding
+     * the INTERACT_ACROSS_USERS permission.
+     *
+     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
+     *
+     * @param intent The Intent to broadcast; all receivers matching this
+     *               Intent will receive the broadcast.
+     * @param user UserHandle to send the intent to.
+     * @param receiverPermission String naming a permissions that
+     *               a receiver must hold in order to receive your broadcast.
+     *               If null, no permission is required.
+     * @param resultReceiver Your own BroadcastReceiver to treat as the final
+     *                       receiver of the broadcast.
+     * @param scheduler A custom Handler with which to schedule the
+     *                  resultReceiver callback; if null it will be
+     *                  scheduled in the Context's main thread.
+     * @param initialCode An initial value for the result code.  Often
+     *                    Activity.RESULT_OK.
+     * @param initialData An initial value for the result data.  Often
+     *                    null.
+     * @param initialExtras An initial value for the result extras.  Often
+     *                      null.
+     *
+     * @see #sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
+     */
+    public abstract void sendOrderedBroadcastAsUser(Intent intent, UserHandle user,
+            @Nullable String receiverPermission, BroadcastReceiver resultReceiver,
+            @Nullable Handler scheduler, int initialCode, @Nullable String initialData,
+            @Nullable  Bundle initialExtras);
+
+    /**
+     * Similar to above but takes an appOp as well, to enforce restrictions.
+     * @see #sendOrderedBroadcastAsUser(Intent, UserHandle, String,
+     *       BroadcastReceiver, Handler, int, String, Bundle)
+     * @hide
+     */
+    public abstract void sendOrderedBroadcastAsUser(Intent intent, UserHandle user,
+            @Nullable String receiverPermission, int appOp, BroadcastReceiver resultReceiver,
+            @Nullable Handler scheduler, int initialCode, @Nullable String initialData,
+            @Nullable  Bundle initialExtras);
+
+    /**
+     * Similar to above but takes an appOp as well, to enforce restrictions, and an options Bundle.
+     * @see #sendOrderedBroadcastAsUser(Intent, UserHandle, String,
+     *       BroadcastReceiver, Handler, int, String, Bundle)
+     * @hide
+     */
+    public abstract void sendOrderedBroadcastAsUser(Intent intent, UserHandle user,
+            @Nullable String receiverPermission, int appOp, @Nullable Bundle options,
+            BroadcastReceiver resultReceiver, @Nullable Handler scheduler, int initialCode,
+            @Nullable String initialData, @Nullable  Bundle initialExtras);
+
+    /**
+     * <p>Perform a {@link #sendBroadcast(Intent)} that is "sticky," meaning the
+     * Intent you are sending stays around after the broadcast is complete,
+     * so that others can quickly retrieve that data through the return
+     * value of {@link #registerReceiver(BroadcastReceiver, IntentFilter)}.  In
+     * all other ways, this behaves the same as
+     * {@link #sendBroadcast(Intent)}.
+     *
+     * <p>You must hold the {@link android.Manifest.permission#BROADCAST_STICKY}
+     * permission in order to use this API.  If you do not hold that
+     * permission, {@link SecurityException} will be thrown.
+     *
+     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone
+     * can access them), no protection (anyone can modify them), and many other problems.
+     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>
+     * has changed, with another mechanism for apps to retrieve the current value whenever
+     * desired.
+     *
+     * @param intent The Intent to broadcast; all receivers matching this
+     * Intent will receive the broadcast, and the Intent will be held to
+     * be re-broadcast to future receivers.
+     *
+     * @see #sendBroadcast(Intent)
+     * @see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
+     */
+    @Deprecated
+    public abstract void sendStickyBroadcast(Intent intent);
+
+    /**
+     * <p>Version of {@link #sendStickyBroadcast} that allows you to
+     * receive data back from the broadcast.  This is accomplished by
+     * supplying your own BroadcastReceiver when calling, which will be
+     * treated as a final receiver at the end of the broadcast -- its
+     * {@link BroadcastReceiver#onReceive} method will be called with
+     * the result values collected from the other receivers.  The broadcast will
+     * be serialized in the same way as calling
+     * {@link #sendOrderedBroadcast(Intent, String)}.
+     *
+     * <p>Like {@link #sendBroadcast(Intent)}, this method is
+     * asynchronous; it will return before
+     * resultReceiver.onReceive() is called.  Note that the sticky data
+     * stored is only the data you initially supply to the broadcast, not
+     * the result of any changes made by the receivers.
+     *
+     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
+     *
+     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone
+     * can access them), no protection (anyone can modify them), and many other problems.
+     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>
+     * has changed, with another mechanism for apps to retrieve the current value whenever
+     * desired.
+     *
+     * @param intent The Intent to broadcast; all receivers matching this
+     *               Intent will receive the broadcast.
+     * @param resultReceiver Your own BroadcastReceiver to treat as the final
+     *                       receiver of the broadcast.
+     * @param scheduler A custom Handler with which to schedule the
+     *                  resultReceiver callback; if null it will be
+     *                  scheduled in the Context's main thread.
+     * @param initialCode An initial value for the result code.  Often
+     *                    Activity.RESULT_OK.
+     * @param initialData An initial value for the result data.  Often
+     *                    null.
+     * @param initialExtras An initial value for the result extras.  Often
+     *                      null.
+     *
+     * @see #sendBroadcast(Intent)
+     * @see #sendBroadcast(Intent, String)
+     * @see #sendOrderedBroadcast(Intent, String)
+     * @see #sendStickyBroadcast(Intent)
+     * @see android.content.BroadcastReceiver
+     * @see #registerReceiver
+     * @see android.app.Activity#RESULT_OK
+     */
+    @Deprecated
+    public abstract void sendStickyOrderedBroadcast(Intent intent,
+            BroadcastReceiver resultReceiver,
+            @Nullable Handler scheduler, int initialCode, @Nullable String initialData,
+            @Nullable Bundle initialExtras);
+
+    /**
+     * <p>Remove the data previously sent with {@link #sendStickyBroadcast},
+     * so that it is as if the sticky broadcast had never happened.
+     *
+     * <p>You must hold the {@link android.Manifest.permission#BROADCAST_STICKY}
+     * permission in order to use this API.  If you do not hold that
+     * permission, {@link SecurityException} will be thrown.
+     *
+     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone
+     * can access them), no protection (anyone can modify them), and many other problems.
+     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>
+     * has changed, with another mechanism for apps to retrieve the current value whenever
+     * desired.
+     *
+     * @param intent The Intent that was previously broadcast.
+     *
+     * @see #sendStickyBroadcast
+     */
+    @Deprecated
+    public abstract void removeStickyBroadcast(Intent intent);
+
+    /**
+     * <p>Version of {@link #sendStickyBroadcast(Intent)} that allows you to specify the
+     * user the broadcast will be sent to.  This is not available to applications
+     * that are not pre-installed on the system image.  Using it requires holding
+     * the INTERACT_ACROSS_USERS permission.
+     *
+     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone
+     * can access them), no protection (anyone can modify them), and many other problems.
+     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>
+     * has changed, with another mechanism for apps to retrieve the current value whenever
+     * desired.
+     *
+     * @param intent The Intent to broadcast; all receivers matching this
+     * Intent will receive the broadcast, and the Intent will be held to
+     * be re-broadcast to future receivers.
+     * @param user UserHandle to send the intent to.
+     *
+     * @see #sendBroadcast(Intent)
+     */
+    @Deprecated
+    public abstract void sendStickyBroadcastAsUser(Intent intent, UserHandle user);
+
+    /**
+     * <p>Version of
+     * {@link #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)}
+     * that allows you to specify the
+     * user the broadcast will be sent to.  This is not available to applications
+     * that are not pre-installed on the system image.  Using it requires holding
+     * the INTERACT_ACROSS_USERS permission.
+     *
+     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
+     *
+     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone
+     * can access them), no protection (anyone can modify them), and many other problems.
+     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>
+     * has changed, with another mechanism for apps to retrieve the current value whenever
+     * desired.
+     *
+     * @param intent The Intent to broadcast; all receivers matching this
+     *               Intent will receive the broadcast.
+     * @param user UserHandle to send the intent to.
+     * @param resultReceiver Your own BroadcastReceiver to treat as the final
+     *                       receiver of the broadcast.
+     * @param scheduler A custom Handler with which to schedule the
+     *                  resultReceiver callback; if null it will be
+     *                  scheduled in the Context's main thread.
+     * @param initialCode An initial value for the result code.  Often
+     *                    Activity.RESULT_OK.
+     * @param initialData An initial value for the result data.  Often
+     *                    null.
+     * @param initialExtras An initial value for the result extras.  Often
+     *                      null.
+     *
+     * @see #sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
+     */
+    @Deprecated
+    public abstract void sendStickyOrderedBroadcastAsUser(Intent intent,
+            UserHandle user, BroadcastReceiver resultReceiver,
+            @Nullable Handler scheduler, int initialCode, @Nullable String initialData,
+            @Nullable Bundle initialExtras);
+
+    /**
+     * <p>Version of {@link #removeStickyBroadcast(Intent)} that allows you to specify the
+     * user the broadcast will be sent to.  This is not available to applications
+     * that are not pre-installed on the system image.  Using it requires holding
+     * the INTERACT_ACROSS_USERS permission.
+     *
+     * <p>You must hold the {@link android.Manifest.permission#BROADCAST_STICKY}
+     * permission in order to use this API.  If you do not hold that
+     * permission, {@link SecurityException} will be thrown.
+     *
+     * @deprecated Sticky broadcasts should not be used.  They provide no security (anyone
+     * can access them), no protection (anyone can modify them), and many other problems.
+     * The recommended pattern is to use a non-sticky broadcast to report that <em>something</em>
+     * has changed, with another mechanism for apps to retrieve the current value whenever
+     * desired.
+     *
+     * @param intent The Intent that was previously broadcast.
+     * @param user UserHandle to remove the sticky broadcast from.
+     *
+     * @see #sendStickyBroadcastAsUser
+     */
+    @Deprecated
+    public abstract void removeStickyBroadcastAsUser(Intent intent, UserHandle user);
+
+    /**
+     * Register a BroadcastReceiver to be run in the main activity thread.  The
+     * <var>receiver</var> will be called with any broadcast Intent that
+     * matches <var>filter</var>, in the main application thread.
+     *
+     * <p>The system may broadcast Intents that are "sticky" -- these stay
+     * around after the broadcast as finished, to be sent to any later
+     * registrations. If your IntentFilter matches one of these sticky
+     * Intents, that Intent will be returned by this function
+     * <strong>and</strong> sent to your <var>receiver</var> as if it had just
+     * been broadcast.
+     *
+     * <p>There may be multiple sticky Intents that match <var>filter</var>,
+     * in which case each of these will be sent to <var>receiver</var>.  In
+     * this case, only one of these can be returned directly by the function;
+     * which of these that is returned is arbitrarily decided by the system.
+     *
+     * <p>If you know the Intent your are registering for is sticky, you can
+     * supply null for your <var>receiver</var>.  In this case, no receiver is
+     * registered -- the function simply returns the sticky Intent that
+     * matches <var>filter</var>.  In the case of multiple matches, the same
+     * rules as described above apply.
+     *
+     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
+     *
+     * <p>As of {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH}, receivers
+     * registered with this method will correctly respect the
+     * {@link Intent#setPackage(String)} specified for an Intent being broadcast.
+     * Prior to that, it would be ignored and delivered to all matching registered
+     * receivers.  Be careful if using this for security.</p>
+     *
+     * <p class="note">Note: this method <em>cannot be called from a
+     * {@link BroadcastReceiver} component;</em> that is, from a BroadcastReceiver
+     * that is declared in an application's manifest.  It is okay, however, to call
+     * this method from another BroadcastReceiver that has itself been registered
+     * at run time with {@link #registerReceiver}, since the lifetime of such a
+     * registered BroadcastReceiver is tied to the object that registered it.</p>
+     *
+     * @param receiver The BroadcastReceiver to handle the broadcast.
+     * @param filter Selects the Intent broadcasts to be received.
+     *
+     * @return The first sticky intent found that matches <var>filter</var>,
+     *         or null if there are none.
+     *
+     * @see #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)
+     * @see #sendBroadcast
+     * @see #unregisterReceiver
+     */
+    @Nullable
+    public abstract Intent registerReceiver(@Nullable BroadcastReceiver receiver,
+                                            IntentFilter filter);
+
+    /**
+     * Register to receive intent broadcasts, to run in the context of
+     * <var>scheduler</var>.  See
+     * {@link #registerReceiver(BroadcastReceiver, IntentFilter)} for more
+     * information.  This allows you to enforce permissions on who can
+     * broadcast intents to your receiver, or have the receiver run in
+     * a different thread than the main application thread.
+     *
+     * <p>See {@link BroadcastReceiver} for more information on Intent broadcasts.
+     *
+     * <p>As of {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH}, receivers
+     * registered with this method will correctly respect the
+     * {@link Intent#setPackage(String)} specified for an Intent being broadcast.
+     * Prior to that, it would be ignored and delivered to all matching registered
+     * receivers.  Be careful if using this for security.</p>
+     *
+     * @param receiver The BroadcastReceiver to handle the broadcast.
+     * @param filter Selects the Intent broadcasts to be received.
+     * @param broadcastPermission String naming a permissions that a
+     *      broadcaster must hold in order to send an Intent to you.  If null,
+     *      no permission is required.
+     * @param scheduler Handler identifying the thread that will receive
+     *      the Intent.  If null, the main thread of the process will be used.
+     *
+     * @return The first sticky intent found that matches <var>filter</var>,
+     *         or null if there are none.
+     *
+     * @see #registerReceiver(BroadcastReceiver, IntentFilter)
+     * @see #sendBroadcast
+     * @see #unregisterReceiver
+     */
+    @Nullable
+    public abstract Intent registerReceiver(BroadcastReceiver receiver,
+            IntentFilter filter, @Nullable String broadcastPermission,
+            @Nullable Handler scheduler);
+
+    /**
+     * @hide
+     * Same as {@link #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)
+     * but for a specific user.  This receiver will receiver broadcasts that
+     * are sent to the requested user.  It
+     * requires holding the {@link android.Manifest.permission#INTERACT_ACROSS_USERS_FULL}
+     * permission.
+     *
+     * @param receiver The BroadcastReceiver to handle the broadcast.
+     * @param user UserHandle to send the intent to.
+     * @param filter Selects the Intent broadcasts to be received.
+     * @param broadcastPermission String naming a permissions that a
+     *      broadcaster must hold in order to send an Intent to you.  If null,
+     *      no permission is required.
+     * @param scheduler Handler identifying the thread that will receive
+     *      the Intent.  If null, the main thread of the process will be used.
+     *
+     * @return The first sticky intent found that matches <var>filter</var>,
+     *         or null if there are none.
+     *
+     * @see #registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)
+     * @see #sendBroadcast
+     * @see #unregisterReceiver
+     */
+    @Nullable
+    public abstract Intent registerReceiverAsUser(BroadcastReceiver receiver,
+            UserHandle user, IntentFilter filter, @Nullable String broadcastPermission,
+            @Nullable Handler scheduler);
+
+    /**
+     * Unregister a previously registered BroadcastReceiver.  <em>All</em>
+     * filters that have been registered for this BroadcastReceiver will be
+     * removed.
+     *
+     * @param receiver The BroadcastReceiver to unregister.
+     *
+     * @see #registerReceiver
+     */
+    public abstract void unregisterReceiver(BroadcastReceiver receiver);
+
+    /**
+     * Request that a given application service be started.  The Intent
+     * should contain either contain the complete class name of a specific service
+     * implementation to start or a specific package name to target.  If the
+     * Intent is less specified, it log a warning about this and which of the
+     * multiple matching services it finds and uses will be undefined.  If this service
+     * is not already running, it will be instantiated and started (creating a
+     * process for it if needed); if it is running then it remains running.
+     *
+     * <p>Every call to this method will result in a corresponding call to
+     * the target service's {@link android.app.Service#onStartCommand} method,
+     * with the <var>intent</var> given here.  This provides a convenient way
+     * to submit jobs to a service without having to bind and call on to its
+     * interface.
+     *
+     * <p>Using startService() overrides the default service lifetime that is
+     * managed by {@link #bindService}: it requires the service to remain
+     * running until {@link #stopService} is called, regardless of whether
+     * any clients are connected to it.  Note that calls to startService()
+     * are not nesting: no matter how many times you call startService(),
+     * a single call to {@link #stopService} will stop it.
+     *
+     * <p>The system attempts to keep running services around as much as
+     * possible.  The only time they should be stopped is if the current
+     * foreground application is using so many resources that the service needs
+     * to be killed.  If any errors happen in the service's process, it will
+     * automatically be restarted.
+     *
+     * <p>This function will throw {@link SecurityException} if you do not
+     * have permission to start the given service.
+     *
+     * @param service Identifies the service to be started.  The Intent must be either
+     *      fully explicit (supplying a component name) or specify a specific package
+     *      name it is targetted to.  Additional values
+     *      may be included in the Intent extras to supply arguments along with
+     *      this specific start call.
+     *
+     * @return If the service is being started or is already running, the
+     * {@link ComponentName} of the actual service that was started is
+     * returned; else if the service does not exist null is returned.
+     *
+     * @throws SecurityException &nbsp;
+     *
+     * @see #stopService
+     * @see #bindService
+     */
+    @Nullable
+    public abstract ComponentName startService(Intent service);
+
+    /**
+     * Request that a given application service be stopped.  If the service is
+     * not running, nothing happens.  Otherwise it is stopped.  Note that calls
+     * to startService() are not counted -- this stops the service no matter
+     * how many times it was started.
+     *
+     * <p>Note that if a stopped service still has {@link ServiceConnection}
+     * objects bound to it with the {@link #BIND_AUTO_CREATE} set, it will
+     * not be destroyed until all of these bindings are removed.  See
+     * the {@link android.app.Service} documentation for more details on a
+     * service's lifecycle.
+     *
+     * <p>This function will throw {@link SecurityException} if you do not
+     * have permission to stop the given service.
+     *
+     * @param service Description of the service to be stopped.  The Intent must be either
+     *      fully explicit (supplying a component name) or specify a specific package
+     *      name it is targetted to.
+     *
+     * @return If there is a service matching the given Intent that is already
+     * running, then it is stopped and {@code true} is returned; else {@code false} is returned.
+     *
+     * @throws SecurityException &nbsp;
+     *
+     * @see #startService
+     */
+    public abstract boolean stopService(Intent service);
+
+    /**
+     * @hide like {@link #startService(Intent)} but for a specific user.
+     */
+    public abstract ComponentName startServiceAsUser(Intent service, UserHandle user);
+
+    /**
+     * @hide like {@link #stopService(Intent)} but for a specific user.
+     */
+    public abstract boolean stopServiceAsUser(Intent service, UserHandle user);
+
+    /**
+     * Connect to an application service, creating it if needed.  This defines
+     * a dependency between your application and the service.  The given
+     * <var>conn</var> will receive the service object when it is created and be
+     * told if it dies and restarts.  The service will be considered required
+     * by the system only for as long as the calling context exists.  For
+     * example, if this Context is an Activity that is stopped, the service will
+     * not be required to continue running until the Activity is resumed.
+     *
+     * <p>This function will throw {@link SecurityException} if you do not
+     * have permission to bind to the given service.
+     *
+     * <p class="note">Note: this method <em>can not be called from a
+     * {@link BroadcastReceiver} component</em>.  A pattern you can use to
+     * communicate from a BroadcastReceiver to a Service is to call
+     * {@link #startService} with the arguments containing the command to be
+     * sent, with the service calling its
+     * {@link android.app.Service#stopSelf(int)} method when done executing
+     * that command.  See the API demo App/Service/Service Start Arguments
+     * Controller for an illustration of this.  It is okay, however, to use
+     * this method from a BroadcastReceiver that has been registered with
+     * {@link #registerReceiver}, since the lifetime of this BroadcastReceiver
+     * is tied to another object (the one that registered it).</p>
+     *
+     * @param service Identifies the service to connect to.  The Intent may
+     *      specify either an explicit component name, or a logical
+     *      description (action, category, etc) to match an
+     *      {@link IntentFilter} published by a service.
+     * @param conn Receives information as the service is started and stopped.
+     *      This must be a valid ServiceConnection object; it must not be null.
+     * @param flags Operation options for the binding.  May be 0,
+     *          {@link #BIND_AUTO_CREATE}, {@link #BIND_DEBUG_UNBIND},
+     *          {@link #BIND_NOT_FOREGROUND}, {@link #BIND_ABOVE_CLIENT},
+     *          {@link #BIND_ALLOW_OOM_MANAGEMENT}, or
+     *          {@link #BIND_WAIVE_PRIORITY}.
+     * @return If you have successfully bound to the service, {@code true} is returned;
+     *         {@code false} is returned if the connection is not made so you will not
+     *         receive the service object.
+     *
+     * @throws SecurityException &nbsp;
+     *
+     * @see #unbindService
+     * @see #startService
+     * @see #BIND_AUTO_CREATE
+     * @see #BIND_DEBUG_UNBIND
+     * @see #BIND_NOT_FOREGROUND
+     */
+    public abstract boolean bindService(Intent service, @NonNull ServiceConnection conn,
+            @BindServiceFlags int flags);
+
+    /**
+     * Same as {@link #bindService(Intent, ServiceConnection, int)}, but with an explicit userHandle
+     * argument for use by system server and other multi-user aware code.
+     * @hide
+     */
+    @SystemApi
+    @SuppressWarnings("unused")
+    public boolean bindServiceAsUser(Intent service, ServiceConnection conn,
+            int flags, UserHandle user) {
+        throw new RuntimeException("Not implemented. Must override in a subclass.");
+    }
+
+    /**
+     * Disconnect from an application service.  You will no longer receive
+     * calls as the service is restarted, and the service is now allowed to
+     * stop at any time.
+     *
+     * @param conn The connection interface previously supplied to
+     *             bindService().  This parameter must not be null.
+     *
+     * @see #bindService
+     */
+    public abstract void unbindService(@NonNull ServiceConnection conn);
+
+    /**
+     * Start executing an {@link android.app.Instrumentation} class.  The given
+     * Instrumentation component will be run by killing its target application
+     * (if currently running), starting the target process, instantiating the
+     * instrumentation component, and then letting it drive the application.
+     *
+     * <p>This function is not synchronous -- it returns as soon as the
+     * instrumentation has started and while it is running.
+     *
+     * <p>Instrumentation is normally only allowed to run against a package
+     * that is either unsigned or signed with a signature that the
+     * the instrumentation package is also signed with (ensuring the target
+     * trusts the instrumentation).
+     *
+     * @param className Name of the Instrumentation component to be run.
+     * @param profileFile Optional path to write profiling data as the
+     * instrumentation runs, or null for no profiling.
+     * @param arguments Additional optional arguments to pass to the
+     * instrumentation, or null.
+     *
+     * @return {@code true} if the instrumentation was successfully started,
+     * else {@code false} if it could not be found.
+     */
+    public abstract boolean startInstrumentation(@NonNull ComponentName className,
+            @Nullable String profileFile, @Nullable Bundle arguments);
+
+    /** @hide */
+    @StringDef({
+            POWER_SERVICE,
+            WINDOW_SERVICE,
+            LAYOUT_INFLATER_SERVICE,
+            ACCOUNT_SERVICE,
+            ACTIVITY_SERVICE,
+            ALARM_SERVICE,
+            NOTIFICATION_SERVICE,
+            ACCESSIBILITY_SERVICE,
+            CAPTIONING_SERVICE,
+            KEYGUARD_SERVICE,
+            LOCATION_SERVICE,
+            //@hide: COUNTRY_DETECTOR,
+            SEARCH_SERVICE,
+            SENSOR_SERVICE,
+            STORAGE_SERVICE,
+            WALLPAPER_SERVICE,
+            VIBRATOR_SERVICE,
+            //@hide: STATUS_BAR_SERVICE,
+            CONNECTIVITY_SERVICE,
+            //@hide: UPDATE_LOCK_SERVICE,
+            //@hide: NETWORKMANAGEMENT_SERVICE,
+            NETWORK_STATS_SERVICE,
+            //@hide: NETWORK_POLICY_SERVICE,
+            WIFI_SERVICE,
+            WIFI_PASSPOINT_SERVICE,
+            WIFI_P2P_SERVICE,
+            WIFI_SCANNING_SERVICE,
+            //@hide: WIFI_RTT_SERVICE,
+            //@hide: ETHERNET_SERVICE,
+            WIFI_RTT_SERVICE,
+            NSD_SERVICE,
+            AUDIO_SERVICE,
+            FINGERPRINT_SERVICE,
+            MEDIA_ROUTER_SERVICE,
+            TELEPHONY_SERVICE,
+            TELEPHONY_SUBSCRIPTION_SERVICE,
+            CARRIER_CONFIG_SERVICE,
+            TELECOM_SERVICE,
+            CLIPBOARD_SERVICE,
+            INPUT_METHOD_SERVICE,
+            TEXT_SERVICES_MANAGER_SERVICE,
+            APPWIDGET_SERVICE,
+            //@hide: VOICE_INTERACTION_MANAGER_SERVICE,
+            //@hide: BACKUP_SERVICE,
+            DROPBOX_SERVICE,
+            //@hide: DEVICE_IDLE_CONTROLLER,
+            DEVICE_POLICY_SERVICE,
+            UI_MODE_SERVICE,
+            DOWNLOAD_SERVICE,
+            NFC_SERVICE,
+            BLUETOOTH_SERVICE,
+            //@hide: SIP_SERVICE,
+            USB_SERVICE,
+            LAUNCHER_APPS_SERVICE,
+            //@hide: SERIAL_SERVICE,
+            //@hide: HDMI_CONTROL_SERVICE,
+            INPUT_SERVICE,
+            DISPLAY_SERVICE,
+            USER_SERVICE,
+            RESTRICTIONS_SERVICE,
+            APP_OPS_SERVICE,
+            CAMERA_SERVICE,
+            PRINT_SERVICE,
+            CONSUMER_IR_SERVICE,
+            //@hide: TRUST_SERVICE,
+            TV_INPUT_SERVICE,
+            //@hide: NETWORK_SCORE_SERVICE,
+            USAGE_STATS_SERVICE,
+            MEDIA_SESSION_SERVICE,
+            BATTERY_SERVICE,
+            JOB_SCHEDULER_SERVICE,
+            //@hide: PERSISTENT_DATA_BLOCK_SERVICE,
+            MEDIA_PROJECTION_SERVICE,
+            MIDI_SERVICE,
+            RADIO_SERVICE,
+    })
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface ServiceName {}
+
+    /**
+     * Return the handle to a system-level service by name. The class of the
+     * returned object varies by the requested name. Currently available names
+     * are:
+     *
+     * <dl>
+     *  <dt> {@link #WINDOW_SERVICE} ("window")
+     *  <dd> The top-level window manager in which you can place custom
+     *  windows.  The returned object is a {@link android.view.WindowManager}.
+     *  <dt> {@link #LAYOUT_INFLATER_SERVICE} ("layout_inflater")
+     *  <dd> A {@link android.view.LayoutInflater} for inflating layout resources
+     *  in this context.
+     *  <dt> {@link #ACTIVITY_SERVICE} ("activity")
+     *  <dd> A {@link android.app.ActivityManager} for interacting with the
+     *  global activity state of the system.
+     *  <dt> {@link #POWER_SERVICE} ("power")
+     *  <dd> A {@link android.os.PowerManager} for controlling power
+     *  management.
+     *  <dt> {@link #ALARM_SERVICE} ("alarm")
+     *  <dd> A {@link android.app.AlarmManager} for receiving intents at the
+     *  time of your choosing.
+     *  <dt> {@link #NOTIFICATION_SERVICE} ("notification")
+     *  <dd> A {@link android.app.NotificationManager} for informing the user
+     *   of background events.
+     *  <dt> {@link #KEYGUARD_SERVICE} ("keyguard")
+     *  <dd> A {@link android.app.KeyguardManager} for controlling keyguard.
+     *  <dt> {@link #LOCATION_SERVICE} ("location")
+     *  <dd> A {@link android.location.LocationManager} for controlling location
+     *   (e.g., GPS) updates.
+     *  <dt> {@link #SEARCH_SERVICE} ("search")
+     *  <dd> A {@link android.app.SearchManager} for handling search.
+     *  <dt> {@link #VIBRATOR_SERVICE} ("vibrator")
+     *  <dd> A {@link android.os.Vibrator} for interacting with the vibrator
+     *  hardware.
+     *  <dt> {@link #CONNECTIVITY_SERVICE} ("connection")
+     *  <dd> A {@link android.net.ConnectivityManager ConnectivityManager} for
+     *  handling management of network connections.
+     *  <dt> {@link #WIFI_SERVICE} ("wifi")
+     *  <dd> A {@link android.net.wifi.WifiManager WifiManager} for management of
+     * Wi-Fi connectivity.
+     *  <dt> {@link #WIFI_P2P_SERVICE} ("wifip2p")
+     *  <dd> A {@link android.net.wifi.p2p.WifiP2pManager WifiP2pManager} for management of
+     * Wi-Fi Direct connectivity.
+     * <dt> {@link #INPUT_METHOD_SERVICE} ("input_method")
+     * <dd> An {@link android.view.inputmethod.InputMethodManager InputMethodManager}
+     * for management of input methods.
+     * <dt> {@link #UI_MODE_SERVICE} ("uimode")
+     * <dd> An {@link android.app.UiModeManager} for controlling UI modes.
+     * <dt> {@link #DOWNLOAD_SERVICE} ("download")
+     * <dd> A {@link android.app.DownloadManager} for requesting HTTP downloads
+     * <dt> {@link #BATTERY_SERVICE} ("batterymanager")
+     * <dd> A {@link android.os.BatteryManager} for managing battery state
+     * <dt> {@link #JOB_SCHEDULER_SERVICE} ("taskmanager")
+     * <dd>  A {@link android.app.job.JobScheduler} for managing scheduled tasks
+     * <dt> {@link #NETWORK_STATS_SERVICE} ("netstats")
+     * <dd> A {@link android.app.usage.NetworkStatsManager NetworkStatsManager} for querying network
+     * usage statistics.
+     * </dl>
+     *
+     * <p>Note:  System services obtained via this API may be closely associated with
+     * the Context in which they are obtained from.  In general, do not share the
+     * service objects between various different contexts (Activities, Applications,
+     * Services, Providers, etc.)
+     *
+     * @param name The name of the desired service.
+     *
+     * @return The service or null if the name does not exist.
+     *
+     * @see #WINDOW_SERVICE
+     * @see android.view.WindowManager
+     * @see #LAYOUT_INFLATER_SERVICE
+     * @see android.view.LayoutInflater
+     * @see #ACTIVITY_SERVICE
+     * @see android.app.ActivityManager
+     * @see #POWER_SERVICE
+     * @see android.os.PowerManager
+     * @see #ALARM_SERVICE
+     * @see android.app.AlarmManager
+     * @see #NOTIFICATION_SERVICE
+     * @see android.app.NotificationManager
+     * @see #KEYGUARD_SERVICE
+     * @see android.app.KeyguardManager
+     * @see #LOCATION_SERVICE
+     * @see android.location.LocationManager
+     * @see #SEARCH_SERVICE
+     * @see android.app.SearchManager
+     * @see #SENSOR_SERVICE
+     * @see android.hardware.SensorManager
+     * @see #STORAGE_SERVICE
+     * @see android.os.storage.StorageManager
+     * @see #VIBRATOR_SERVICE
+     * @see android.os.Vibrator
+     * @see #CONNECTIVITY_SERVICE
+     * @see android.net.ConnectivityManager
+     * @see #WIFI_SERVICE
+     * @see android.net.wifi.WifiManager
+     * @see #AUDIO_SERVICE
+     * @see android.media.AudioManager
+     * @see #MEDIA_ROUTER_SERVICE
+     * @see android.media.MediaRouter
+     * @see #TELEPHONY_SERVICE
+     * @see android.telephony.TelephonyManager
+     * @see #TELEPHONY_SUBSCRIPTION_SERVICE
+     * @see android.telephony.SubscriptionManager
+     * @see #CARRIER_CONFIG_SERVICE
+     * @see android.telephony.CarrierConfigManager
+     * @see #INPUT_METHOD_SERVICE
+     * @see android.view.inputmethod.InputMethodManager
+     * @see #UI_MODE_SERVICE
+     * @see android.app.UiModeManager
+     * @see #DOWNLOAD_SERVICE
+     * @see android.app.DownloadManager
+     * @see #BATTERY_SERVICE
+     * @see android.os.BatteryManager
+     * @see #JOB_SCHEDULER_SERVICE
+     * @see android.app.job.JobScheduler
+     * @see #NETWORK_STATS_SERVICE
+     * @see android.app.usage.NetworkStatsManager
+     */
+    public abstract Object getSystemService(@ServiceName @NonNull String name);
+
+    /**
+     * Return the handle to a system-level service by class.
+     * <p>
+     * Currently available classes are:
+     * {@link android.view.WindowManager}, {@link android.view.LayoutInflater},
+     * {@link android.app.ActivityManager}, {@link android.os.PowerManager},
+     * {@link android.app.AlarmManager}, {@link android.app.NotificationManager},
+     * {@link android.app.KeyguardManager}, {@link android.location.LocationManager},
+     * {@link android.app.SearchManager}, {@link android.os.Vibrator},
+     * {@link android.net.ConnectivityManager},
+     * {@link android.net.wifi.WifiManager},
+     * {@link android.media.AudioManager}, {@link android.media.MediaRouter},
+     * {@link android.telephony.TelephonyManager}, {@link android.telephony.SubscriptionManager},
+     * {@link android.view.inputmethod.InputMethodManager},
+     * {@link android.app.UiModeManager}, {@link android.app.DownloadManager},
+     * {@link android.os.BatteryManager}, {@link android.app.job.JobScheduler},
+     * {@link android.app.usage.NetworkStatsManager}.
+     * </p><p>
+     * Note: System services obtained via this API may be closely associated with
+     * the Context in which they are obtained from.  In general, do not share the
+     * service objects between various different contexts (Activities, Applications,
+     * Services, Providers, etc.)
+     * </p>
+     *
+     * @param serviceClass The class of the desired service.
+     * @return The service or null if the class is not a supported system service.
+     */
+    @SuppressWarnings("unchecked")
+    public final <T> T getSystemService(Class<T> serviceClass) {
+        // Because subclasses may override getSystemService(String) we cannot
+        // perform a lookup by class alone.  We must first map the class to its
+        // service name then invoke the string-based method.
+        String serviceName = getSystemServiceName(serviceClass);
+        return serviceName != null ? (T)getSystemService(serviceName) : null;
+    }
+
+    /**
+     * Gets the name of the system-level service that is represented by the specified class.
+     *
+     * @param serviceClass The class of the desired service.
+     * @return The service name or null if the class is not a supported system service.
+     */
+    public abstract String getSystemServiceName(Class<?> serviceClass);
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.os.PowerManager} for controlling power management,
+     * including "wake locks," which let you keep the device on while
+     * you're running long tasks.
+     */
+    public static final String POWER_SERVICE = "power";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.view.WindowManager} for accessing the system's window
+     * manager.
+     *
+     * @see #getSystemService
+     * @see android.view.WindowManager
+     */
+    public static final String WINDOW_SERVICE = "window";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.view.LayoutInflater} for inflating layout resources in this
+     * context.
+     *
+     * @see #getSystemService
+     * @see android.view.LayoutInflater
+     */
+    public static final String LAYOUT_INFLATER_SERVICE = "layout_inflater";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.accounts.AccountManager} for receiving intents at a
+     * time of your choosing.
+     *
+     * @see #getSystemService
+     * @see android.accounts.AccountManager
+     */
+    public static final String ACCOUNT_SERVICE = "account";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.app.ActivityManager} for interacting with the global
+     * system state.
+     *
+     * @see #getSystemService
+     * @see android.app.ActivityManager
+     */
+    public static final String ACTIVITY_SERVICE = "activity";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.app.AlarmManager} for receiving intents at a
+     * time of your choosing.
+     *
+     * @see #getSystemService
+     * @see android.app.AlarmManager
+     */
+    public static final String ALARM_SERVICE = "alarm";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.app.NotificationManager} for informing the user of
+     * background events.
+     *
+     * @see #getSystemService
+     * @see android.app.NotificationManager
+     */
+    public static final String NOTIFICATION_SERVICE = "notification";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.view.accessibility.AccessibilityManager} for giving the user
+     * feedback for UI events through the registered event listeners.
+     *
+     * @see #getSystemService
+     * @see android.view.accessibility.AccessibilityManager
+     */
+    public static final String ACCESSIBILITY_SERVICE = "accessibility";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.view.accessibility.CaptioningManager} for obtaining
+     * captioning properties and listening for changes in captioning
+     * preferences.
+     *
+     * @see #getSystemService
+     * @see android.view.accessibility.CaptioningManager
+     */
+    public static final String CAPTIONING_SERVICE = "captioning";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.app.NotificationManager} for controlling keyguard.
+     *
+     * @see #getSystemService
+     * @see android.app.KeyguardManager
+     */
+    public static final String KEYGUARD_SERVICE = "keyguard";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.location.LocationManager} for controlling location
+     * updates.
+     *
+     * @see #getSystemService
+     * @see android.location.LocationManager
+     */
+    public static final String LOCATION_SERVICE = "location";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.location.CountryDetector} for detecting the country that
+     * the user is in.
+     *
+     * @hide
+     */
+    public static final String COUNTRY_DETECTOR = "country_detector";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.app.SearchManager} for handling searches.
+     *
+     * @see #getSystemService
+     * @see android.app.SearchManager
+     */
+    public static final String SEARCH_SERVICE = "search";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.hardware.SensorManager} for accessing sensors.
+     *
+     * @see #getSystemService
+     * @see android.hardware.SensorManager
+     */
+    public static final String SENSOR_SERVICE = "sensor";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.os.storage.StorageManager} for accessing system storage
+     * functions.
+     *
+     * @see #getSystemService
+     * @see android.os.storage.StorageManager
+     */
+    public static final String STORAGE_SERVICE = "storage";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * com.android.server.WallpaperService for accessing wallpapers.
+     *
+     * @see #getSystemService
+     */
+    public static final String WALLPAPER_SERVICE = "wallpaper";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.os.Vibrator} for interacting with the vibration hardware.
+     *
+     * @see #getSystemService
+     * @see android.os.Vibrator
+     */
+    public static final String VIBRATOR_SERVICE = "vibrator";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.app.StatusBarManager} for interacting with the status bar.
+     *
+     * @see #getSystemService
+     * @see android.app.StatusBarManager
+     * @hide
+     */
+    public static final String STATUS_BAR_SERVICE = "statusbar";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.net.ConnectivityManager} for handling management of
+     * network connections.
+     *
+     * @see #getSystemService
+     * @see android.net.ConnectivityManager
+     */
+    public static final String CONNECTIVITY_SERVICE = "connectivity";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.os.IUpdateLock} for managing runtime sequences that
+     * must not be interrupted by headless OTA application or similar.
+     *
+     * @hide
+     * @see #getSystemService
+     * @see android.os.UpdateLock
+     */
+    public static final String UPDATE_LOCK_SERVICE = "updatelock";
+
+    /**
+     * Constant for the internal network management service, not really a Context service.
+     * @hide
+     */
+    public static final String NETWORKMANAGEMENT_SERVICE = "network_management";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.app.usage.NetworkStatsManager} for querying network usage stats.
+     *
+     * @see #getSystemService
+     * @see android.app.usage.NetworkStatsManager
+     */
+    public static final String NETWORK_STATS_SERVICE = "netstats";
+    /** {@hide} */
+    public static final String NETWORK_POLICY_SERVICE = "netpolicy";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.net.wifi.WifiManager} for handling management of
+     * Wi-Fi access.
+     *
+     * @see #getSystemService
+     * @see android.net.wifi.WifiManager
+     */
+    public static final String WIFI_SERVICE = "wifi";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.net.wifi.passpoint.WifiPasspointManager} for handling management of
+     * Wi-Fi passpoint access.
+     *
+     * @see #getSystemService
+     * @see android.net.wifi.passpoint.WifiPasspointManager
+     * @hide
+     */
+    public static final String WIFI_PASSPOINT_SERVICE = "wifipasspoint";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.net.wifi.p2p.WifiP2pManager} for handling management of
+     * Wi-Fi peer-to-peer connections.
+     *
+     * @see #getSystemService
+     * @see android.net.wifi.p2p.WifiP2pManager
+     */
+    public static final String WIFI_P2P_SERVICE = "wifip2p";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.net.wifi.WifiScanner} for scanning the wifi universe
+     *
+     * @see #getSystemService
+     * @see android.net.wifi.WifiScanner
+     * @hide
+     */
+    @SystemApi
+    public static final String WIFI_SCANNING_SERVICE = "wifiscanner";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.net.wifi.RttManager} for ranging devices with wifi
+     *
+     * @see #getSystemService
+     * @see android.net.wifi.RttManager
+     * @hide
+     */
+    @SystemApi
+    public static final String WIFI_RTT_SERVICE = "rttmanager";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.net.EthernetManager} for handling management of
+     * Ethernet access.
+     *
+     * @see #getSystemService
+     * @see android.net.EthernetManager
+     *
+     * @hide
+     */
+    public static final String ETHERNET_SERVICE = "ethernet";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.net.nsd.NsdManager} for handling management of network service
+     * discovery
+     *
+     * @see #getSystemService
+     * @see android.net.nsd.NsdManager
+     */
+    public static final String NSD_SERVICE = "servicediscovery";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.media.AudioManager} for handling management of volume,
+     * ringer modes and audio routing.
+     *
+     * @see #getSystemService
+     * @see android.media.AudioManager
+     */
+    public static final String AUDIO_SERVICE = "audio";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.hardware.fingerprint.FingerprintManager} for handling management
+     * of fingerprints.
+     *
+     * @see #getSystemService
+     * @see android.hardware.fingerprint.FingerprintManager
+     */
+    public static final String FINGERPRINT_SERVICE = "fingerprint";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.media.MediaRouter} for controlling and managing
+     * routing of media.
+     *
+     * @see #getSystemService
+     * @see android.media.MediaRouter
+     */
+    public static final String MEDIA_ROUTER_SERVICE = "media_router";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.media.session.MediaSessionManager} for managing media Sessions.
+     *
+     * @see #getSystemService
+     * @see android.media.session.MediaSessionManager
+     */
+    public static final String MEDIA_SESSION_SERVICE = "media_session";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.telephony.TelephonyManager} for handling management the
+     * telephony features of the device.
+     *
+     * @see #getSystemService
+     * @see android.telephony.TelephonyManager
+     */
+    public static final String TELEPHONY_SERVICE = "phone";
+
+// MTK
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.telephony.TelephonyManagerEx} for handling management the
+     * telephony features of the device.
+     *
+     * @see #getSystemService
+     * @see android.telephony.TelephonyManagerEx
+     * @hide
+     * @internal
+     */
+    public static final String TELEPHONY_SERVICE_EX = "phoneEx";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.telephony.SubscriptionManager} for handling management the
+     * telephony subscriptions of the device.
+     *
+     * @see #getSystemService
+     * @see android.telephony.SubscriptionManager
+     */
+    public static final String TELEPHONY_SUBSCRIPTION_SERVICE = "telephony_subscription_service";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.telecom.TelecomManager} to manage telecom-related features
+     * of the device.
+     *
+     * @see #getSystemService
+     * @see android.telecom.TelecomManager
+     */
+    public static final String TELECOM_SERVICE = "telecom";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.telephony.CarrierConfigManager} for reading carrier configuration values.
+     *
+     * @see #getSystemService
+     * @see android.telephony.CarrierConfigManager
+     */
+    public static final String CARRIER_CONFIG_SERVICE = "carrier_config";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.text.ClipboardManager} for accessing and modifying
+     * {@link android.content.ClipboardManager} for accessing and modifying
+     * the contents of the global clipboard.
+     *
+     * @see #getSystemService
+     * @see android.content.ClipboardManager
+     */
+    public static final String CLIPBOARD_SERVICE = "clipboard";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.view.inputmethod.InputMethodManager} for accessing input
+     * methods.
+     *
+     * @see #getSystemService
+     */
+    public static final String INPUT_METHOD_SERVICE = "input_method";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.view.textservice.TextServicesManager} for accessing
+     * text services.
+     *
+     * @see #getSystemService
+     */
+    public static final String TEXT_SERVICES_MANAGER_SERVICE = "textservices";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.appwidget.AppWidgetManager} for accessing AppWidgets.
+     *
+     * @see #getSystemService
+     */
+    public static final String APPWIDGET_SERVICE = "appwidget";
+
+    /**
+     * Official published name of the (internal) voice interaction manager service.
+     *
+     * @hide
+     * @see #getSystemService
+     */
+    public static final String VOICE_INTERACTION_MANAGER_SERVICE = "voiceinteraction";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve an
+     * {@link android.app.backup.IBackupManager IBackupManager} for communicating
+     * with the backup mechanism.
+     * @hide
+     *
+     * @see #getSystemService
+     */
+    @SystemApi
+    public static final String BACKUP_SERVICE = "backup";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.os.DropBoxManager} instance for recording
+     * diagnostic logs.
+     * @see #getSystemService
+     */
+    public static final String DROPBOX_SERVICE = "dropbox";
+
+    /**
+     * System service name for the DeviceIdleController.  There is no Java API for this.
+     * @see #getSystemService
+     * @hide
+     */
+    public static final String DEVICE_IDLE_CONTROLLER = "deviceidle";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.app.admin.DevicePolicyManager} for working with global
+     * device policy management.
+     *
+     * @see #getSystemService
+     */
+    public static final String DEVICE_POLICY_SERVICE = "device_policy";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.app.UiModeManager} for controlling UI modes.
+     *
+     * @see #getSystemService
+     */
+    public static final String UI_MODE_SERVICE = "uimode";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.app.DownloadManager} for requesting HTTP downloads.
+     *
+     * @see #getSystemService
+     */
+    public static final String DOWNLOAD_SERVICE = "download";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.os.BatteryManager} for managing battery state.
+     *
+     * @see #getSystemService
+     */
+    public static final String BATTERY_SERVICE = "batterymanager";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.nfc.NfcManager} for using NFC.
+     *
+     * @see #getSystemService
+     */
+    public static final String NFC_SERVICE = "nfc";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.bluetooth.BluetoothManager} for using Bluetooth.
+     *
+     * @see #getSystemService
+     */
+    public static final String BLUETOOTH_SERVICE = "bluetooth";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.net.sip.SipManager} for accessing the SIP related service.
+     *
+     * @see #getSystemService
+     */
+    /** @hide */
+    public static final String SIP_SERVICE = "sip";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.hardware.usb.UsbManager} for access to USB devices (as a USB host)
+     * and for controlling this device's behavior as a USB device.
+     *
+     * @see #getSystemService
+     * @see android.hardware.usb.UsbManager
+     */
+    public static final String USB_SERVICE = "usb";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.hardware.SerialManager} for access to serial ports.
+     *
+     * @see #getSystemService
+     * @see android.hardware.SerialManager
+     *
+     * @hide
+     */
+    public static final String SERIAL_SERVICE = "serial";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.hardware.hdmi.HdmiControlManager} for controlling and managing
+     * HDMI-CEC protocol.
+     *
+     * @see #getSystemService
+     * @see android.hardware.hdmi.HdmiControlManager
+     * @hide
+     */
+    @SystemApi
+    public static final String HDMI_CONTROL_SERVICE = "hdmi_control";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.hardware.input.InputManager} for interacting with input devices.
+     *
+     * @see #getSystemService
+     * @see android.hardware.input.InputManager
+     */
+    public static final String INPUT_SERVICE = "input";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.hardware.display.DisplayManager} for interacting with display devices.
+     *
+     * @see #getSystemService
+     * @see android.hardware.display.DisplayManager
+     */
+    public static final String DISPLAY_SERVICE = "display";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.os.UserManager} for managing users on devices that support multiple users.
+     *
+     * @see #getSystemService
+     * @see android.os.UserManager
+     */
+    public static final String USER_SERVICE = "user";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.content.pm.LauncherApps} for querying and monitoring launchable apps across
+     * profiles of a user.
+     *
+     * @see #getSystemService
+     * @see android.content.pm.LauncherApps
+     */
+    public static final String LAUNCHER_APPS_SERVICE = "launcherapps";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.content.RestrictionsManager} for retrieving application restrictions
+     * and requesting permissions for restricted operations.
+     * @see #getSystemService
+     * @see android.content.RestrictionsManager
+     */
+    public static final String RESTRICTIONS_SERVICE = "restrictions";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.app.AppOpsManager} for tracking application operations
+     * on the device.
+     *
+     * @see #getSystemService
+     * @see android.app.AppOpsManager
+     */
+    public static final String APP_OPS_SERVICE = "appops";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.hardware.camera2.CameraManager} for interacting with
+     * camera devices.
+     *
+     * @see #getSystemService
+     * @see android.hardware.camera2.CameraManager
+     */
+    public static final String CAMERA_SERVICE = "camera";
+
+    /**
+     * {@link android.print.PrintManager} for printing and managing
+     * printers and print tasks.
+     *
+     * @see #getSystemService
+     * @see android.print.PrintManager
+     */
+    public static final String PRINT_SERVICE = "print";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.hardware.ConsumerIrManager} for transmitting infrared
+     * signals from the device.
+     *
+     * @see #getSystemService
+     * @see android.hardware.ConsumerIrManager
+     */
+    public static final String CONSUMER_IR_SERVICE = "consumer_ir";
+
+    /**
+     * {@link android.app.trust.TrustManager} for managing trust agents.
+     * @see #getSystemService
+     * @see android.app.trust.TrustManager
+     * @hide
+     */
+    public static final String TRUST_SERVICE = "trust";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.media.tv.TvInputManager} for interacting with TV inputs
+     * on the device.
+     *
+     * @see #getSystemService
+     * @see android.media.tv.TvInputManager
+     */
+    public static final String TV_INPUT_SERVICE = "tv_input";
+
+    /**
+     * {@link android.net.NetworkScoreManager} for managing network scoring.
+     * @see #getSystemService
+     * @see android.net.NetworkScoreManager
+     * @hide
+     */
+    @SystemApi
+    public static final String NETWORK_SCORE_SERVICE = "network_score";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.app.usage.UsageStatsManager} for querying device usage stats.
+     *
+     * @see #getSystemService
+     * @see android.app.usage.UsageStatsManager
+     */
+    public static final String USAGE_STATS_SERVICE = "usagestats";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.app.job.JobScheduler} instance for managing occasional
+     * background tasks.
+     * @see #getSystemService
+     * @see android.app.job.JobScheduler
+     */
+    public static final String JOB_SCHEDULER_SERVICE = "jobscheduler";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.service.persistentdata.PersistentDataBlockManager} instance
+     * for interacting with a storage device that lives across factory resets.
+     *
+     * @see #getSystemService
+     * @see android.service.persistentdata.PersistentDataBlockManager
+     * @hide
+     */
+    @SystemApi
+    public static final String PERSISTENT_DATA_BLOCK_SERVICE = "persistent_data_block";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.media.projection.MediaProjectionManager} instance for managing
+     * media projection sessions.
+     * @see #getSystemService
+     * @see android.media.projection.MediaProjectionManager
+     */
+    public static final String MEDIA_PROJECTION_SERVICE = "media_projection";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.media.midi.MidiManager} for accessing the MIDI service.
+     *
+     * @see #getSystemService
+     */
+    public static final String MIDI_SERVICE = "midi";
+
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.hardware.radio.RadioManager} for accessing the broadcast radio service.
+     *
+     * @see #getSystemService
+     * @hide
+     */
+    public static final String RADIO_SERVICE = "radio";
+
+    /**
+     * Determine whether the given permission is allowed for a particular
+     * process and user ID running in the system.
+     *
+     * @param permission The name of the permission being checked.
+     * @param pid The process ID being checked against.  Must be > 0.
+     * @param uid The user ID being checked against.  A uid of 0 is the root
+     * user, which will pass every permission check.
+     *
+     * @return {@link PackageManager#PERMISSION_GRANTED} if the given
+     * pid/uid is allowed that permission, or
+     * {@link PackageManager#PERMISSION_DENIED} if it is not.
+     *
+     * @see PackageManager#checkPermission(String, String)
+     * @see #checkCallingPermission
+     */
+    @CheckResult(suggest="#enforcePermission(String,int,int,String)")
+    @PackageManager.PermissionResult
+    public abstract int checkPermission(@NonNull String permission, int pid, int uid);
+
+    /** @hide */
+    @PackageManager.PermissionResult
+    public abstract int checkPermission(@NonNull String permission, int pid, int uid,
+            IBinder callerToken);
+
+    /**
+     * Determine whether the calling process of an IPC you are handling has been
+     * granted a particular permission.  This is basically the same as calling
+     * {@link #checkPermission(String, int, int)} with the pid and uid returned
+     * by {@link android.os.Binder#getCallingPid} and
+     * {@link android.os.Binder#getCallingUid}.  One important difference
+     * is that if you are not currently processing an IPC, this function
+     * will always fail.  This is done to protect against accidentally
+     * leaking permissions; you can use {@link #checkCallingOrSelfPermission}
+     * to avoid this protection.
+     *
+     * @param permission The name of the permission being checked.
+     *
+     * @return {@link PackageManager#PERMISSION_GRANTED} if the calling
+     * pid/uid is allowed that permission, or
+     * {@link PackageManager#PERMISSION_DENIED} if it is not.
+     *
+     * @see PackageManager#checkPermission(String, String)
+     * @see #checkPermission
+     * @see #checkCallingOrSelfPermission
+     */
+    @CheckResult(suggest="#enforceCallingPermission(String,String)")
+    @PackageManager.PermissionResult
+    public abstract int checkCallingPermission(@NonNull String permission);
+
+    /**
+     * Determine whether the calling process of an IPC <em>or you</em> have been
+     * granted a particular permission.  This is the same as
+     * {@link #checkCallingPermission}, except it grants your own permissions
+     * if you are not currently processing an IPC.  Use with care!
+     *
+     * @param permission The name of the permission being checked.
+     *
+     * @return {@link PackageManager#PERMISSION_GRANTED} if the calling
+     * pid/uid is allowed that permission, or
+     * {@link PackageManager#PERMISSION_DENIED} if it is not.
+     *
+     * @see PackageManager#checkPermission(String, String)
+     * @see #checkPermission
+     * @see #checkCallingPermission
+     */
+    @CheckResult(suggest="#enforceCallingOrSelfPermission(String,String)")
+    @PackageManager.PermissionResult
+    public abstract int checkCallingOrSelfPermission(@NonNull String permission);
+
+    /**
+     * Determine whether <em>you</em> have been granted a particular permission.
+     *
+     * @param permission The name of the permission being checked.
+     *
+     * @return {@link PackageManager#PERMISSION_GRANTED} if you have the
+     * permission, or {@link PackageManager#PERMISSION_DENIED} if not.
+     *
+     * @see PackageManager#checkPermission(String, String)
+     * @see #checkCallingPermission(String)
+     */
+    @PackageManager.PermissionResult
+    public abstract int checkSelfPermission(@NonNull String permission);
+
+    /**
+     * If the given permission is not allowed for a particular process
+     * and user ID running in the system, throw a {@link SecurityException}.
+     *
+     * @param permission The name of the permission being checked.
+     * @param pid The process ID being checked against.  Must be &gt; 0.
+     * @param uid The user ID being checked against.  A uid of 0 is the root
+     * user, which will pass every permission check.
+     * @param message A message to include in the exception if it is thrown.
+     *
+     * @see #checkPermission(String, int, int)
+     */
+    public abstract void enforcePermission(
+            @NonNull String permission, int pid, int uid, @Nullable String message);
+
+    /**
+     * If the calling process of an IPC you are handling has not been
+     * granted a particular permission, throw a {@link
+     * SecurityException}.  This is basically the same as calling
+     * {@link #enforcePermission(String, int, int, String)} with the
+     * pid and uid returned by {@link android.os.Binder#getCallingPid}
+     * and {@link android.os.Binder#getCallingUid}.  One important
+     * difference is that if you are not currently processing an IPC,
+     * this function will always throw the SecurityException.  This is
+     * done to protect against accidentally leaking permissions; you
+     * can use {@link #enforceCallingOrSelfPermission} to avoid this
+     * protection.
+     *
+     * @param permission The name of the permission being checked.
+     * @param message A message to include in the exception if it is thrown.
+     *
+     * @see #checkCallingPermission(String)
+     */
+    public abstract void enforceCallingPermission(
+            @NonNull String permission, @Nullable String message);
+
+    /**
+     * If neither you nor the calling process of an IPC you are
+     * handling has been granted a particular permission, throw a
+     * {@link SecurityException}.  This is the same as {@link
+     * #enforceCallingPermission}, except it grants your own
+     * permissions if you are not currently processing an IPC.  Use
+     * with care!
+     *
+     * @param permission The name of the permission being checked.
+     * @param message A message to include in the exception if it is thrown.
+     *
+     * @see #checkCallingOrSelfPermission(String)
+     */
+    public abstract void enforceCallingOrSelfPermission(
+            @NonNull String permission, @Nullable String message);
+
+    /**
+     * Grant permission to access a specific Uri to another package, regardless
+     * of whether that package has general permission to access the Uri's
+     * content provider.  This can be used to grant specific, temporary
+     * permissions, typically in response to user interaction (such as the
+     * user opening an attachment that you would like someone else to
+     * display).
+     *
+     * <p>Normally you should use {@link Intent#FLAG_GRANT_READ_URI_PERMISSION
+     * Intent.FLAG_GRANT_READ_URI_PERMISSION} or
+     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION
+     * Intent.FLAG_GRANT_WRITE_URI_PERMISSION} with the Intent being used to
+     * start an activity instead of this function directly.  If you use this
+     * function directly, you should be sure to call
+     * {@link #revokeUriPermission} when the target should no longer be allowed
+     * to access it.
+     *
+     * <p>To succeed, the content provider owning the Uri must have set the
+     * {@link android.R.styleable#AndroidManifestProvider_grantUriPermissions
+     * grantUriPermissions} attribute in its manifest or included the
+     * {@link android.R.styleable#AndroidManifestGrantUriPermission
+     * &lt;grant-uri-permissions&gt;} tag.
+     *
+     * @param toPackage The package you would like to allow to access the Uri.
+     * @param uri The Uri you would like to grant access to.
+     * @param modeFlags The desired access modes.  Any combination of
+     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION
+     * Intent.FLAG_GRANT_READ_URI_PERMISSION},
+     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION
+     * Intent.FLAG_GRANT_WRITE_URI_PERMISSION},
+     * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION
+     * Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION}, or
+     * {@link Intent#FLAG_GRANT_PREFIX_URI_PERMISSION
+     * Intent.FLAG_GRANT_PREFIX_URI_PERMISSION}.
+     *
+     * @see #revokeUriPermission
+     */
+    public abstract void grantUriPermission(String toPackage, Uri uri,
+            @Intent.GrantUriMode int modeFlags);
+
+    /**
+     * Remove all permissions to access a particular content provider Uri
+     * that were previously added with {@link #grantUriPermission}.  The given
+     * Uri will match all previously granted Uris that are the same or a
+     * sub-path of the given Uri.  That is, revoking "content://foo/target" will
+     * revoke both "content://foo/target" and "content://foo/target/sub", but not
+     * "content://foo".  It will not remove any prefix grants that exist at a
+     * higher level.
+     *
+     * <p>Prior to {@link android.os.Build.VERSION_CODES#LOLLIPOP}, if you did not have
+     * regular permission access to a Uri, but had received access to it through
+     * a specific Uri permission grant, you could not revoke that grant with this
+     * function and a {@link SecurityException} would be thrown.  As of
+     * {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this function will not throw a security exception,
+     * but will remove whatever permission grants to the Uri had been given to the app
+     * (or none).</p>
+     *
+     * @param uri The Uri you would like to revoke access to.
+     * @param modeFlags The desired access modes.  Any combination of
+     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION
+     * Intent.FLAG_GRANT_READ_URI_PERMISSION} or
+     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION
+     * Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
+     *
+     * @see #grantUriPermission
+     */
+    public abstract void revokeUriPermission(Uri uri, @Intent.AccessUriMode int modeFlags);
+
+    /**
+     * Determine whether a particular process and user ID has been granted
+     * permission to access a specific URI.  This only checks for permissions
+     * that have been explicitly granted -- if the given process/uid has
+     * more general access to the URI's content provider then this check will
+     * always fail.
+     *
+     * @param uri The uri that is being checked.
+     * @param pid The process ID being checked against.  Must be &gt; 0.
+     * @param uid The user ID being checked against.  A uid of 0 is the root
+     * user, which will pass every permission check.
+     * @param modeFlags The type of access to grant.  May be one or both of
+     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
+     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
+     *
+     * @return {@link PackageManager#PERMISSION_GRANTED} if the given
+     * pid/uid is allowed to access that uri, or
+     * {@link PackageManager#PERMISSION_DENIED} if it is not.
+     *
+     * @see #checkCallingUriPermission
+     */
+    @CheckResult(suggest="#enforceUriPermission(Uri,int,int,String)")
+    public abstract int checkUriPermission(Uri uri, int pid, int uid,
+            @Intent.AccessUriMode int modeFlags);
+
+    /** @hide */
+    public abstract int checkUriPermission(Uri uri, int pid, int uid,
+            @Intent.AccessUriMode int modeFlags, IBinder callerToken);
+
+    /**
+     * Determine whether the calling process and user ID has been
+     * granted permission to access a specific URI.  This is basically
+     * the same as calling {@link #checkUriPermission(Uri, int, int,
+     * int)} with the pid and uid returned by {@link
+     * android.os.Binder#getCallingPid} and {@link
+     * android.os.Binder#getCallingUid}.  One important difference is
+     * that if you are not currently processing an IPC, this function
+     * will always fail.
+     *
+     * @param uri The uri that is being checked.
+     * @param modeFlags The type of access to grant.  May be one or both of
+     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
+     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
+     *
+     * @return {@link PackageManager#PERMISSION_GRANTED} if the caller
+     * is allowed to access that uri, or
+     * {@link PackageManager#PERMISSION_DENIED} if it is not.
+     *
+     * @see #checkUriPermission(Uri, int, int, int)
+     */
+    @CheckResult(suggest="#enforceCallingUriPermission(Uri,int,String)")
+    public abstract int checkCallingUriPermission(Uri uri, @Intent.AccessUriMode int modeFlags);
+
+    /**
+     * Determine whether the calling process of an IPC <em>or you</em> has been granted
+     * permission to access a specific URI.  This is the same as
+     * {@link #checkCallingUriPermission}, except it grants your own permissions
+     * if you are not currently processing an IPC.  Use with care!
+     *
+     * @param uri The uri that is being checked.
+     * @param modeFlags The type of access to grant.  May be one or both of
+     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
+     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
+     *
+     * @return {@link PackageManager#PERMISSION_GRANTED} if the caller
+     * is allowed to access that uri, or
+     * {@link PackageManager#PERMISSION_DENIED} if it is not.
+     *
+     * @see #checkCallingUriPermission
+     */
+    @CheckResult(suggest="#enforceCallingOrSelfUriPermission(Uri,int,String)")
+    public abstract int checkCallingOrSelfUriPermission(Uri uri,
+            @Intent.AccessUriMode int modeFlags);
+
+    /**
+     * Check both a Uri and normal permission.  This allows you to perform
+     * both {@link #checkPermission} and {@link #checkUriPermission} in one
+     * call.
+     *
+     * @param uri The Uri whose permission is to be checked, or null to not
+     * do this check.
+     * @param readPermission The permission that provides overall read access,
+     * or null to not do this check.
+     * @param writePermission The permission that provides overall write
+     * access, or null to not do this check.
+     * @param pid The process ID being checked against.  Must be &gt; 0.
+     * @param uid The user ID being checked against.  A uid of 0 is the root
+     * user, which will pass every permission check.
+     * @param modeFlags The type of access to grant.  May be one or both of
+     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
+     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
+     *
+     * @return {@link PackageManager#PERMISSION_GRANTED} if the caller
+     * is allowed to access that uri or holds one of the given permissions, or
+     * {@link PackageManager#PERMISSION_DENIED} if it is not.
+     */
+    @CheckResult(suggest="#enforceUriPermission(Uri,String,String,int,int,int,String)")
+    public abstract int checkUriPermission(@Nullable Uri uri, @Nullable String readPermission,
+            @Nullable String writePermission, int pid, int uid,
+            @Intent.AccessUriMode int modeFlags);
+
+    /**
+     * If a particular process and user ID has not been granted
+     * permission to access a specific URI, throw {@link
+     * SecurityException}.  This only checks for permissions that have
+     * been explicitly granted -- if the given process/uid has more
+     * general access to the URI's content provider then this check
+     * will always fail.
+     *
+     * @param uri The uri that is being checked.
+     * @param pid The process ID being checked against.  Must be &gt; 0.
+     * @param uid The user ID being checked against.  A uid of 0 is the root
+     * user, which will pass every permission check.
+     * @param modeFlags The type of access to grant.  May be one or both of
+     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
+     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
+     * @param message A message to include in the exception if it is thrown.
+     *
+     * @see #checkUriPermission(Uri, int, int, int)
+     */
+    public abstract void enforceUriPermission(
+            Uri uri, int pid, int uid, @Intent.AccessUriMode int modeFlags, String message);
+
+    /**
+     * If the calling process and user ID has not been granted
+     * permission to access a specific URI, throw {@link
+     * SecurityException}.  This is basically the same as calling
+     * {@link #enforceUriPermission(Uri, int, int, int, String)} with
+     * the pid and uid returned by {@link
+     * android.os.Binder#getCallingPid} and {@link
+     * android.os.Binder#getCallingUid}.  One important difference is
+     * that if you are not currently processing an IPC, this function
+     * will always throw a SecurityException.
+     *
+     * @param uri The uri that is being checked.
+     * @param modeFlags The type of access to grant.  May be one or both of
+     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
+     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
+     * @param message A message to include in the exception if it is thrown.
+     *
+     * @see #checkCallingUriPermission(Uri, int)
+     */
+    public abstract void enforceCallingUriPermission(
+            Uri uri, @Intent.AccessUriMode int modeFlags, String message);
+
+    /**
+     * If the calling process of an IPC <em>or you</em> has not been
+     * granted permission to access a specific URI, throw {@link
+     * SecurityException}.  This is the same as {@link
+     * #enforceCallingUriPermission}, except it grants your own
+     * permissions if you are not currently processing an IPC.  Use
+     * with care!
+     *
+     * @param uri The uri that is being checked.
+     * @param modeFlags The type of access to grant.  May be one or both of
+     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
+     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
+     * @param message A message to include in the exception if it is thrown.
+     *
+     * @see #checkCallingOrSelfUriPermission(Uri, int)
+     */
+    public abstract void enforceCallingOrSelfUriPermission(
+            Uri uri, @Intent.AccessUriMode int modeFlags, String message);
+
+    /**
+     * Enforce both a Uri and normal permission.  This allows you to perform
+     * both {@link #enforcePermission} and {@link #enforceUriPermission} in one
+     * call.
+     *
+     * @param uri The Uri whose permission is to be checked, or null to not
+     * do this check.
+     * @param readPermission The permission that provides overall read access,
+     * or null to not do this check.
+     * @param writePermission The permission that provides overall write
+     * access, or null to not do this check.
+     * @param pid The process ID being checked against.  Must be &gt; 0.
+     * @param uid The user ID being checked against.  A uid of 0 is the root
+     * user, which will pass every permission check.
+     * @param modeFlags The type of access to grant.  May be one or both of
+     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION} or
+     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION}.
+     * @param message A message to include in the exception if it is thrown.
+     *
+     * @see #checkUriPermission(Uri, String, String, int, int, int)
+     */
+    public abstract void enforceUriPermission(
+            @Nullable Uri uri, @Nullable String readPermission,
+            @Nullable String writePermission, int pid, int uid, @Intent.AccessUriMode int modeFlags,
+            @Nullable String message);
+
+    /** @hide */
+    @IntDef(flag = true,
+            value = {CONTEXT_INCLUDE_CODE, CONTEXT_IGNORE_SECURITY, CONTEXT_RESTRICTED})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface CreatePackageOptions {}
+
+    /**
+     * Flag for use with {@link #createPackageContext}: include the application
+     * code with the context.  This means loading code into the caller's
+     * process, so that {@link #getClassLoader()} can be used to instantiate
+     * the application's classes.  Setting this flags imposes security
+     * restrictions on what application context you can access; if the
+     * requested application can not be safely loaded into your process,
+     * java.lang.SecurityException will be thrown.  If this flag is not set,
+     * there will be no restrictions on the packages that can be loaded,
+     * but {@link #getClassLoader} will always return the default system
+     * class loader.
+     */
+    public static final int CONTEXT_INCLUDE_CODE = 0x00000001;
+
+    /**
+     * Flag for use with {@link #createPackageContext}: ignore any security
+     * restrictions on the Context being requested, allowing it to always
+     * be loaded.  For use with {@link #CONTEXT_INCLUDE_CODE} to allow code
+     * to be loaded into a process even when it isn't safe to do so.  Use
+     * with extreme care!
+     */
+    public static final int CONTEXT_IGNORE_SECURITY = 0x00000002;
+
+    /**
+     * Flag for use with {@link #createPackageContext}: a restricted context may
+     * disable specific features. For instance, a View associated with a restricted
+     * context would ignore particular XML attributes.
+     */
+    public static final int CONTEXT_RESTRICTED = 0x00000004;
+
+    /**
+     * @hide Used to indicate we should tell the activity manager about the process
+     * loading this code.
+     */
+    public static final int CONTEXT_REGISTER_PACKAGE = 0x40000000;
+
+    /**
+     * Return a new Context object for the given application name.  This
+     * Context is the same as what the named application gets when it is
+     * launched, containing the same resources and class loader.  Each call to
+     * this method returns a new instance of a Context object; Context objects
+     * are not shared, however they share common state (Resources, ClassLoader,
+     * etc) so the Context instance itself is fairly lightweight.
+     *
+     * <p>Throws {@link android.content.pm.PackageManager.NameNotFoundException} if there is no
+     * application with the given package name.
+     *
+     * <p>Throws {@link java.lang.SecurityException} if the Context requested
+     * can not be loaded into the caller's process for security reasons (see
+     * {@link #CONTEXT_INCLUDE_CODE} for more information}.
+     *
+     * @param packageName Name of the application's package.
+     * @param flags Option flags, one of {@link #CONTEXT_INCLUDE_CODE}
+     *              or {@link #CONTEXT_IGNORE_SECURITY}.
+     *
+     * @return A {@link Context} for the application.
+     *
+     * @throws SecurityException &nbsp;
+     * @throws PackageManager.NameNotFoundException if there is no application with
+     * the given package name.
+     */
+    public abstract Context createPackageContext(String packageName,
+            @CreatePackageOptions int flags) throws PackageManager.NameNotFoundException;
+
+    /**
+     * Similar to {@link #createPackageContext(String, int)}, but with a
+     * different {@link UserHandle}. For example, {@link #getContentResolver()}
+     * will open any {@link Uri} as the given user.
+     *
+     * @hide
+     */
+    public abstract Context createPackageContextAsUser(
+            String packageName, int flags, UserHandle user)
+            throws PackageManager.NameNotFoundException;
+
+    /**
+     * Creates a context given an {@link android.content.pm.ApplicationInfo}.
+     *
+     * @hide
+     */
+    public abstract Context createApplicationContext(ApplicationInfo application,
+            int flags) throws PackageManager.NameNotFoundException;
+
+    /**
+     * Get the userId associated with this context
+     * @return user id
+     *
+     * @hide
+     */
+    public abstract int getUserId();
+
+    /**
+     * Return a new Context object for the current Context but whose resources
+     * are adjusted to match the given Configuration.  Each call to this method
+     * returns a new instance of a Context object; Context objects are not
+     * shared, however common state (ClassLoader, other Resources for the
+     * same configuration) may be so the Context itself can be fairly lightweight.
+     *
+     * @param overrideConfiguration A {@link Configuration} specifying what
+     * values to modify in the base Configuration of the original Context's
+     * resources.  If the base configuration changes (such as due to an
+     * orientation change), the resources of this context will also change except
+     * for those that have been explicitly overridden with a value here.
+     *
+     * @return A {@link Context} with the given configuration override.
+     */
+    public abstract Context createConfigurationContext(
+            @NonNull Configuration overrideConfiguration);
+
+    /**
+     * Return a new Context object for the current Context but whose resources
+     * are adjusted to match the metrics of the given Display.  Each call to this method
+     * returns a new instance of a Context object; Context objects are not
+     * shared, however common state (ClassLoader, other Resources for the
+     * same configuration) may be so the Context itself can be fairly lightweight.
+     *
+     * The returned display Context provides a {@link WindowManager}
+     * (see {@link #getSystemService(String)}) that is configured to show windows
+     * on the given display.  The WindowManager's {@link WindowManager#getDefaultDisplay}
+     * method can be used to retrieve the Display from the returned Context.
+     *
+     * @param display A {@link Display} object specifying the display
+     * for whose metrics the Context's resources should be tailored and upon which
+     * new windows should be shown.
+     *
+     * @return A {@link Context} for the display.
+     */
+    public abstract Context createDisplayContext(@NonNull Display display);
+
+    /**
+     * Gets the display adjustments holder for this context.  This information
+     * is provided on a per-application or activity basis and is used to simulate lower density
+     * display metrics for legacy applications and restricted screen sizes.
+     *
+     * @param displayId The display id for which to get compatibility info.
+     * @return The compatibility info holder, or null if not required by the application.
+     * @hide
+     */
+    public abstract DisplayAdjustments getDisplayAdjustments(int displayId);
+
+    /**
+     * Indicates whether this Context is restricted.
+     *
+     * @return {@code true} if this Context is restricted, {@code false} otherwise.
+     *
+     * @see #CONTEXT_RESTRICTED
+     */
+    public boolean isRestricted() {
+        return false;
+    }
+}
diff --git a/core/java/android/net/ConnectivityManager.java b/core/java/android/net/ConnectivityManager.java
index 4d9b759..b132c70 100644
--- a/core/java/android/net/ConnectivityManager.java
+++ b/core/java/android/net/ConnectivityManager.java
@@ -461,11 +461,41 @@
      */
     public static final int TYPE_VPN = 17;
 
+    // MTK
+    /**
+     * Device Managment purpose.
+     * {@hide}
+     * @internal
+     */
+    public static final int TYPE_MOBILE_DM = 34;
+    /** {@hide} */
+    public static final int TYPE_MOBILE_WAP = 35;
+    /** {@hide} */
+    public static final int TYPE_MOBILE_NET = 36;
+    /** {@hide} */
+    public static final int TYPE_MOBILE_CMMAIL = 37;
+    /** {@hide} */
+    public static final int TYPE_MOBILE_TETHERING = 38;
+    /** {@hide} */
+    public static final int TYPE_MOBILE_RCSE = 39;
+    /** {@hide} */
+    public static final int TYPE_MOBILE_XCAP = 40;
+    /** {@hide} */
+    public static final int TYPE_MOBILE_RCS = 41;
+    /** M: end */
+
+    ///M @add  for 3gdongle
+    /** {@hide} */
+    public static final int TYPE_TEDONGLE = 49;
+
     /** {@hide} */
     public static final int MAX_RADIO_TYPE   = TYPE_VPN;
 
     /** {@hide} */
-    public static final int MAX_NETWORK_TYPE = TYPE_VPN;
+    public static final int MAX_AOSP_NETWORK_TYPE = TYPE_VPN;
+
+    /** {@hide} */
+    public static final int MAX_NETWORK_TYPE = TYPE_TEDONGLE;
 
     /**
      * If you want to set the default network preference,you can directly
@@ -514,7 +544,9 @@
      *             validate a network type.
      */
     public static boolean isNetworkTypeValid(int networkType) {
-        return networkType >= 0 && networkType <= MAX_NETWORK_TYPE;
+        // MTK
+        return (networkType >= 0 && networkType <= MAX_AOSP_NETWORK_TYPE)
+            || (networkType >= TYPE_MOBILE_DM && networkType <= MAX_NETWORK_TYPE);
     }
 
     /**
@@ -587,6 +619,9 @@ public static boolean isNetworkTypeMobile(int networkType) {
             case TYPE_MOBILE_CBS:
             case TYPE_MOBILE_IA:
             case TYPE_MOBILE_EMERGENCY:
+            // MTK
+            case TYPE_MOBILE_XCAP:
+            case TYPE_MOBILE_RCS:
                 return true;
             default:
                 return false;
@@ -999,6 +1034,13 @@ private NetworkCapabilities networkCapabilitiesForFeature(int networkType, Strin
                 cap = NetworkCapabilities.NET_CAPABILITY_IMS;
             } else if ("enableCBS".equals(feature)) {
                 cap = NetworkCapabilities.NET_CAPABILITY_CBS;
+            // MTK
+            } else if ("enableEmergency".equals(feature)) {
+                cap = NetworkCapabilities.NET_CAPABILITY_EIMS;
+            } else if ("enableXCAP".equals(feature)) {
+                cap = NetworkCapabilities.NET_CAPABILITY_XCAP;
+            } else if ("enableRCS".equals(feature)) {
+                cap = NetworkCapabilities.NET_CAPABILITY_RCS;
             } else {
                 return null;
             }
@@ -1066,6 +1108,16 @@ private int inferLegacyTypeForNetworkCapabilities(NetworkCapabilities netCap) {
         } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
             type = "enableHIPRI";
             result = TYPE_MOBILE_HIPRI;
+          // MTK
+        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_EIMS)) {
+            type = "enableEmergency";
+            result = TYPE_MOBILE_EMERGENCY;
+        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_XCAP)) {
+            type = "enableXCAP";
+            result = TYPE_MOBILE_XCAP;
+        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_RCS)) {
+            type = "enableRCS";
+            result = TYPE_MOBILE_RCS;
         }
         if (type != null) {
             NetworkCapabilities testCap = networkCapabilitiesForFeature(TYPE_MOBILE, type);
@@ -1102,6 +1154,10 @@ private int legacyTypeForNetworkCapabilities(NetworkCapabilities netCap) {
         if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_WIFI_P2P)) {
             return TYPE_WIFI_P2P;
         }
+        // MTK
+        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_EIMS)) {
+            return TYPE_MOBILE_EMERGENCY;
+        }
         return TYPE_NONE;
     }
 
@@ -1861,6 +1917,22 @@ public int setUsbTethering(boolean enable) {
     /** {@hide} */
     public static final int TETHER_ERROR_IFACE_CFG_ERROR      = 10;
 
+    // MTK
+    /** M: ipv6 tethering @{ */
+    /** {@hide}
+     * @internal
+     */
+    public static final int TETHER_ERROR_IPV6_NO_ERROR      = 0x10;
+    /** {@hide}
+     * @internal
+     */
+    public static final int TETHER_ERROR_IPV6_AVAIABLE      = 0x20;
+    /** {@hide}
+     * @internal
+     */
+    public static final int TETHER_ERROR_IPV6_UNAVAIABLE      = 0x30;
+    /** @} */
+
     /**
      * Get a more detailed error code after a Tethering or Untethering
      * request asynchronously failed.
@@ -2919,4 +2991,53 @@ public static boolean setProcessDefaultNetworkForHostResolution(Network network)
         return NetworkUtils.bindProcessToNetworkForHostResolution(
                 network == null ? NETID_UNSET : network.netId);
     }
+
+    // MTK
+    /**
+     * support Tether dediated APN feature  for OP03APNSettingExt
+     * @internal
+     * @return true if tethering is completed or false
+     * @hide
+     */
+    public boolean isTetheringChangeDone() {
+        /*
+        try {
+            return mService.isTetheringChangeDone();
+        } catch (RemoteException e) {
+            return false;
+        }
+        */
+        return false;
+    }
+
+    /**
+     * Ipv6 Tethering Feature
+     * @internal
+     * @param enable to set ipv6 tethering function
+     * @hide
+     */
+    public void setTetheringIpv6Enable(boolean enable) {
+        /*
+        try {
+            mService.setTetheringIpv6Enable(enable);
+        } catch (RemoteException e) { }
+        */
+    }
+
+    /**
+     * Ipv6 Tethering Feature
+     * @internal
+     * @return the value to latest set by setTetheringIpv6Enable
+     * @hide
+     */
+    public boolean getTetheringIpv6Enable() {
+        /*
+        try {
+            return mService.getTetheringIpv6Enable();
+        } catch (RemoteException e) {
+            return false;
+        }
+        */
+        return false;
+    }
 }
diff --git a/core/java/android/os/storage/DiskInfo.java b/core/java/android/os/storage/DiskInfo.java
index 9114107..a679ec1 100644
--- a/core/java/android/os/storage/DiskInfo.java
+++ b/core/java/android/os/storage/DiskInfo.java
@@ -108,7 +108,7 @@ public String getDescription() {
                 return res.getString(com.android.internal.R.string.storage_usb_drive);
             }
         } else {
-            return null;
+            return res.getString(com.android.internal.R.string.storage_sd_card);
         }
     }
 
diff --git a/core/java/com/mediatek/GbaBaseCredential.java b/core/java/com/mediatek/GbaBaseCredential.java
new file mode 100644
index 0000000..3646461
--- /dev/null
+++ b/core/java/com/mediatek/GbaBaseCredential.java
@@ -0,0 +1,182 @@
+package com.mediatek.gba;
+
+import android.content.Context;
+import android.net.Network;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.telephony.SubscriptionManager;
+import android.util.Log;
+
+/**
+ * HTTP Authenticator for GBA procedure.
+ * It is based class.
+ *
+ * @hide
+ */
+public abstract class GbaBaseCredential {
+    private final static String TAG = "GbaBaseCredential";
+
+    static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID_HTTP =
+        new byte[] {(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02};
+    static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID_TLS =
+        new byte[] {(byte) 0x01, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x2F};
+    final protected static char[] HEX_ARRAY = "0123456789abcdef".toCharArray();
+
+    protected static Context sContext;
+    protected static Network sNetwork;
+    protected static int sSubId;
+    protected static boolean sIsTlsEnabled;
+    protected static boolean sCachedSessionKeyUsed;
+    protected static String sPasswd;
+    protected static String sNafAddress;
+    protected static IGbaService sService;
+
+    /**
+      * Empty construciton function.
+      *
+      */
+    GbaBaseCredential() {
+
+    }
+
+    /**
+      * Construciton function with initalization parameters.
+      *
+      */
+    GbaBaseCredential(Context context, String nafAddress, int subId) {
+        super();
+        sContext = context;
+        sSubId = subId;
+
+        if (nafAddress.charAt(nafAddress.length() - 1) == '/') {
+            nafAddress = nafAddress.substring(0, nafAddress.length() - 1);
+        }
+
+        sIsTlsEnabled = true;
+        sCachedSessionKeyUsed = false;
+        sNafAddress = nafAddress.toLowerCase();
+
+        if (sNafAddress.indexOf("http://") != -1) {
+            sNafAddress = nafAddress.substring(7);
+            sIsTlsEnabled = false;
+        } else if (sNafAddress.indexOf("https://") != -1) {
+            sNafAddress = nafAddress.substring(8);
+            sIsTlsEnabled = true;
+        }
+
+        Log.d(TAG, "nafAddress:" + sNafAddress);
+    }
+
+    /**
+      * Tell GbaCredential the connection is TLS or not.
+      *
+      * @param tlsEnabled indicate the connection is over TLS or not.
+      *
+      */
+    public void setTlsEnabled(boolean tlsEnabled) {
+        sIsTlsEnabled = tlsEnabled;
+    }
+
+    /**
+      * Configure which subscription to use in GBA procedure.
+      *
+      * @param subId indicate the subscription id.
+      *
+      */
+    public void setSubId(int subId) {
+        sSubId = subId;
+    }
+
+    /**
+      * Configure dedicated network.
+      *
+      * @param network network that will be used to establish socket connection.
+      *
+      */
+    public void setNetwork(Network network) {
+        if (network != null) {
+            Log.i(TAG, "GBA dedicated network netid:" + network);
+            sNetwork = network;
+        }
+    }
+
+    /**
+      * Get session key for NAF server by GBA procedure.
+      *
+      @return NafSessionKey: the session key of NAF server.
+      */
+    public static NafSessionKey getNafSessionKey() {
+        NafSessionKey nafSessionKey = null;
+
+        try {
+            IBinder b = ServiceManager.getService("GbaService");
+
+            if (b == null) {
+                Log.i("debug", "The binder is null");
+                return null;
+            }
+
+            sService = IGbaService.Stub.asInterface(b);
+        } catch (NullPointerException e) {
+            e.printStackTrace();
+        }
+
+        try {
+            byte[] uaId = DEFAULT_UA_SECURITY_PROTOCOL_ID_TLS;
+
+            if (sIsTlsEnabled) {
+                String gbaStr = System.getProperty("gba.ciper.suite", "");
+
+                if (gbaStr.length() > 0) {
+                    GbaCipherSuite cipherSuite = GbaCipherSuite.getByName(gbaStr);
+
+                    if (cipherSuite != null) {
+                        byte[] cipherSuiteCode = cipherSuite.getCode();
+                        uaId[3] = cipherSuiteCode[0];
+                        uaId[4] = cipherSuiteCode[1];
+                    }
+                }
+            } else {
+                uaId = DEFAULT_UA_SECURITY_PROTOCOL_ID_HTTP;
+            }
+
+            if (sNetwork != null) {
+                sService.setNetwork(sNetwork);
+            }
+
+            String realm = System.getProperty("digest.realm", "");
+            Log.i(TAG, "realm:" + realm);
+            if (realm.length() > 0) {
+                String[] segments = realm.split(";");
+                sNafAddress = segments[0].substring(segments[0].indexOf("@") + 1);
+                Log.i(TAG, "NAF FQDN:" + sNafAddress);
+            } else {
+                return null;
+            }
+
+            if (SubscriptionManager.INVALID_SUBSCRIPTION_ID == sSubId) {
+                nafSessionKey = sService.runGbaAuthentication(sNafAddress,
+                                uaId, sCachedSessionKeyUsed);
+            } else {
+                nafSessionKey = sService.runGbaAuthenticationForSubscriber(sNafAddress,
+                                uaId, sCachedSessionKeyUsed, sSubId);
+            }
+
+            if (nafSessionKey != null && (nafSessionKey.getException() != null) &&
+                    (nafSessionKey.getException() instanceof IllegalStateException)) {
+                String msg = ((IllegalStateException) nafSessionKey.getException())
+                        .getMessage();
+
+                if ("HTTP 403 Forbidden".equals(msg)) {
+                    Log.i(TAG, "GBA hit 403");
+                    System.setProperty("gba.auth", "403");
+                }
+            }
+        } catch (RemoteException re) {
+            re.printStackTrace();
+        }
+
+        return nafSessionKey;
+    }
+}
\ No newline at end of file
diff --git a/core/java/com/mediatek/GbaCipherSuite.java b/core/java/com/mediatek/GbaCipherSuite.java
new file mode 100644
index 0000000..6be8854
--- /dev/null
+++ b/core/java/com/mediatek/GbaCipherSuite.java
@@ -0,0 +1,465 @@
+package com.mediatek.gba;
+
+import java.util.Hashtable;
+
+/**
+* Represents Cipher Suite as defined in TLS 1.0 spec.,
+* A.5. The CipherSuite;
+* C. CipherSuite definitions.
+* @see <a href="http://www.ietf.org/rfc/rfc2246.txt">TLS 1.0 spec.</a>
+ * @hide
+*
+*/
+class GbaCipherSuite {
+    // cipher suite code
+    private final byte[] mCipherSuiteCode;
+
+    // cipher suite name
+    private final String mCipherSuiteName;
+
+    // hash for quick access to cipher suite by name
+    private static final Hashtable<String, GbaCipherSuite> mSuiteByName;
+
+    /**
+    * TLS cipher suite codes.
+    */
+    static final byte[] CODE_SSL_NULL_WITH_NULL_NULL = { 0x00, 0x00 };
+    static final byte[] CODE_SSL_RSA_WITH_NULL_MD5 = { 0x00, 0x01 };
+    static final byte[] CODE_SSL_RSA_WITH_NULL_SHA = { 0x00, 0x02 };
+    static final byte[] CODE_SSL_RSA_EXPORT_WITH_RC4_40_MD5 = { 0x00, 0x03 };
+    static final byte[] CODE_SSL_RSA_WITH_RC4_128_MD5 = { 0x00, 0x04 };
+    static final byte[] CODE_SSL_RSA_WITH_RC4_128_SHA = { 0x00, 0x05 };
+    static final byte[] CODE_SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = { 0x00, 0x06 };
+    // BEGIN android-removed
+    // static final byte[] CODE_TLS_RSA_WITH_IDEA_CBC_SHA = { 0x00, 0x07 };
+    // END android-removed
+    static final byte[] CODE_SSL_RSA_EXPORT_WITH_DES40_CBC_SHA = { 0x00, 0x08 };
+    static final byte[] CODE_SSL_RSA_WITH_DES_CBC_SHA = { 0x00, 0x09 };
+    static final byte[] CODE_SSL_RSA_WITH_3DES_EDE_CBC_SHA = { 0x00, 0x0A };
+    // BEGIN android-removed
+    // static final byte[] CODE_SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = { 0x00, 0x0B };
+    // static final byte[] CODE_SSL_DH_DSS_WITH_DES_CBC_SHA = { 0x00, 0x0C };
+    // static final byte[] CODE_SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA = { 0x00, 0x0D };
+    // static final byte[] CODE_SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = { 0x00, 0x0E };
+    // static final byte[] CODE_SSL_DH_RSA_WITH_DES_CBC_SHA = { 0x00, 0x0F };
+    // static final byte[] CODE_SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA = { 0x00, 0x10 };
+    // END android-removed
+    static final byte[] CODE_SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = { 0x00, 0x11 };
+    static final byte[] CODE_SSL_DHE_DSS_WITH_DES_CBC_SHA = { 0x00, 0x12 };
+    static final byte[] CODE_SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA = { 0x00, 0x13 };
+    static final byte[] CODE_SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = { 0x00, 0x14 };
+    static final byte[] CODE_SSL_DHE_RSA_WITH_DES_CBC_SHA = { 0x00, 0x15 };
+    static final byte[] CODE_SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA = { 0x00, 0x16 };
+    static final byte[] CODE_SSL_DH_anon_EXPORT_WITH_RC4_40_MD5 = { 0x00, 0x17 };
+    static final byte[] CODE_SSL_DH_anon_WITH_RC4_128_MD5 = { 0x00, 0x18 };
+    static final byte[] CODE_SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA = { 0x00, 0x19 };
+    static final byte[] CODE_SSL_DH_anon_WITH_DES_CBC_SHA = { 0x00, 0x1A };
+    static final byte[] CODE_SSL_DH_anon_WITH_3DES_EDE_CBC_SHA = { 0x00, 0x1B };
+
+    // AES Cipher Suites from RFC 3268 - http://www.ietf.org/rfc/rfc3268.txt
+    static final byte[] CODE_TLS_RSA_WITH_AES_128_CBC_SHA = { 0x00, 0x2F };
+    //static final byte[] CODE_TLS_DH_DSS_WITH_AES_128_CBC_SHA = { 0x00, 0x30 };
+    //static final byte[] CODE_TLS_DH_RSA_WITH_AES_128_CBC_SHA = { 0x00, 0x31 };
+    static final byte[] CODE_TLS_DHE_DSS_WITH_AES_128_CBC_SHA = { 0x00, 0x32 };
+    static final byte[] CODE_TLS_DHE_RSA_WITH_AES_128_CBC_SHA = { 0x00, 0x33 };
+    static final byte[] CODE_TLS_DH_anon_WITH_AES_128_CBC_SHA = { 0x00, 0x34 };
+    static final byte[] CODE_TLS_RSA_WITH_AES_256_CBC_SHA = { 0x00, 0x35 };
+    //static final byte[] CODE_TLS_DH_DSS_WITH_AES_256_CBC_SHA = { 0x00, 0x36 };
+    //static final byte[] CODE_TLS_DH_RSA_WITH_AES_256_CBC_SHA = { 0x00, 0x37 };
+    static final byte[] CODE_TLS_DHE_DSS_WITH_AES_256_CBC_SHA = { 0x00, 0x38 };
+    static final byte[] CODE_TLS_DHE_RSA_WITH_AES_256_CBC_SHA = { 0x00, 0x39 };
+    static final byte[] CODE_TLS_DH_anon_WITH_AES_256_CBC_SHA = { 0x00, 0x3A };
+
+    // EC Cipher Suites from RFC 4492 - http://www.ietf.org/rfc/rfc4492.txt
+    static final byte[] CODE_TLS_ECDH_ECDSA_WITH_NULL_SHA = { (byte) 0xc0, 0x01};
+    static final byte[] CODE_TLS_ECDH_ECDSA_WITH_RC4_128_SHA = { (byte) 0xc0, 0x02};
+    static final byte[] CODE_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = { (byte) 0xc0, 0x03};
+    static final byte[] CODE_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = { (byte) 0xc0, 0x04};
+    static final byte[] CODE_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = { (byte) 0xc0, 0x05};
+    static final byte[] CODE_TLS_ECDHE_ECDSA_WITH_NULL_SHA = { (byte) 0xc0, 0x06};
+    static final byte[] CODE_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = { (byte) 0xc0, 0x07};
+    static final byte[] CODE_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = { (byte) 0xc0, 0x08};
+    static final byte[] CODE_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = { (byte) 0xc0, 0x09};
+    static final byte[] CODE_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = { (byte) 0xc0, 0x0A};
+    static final byte[] CODE_TLS_ECDH_RSA_WITH_NULL_SHA = { (byte) 0xc0, 0x0B};
+    static final byte[] CODE_TLS_ECDH_RSA_WITH_RC4_128_SHA = { (byte) 0xc0, 0x0C};
+    static final byte[] CODE_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = { (byte) 0xc0, 0x0D};
+    static final byte[] CODE_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = { (byte) 0xc0, 0x0E};
+    static final byte[] CODE_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = { (byte) 0xc0, 0x0F};
+    static final byte[] CODE_TLS_ECDHE_RSA_WITH_NULL_SHA = { (byte) 0xc0, 0x10};
+    static final byte[] CODE_TLS_ECDHE_RSA_WITH_RC4_128_SHA = { (byte) 0xc0, 0x11};
+    static final byte[] CODE_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = { (byte) 0xc0, 0x12};
+    static final byte[] CODE_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = { (byte) 0xc0, 0x13};
+    static final byte[] CODE_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = { (byte) 0xc0, 0x14};
+    static final byte[] CODE_TLS_ECDH_anon_WITH_NULL_SHA = { (byte) 0xc0, 0x15};
+    static final byte[] CODE_TLS_ECDH_anon_WITH_RC4_128_SHA = { (byte) 0xc0, 0x16};
+    static final byte[] CODE_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = { (byte) 0xc0, 0x17};
+    static final byte[] CODE_TLS_ECDH_anon_WITH_AES_128_CBC_SHA = { (byte) 0xc0, 0x18};
+    static final byte[] CODE_TLS_ECDH_anon_WITH_AES_256_CBC_SHA = { (byte) 0xc0, 0x19};
+
+    static final  GbaCipherSuite SSL_NULL_WITH_NULL_NULL = new GbaCipherSuite(
+        "SSL_NULL_WITH_NULL_NULL", CODE_SSL_NULL_WITH_NULL_NULL);
+
+    static final  GbaCipherSuite SSL_RSA_WITH_NULL_MD5 = new GbaCipherSuite(
+        "SSL_RSA_WITH_NULL_MD5", CODE_SSL_RSA_WITH_NULL_MD5);
+
+    static final  GbaCipherSuite SSL_RSA_WITH_NULL_SHA = new GbaCipherSuite(
+        "SSL_RSA_WITH_NULL_SHA", CODE_SSL_RSA_WITH_NULL_SHA);
+
+    static final  GbaCipherSuite SSL_RSA_EXPORT_WITH_RC4_40_MD5 = new GbaCipherSuite(
+        "SSL_RSA_EXPORT_WITH_RC4_40_MD5", CODE_SSL_RSA_EXPORT_WITH_RC4_40_MD5);
+
+    static final  GbaCipherSuite SSL_RSA_WITH_RC4_128_MD5 = new GbaCipherSuite(
+        "SSL_RSA_WITH_RC4_128_MD5", CODE_SSL_RSA_WITH_RC4_128_MD5);
+
+    static final  GbaCipherSuite SSL_RSA_WITH_RC4_128_SHA = new GbaCipherSuite(
+        "SSL_RSA_WITH_RC4_128_SHA", CODE_SSL_RSA_WITH_RC4_128_SHA);
+
+    static final  GbaCipherSuite SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = new GbaCipherSuite(
+        "SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", CODE_SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5);
+
+    // BEGIN android-removed
+    // static final  GbaCipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = new GbaCipherSuite(
+    //         "TLS_RSA_WITH_IDEA_CBC_SHA", CODE_TLS_RSA_WITH_IDEA_CBC_SHA);
+    // END android-removed
+
+    static final  GbaCipherSuite SSL_RSA_EXPORT_WITH_DES40_CBC_SHA = new GbaCipherSuite(
+        "SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", CODE_SSL_RSA_EXPORT_WITH_DES40_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_RSA_WITH_DES_CBC_SHA = new GbaCipherSuite(
+        "SSL_RSA_WITH_DES_CBC_SHA", CODE_SSL_RSA_WITH_DES_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_RSA_WITH_3DES_EDE_CBC_SHA = new GbaCipherSuite(
+        "SSL_RSA_WITH_3DES_EDE_CBC_SHA", CODE_SSL_RSA_WITH_3DES_EDE_CBC_SHA);
+
+    // BEGIN android-removed
+    // static final  GbaCipherSuite SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = new GbaCipherSuite(
+    //         "SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", CODE_SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA);
+    //
+    // static final  GbaCipherSuite SSL_DH_DSS_WITH_DES_CBC_SHA = new GbaCipherSuite(
+    //         "SSL_DH_DSS_WITH_DES_CBC_SHA", CODE_SSL_DH_DSS_WITH_DES_CBC_SHA);
+    //
+    // static final  GbaCipherSuite SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA = new GbaCipherSuite(
+    //         "SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA", CODE_SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA);
+    //
+    // static final  GbaCipherSuite SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = new GbaCipherSuite(
+    //         "SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", CODE_SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA);
+    //
+    // static final  GbaCipherSuite SSL_DH_RSA_WITH_DES_CBC_SHA = new GbaCipherSuite(
+    //         "SSL_DH_RSA_WITH_DES_CBC_SHA", CODE_SSL_DH_RSA_WITH_DES_CBC_SHA);
+    //
+    // static final  GbaCipherSuite SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA = new GbaCipherSuite(
+    //         "SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA", CODE_SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA);
+    // END android-removed
+
+    static final  GbaCipherSuite SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = new GbaCipherSuite(
+        "SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", CODE_SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DHE_DSS_WITH_DES_CBC_SHA = new GbaCipherSuite(
+        "SSL_DHE_DSS_WITH_DES_CBC_SHA", CODE_SSL_DHE_DSS_WITH_DES_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA = new GbaCipherSuite(
+        "SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", CODE_SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = new GbaCipherSuite(
+        "SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", CODE_SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DHE_RSA_WITH_DES_CBC_SHA = new GbaCipherSuite(
+        "SSL_DHE_RSA_WITH_DES_CBC_SHA", CODE_SSL_DHE_RSA_WITH_DES_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA = new GbaCipherSuite(
+        "SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", CODE_SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DH_anon_EXPORT_WITH_RC4_40_MD5 = new GbaCipherSuite(
+        "SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", CODE_SSL_DH_anon_EXPORT_WITH_RC4_40_MD5);
+
+    static final  GbaCipherSuite SSL_DH_anon_WITH_RC4_128_MD5 = new GbaCipherSuite(
+        "SSL_DH_anon_WITH_RC4_128_MD5", CODE_SSL_DH_anon_WITH_RC4_128_MD5);
+
+    static final  GbaCipherSuite SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA = new GbaCipherSuite(
+        "SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", CODE_SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DH_anon_WITH_DES_CBC_SHA = new GbaCipherSuite(
+        "SSL_DH_anon_WITH_DES_CBC_SHA", CODE_SSL_DH_anon_WITH_DES_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DH_anon_WITH_3DES_EDE_CBC_SHA = new GbaCipherSuite(
+        "SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", CODE_SSL_DH_anon_WITH_3DES_EDE_CBC_SHA);
+
+    static final  GbaCipherSuite TLS_RSA_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_RSA_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_RSA_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_DHE_DSS_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_DHE_DSS_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_DHE_RSA_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_DHE_RSA_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_DH_anon_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_DH_anon_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_RSA_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_RSA_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_RSA_WITH_AES_256_CBC_SHA);
+    static final  GbaCipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_DHE_DSS_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_DHE_DSS_WITH_AES_256_CBC_SHA);
+    static final  GbaCipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_DHE_RSA_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_DHE_RSA_WITH_AES_256_CBC_SHA);
+    static final  GbaCipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_DH_anon_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_DH_anon_WITH_AES_256_CBC_SHA);
+
+    static final  GbaCipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA
+    = new GbaCipherSuite("TLS_ECDH_ECDSA_WITH_NULL_SHA",
+                         CODE_TLS_ECDH_ECDSA_WITH_NULL_SHA);
+    static final  GbaCipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA
+    = new GbaCipherSuite("TLS_ECDH_ECDSA_WITH_RC4_128_SHA",
+                         CODE_TLS_ECDH_ECDSA_WITH_RC4_128_SHA);
+    static final  GbaCipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA",
+                         CODE_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA
+    = new GbaCipherSuite("TLS_ECDHE_ECDSA_WITH_NULL_SHA",
+                         CODE_TLS_ECDHE_ECDSA_WITH_NULL_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
+    = new GbaCipherSuite("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
+                         CODE_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA",
+                         CODE_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_RSA_WITH_NULL_SHA
+    = new GbaCipherSuite("TLS_ECDH_RSA_WITH_NULL_SHA",
+                         CODE_TLS_ECDH_RSA_WITH_NULL_SHA);
+    static final  GbaCipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA
+    = new GbaCipherSuite("TLS_ECDH_RSA_WITH_RC4_128_SHA",
+                         CODE_TLS_ECDH_RSA_WITH_RC4_128_SHA);
+    static final  GbaCipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA",
+                         CODE_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA
+    = new GbaCipherSuite("TLS_ECDHE_RSA_WITH_NULL_SHA",
+                         CODE_TLS_ECDHE_RSA_WITH_NULL_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA
+    = new GbaCipherSuite("TLS_ECDHE_RSA_WITH_RC4_128_SHA",
+                         CODE_TLS_ECDHE_RSA_WITH_RC4_128_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
+                         CODE_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_anon_WITH_NULL_SHA
+    = new GbaCipherSuite("TLS_ECDH_anon_WITH_NULL_SHA",
+                         CODE_TLS_ECDH_anon_WITH_NULL_SHA);
+    static final  GbaCipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA
+    = new GbaCipherSuite("TLS_ECDH_anon_WITH_RC4_128_SHA",
+                         CODE_TLS_ECDH_anon_WITH_RC4_128_SHA);
+    static final  GbaCipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA",
+                         CODE_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_anon_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_ECDH_anon_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_anon_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_ECDH_anon_WITH_AES_256_CBC_SHA);
+
+    // arrays for quick access to cipher suite by code
+    private static final  GbaCipherSuite[] SUITES_BY_CODE_0x00 = {
+        // http://www.iana.org/assignments/tls-parameters/tls-parameters.xml
+        SSL_NULL_WITH_NULL_NULL,                          // { 0x00, 0x00 };
+        SSL_RSA_WITH_NULL_MD5,                            // { 0x00, 0x01 };
+        SSL_RSA_WITH_NULL_SHA,                            // { 0x00, 0x02 };
+        SSL_RSA_EXPORT_WITH_RC4_40_MD5,                   // { 0x00, 0x03 };
+        SSL_RSA_WITH_RC4_128_MD5,                         // { 0x00, 0x04 };
+        SSL_RSA_WITH_RC4_128_SHA,                         // { 0x00, 0x05 };
+        // BEGIN android-changed
+        null, // SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5,      // { 0x00, 0x06 };
+        null, // TLS_RSA_WITH_IDEA_CBC_SHA,               // { 0x00, 0x07 };
+        // END android-changed
+        SSL_RSA_EXPORT_WITH_DES40_CBC_SHA,                // { 0x00, 0x08 };
+        SSL_RSA_WITH_DES_CBC_SHA,                         // { 0x00, 0x09 };
+        SSL_RSA_WITH_3DES_EDE_CBC_SHA,                    // { 0x00, 0x0a };
+        // BEGIN android-changed
+        null, // SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA     // { 0x00, 0x0b };
+        null, // SSL_DH_DSS_WITH_DES_CBC_SHA,             // { 0x00, 0x0c };
+        null, // SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA,        // { 0x00, 0x0d };
+        null, // SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA,    // { 0x00, 0x0e };
+        null, // SSL_DH_RSA_WITH_DES_CBC_SHA,             // { 0x00, 0x0f };
+        null, // SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA,        // { 0x00, 0x10 };
+        // END android-changed
+        SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA,            // { 0x00, 0x11 };
+        SSL_DHE_DSS_WITH_DES_CBC_SHA,                     // { 0x00, 0x12 };
+        SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA,                // { 0x00, 0x13 };
+        SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA,            // { 0x00, 0x14 };
+        SSL_DHE_RSA_WITH_DES_CBC_SHA,                     // { 0x00, 0x15 };
+        SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA,                // { 0x00, 0x16 };
+        SSL_DH_anon_EXPORT_WITH_RC4_40_MD5,               // { 0x00, 0x17 };
+        SSL_DH_anon_WITH_RC4_128_MD5,                     // { 0x00, 0x18 };
+        SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA,            // { 0x00, 0x19 };
+        SSL_DH_anon_WITH_DES_CBC_SHA,                     // { 0x00, 0x1A };
+        SSL_DH_anon_WITH_3DES_EDE_CBC_SHA,                // { 0x00, 0x1B };
+        // BEGIN android-added
+        null, // SSL_FORTEZZA_KEA_WITH_NULL_SHA           // { 0x00, 0x1C };
+        null, // SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA   // { 0x00, 0x1D };
+        null, // TLS_KRB5_WITH_DES_CBC_SHA                // { 0x00, 0x1E };
+        null, // TLS_KRB5_WITH_3DES_EDE_CBC_SHA           // { 0x00, 0x1F };
+        null, // TLS_KRB5_WITH_RC4_128_SHA                // { 0x00, 0x20 };
+        null, // TLS_KRB5_WITH_IDEA_CBC_SHA               // { 0x00, 0x21 };
+        null, // TLS_KRB5_WITH_DES_CBC_MD5                // { 0x00, 0x22 };
+        null, // TLS_KRB5_WITH_3DES_EDE_CBC_MD5           // { 0x00, 0x23 };
+        null, // TLS_KRB5_WITH_RC4_128_MD5                // { 0x00, 0x24 };
+        null, // TLS_KRB5_WITH_IDEA_CBC_MD5               // { 0x00, 0x25 };
+        null, // TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA      // { 0x00, 0x26 };
+        null, // TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA      // { 0x00, 0x27 };
+        null, // TLS_KRB5_EXPORT_WITH_RC4_40_SHA          // { 0x00, 0x28 };
+        null, // TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5      // { 0x00, 0x29 };
+        null, // TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5      // { 0x00, 0x2A };
+        null, // TLS_KRB5_EXPORT_WITH_RC4_40_MD5          // { 0x00, 0x2B };
+        null, // TLS_PSK_WITH_NULL_SHA                    // { 0x00, 0x2C };
+        null, // TLS_DHE_PSK_WITH_NULL_SHA                // { 0x00, 0x2D };
+        null, // TLS_RSA_PSK_WITH_NULL_SHA                // { 0x00, 0x2E };
+        TLS_RSA_WITH_AES_128_CBC_SHA,                     // { 0x00, 0x2F };
+        null, // TLS_DH_DSS_WITH_AES_128_CBC_SHA          // { 0x00, 0x30 };
+        null, // TLS_DH_RSA_WITH_AES_128_CBC_SHA          // { 0x00, 0x31 };
+        TLS_DHE_DSS_WITH_AES_128_CBC_SHA,                 // { 0x00, 0x32 };
+        TLS_DHE_RSA_WITH_AES_128_CBC_SHA,                 // { 0x00, 0x33 };
+        TLS_DH_anon_WITH_AES_128_CBC_SHA,                 // { 0x00, 0x34 };
+        TLS_RSA_WITH_AES_256_CBC_SHA,                     // { 0x00, 0x35 };
+        null, // TLS_DH_DSS_WITH_AES_256_CBC_SHA,         // { 0x00, 0x36 };
+        null, // TLS_DH_RSA_WITH_AES_256_CBC_SHA,         // { 0x00, 0x37 };
+        TLS_DHE_DSS_WITH_AES_256_CBC_SHA,                 // { 0x00, 0x38 };
+        TLS_DHE_RSA_WITH_AES_256_CBC_SHA,                 // { 0x00, 0x39 };
+        TLS_DH_anon_WITH_AES_256_CBC_SHA,                 // { 0x00, 0x3A };
+        // END android-added
+    };
+    private static final  GbaCipherSuite[] SUITES_BY_CODE_0xc0 = {
+        null,                                             // { 0xc0, 0x00};
+        TLS_ECDH_ECDSA_WITH_NULL_SHA,                     // { 0xc0, 0x01};
+        TLS_ECDH_ECDSA_WITH_RC4_128_SHA,                  // { 0xc0, 0x02};
+        TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,             // { 0xc0, 0x03};
+        TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,              // { 0xc0, 0x04};
+        TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA,              // { 0xc0, 0x05};
+        TLS_ECDHE_ECDSA_WITH_NULL_SHA,                    // { 0xc0, 0x06};
+        TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,                 // { 0xc0, 0x07};
+        TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,            // { 0xc0, 0x08};
+        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,             // { 0xc0, 0x09};
+        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,             // { 0xc0, 0x0A};
+        TLS_ECDH_RSA_WITH_NULL_SHA,                       // { 0xc0, 0x0B};
+        TLS_ECDH_RSA_WITH_RC4_128_SHA,                    // { 0xc0, 0x0C};
+        TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA,               // { 0xc0, 0x0D};
+        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA,                // { 0xc0, 0x0E};
+        TLS_ECDH_RSA_WITH_AES_256_CBC_SHA,                // { 0xc0, 0x0F};
+        TLS_ECDHE_RSA_WITH_NULL_SHA,                      // { 0xc0, 0x10};
+        TLS_ECDHE_RSA_WITH_RC4_128_SHA,                   // { 0xc0, 0x11};
+        TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,              // { 0xc0, 0x12};
+        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,               // { 0xc0, 0x13};
+        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,               // { 0xc0, 0x14};
+        TLS_ECDH_anon_WITH_NULL_SHA,                      // { 0xc0, 0x15};
+        TLS_ECDH_anon_WITH_RC4_128_SHA,                   // { 0xc0, 0x16};
+        TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA,              // { 0xc0, 0x17};
+        TLS_ECDH_anon_WITH_AES_128_CBC_SHA,               // { 0xc0, 0x18};
+        TLS_ECDH_anon_WITH_AES_256_CBC_SHA,               // { 0xc0, 0x19};
+        // TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA,             // { 0xc0, 0x1A};
+        // TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA,         // { 0xc0, 0x1B};
+        // TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA,         // { 0xc0, 0x1C};
+        // TLS_SRP_SHA_WITH_AES_128_CBC_SHA,              // { 0xc0, 0x1D};
+        // TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA,          // { 0xc0, 0x1E};
+        // TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA,          // { 0xc0, 0x1F};
+        // TLS_SRP_SHA_WITH_AES_256_CBC_SHA,              // { 0xc0, 0x20};
+        // TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA,          // { 0xc0, 0x21};
+        // TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA,          // { 0xc0, 0x22};
+        // TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,       // { 0xc0, 0x23};
+        // TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,       // { 0xc0, 0x24};
+        // TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256,        // { 0xc0, 0x25};
+        // TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384,        // { 0xc0, 0x26};
+        // TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,         // { 0xc0, 0x27};
+        // TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,         // { 0xc0, 0x28};
+        // TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256,          // { 0xc0, 0x29};
+        // TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384,          // { 0xc0, 0x2A};
+        // TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,       // { 0xc0, 0x2B};
+        // TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,       // { 0xc0, 0x2C};
+        // TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256,        // { 0xc0, 0x2D};
+        // TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384,        // { 0xc0, 0x2E};
+        // TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,         // { 0xc0, 0x2F};
+        // TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,         // { 0xc0, 0x30};
+        // TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256,          // { 0xc0, 0x31};
+        // TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384,          // { 0xc0, 0x32};
+        // TLS_ECDHE_PSK_WITH_RC4_128_SHA,                // { 0xc0, 0x33};
+        // TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA,           // { 0xc0, 0x34};
+        // TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA,            // { 0xc0, 0x35};
+        // TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA,            // { 0xc0, 0x36};
+        // TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256,         // { 0xc0, 0x37};
+        // TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384,         // { 0xc0, 0x38};
+        // TLS_ECDHE_PSK_WITH_NULL_SHA,                   // { 0xc0, 0x39};
+        // TLS_ECDHE_PSK_WITH_NULL_SHA256,                // { 0xc0, 0x3A};
+        // TLS_ECDHE_PSK_WITH_NULL_SHA384,                // { 0xc0, 0x3B};
+    };
+
+    private GbaCipherSuite(String name, byte[] code) {
+        this.mCipherSuiteName = name;
+        this.mCipherSuiteCode = code;
+    }
+
+    static {
+        mSuiteByName = new Hashtable<String, GbaCipherSuite>();
+        registerCipherSuitesByCode(SUITES_BY_CODE_0x00);
+        registerCipherSuitesByCode(SUITES_BY_CODE_0xc0);
+    }
+
+    private static int registerCipherSuitesByCode(GbaCipherSuite[] cipherSuites) {
+        int count = 0;
+
+        for (int i = 0; i < cipherSuites.length; i++) {
+            if (cipherSuites[i] == SSL_NULL_WITH_NULL_NULL) {
+                continue;
+            }
+
+            if (cipherSuites[i] == null) {
+                continue;
+            }
+
+            mSuiteByName.put(cipherSuites[i].getName(), cipherSuites[i]);
+        }
+
+        return count;
+    }
+
+    /**
+     * Returns CipherSuite by name.
+     */
+    public static GbaCipherSuite getByName(String name) {
+        return mSuiteByName.get(name);
+    }
+
+    public String getName() {
+        return mCipherSuiteName;
+    }
+
+    public byte[] getCode() {
+        return mCipherSuiteCode;
+    }
+
+}
\ No newline at end of file
diff --git a/core/java/com/mediatek/GbaHttpUrlCredential.java b/core/java/com/mediatek/GbaHttpUrlCredential.java
new file mode 100644
index 0000000..3c85f21
--- /dev/null
+++ b/core/java/com/mediatek/GbaHttpUrlCredential.java
@@ -0,0 +1,86 @@
+package com.mediatek.gba;
+
+import android.content.Context;
+import android.telephony.SubscriptionManager;
+import android.util.Base64;
+import android.util.Log;
+
+import java.net.Authenticator;
+import java.net.PasswordAuthentication;
+
+/**
+ * HTTP Authenticator for GBA procedure.
+ * This is designed for HttpUrlConnection.
+ *
+ * @hide
+ */
+public class GbaHttpUrlCredential extends GbaBaseCredential {
+    private final static String TAG = "GbaCredentials";
+
+    private Authenticator mAuthenticator = new GbaAuthenticator();
+
+    /**
+      * Construction function for GbaCredentials.
+      *
+      * @param context the application context.
+      * @param nafAddress the sceme name + FQDN value of NAF server address.
+      * e.g. https://www.google.com or http://www.google.com
+      *
+      * @hide
+      */
+    public GbaHttpUrlCredential(Context context, String nafAddress) {
+        this(context, nafAddress, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+    }
+
+    /**
+      * Construction function for GbaCredentials.
+      *
+      * @param context the application context.
+      * @param nafAddress the sceme name + FQDN value of NAF server address.
+      * @param subId the subscription id.
+      * e.g. https://www.google.com or http://www.google.com
+      *
+      * @hide
+      */
+    public GbaHttpUrlCredential(Context context, String nafAddress, int subId) {
+        super(context, nafAddress, subId);
+        System.setProperty("http.digest.support", "true");
+    }
+
+    public Authenticator getAuthenticator() {
+        return mAuthenticator;
+    }
+
+    /**
+      * Authenticator for OkHttp stack.
+      * Used for HTTP digest method.
+      *
+      */
+    private class GbaAuthenticator extends Authenticator {
+        private PasswordAuthentication mPasswordAuthentication;
+
+        protected PasswordAuthentication getPasswordAuthentication() {
+            Log.i(TAG, "getPasswordAuthentication");
+
+            if (mPasswordAuthentication == null || sCachedSessionKeyUsed) {
+                Log.i(TAG, "Run GBA procedure");
+                NafSessionKey nafSessionKey = GbaBaseCredential.getNafSessionKey();
+                if (nafSessionKey == null ||
+                        (nafSessionKey != null && nafSessionKey.getKey() == null)) {
+                    return null;
+                }
+                String password = Base64.encodeToString(nafSessionKey.getKey(), Base64.NO_WRAP);
+                mPasswordAuthentication = new PasswordAuthentication(
+                    nafSessionKey.getBtid(),
+                    password.toCharArray());
+            } else {
+                if (!sCachedSessionKeyUsed) {
+                    sCachedSessionKeyUsed = true;
+                }
+            }
+
+            return mPasswordAuthentication;
+        }
+    }
+
+}
diff --git a/core/java/com/mediatek/GbaManager.java b/core/java/com/mediatek/GbaManager.java
new file mode 100644
index 0000000..b5c9e3f
--- /dev/null
+++ b/core/java/com/mediatek/GbaManager.java
@@ -0,0 +1,201 @@
+package com.mediatek.gba;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Log;
+
+
+/**
+ * A class provides the GBA service APIs.
+ *
+ * @hide
+ */
+public final class GbaManager {
+    private static final String TAG = "GbaManager";
+
+    private final Context mContext;
+    private static IGbaService mService;
+    private static GbaManager mGbaManager = null;
+
+    public static final int IMS_GBA_NONE     = 0;
+    public static final int IMS_GBA_ME       = 1;
+    public static final int IMS_GBA_U        = 2;
+
+    public static final String IMS_GBA_KS_NAF       = "Ks_NAF";
+    public static final String IMS_GBA_KS_EXT_NAF   = "Ks_ext_NAF";
+
+    public static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID0 = new byte[]
+                    {(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00};
+    public static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID1 = new byte[]
+                    {(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01}; //MBMS
+    public static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID2 = new byte[]
+                    {(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02};
+    public static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID3 = new byte[]
+                    {(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03}; //MBMS
+
+    private static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID_HTTP =
+        new byte[] {(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02};
+    private static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID_TLS =
+        new byte[] {(byte) 0x01, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x2F};
+
+    /**
+     * Helpers to get the default GbaManager.
+     */
+    public static GbaManager getDefaultGbaManager(Context context) {
+        if (context == null) {
+            throw new IllegalArgumentException("context cannot be null");
+        }
+
+        synchronized (GbaManager.class) {
+            if (mGbaManager == null) {
+                IBinder b = ServiceManager.getService("GbaService");
+
+                if (b == null) {
+                    Log.i("debug", "The binder is null");
+                    return null;
+                }
+
+                mService = IGbaService.Stub.asInterface(b);
+                mGbaManager = new GbaManager(context);
+            }
+
+            return mGbaManager;
+        }
+    }
+
+    GbaManager(Context context) {
+        mContext = context;
+    }
+
+    /**
+     * Check GBA is supported and support type or not.
+     *
+     * @return GBA Support Type
+     */
+    public int getGbaSupported() {
+        try {
+            return mService.getGbaSupported();
+        } catch (RemoteException e) {
+            return 0;
+        }
+    }
+
+    /**
+     * Check GBA is supported and support type or not for a particular subscription.
+     *
+     * @param subId subscription whose subscriber id is returned
+     *
+     * @return GBA Support Type
+     */
+    public int getGbaSupported(int subId) {
+        try {
+            return mService.getGbaSupported();
+        } catch (RemoteException e) {
+            return 0;
+        }
+    }
+
+    /**
+     * Check GBA NAFSession key is expired or not.
+     *
+     * @param nafFqdn The FQDN address of NAF server
+     * @param nafSecurProtocolId The security protocol id of NAF server
+     *
+     * @return indicate key is expired or not
+     */
+    public boolean isGbaKeyExpired(String nafFqdn, byte[] nafSecurProtocolId) {
+        try {
+            return mService.isGbaKeyExpired(nafFqdn, nafSecurProtocolId);
+        } catch (RemoteException e) {
+            return true;
+        }
+    }
+
+    /**
+     * Check GBA NAFSession key is expired or not for a particular subscription.
+     *
+     * @param nafFqdn The FQDN address of NAF server
+     * @param nafSecurProtocolId The security protocol id of NAF server
+     * @param subId subscription whose subscriber id is returned
+     *
+     * @return indicate key is expired or not
+     */
+    public boolean isGbaKeyExpired(String nafFqdn, byte[] nafSecurProtocolId, int subId) {
+        try {
+            return mService.isGbaKeyExpired(nafFqdn, nafSecurProtocolId);
+        } catch (RemoteException e) {
+            return true;
+        }
+    }
+
+    /**
+     * Perform GBA bootstrap authentication.
+     *
+     * @param nafFqdn The FQDN address of NAF server
+     * @param nafSecureProtocolId The security protocol id of NAF server
+     * @param forceRun Indicate to force run GBA bootstrap procedure without
+     *                 get NAS Session key from GBA cache
+     *
+     * @return GBA NAS Session Key
+     */
+    public NafSessionKey runGbaAuthentication(String nafFqdn, byte[] nafSecureProtocolId,
+            boolean forceRun) {
+        try {
+            return mService.runGbaAuthentication(nafFqdn, nafSecureProtocolId, forceRun);
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Perform GBA bootstrap authentication for a particular subscription.
+     *
+     * @param nafFqdn The FQDN address of NAF server
+     * @param nafSecureProtocolId The security protocol id of NAF server
+     * @param forceRun Indicate to force run GBA bootstrap procedure without
+     *                 get NAS Session key from GBA cache
+     * @param subId subscription whose subscriber id is returned
+     *
+     * @return GBA NAS Session Key
+     */
+    public NafSessionKey runGbaAuthentication(String nafFqdn, byte[] nafSecureProtocolId,
+            boolean forceRun, int subId) {
+        try {
+            return mService.runGbaAuthenticationForSubscriber(nafFqdn,
+                    nafSecureProtocolId, forceRun, subId);
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Get the NAF security protocol id.
+     * If NAF client uses TLS connection, this API should be called after the TLS connection
+     * is established. By this case, the cipher suite has been decided.
+     * @param isTls Indicate to connect with server with TLS connection or not.
+     *
+     * @return return the NAF security protocol id.
+     */
+
+   public byte[] getNafSecureProtocolId(boolean isTls) {
+        byte[] uaId = DEFAULT_UA_SECURITY_PROTOCOL_ID_TLS;
+
+        if (isTls) {
+            String gbaStr = System.getProperty("gba.ciper.suite", "");
+            if (gbaStr.length() > 0) {
+                GbaCipherSuite cipherSuite = GbaCipherSuite.getByName(gbaStr);
+                if (cipherSuite != null) {
+                    byte[] cipherSuiteCode = cipherSuite.getCode();
+                    uaId[3] = cipherSuiteCode[0];
+                    uaId[4] = cipherSuiteCode[1];
+                }
+            }
+        } else {
+            uaId = DEFAULT_UA_SECURITY_PROTOCOL_ID_HTTP;
+        }
+
+        return uaId;
+   }
+}
\ No newline at end of file
diff --git a/core/java/com/mediatek/IGbaService.aidl b/core/java/com/mediatek/IGbaService.aidl
new file mode 100644
index 0000000..53474e1
--- /dev/null
+++ b/core/java/com/mediatek/IGbaService.aidl
@@ -0,0 +1,17 @@
+package com.mediatek.gba;
+
+import android.net.Network;
+import com.mediatek.gba.NafSessionKey;
+
+/**
+ * @hide
+ */
+interface IGbaService {
+    int getGbaSupported();
+    int getGbaSupportedForSubscriber(in int subId);
+    boolean isGbaKeyExpired(String nafFqdn, in byte[] nafSecurProtocolId);
+    boolean isGbaKeyExpiredForSubscriber(String nafFqdn, in byte[] nafSecurProtocolId, in int subId);
+    NafSessionKey runGbaAuthentication(in String nafFqdn, in byte[] nafSecurProtocolId, boolean forceRun);
+    NafSessionKey runGbaAuthenticationForSubscriber(in String nafFqdn, in byte[] nafSecurProtocolId, boolean forceRun, in int subId);
+    void setNetwork(in Network network);
+}
\ No newline at end of file
diff --git a/core/java/com/mediatek/NafSessionKey.aidl b/core/java/com/mediatek/NafSessionKey.aidl
new file mode 100644
index 0000000..1c85657
--- /dev/null
+++ b/core/java/com/mediatek/NafSessionKey.aidl
@@ -0,0 +1,3 @@
+package com.mediatek.gba;
+
+parcelable NafSessionKey;
\ No newline at end of file
diff --git a/core/java/com/mediatek/NafSessionKey.java b/core/java/com/mediatek/NafSessionKey.java
new file mode 100644
index 0000000..8c1783b
--- /dev/null
+++ b/core/java/com/mediatek/NafSessionKey.java
@@ -0,0 +1,157 @@
+package com.mediatek.gba;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Utitity contain class for NafSessionKey.
+ * @hide
+ */
+public class NafSessionKey implements Parcelable {
+    private String mBtid;
+    private byte[] mKey;
+    private String mKeylifetime;
+    private String mNafKeyName;
+    private byte[] mNafId;
+    private Exception mException;
+
+    public NafSessionKey() {
+        super();
+
+    }
+
+    public NafSessionKey(final String btid, final byte[] key, final String keylifetime) {
+        mBtid = btid;
+        mKey = key;
+        mKeylifetime = keylifetime;
+    }
+
+    public String getBtid() {
+        return mBtid;
+    }
+
+    public void setBtid(final String btid) {
+        mBtid = btid;
+    }
+
+    public byte[] getKey() {
+        return mKey;
+    }
+
+    public void setKey(final byte[] key) {
+        mKey = key;
+    }
+
+    public String getKeylifetime() {
+        return mKeylifetime;
+    }
+
+    public void setKeylifetime(final String keylifetime) {
+        mKeylifetime = keylifetime;
+    }
+
+    public String getNafKeyName() {
+        return mNafKeyName;
+    }
+
+    public void setNafKeyName(String nafKeyName) {
+        mNafKeyName = nafKeyName;
+    }
+
+    public void setNafId(byte[] nafId) {
+        mNafId = nafId;
+    }
+
+    public byte[] getNafId() {
+        return mNafId;
+    }
+
+    public void setException(Exception e) {
+        mException = e;
+    }
+
+    public Exception getException() {
+        return mException;
+    }
+
+    /**
+     * Implement the Parcelable interface
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Implement the Parcelable interface.
+     *
+     * @param dest The Parcel in which the object should be written.
+     * @param flags Additional flags about how the object should be written.
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(mBtid);
+        dest.writeByteArray(mKey);
+        dest.writeString(mKeylifetime);
+        dest.writeString(mNafKeyName);
+        if (mException != null) {
+            dest.writeException(mException);
+        }
+    }
+
+    /**
+     * Implement the Parcelable interface.
+     * @hide
+     */
+    public static final Creator<NafSessionKey> CREATOR =
+        new Creator<NafSessionKey>() {
+            public NafSessionKey createFromParcel(Parcel in) {
+                NafSessionKey nafSessionKey = new NafSessionKey();
+                String btid = in.readString();
+
+                if (btid != null) {
+                    nafSessionKey.setBtid(btid);
+                }
+
+                byte[] key = in.createByteArray();
+
+                if (key != null) {
+                    nafSessionKey.setKey(key);
+                }
+
+                String keylifetime = in.readString();
+
+                if (keylifetime != null) {
+                    nafSessionKey.setKeylifetime(keylifetime);
+                }
+
+                String nafKeyName = in.readString();
+
+                if (nafKeyName != null) {
+                    nafSessionKey.setNafKeyName(nafKeyName);
+                }
+
+                int exceptionCode = in.readInt();
+                String exceptionString = in.readString();
+
+                if (exceptionString != null) {
+                    nafSessionKey.setException(new IllegalStateException(exceptionString));
+                }
+
+                return nafSessionKey;
+            }
+
+            public NafSessionKey[] newArray(int size) {
+                return new NafSessionKey[size];
+            }
+        };
+
+    @Override
+    public String toString() {
+        synchronized (this) {
+            StringBuilder builder = new StringBuilder("NafSessionKey: btid:");
+            builder.append(mBtid).append(":").append(mKeylifetime).append(":").append(mNafKeyName);
+            return builder.toString();
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/lights/LightsManager.java b/services/core/java/com/android/server/lights/LightsManager.java
index 2f20509..69d0c76 100644
--- a/services/core/java/com/android/server/lights/LightsManager.java
+++ b/services/core/java/com/android/server/lights/LightsManager.java
@@ -20,8 +20,8 @@
     public static final int LIGHT_ID_BACKLIGHT = 0;
     public static final int LIGHT_ID_KEYBOARD = 1;
     public static final int LIGHT_ID_BUTTONS = 2;
-    public static final int LIGHT_ID_BATTERY = 3;
-    public static final int LIGHT_ID_NOTIFICATIONS = 4;
+    public static final int LIGHT_ID_NOTIFICATIONS = 3;
+    public static final int LIGHT_ID_BATTERY = 4;
     public static final int LIGHT_ID_ATTENTION = 5;
     public static final int LIGHT_ID_BLUETOOTH = 6;
     public static final int LIGHT_ID_WIFI = 7;
diff --git a/services/core/java/com/android/server/policy/PhoneWindowManager.java b/services/core/java/com/android/server/policy/PhoneWindowManager.java
index 04a4aff..81583d8 100644
--- a/services/core/java/com/android/server/policy/PhoneWindowManager.java
+++ b/services/core/java/com/android/server/policy/PhoneWindowManager.java
@@ -5609,7 +5609,8 @@ public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
             }
         }
 
-        if (useHapticFeedback) {
+        if (useHapticFeedback && mDisplay != null
+                && mDisplay.getState() != Display.STATE_OFF) {
             performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
         }
 
diff --git a/telephony/java/android/telephony/PhoneNumberUtils.java b/telephony/java/android/telephony/PhoneNumberUtils.java
index b430340..f5170ce 100644
--- a/telephony/java/android/telephony/PhoneNumberUtils.java
+++ b/telephony/java/android/telephony/PhoneNumberUtils.java
@@ -43,6 +43,14 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import java.util.ArrayList;
+import java.util.HashMap;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParserFactory;
+import java.io.FileReader;
+import java.io.IOException;
+
 /**
  * Various utilities for dealing with phone number strings.
  */
@@ -84,6 +92,78 @@
     private static final Pattern GLOBAL_PHONE_NUMBER_PATTERN =
             Pattern.compile("[\\+]?[0-9.-]+");
 
+	// MTK
+
+    /** @hide */
+    public static class EccEntry {
+        public static final String ECC_LIST_PATH = "/system/etc/ecc_list.xml";
+        public static final String ECC_ENTRY_TAG = "EccEntry";
+        public static final String ECC_ATTR = "Ecc";
+        public static final String CATEGORY_ATTR = "Category";
+        public static final String CONDITION_ATTR = "Condition";
+
+        public static final String ECC_NO_SIM = "0";
+        public static final String ECC_ALWAYS = "1";
+        public static final String ECC_FOR_MMI = "2";
+
+        private String mEcc;
+        private String mCategory;
+        private String mCondition; // ECC_NO_SIM, ECC_ALWAYS, or ECC_FOR_MMI
+
+        public EccEntry() {
+            mEcc = new String("");
+            mCategory = new String("");
+            mCondition = new String("");
+        }
+
+        public void setEcc(String strEcc) {
+            mEcc = strEcc;
+        }
+        public void setCategory(String strCategory) {
+            mCategory = strCategory;
+        }
+        public void setCondition(String strCondition) {
+            mCondition = strCondition;
+        }
+
+        public String getEcc() {
+            return mEcc;
+        }
+        public String getCategory() {
+            return mCategory;
+        }
+        public String getCondition() {
+            return mCondition;
+        }
+
+        @Override
+        public String toString() {
+            return ("\n" + ECC_ATTR + "=" + getEcc() + ", " + CATEGORY_ATTR + "="
+                    + getCategory() + ", " + CONDITION_ATTR + "=" + getCondition());
+        }
+    }
+
+    private static ArrayList<EccEntry> mCustomizedEccList = null;
+    private static HashMap<String, Integer> mHashMapForNetworkEccCategory = null;
+
+    // private static IPhoneNumberExt sPhoneNumberExt = null;
+
+    private static boolean sIsCtaSupport = false;
+    private static boolean sIsCtaSet = false;
+
+    static {
+        sIsCtaSupport = "1".equals(SystemProperties.get("persist.mtk_cta_support"));
+        sIsCtaSet = "1".equals(SystemProperties.get("ro.mtk_cta_set"));
+        /*
+        if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            sPhoneNumberExt = MPlugin.createInstance(IPhoneNumberExt.class.getName());
+        }
+        */
+        mCustomizedEccList = new ArrayList<EccEntry>();
+        parseEccList();
+        mHashMapForNetworkEccCategory = new HashMap<String, Integer>();
+    }            
+
     /** True if c is ISO-LATIN characters 0-9 */
     public static boolean
     isISODigit (char c) {
@@ -1839,6 +1919,8 @@ private static boolean isEmergencyNumberInternal(String number,
     private static boolean isEmergencyNumberInternal(int subId, String number,
                                                      String defaultCountryIso,
                                                      boolean useExactMatch) {
+    	boolean bSIMInserted = false;
+
         // If the number passed in is null, just return false:
         if (number == null) return false;
 
@@ -1860,6 +1942,28 @@ private static boolean isEmergencyNumberInternal(int subId, String number,
         Rlog.d(LOG_TAG, "subId:" + subId + ", defaultCountryIso:" +
                 ((defaultCountryIso == null) ? "NULL" : defaultCountryIso));
 
+        // MTK
+        // 1. Check ECCs updated by network
+        mHashMapForNetworkEccCategory.clear();
+        String strEccCategoryList = SystemProperties.get("ril.ecc.service.category.list");
+        if (!TextUtils.isEmpty(strEccCategoryList)) {
+            for (String strEccCategory : strEccCategoryList.split(";")) {
+                if (!strEccCategory.isEmpty()) {
+                    String[] strEccCategoryAry = strEccCategory.split(",");
+                    if (2 == strEccCategoryAry.length)
+                        mHashMapForNetworkEccCategory.put(strEccCategoryAry[0], Integer.parseInt(strEccCategoryAry[1]));
+                }
+            }
+        }
+        for (String emergencyNum : mHashMapForNetworkEccCategory.keySet()) {
+            String numberPlus = emergencyNum + "+";
+            if (emergencyNum.equals(number)
+                 || numberPlus.equals(number)) {
+                Rlog.d(LOG_TAG, "[isEmergencyNumber] match network ecc list");
+                return true;
+            }
+        }
+
         String emergencyNumbers = "";
         int slotId = SubscriptionManager.getSlotId(subId);
 
@@ -1868,6 +1972,7 @@ private static boolean isEmergencyNumberInternal(int subId, String number,
         String ecclist = (slotId <= 0) ? "ril.ecclist" : ("ril.ecclist" + slotId);
 
         emergencyNumbers = SystemProperties.get(ecclist, "");
+        bSIMInserted = slotId >= 0;
 
         Rlog.d(LOG_TAG, "slotId:" + slotId + ", emergencyNumbers: " +  emergencyNumbers);
 
@@ -1896,6 +2001,36 @@ private static boolean isEmergencyNumberInternal(int subId, String number,
             return false;
         }
 
+        // MTK
+        // 3. Check ECCs customized by user
+         if (bSIMInserted) {
+             if (mCustomizedEccList != null) {
+                 for (EccEntry eccEntry : mCustomizedEccList) {
+                     if (!eccEntry.getCondition().equals(EccEntry.ECC_NO_SIM)) {
+                         String ecc = eccEntry.getEcc();
+                         String numberPlus = ecc + "+";
+                        if (ecc.equals(number)
+                             || numberPlus.equals(number)) {
+                            Rlog.d(LOG_TAG, "[isEmergencyNumber] match customized ecc list");
+                            return true;
+                        }
+                    }
+                }
+            }
+        } else {
+            if (mCustomizedEccList != null) {
+                for (EccEntry eccEntry : mCustomizedEccList) {
+                    String ecc = eccEntry.getEcc();
+                    String numberPlus = ecc + "+";
+                    if (ecc.equals(number)
+                         || numberPlus.equals(number)) {
+                        Rlog.d(LOG_TAG, "[isEmergencyNumber] match customized ecc list when no sim");
+                        return true;
+                    }
+                }
+            }
+        }
+
         Rlog.d(LOG_TAG, "System property doesn't provide any emergency numbers."
                 + " Use embedded logic for determining ones.");
 
@@ -2980,4 +3115,149 @@ private static int getDefaultVoiceSubId() {
         return SubscriptionManager.getDefaultVoiceSubId();
     }
     //==== End of utility methods used only in compareStrictly() =====
+
+    // MTK
+
+    /**
+     * Parse Ecc List From XML File
+     *
+     * @param none.
+     * @return none.
+     * @hide
+     */
+    private static void parseEccList() {
+        mCustomizedEccList.clear();
+
+        try {
+            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
+            XmlPullParser parser = factory.newPullParser();
+            if (parser == null) {
+                Rlog.d(LOG_TAG, "XmlPullParserFactory.newPullParser() return null");
+                return;
+            }
+            FileReader fileReader = new FileReader(EccEntry.ECC_LIST_PATH);
+            parser.setInput(fileReader);
+            int eventType = parser.getEventType();
+            EccEntry record = null;
+
+            while (eventType != XmlPullParser.END_DOCUMENT) {
+                switch (eventType) {
+                    case XmlPullParser.START_TAG:
+                        if (parser.getName().equals(EccEntry.ECC_ENTRY_TAG)) {
+                            record = new EccEntry();
+                            int attrNum = parser.getAttributeCount();
+                            for (int i = 0; i < attrNum; ++i) {
+                                String name = parser.getAttributeName(i);
+                                String value = parser.getAttributeValue(i);
+                                if (name.equals(EccEntry.ECC_ATTR))
+                                    record.setEcc(value);
+                                else if (name.equals(EccEntry.CATEGORY_ATTR))
+                                    record.setCategory(value);
+                                else if (name.equals(EccEntry.CONDITION_ATTR))
+                                    record.setCondition(value);
+                            }
+                        }
+                        break;
+                    case XmlPullParser.END_TAG:
+                        if (parser.getName().equals(EccEntry.ECC_ENTRY_TAG) && record != null)
+                            mCustomizedEccList.add(record);
+                        break;
+                }
+                eventType = parser.next();
+            }
+            fileReader.close();
+
+            if (sIsCtaSet) {
+                String [] emergencyCTAList = {"120", "122"};
+                for (String emergencyNum : emergencyCTAList) {
+                    record = new EccEntry();
+                    record.setEcc(emergencyNum);
+                    record.setCategory("0");
+                    record.setCondition(EccEntry.ECC_FOR_MMI);
+
+                    boolean bFound = false;
+                    int nIndex = 0;
+                    for (EccEntry eccEntry : mCustomizedEccList) {
+                        String ecc = eccEntry.getEcc();
+                        if (ecc.equals(emergencyNum)) {
+                            bFound = true;
+                            Rlog.d(LOG_TAG, "[parseEccList]"
+                                    + "CTA ecc match customized ecc list, ecc=" + ecc);
+                            break;
+                        }
+                        nIndex++;
+                    }
+
+                    if (bFound)
+                        mCustomizedEccList.set(nIndex, record);
+                    else
+                        mCustomizedEccList.add(record);
+                }
+            }
+        } catch (XmlPullParserException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        Rlog.d(LOG_TAG, "parseEccList: "  mCustomizedEccList);
+    }
+
+    /**
+     * Get Ecc List
+     *
+     * @param none.
+     * @return Ecc List with type ArrayList<EccEntry>.
+     * @hide
+     */
+    public static ArrayList<EccEntry> getEccList() {
+        return mCustomizedEccList;
+    }
+
+    /**
+     * Get the service category for the given ECC number.
+     * @param number The ECC number.
+     * @return The service category for the given number.
+     * @hide
+     */
+    public static int getServiceCategoryFromEcc(String number) {
+        String numberPlus = null;
+
+        // 1. Get category from network
+        for (String emergencyNum : mHashMapForNetworkEccCategory.keySet()) {
+            numberPlus = emergencyNum + "+";
+            if (emergencyNum.equals(number)
+                 || numberPlus.equals(number)) {
+                Integer nSC = mHashMapForNetworkEccCategory.get(emergencyNum);
+                if (nSC != null) {
+                    Rlog.d(LOG_TAG, "[getServiceCategoryFromEcc] match network ecc list, "
+                            + "Ecc= " + number + ", Category= " + nSC);
+                    return nSC;
+                }
+            }
+        }
+
+        // 2. Get category from sim
+        // ToDo: EF_Ecc will convey service category later
+
+        // 3. Get category from user-customized
+        if (mCustomizedEccList != null) {
+            for (EccEntry eccEntry : mCustomizedEccList) {
+                String ecc = eccEntry.getEcc();
+                numberPlus = ecc + "+";
+                if (ecc.equals(number)
+                     || numberPlus.equals(number)) {
+                    Rlog.d(LOG_TAG, "[getServiceCategoryFromEcc] match customized ecc list, "
+                            + "Ecc= " + ecc + ", Category= " + eccEntry.getCategory());
+                    return Integer.parseInt(eccEntry.getCategory());
+                }
+            }
+        }
+
+        Rlog.d(LOG_TAG, "[getServiceCategoryFromEcc] no matched for Ecc =" + number + ", return 0");
+        return 0;
+    }
+
 }
diff --git a/telephony/java/android/telephony/ServiceState.java b/telephony/java/android/telephony/ServiceState.java
index 1337487..fcffdac 100644
--- a/telephony/java/android/telephony/ServiceState.java
+++ b/telephony/java/android/telephony/ServiceState.java
@@ -153,6 +153,36 @@
      * @hide
      */
     public static final int RIL_RADIO_TECHNOLOGY_IWLAN = 18;
+
+    // MTK
+    // For HSPAP detail radio technology
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_MTK = 128;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_HSDPAP = RIL_RADIO_TECHNOLOGY_MTK + 1;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_HSDPAP_UPA = RIL_RADIO_TECHNOLOGY_MTK + 2;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_HSUPAP = RIL_RADIO_TECHNOLOGY_MTK + 3;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_HSUPAP_DPA = RIL_RADIO_TECHNOLOGY_MTK + 4;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_DPA = RIL_RADIO_TECHNOLOGY_MTK + 5;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_UPA = RIL_RADIO_TECHNOLOGY_MTK + 6;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_HSDPAP = RIL_RADIO_TECHNOLOGY_MTK + 7;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_HSDPAP_UPA = RIL_RADIO_TECHNOLOGY_MTK + 8;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_HSDPAP_DPA = RIL_RADIO_TECHNOLOGY_MTK + 9;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_HSPAP = RIL_RADIO_TECHNOLOGY_MTK + 10;
+
+    // for LTEA (carrier aggregation)
+    /** @hide*/
+    public static final int RIL_RADIO_TECHNOLOGY_LTEA = RIL_RADIO_TECHNOLOGY_MTK + 11;
+
     /**
      * Available registration states for GSM, UMTS and CDMA.
      */
@@ -169,6 +199,18 @@
     /** @hide */
     public static final int REGISTRATION_STATE_ROAMING = 5;
 
+    // MTK
+    /** @hide */
+    public static final int
+            REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING_EMERGENCY_CALL_ENABLED = 10;
+    /** @hide */
+    public static final int REGISTRATION_STATE_NOT_REGISTERED_AND_SEARCHING_EMERGENCY_CALL_ENABLED
+            = 12;
+    /** @hide */
+    public static final int REGISTRATION_STATE_REGISTRATION_DENIED_EMERGENCY_CALL_ENABLED = 13;
+    /** @hide */
+    public static final int REGISTRATION_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED = 14;
+
     private int mVoiceRegState = STATE_OUT_OF_SERVICE;
     private int mDataRegState = STATE_OUT_OF_SERVICE;
 
@@ -222,6 +264,30 @@
 
     private boolean mIsDataRoamingFromRegistration;
 
+    // MTK
+    //MTK-START
+    private int mRilVoiceRegState = REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING;
+    private int mRilDataRegState  = REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING;
+    //[ALPS01675318] -START
+    private int mProprietaryDataRadioTechnology;
+    //[ALPS01675318] -END
+    private int mVoiceRejectCause = -1;
+    private int mDataRejectCause = -1;
+    //MTK-END
+
+    //support by via start [ALPS00421033]
+    /** @hide */
+    public static final int RIL_CDMA_NETWORK_MODE_UNKOWN    = 0;
+    /** @hide */
+    public static final int RIL_CDMA_NETWORK_MODE_1X_ONLY   = 2;
+    /** @hide */
+    public static final int RIL_CDMA_NETWORK_MODE_EVDO_ONLY = 4;
+    /** @hide */
+    public static final int RIL_CDMA_NETWORK_MODE_1X_EVDO   = 8;
+    /** @hide */
+    protected int mCdmaNetWorkMode = RIL_CDMA_NETWORK_MODE_UNKOWN;
+    //support by via end. [ALPS00421033]
+
     /**
      * get String description of roaming type
      * @hide
@@ -300,6 +366,13 @@ protected void copyFrom(ServiceState s) {
         mCdmaEriIconMode = s.mCdmaEriIconMode;
         mIsEmergencyOnly = s.mIsEmergencyOnly;
         mIsDataRoamingFromRegistration = s.mIsDataRoamingFromRegistration;
+        // MTK
+        mRilVoiceRegState = s.mRilVoiceRegState;
+        mRilDataRegState = s.mRilDataRegState;
+        mProprietaryDataRadioTechnology = s.mProprietaryDataRadioTechnology;
+        mVoiceRejectCause = s.mVoiceRejectCause;
+        mDataRejectCause = s.mDataRejectCause;
+        mCdmaNetWorkMode = s.mCdmaNetWorkMode;
     }
 
     /**
@@ -327,6 +400,16 @@ public ServiceState(Parcel in) {
         mCdmaEriIconIndex = in.readInt();
         mCdmaEriIconMode = in.readInt();
         mIsEmergencyOnly = in.readInt() != 0;
+        // MTK
+        // xen0n: keep the order consistent with MTK sources to prevent some
+        // external components making assumptions about the parcel layout
+        mRilVoiceRegState = in.readInt();
+        mRilDataRegState = in.readInt();
+        mProprietaryDataRadioTechnology = in.readInt();
+        mVoiceRejectCause = in.readInt();
+        mDataRejectCause = in.readInt();
+        mCdmaNetWorkMode = in.readInt();
+        // MTK-END
         mIsDataRoamingFromRegistration = in.readInt() != 0;
     }
 
@@ -352,6 +435,16 @@ public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mCdmaEriIconIndex);
         out.writeInt(mCdmaEriIconMode);
         out.writeInt(mIsEmergencyOnly ? 1 : 0);
+        // MTK
+        // xen0n: keep the order consistent with MTK sources to prevent some
+        // external components making assumptions about the parcel layout
+        out.writeInt(mRilVoiceRegState);
+        out.writeInt(mRilDataRegState);
+        out.writeInt(mProprietaryDataRadioTechnology);
+        out.writeInt(mVoiceRejectCause);
+        out.writeInt(mDataRejectCause);
+        out.writeInt(mCdmaNetWorkMode);
+        // MTK-END
         out.writeInt(mIsDataRoamingFromRegistration ? 1 : 0);
     }
 
@@ -625,6 +718,13 @@ public int hashCode() {
                 + mCdmaRoamingIndicator
                 + mCdmaDefaultRoamingIndicator
                 + (mIsEmergencyOnly ? 1 : 0)
+                // xen0n: MTK impl didn't take their additions into account
+                + mRilVoiceRegState
+                + mRilDataRegState
+                + mProprietaryDataRadioTechnology
+                + mVoiceRejectCause
+                + mDataRejectCause
+                // xen0n end
                 + (mIsDataRoamingFromRegistration ? 1 : 0));
     }
 
@@ -662,6 +762,15 @@ public boolean equals (Object o) {
                 && equalsHandlesNulls(mCdmaDefaultRoamingIndicator,
                         s.mCdmaDefaultRoamingIndicator)
                 && mIsEmergencyOnly == s.mIsEmergencyOnly
+                // MTK
+                && mRilVoiceRegState == s.mRilVoiceRegState
+                && mRilDataRegState == s.mRilDataRegState
+                && equalsHandlesNulls(mProprietaryDataRadioTechnology,
+                        s.mProprietaryDataRadioTechnology)
+                && mVoiceRejectCause == s.mVoiceRejectCause
+                && mDataRejectCause == s.mDataRejectCause
+                && mCdmaNetWorkMode == s.mCdmaNetWorkMode
+                // MTK-END
                 && mIsDataRoamingFromRegistration == s.mIsDataRoamingFromRegistration);
     }
 
@@ -767,6 +876,14 @@ public String toString() {
                 + " RoamInd=" + mCdmaRoamingIndicator
                 + " DefRoamInd=" + mCdmaDefaultRoamingIndicator
                 + " EmergOnly=" + mIsEmergencyOnly
+                // MTK
+                + " Ril Voice Regist state: " + mRilVoiceRegState
+                + " Ril Data Regist state: " + mRilDataRegState
+                + " mProprietaryDataRadioTechnology: " + mProprietaryDataRadioTechnology
+                + " VoiceRejectCause: " + mVoiceRejectCause
+                + " DataRejectCause: " + mDataRejectCause
+                + " mCdmaNetWorkMode: " + mCdmaNetWorkMode
+                // MTK-END
                 + " IsDataRoamingFromRegistration=" + mIsDataRoamingFromRegistration);
     }
 
@@ -794,6 +911,12 @@ private void setNullState(int state) {
         mCdmaEriIconMode = -1;
         mIsEmergencyOnly = false;
         mIsDataRoamingFromRegistration = false;
+        // MTK
+        mRilVoiceRegState = REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING;
+        mRilDataRegState  = REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING;
+        mProprietaryDataRadioTechnology = 0;
+        mVoiceRejectCause = -1;
+        mDataRejectCause = -1;
     }
 
     public void setStateOutOfService() {
@@ -967,6 +1090,13 @@ private void setFromNotifierBundle(Bundle m) {
         mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
         mIsEmergencyOnly = m.getBoolean("emergencyOnly");
         mIsDataRoamingFromRegistration = m.getBoolean("isDataRoamingFromRegistration");
+        // MTK
+        mRilVoiceRegState = m.getInt("RilVoiceRegState");
+        mRilDataRegState = m.getInt("RilDataRegState");
+        mProprietaryDataRadioTechnology = m.getInt("proprietaryDataRadioTechnology");
+        mVoiceRejectCause= m.getInt("VoiceRejectCause");
+        mDataRejectCause= m.getInt("DataRejectCause");
+        mCdmaNetWorkMode = m.getInt("cdmaNetWorkMode");
     }
 
     /**
@@ -996,6 +1126,13 @@ public void fillInNotifierBundle(Bundle m) {
         m.putInt("cdmaDefaultRoamingIndicator", mCdmaDefaultRoamingIndicator);
         m.putBoolean("emergencyOnly", Boolean.valueOf(mIsEmergencyOnly));
         m.putBoolean("isDataRoamingFromRegistration", Boolean.valueOf(mIsDataRoamingFromRegistration));
+         // MTK
+        m.putInt("RilVoiceRegState", mRilVoiceRegState);
+        m.putInt("RilDataRegState", mRilDataRegState);
+        m.putInt("proprietaryDataRadioTechnology", mProprietaryDataRadioTechnology);
+        m.putInt("VoiceRejectCause", mVoiceRejectCause);
+        m.putInt("DataRejectCause", mDataRejectCause);
+        m.putInt("cdmaNetWorkMode", mCdmaNetWorkMode);
     }
 
     /** @hide */
@@ -1210,4 +1347,169 @@ public static ServiceState mergeServiceStates(ServiceState baseSs, ServiceState
 
         return newSs;
     }
+
+    // MTK
+
+    /**
+     * Get current voice network registration reject cause.
+     * See 3GPP TS 24.008,section 10.5.3.6 and Annex G.
+     * @return registration reject cause or INVALID value (-1)
+     * @hide
+     */
+    public int getVoiceRejectCause() {
+        return mVoiceRejectCause;
+    }
+
+    /**
+     * Get current data network registration reject cause.
+     * See 3GPP TS 24.008 Annex G.6 "Additional cause codes for GMM".
+     * @return registration reject cause or INVALID value (-1)
+     * @hide
+     */
+    public int getDataRejectCause() {
+        return mDataRejectCause;
+    }
+
+    /** @hide */
+    public void setVoiceRejectCause(int cause) {
+        mVoiceRejectCause = cause;
+    }
+
+    /** @hide */
+    public void setDataRejectCause(int cause) {
+        mDataRejectCause = cause;
+    }
+
+    //[ALPS01675318] -START
+    /** @hide */
+    public int getProprietaryDataRadioTechnology() {
+        return this.mProprietaryDataRadioTechnology;
+    }
+
+    /** @hide */
+    public void setProprietaryDataRadioTechnology(int rt) {
+        if (rt > ServiceState.RIL_RADIO_TECHNOLOGY_MTK) {
+            if (DBG) Rlog.d(LOG_TAG, "[ServiceState] setProprietaryDataRadioTechnology =" + rt);
+            mProprietaryDataRadioTechnology = rt;
+            //carrier aggregation
+            if (rt == ServiceState.RIL_RADIO_TECHNOLOGY_LTEA) {
+                // xen0n: for CM CAF code
+                // rt = ServiceState.RIL_RADIO_TECHNOLOGY_LTE;
+                rt = ServiceState.RIL_RADIO_TECHNOLOGY_LTE_CA;
+            } else {
+                rt = ServiceState.RIL_RADIO_TECHNOLOGY_HSPAP;
+            }
+        } else {
+            if (DBG) Rlog.d(LOG_TAG, "[ServiceState] setProprietaryDataRadioTechnology=0");
+            mProprietaryDataRadioTechnology = 0;
+        }
+        setRilDataRadioTechnology(rt);
+    }
+
+    /** @hide */
+    public int getRegState() {
+        return getRilVoiceRegState();
+    }
+
+   /** @hide */
+    public int getRilVoiceRegState() {
+        return mRilVoiceRegState;
+    }
+
+   /** @hide */
+    public int getRilDataRegState() {
+        return mRilDataRegState;
+    }
+
+    /**
+     * @hide
+     */
+    public void setRegState(int nRegState) {
+        setRilVoiceRegState(nRegState);
+    }
+
+    /**
+     * @hide
+     */
+    public void setRilVoiceRegState(int nRegState) {
+        mRilVoiceRegState = nRegState;
+    }
+
+    /**
+     * @hide
+     */
+    public void setRilDataRegState(int nDataRegState) {
+        mRilDataRegState = nDataRegState;
+    }
+
+    /**
+     * @hide
+     */
+    public boolean isVoiceRadioTechnologyHigher(int nRadioTechnology) {
+        return compareTwoRadioTechnology(mRilVoiceRadioTechnology, nRadioTechnology);
+    }
+
+    /**
+     * @hide
+     */
+     public boolean isDataRadioTechnologyHigher(int nRadioTechnology) {
+        return compareTwoRadioTechnology(mRilDataRadioTechnology, nRadioTechnology);
+    }
+
+    /**
+     * @hide
+     */
+     public boolean compareTwoRadioTechnology(int nRadioTechnology1, int nRadioTechnology2) {
+         if (nRadioTechnology1 == nRadioTechnology2) {
+             return false;
+         } else if (nRadioTechnology1 == RIL_RADIO_TECHNOLOGY_LTE) {
+             return true;
+         } else if (nRadioTechnology2 == RIL_RADIO_TECHNOLOGY_LTE) {
+             return false;
+         // xen0n: take CAF constant into consideration
+         // reason for not using or expressions is just for cleaner diff
+         } else if (nRadioTechnology1 == RIL_RADIO_TECHNOLOGY_LTE_CA) {
+             return true;
+         } else if (nRadioTechnology2 == RIL_RADIO_TECHNOLOGY_LTE_CA) {
+             return false;
+         // xen0n end
+         } else if (nRadioTechnology1 == RIL_RADIO_TECHNOLOGY_GSM) {
+             // ALPS02230032-START
+             if (nRadioTechnology2 == RIL_RADIO_TECHNOLOGY_UNKNOWN) {
+                 return true;
+             }
+             // ALPS00230032-END
+             return false;
+         } else if (nRadioTechnology2 == RIL_RADIO_TECHNOLOGY_GSM) {
+             // ALPS02230032-START
+             if (nRadioTechnology1 == RIL_RADIO_TECHNOLOGY_UNKNOWN) {
+                 return false;
+             }
+             // ALPS00230032-END
+             return true;
+         } else if (nRadioTechnology1 > nRadioTechnology2) {
+             return true;
+         } else {
+             return false;
+         }
+     }
+
+     //M: MTK Added methods END
+
+
+    //support by via start [ALPS00421033]
+    /**
+     * @hide
+     */
+    public int getCdmaNetworkMode() {
+        return mCdmaNetWorkMode;
+    }
+
+    /**
+     * @hide
+     */
+    public void setCdmaNetworkMode(int networkMode) {
+        mCdmaNetWorkMode = networkMode;
+    }
+    //support by via end. [ALPS00421033]
 }
diff --git a/telephony/java/android/telephony/SubscriptionManager.java b/telephony/java/android/telephony/SubscriptionManager.java
index 32b7383..846f0c5 100644
--- a/telephony/java/android/telephony/SubscriptionManager.java
+++ b/telephony/java/android/telephony/SubscriptionManager.java
@@ -95,6 +95,63 @@
     /** @hide */
     public static final Uri CONTENT_URI = Uri.parse("content://telephony/siminfo");
 
+    // MTK
+    /** @hide */
+    public static final int LTE_DC_PHONE_ID = TelephonyManager.getDefault().getPhoneCount();
+
+    /**
+     * M: Indicates the specified phone id for slot1 LteDcPhone.
+     */
+    /** @hide */
+    public static final int LTE_DC_PHONE_ID_1 = 10;
+
+    /**
+     * M: Indicates the specified phone id for slot2 LteDcPhone.
+     */
+    /** @hide */
+    public static final int LTE_DC_PHONE_ID_2 = 11;
+
+    /**
+     * M: Indicates the specified subscription identifier for LteDcPhone.
+     */
+    /** @hide */
+    public static final int LTE_DC_SUB_ID = -999;
+
+    /**
+     * M: Indicates the specified subscription identifier for slot1 LteDcPhone.
+     */
+    /** @hide */
+    public static final int LTE_DC_SUB_ID_1 = -10;
+
+    /**
+     * M: Indicates the specified subscription identifier for slot2 LteDcPhone.
+     */
+    /** @hide */
+    public static final int LTE_DC_SUB_ID_2 = -11;
+
+    private static final boolean MTK_LTEDC_SUPPORT =
+                        "1".equals(android.os.SystemProperties.get("ro.mtk_svlte_support"))
+                        || "1".equals(android.os.SystemProperties.get("ro.mtk_srlte_support"));
+
+    /** @hide */
+    public static final int EXTRA_VALUE_NEW_SIM = 1;
+    /** @hide */
+    public static final int EXTRA_VALUE_REMOVE_SIM = 2;
+    /** @hide */
+    public static final int EXTRA_VALUE_REPOSITION_SIM = 3;
+    /** @hide */
+    public static final int EXTRA_VALUE_NOCHANGE = 4;
+
+    /** @hide */
+    public static final String INTENT_KEY_DETECT_STATUS = "simDetectStatus";
+    /** @hide */
+    public static final String INTENT_KEY_SIM_COUNT = "simCount";
+    /** @hide */
+    public static final String INTENT_KEY_NEW_SIM_SLOT = "newSIMSlot";
+    /** @hide */
+    public static final String INTENT_KEY_NEW_SIM_STATUS = "newSIMStatus";
+    // MTK-END
+
     /**
      * TelephonyProvider unique key column name is the subscription id.
      * <P>Type: TEXT (String)</P>
@@ -874,6 +931,12 @@ public static int getPhoneId(int subId) {
             if (DBG) {
                 logd("[getPhoneId]- fail");
             }
+            // MTK
+            if (subId > DUMMY_SUBSCRIPTION_ID_BASE - TelephonyManager.getDefault().getSimCount()) {
+                logd("[getPhoneId]- return dummy value, subId = " + subId);
+                return (DUMMY_SUBSCRIPTION_ID_BASE  - subId);
+            }
+            // MTK-END
             return INVALID_PHONE_INDEX;
         }
 
@@ -1095,6 +1158,13 @@ public void clearDefaultsForInactiveSubIds() {
      * @hide
      */
     public static boolean isValidSubscriptionId(int subId) {
+        // MTK-START
+        // Add the special handle for LTEDC
+        if (MTK_LTEDC_SUPPORT) {
+            return subId > INVALID_SUBSCRIPTION_ID || subId == LTE_DC_SUB_ID_1
+                    || subId == LTE_DC_SUB_ID_2;
+        }
+        // MTK-END
         return subId > INVALID_SUBSCRIPTION_ID ;
     }
 
@@ -1114,6 +1184,13 @@ public static boolean isValidSlotId(int slotId) {
 
     /** @hide */
     public static boolean isValidPhoneId(int phoneId) {
+        // MTK-START
+        // Add the special handle for LTEDC
+        if (MTK_LTEDC_SUPPORT) {
+            return (phoneId >= 0 && phoneId < TelephonyManager.getDefault().getPhoneCount())
+                    || phoneId == LTE_DC_PHONE_ID_1 || phoneId == LTE_DC_PHONE_ID_2;
+        }
+        // MTK-END
         return phoneId >= 0 && phoneId < TelephonyManager.getDefault().getPhoneCount();
     }
 
@@ -1332,4 +1409,148 @@ public boolean isActiveSubId(int subId) {
         }
         return false;
     }
+
+    // MTK
+
+    /**
+     * Get subId associated with the slotId.
+     * @param phoneId the specified phoneId
+     * @return subId as a positive integer
+     * INVALID_SUBSCRIPTION_ID if an invalid phone index
+     * @hide
+     */
+    public static int getSubIdUsingPhoneId(int phoneId) {
+        if (VDBG) logd("[getSubIdUsingPhoneId]+ phoneId:" + phoneId);
+
+        int subId = INVALID_SUBSCRIPTION_ID;
+
+        try {
+            ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
+            if (iSub != null) {
+                subId = iSub.getSubIdUsingPhoneId(phoneId);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return subId;
+    }
+
+    // xen0n: MTK TODO
+    /**
+     * Set subId as default SubId.
+     * @param subId the specified subId
+     * @hide
+     */
+    /*
+    public static void setDefaultSubId(int subId) {
+        if (VDBG) logd("setDefaultSubId sub id = " + subId);
+
+        if (subId <= 0) {
+            printStackTrace("setDefaultSubId subId 0");
+        }
+
+        try {
+            ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
+            if (iSub != null) {
+                iSub.setDefaultFallbackSubId(subId);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+    */
+
+    // MTK-START
+    // FIXME: getSubscriptionInfo and getSubscriptionInfoForIccId seem could be removed.
+    // It could be replace by AOSP API. It seems only for simple usage.
+    // xen0n: What, you know it already? Then why do you write and use them in the first place? :-/
+    /**
+     * Get the SubscriptionInfo with the subId key.
+     * @param subId The unique SubscriptionInfo key in database
+     * @return SubscriptionInfo, maybe null if not found
+     * @hide
+     */
+    /*
+    public SubscriptionInfo getSubscriptionInfo(int subId) {
+        if (VDBG) {
+            logd("[getSubscriptionInfo]+ subId=" + subId);
+        }
+
+        if (!isValidSubscriptionId(subId)) {
+            logd("[getSubscriptionInfo]- invalid subId, subId = " + subId);
+            return null;
+        }
+
+        SubscriptionInfo subInfo = null;
+
+        try {
+            ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
+            if (iSub != null) {
+                subInfo = iSub.getSubscriptionInfo(subId);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return subInfo;
+    }
+    */
+
+    /**
+     * Get the SubscriptionInfo associated with the iccId.
+     * @param iccId the IccId of SIM card
+     * @return SubscriptionInfo, maybe null if not found
+     * @hide
+     */
+    /*
+    public SubscriptionInfo getSubscriptionInfoForIccId(String iccId) {
+        if (VDBG) {
+            logd("[getSubscriptionInfoForIccId]+ iccId=" + iccId);
+        }
+
+        if (iccId == null) {
+            logd("[getSubscriptionInfoForIccId]- null iccid");
+            return null;
+        }
+
+        SubscriptionInfo result = null;
+
+        try {
+            ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
+            if (iSub != null) {
+                result = iSub.getSubscriptionInfoForIccId(iccId);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return result;
+    }
+    */
+
+    /**
+     * Set deafult data sub ID without invoking capability switch.
+     * @param subId the default data sub ID
+     * @hide
+     */
+    /*
+    public void setDefaultDataSubIdWithoutCapabilitySwitch(int subId) {
+        if (VDBG) { logd("setDefaultDataSubIdWithoutCapabilitySwitch sub id = " + subId); }
+
+        if (subId <= 0) {
+            printStackTrace("setDefaultDataSubIdWithoutCapabilitySwitch subId 0");
+        }
+
+        try {
+            ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
+            if (iSub != null) {
+                iSub.setDefaultDataSubIdWithoutCapabilitySwitch(subId);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+    */
+    // MTK-END
 }
diff --git a/telephony/java/com/android/ims/ImsCallForwardInfoEx.aidl b/telephony/java/com/android/ims/ImsCallForwardInfoEx.aidl
new file mode 100644
index 0000000..796ea10
--- /dev/null
+++ b/telephony/java/com/android/ims/ImsCallForwardInfoEx.aidl
@@ -0,0 +1,40 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package com.android.ims;
+
+parcelable ImsCallForwardInfoEx;
diff --git a/telephony/java/com/android/ims/ImsCallForwardInfoEx.java b/telephony/java/com/android/ims/ImsCallForwardInfoEx.java
new file mode 100644
index 0000000..ee3b752
--- /dev/null
+++ b/telephony/java/com/android/ims/ImsCallForwardInfoEx.java
@@ -0,0 +1,126 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package com.android.ims;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import java.util.Arrays;
+
+/**
+ * Provides the call forward information for the supplementary service configuration.
+ *
+ * @hide
+ */
+public class ImsCallForwardInfoEx implements Parcelable {
+    // Refer to ImsUtInterface#CDIV_CF_XXX
+    public int mCondition;
+    // 0: disabled, 1: enabled
+    public int mStatus;
+    // Sum of CommandsInterface.SERVICE_CLASS
+    public int mServiceClass;
+    // 0x91: International, 0x81: Unknown
+    public int mToA;
+    // Number (it will not include the "sip" or "tel" URI scheme)
+    public String mNumber;
+    // No reply timer for CF
+    public int mTimeSeconds;
+    // Time slot for CF
+    public long[] mTimeSlot;
+
+    public ImsCallForwardInfoEx() {
+    }
+
+    public ImsCallForwardInfoEx(Parcel in) {
+        readFromParcel(in);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel out, int flags) {
+        out.writeInt(mCondition);
+        out.writeInt(mStatus);
+        out.writeInt(mServiceClass);
+        out.writeInt(mToA);
+        out.writeString(mNumber);
+        out.writeInt(mTimeSeconds);
+        out.writeLongArray(mTimeSlot);
+    }
+
+    @Override
+    public String toString() {
+        return super.toString() + ", Condition: " + mCondition
+            + ", Status: " + ((mStatus == 0) ? "disabled" : "enabled")
+            + ", ServiceClass: " + mServiceClass
+            + ", ToA: " + mToA + ", Number=" + mNumber
+            + ", Time (seconds): " + mTimeSeconds
+            + ", timeSlot: " + Arrays.toString(mTimeSlot);
+    }
+
+    private void readFromParcel(Parcel in) {
+        mCondition = in.readInt();
+        mStatus = in.readInt();
+        mServiceClass = in.readInt();
+        mToA = in.readInt();
+        mNumber = in.readString();
+        mTimeSeconds = in.readInt();
+        mTimeSlot = new long[2];
+        try {
+            in.readLongArray(mTimeSlot);
+        } catch (RuntimeException e) {
+            mTimeSlot = null;
+        }
+    }
+
+    public static final Creator<ImsCallForwardInfoEx> CREATOR =
+            new Creator<ImsCallForwardInfoEx>() {
+        @Override
+        public ImsCallForwardInfoEx createFromParcel(Parcel in) {
+            return new ImsCallForwardInfoEx(in);
+        }
+
+        @Override
+        public ImsCallForwardInfoEx[] newArray(int size) {
+            return new ImsCallForwardInfoEx[size];
+        }
+    };
+}
diff --git a/telephony/java/com/android/ims/ImsCallProfile.java b/telephony/java/com/android/ims/ImsCallProfile.java
index 5f84e0c..c637b1a 100644
--- a/telephony/java/com/android/ims/ImsCallProfile.java
+++ b/telephony/java/com/android/ims/ImsCallProfile.java
@@ -179,6 +179,7 @@
      *  DisplayText: Display text for the call.
      *  AdditionalCallInfo: Additional call info.
      *  CallRadioTech: The radio tech on which the call is placed.
+     *  pau : Additional user identity information
      */
     public static final String EXTRA_OI = "oi";
     public static final String EXTRA_CNA = "cna";
@@ -189,6 +190,16 @@
     public static final String EXTRA_DISPLAY_TEXT = "DisplayText";
     public static final String EXTRA_ADDITIONAL_CALL_INFO = "AdditionalCallInfo";
 
+    // MTK
++    public static final String EXTRA_PAU = "pau";
++
++    /// M: @{
++    public static final String EXTRA_MPTY = "mpty";
++    public static final String EXTRA_INCOMING_MPTY = "incoming_mpty";
++    public static final String EXTRA_CONF_PARTICIPANT_INDEX = "conf_participant_index";
++    public static final String EXTRA_CONF_PARTICIPANT_STATE = "conf_participant_state";
++    /// @}
+
     /**
      * Extra key which the RIL can use to indicate the radio technology used for a call.
      * Valid values are:
diff --git a/telephony/java/com/android/ims/ImsReasonInfo.java b/telephony/java/com/android/ims/ImsReasonInfo.java
index 74e850b..a0ada66 100644
--- a/telephony/java/com/android/ims/ImsReasonInfo.java
+++ b/telephony/java/com/android/ims/ImsReasonInfo.java
@@ -332,4 +332,20 @@ public ImsReasonInfo createFromParcel(Parcel in) {
             return new ImsReasonInfo[size];
         }
     };
+
+     // MTK
+
+    /// M: @{
+    public static final int CODE_SIP_REDIRECTED_EMERGENCY = 329;
+    /// @}
+
+    public static final int CODE_UT_XCAP_403_FORBIDDEN = 830;
+    public static final int CODE_UT_UNKNOWN_HOST = 831;
+
+    ///M: ALPS02112553. For WFC @{
+    public static final int CODE_SIP_WIFI_SIGNAL_LOST = 905;
+    public static final int CODE_SIP_WFC_ISP_PROBLEM = 906;
+    public static final int CODE_SIP_HANDOVER_WIFI_FAIL = 907;
+    public static final int CODE_SIP_HANDOVER_LTE_FAIL = 908;
+    ///@}
 }
diff --git a/telephony/java/com/android/ims/internal/IImsCallSession.aidl b/telephony/java/com/android/ims/internal/IImsCallSession.aidl
index b1f2d32..bbca0a8 100644
--- a/telephony/java/com/android/ims/internal/IImsCallSession.aidl
+++ b/telephony/java/com/android/ims/internal/IImsCallSession.aidl
@@ -17,6 +17,7 @@
 package com.android.ims.internal;
 
 import android.os.Message;
+import android.os.Messenger;
 import com.android.ims.ImsCallProfile;
 import com.android.ims.ImsStreamMediaProfile;
 import com.android.ims.internal.IImsCallSessionListener;
@@ -255,4 +256,33 @@ interface IImsCallSession {
      * @return {@code True} if the session is multiparty.
      */
     boolean isMultiparty();
-}
+
+    // MTK
+
+    /// M: For one-key conference MT displayed as incoming conference call. @{
+    /**
+     * Determines if the current incoming session is multiparty.
+     * @return {@code True} if the incoming session is multiparty.
+     * @hide
+     */
+    boolean isIncomingCallMultiparty();
+    /// @}
+
+    /// M: ALPS02321477 @{
+    /// Google issue. Original sendDtmf could not pass Message.target to another process, because
+    /// Message.writeToParcel didn't write target. Workaround this issue by adding a new API
+    /// which passes target by Messenger.
+    /**
+     * Sends a DTMF code. According to <a href="http://tools.ietf.org/html/rfc2833">RFC 2833</a>,
+     * event 0 ~ 9 maps to decimal value 0 ~ 9, '*' to 10, '#' to 11, event 'A' ~ 'D' to 12 ~ 15,
+     * and event flash to 16. Currently, event flash is not supported. For usage of passing Message
+     * across processes.
+     *
+     * @param c the DTMF to send. '0' ~ '9', 'A' ~ 'D', '*', '#' are valid inputs.
+     * @param result.
+     * @param target Message target handler.
+     * @hide
+     */
+    void sendDtmfbyTarget(char c, in Message result, in Messenger target);
+    /// @}
+}
\ No newline at end of file
diff --git a/telephony/java/com/android/ims/internal/IImsCallSessionListener.aidl b/telephony/java/com/android/ims/internal/IImsCallSessionListener.aidl
index d562ecc..ac394d3 100644
--- a/telephony/java/com/android/ims/internal/IImsCallSessionListener.aidl
+++ b/telephony/java/com/android/ims/internal/IImsCallSessionListener.aidl
@@ -130,4 +130,17 @@ interface IImsCallSessionListener {
      */
     void callSessionSuppServiceReceived(in IImsCallSession session,
          in ImsSuppServiceNotification suppSrvNotification);
+
+	// MTK
+
+    /// M: ALPS02256671. PAU update. @{
+    /**
+     * Notifies of a change to the PAU information for this {@code ImsCallSession}.
+     *
+     * @param session The call session.
+     * @param profile The call profile.
+     * @hide
+     */
+    void callSessionPauInfoChanged(in IImsCallSession session, in ImsCallProfile profile);
+    /// @}         
 }
diff --git a/telephony/java/com/android/ims/internal/IImsService.aidl b/telephony/java/com/android/ims/internal/IImsService.aidl
index 30c48d7..ce98067 100644
--- a/telephony/java/com/android/ims/internal/IImsService.aidl
+++ b/telephony/java/com/android/ims/internal/IImsService.aidl
@@ -75,4 +75,38 @@ interface IImsService {
      * Used to set current TTY Mode.
      */
     void setUiTTYMode(int serviceId, int uiTtyMode, in Message onComplete);
-}
+
+    // MTK
+
+    /**
+     * call interface for allowing/refusing the incoming call indication send to App.
+     */
+    void setCallIndication(String callId, int seqNum, boolean isAllow);
+
+    /**
+     * Use to query ims enable/disable status.
+     */
+    int getImsState();
+
+    /**
+     * Use to query ims registration information.
+     */
+    boolean getImsRegInfo(int phoneId);
+
+    /**
+     * Use to query ims registration extension information.
+     */
+    String getImsExtInfo();
+
+    /**
+     * Use to hang up all calls.
+     */
+    void hangupAllCall();
+
+    ///M: WFC: Use to get WFC registration status @ {
+    /**
+     * Use to get registration status.
+     */
+    int getRegistrationStatus();
+    /// @}
+}
\ No newline at end of file
diff --git a/telephony/java/com/android/ims/internal/IImsUt.aidl b/telephony/java/com/android/ims/internal/IImsUt.aidl
index 4ab5ee3..7c84de3 100644
--- a/telephony/java/com/android/ims/internal/IImsUt.aidl
+++ b/telephony/java/com/android/ims/internal/IImsUt.aidl
@@ -111,4 +111,19 @@ interface IImsUt {
      * Sets the listener.
      */
     void setListener(in IImsUtListener listener);
+
+    // MTK
+
+    /// M: SS OP01 Ut @{
+    /**
+     * Retrieves the configuration of the call forward in time slot.
+     */
+    int queryCallForwardInTimeSlot(int condition);
+
+    /**
+     * Updates the configuration of the call forward in time slot.
+     */
+    int updateCallForwardInTimeSlot(int action, int condition,
+            String number, int timeSeconds, in long[] timeSlot);
+    /// @}
 }
diff --git a/telephony/java/com/android/ims/internal/IImsUtListener.aidl b/telephony/java/com/android/ims/internal/IImsUtListener.aidl
index 6416631..50461bb 100644
--- a/telephony/java/com/android/ims/internal/IImsUtListener.aidl
+++ b/telephony/java/com/android/ims/internal/IImsUtListener.aidl
@@ -19,6 +19,8 @@ package com.android.ims.internal;
 import android.os.Bundle;
 
 import com.android.ims.ImsCallForwardInfo;
+/// M: SS OP01 Ut
+import com.android.ims.ImsCallForwardInfoEx;
 import com.android.ims.ImsSsInfo;
 import com.android.ims.internal.IImsUt;
 import com.android.ims.ImsReasonInfo;
@@ -56,4 +58,14 @@ interface IImsUtListener {
      */
     void utConfigurationCallWaitingQueried(in IImsUt ut,
             int id, in ImsSsInfo[] cwInfo);
+
+    // MTK
+
+    /// M: SS OP01 Ut @{
+    /**
+     * Notifies the status of the call forwarding in a time slot supplementary service.
+     */
+    void utConfigurationCallForwardInTimeSlotQueried(in IImsUt ut,
+            int id, in ImsCallForwardInfoEx[] cfInfo);
+    /// @}
 }
diff --git a/telephony/java/com/android/ims/internal/IImsVideoCallCallback.aidl b/telephony/java/com/android/ims/internal/IImsVideoCallCallback.aidl
index 9499c9f..2eeb182 100644
--- a/telephony/java/com/android/ims/internal/IImsVideoCallCallback.aidl
+++ b/telephony/java/com/android/ims/internal/IImsVideoCallCallback.aidl
@@ -45,4 +45,11 @@ oneway interface IImsVideoCallCallback {
     void changeCameraCapabilities(in VideoProfile.CameraCapabilities cameraCapabilities);
 
     void changeVideoQuality(int videoQuality);
+
+    // MTK
+
+    /* M: ViLTE part start */
+    /* Different from AOSP, additional parameter "rotation" is added. */
+    void changePeerDimensionsWithAngle(int width, int height, int rotation);
+    /* M: ViLTE part end */
 }
diff --git a/telephony/java/com/android/ims/internal/IImsVideoCallProvider.aidl b/telephony/java/com/android/ims/internal/IImsVideoCallProvider.aidl
index 39e83c6..24592ff 100644
--- a/telephony/java/com/android/ims/internal/IImsVideoCallProvider.aidl
+++ b/telephony/java/com/android/ims/internal/IImsVideoCallProvider.aidl
@@ -62,4 +62,10 @@ oneway interface IImsVideoCallProvider {
     void requestCallDataUsage();
 
     void setPauseImage(in Uri uri);
+
+    // MTK
+
+    /* M: ViLTE part start */
+    void setUIMode(int mode);
+    /* M: ViLTE part end */
 }
diff --git a/telephony/java/com/android/internal/telephony/DctConstants.java b/telephony/java/com/android/internal/telephony/DctConstants.java
index a4e9486..c0307e6 100644
--- a/telephony/java/com/android/internal/telephony/DctConstants.java
+++ b/telephony/java/com/android/internal/telephony/DctConstants.java
@@ -114,7 +114,15 @@
     public static final int APN_CBS_ID = 7;
     public static final int APN_IA_ID = 8;
     public static final int APN_EMERGENCY_ID = 9;
-    public static final int APN_NUM_TYPES = 10;
+    // MTK
+    public static final int APN_DM_ID = 10;
+    public static final int APN_WAP_ID = 11;
+    public static final int APN_NET_ID = 12;
+    public static final int APN_CMMAIL_ID = 13;
+    public static final int APN_RCSE_ID = 14;
+    public static final int APN_XCAP_ID = 15;
+    public static final int APN_RCS_ID = 16;
+    public static final int APN_NUM_TYPES = APN_RCS_ID + 1;
 
     public static final int INVALID = -1;
     public static final int DISABLED = 0;
@@ -122,4 +130,30 @@
 
     public static final String APN_TYPE_KEY = "apnType";
     public static final String PROVISIONING_URL_KEY = "provisioningUrl";
-}
+
+    // MTK
+
+    /** M: start */
+    public static final int MTK_BASE = BASE + 500;
+    public static final int EVENT_DATA_ROAMING_CHANGED = MTK_BASE + 1;
+    public static final int EVENT_INIT_EMERGENCY_APN_SETTINGS = MTK_BASE + 2;
+    public static final int EVENT_APN_CHANGED_DONE = MTK_BASE + 3;
+    public static final int EVENT_SETUP_DATA_WHEN_LOADED = MTK_BASE + 4;
+    public static final int EVENT_VOICE_CALL_STARTED_PEER = MTK_BASE + 5;
+    public static final int EVENT_VOICE_CALL_ENDED_PEER = MTK_BASE + 6;
+    public static final int EVENT_FDN_CHANGED = MTK_BASE + 7;
+
+    // M: CC33 LTE.
+    public static final int EVENT_REMOVE_RESTRICT_EUTRAN = MTK_BASE + 25;
+    public static final int EVENT_RESET_PDP_DONE = MTK_BASE + 26;
+    // M: Reset Attach Apn
+    public static final int EVENT_RESET_ATTACH_APN = MTK_BASE + 27;
+    /* M: end */
+    // M: Send this event when DcTracker is creating, and all phones has been created
+    //    when handle this event. So we can do registration which need peer phone.
+    public static final int EVENT_POST_CREATE_PHONE = MTK_BASE + 28;
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    public static final int EVENT_DEFAULT_APN_REFERENCE_COUNT_CHANGED = MTK_BASE + 29;
+    public static final int EVENT_LTE_ACCESS_STRATUM_STATE = MTK_BASE +30;
+    // M: [LTE][Low Power][UL traffic shaping] End
+}
\ No newline at end of file
diff --git a/telephony/java/com/android/internal/telephony/ISub.aidl b/telephony/java/com/android/internal/telephony/ISub.aidl
index f6aef08..45d2965 100755
--- a/telephony/java/com/android/internal/telephony/ISub.aidl
+++ b/telephony/java/com/android/internal/telephony/ISub.aidl
@@ -183,4 +183,8 @@ interface ISub {
     int getSimStateForSlotIdx(int slotIdx);
 
     boolean isActiveSubId(int subId);
+
+    // MTK
+
+    int getSubIdUsingPhoneId(int phoneId);
 }
diff --git a/telephony/java/com/android/internal/telephony/IccCardConstants.java b/telephony/java/com/android/internal/telephony/IccCardConstants.java
index c1e2518..9567cd6 100644
--- a/telephony/java/com/android/internal/telephony/IccCardConstants.java
+++ b/telephony/java/com/android/internal/telephony/IccCardConstants.java
@@ -102,4 +102,113 @@ public static State intToState(int state) throws IllegalArgumentException {
             }
         }
     }
+
+    // MTK
+
+    // Added by M begin
+    /**
+     * NETWORK_SUBSET means ICC is locked on NETWORK SUBSET PERSONALIZATION.
+     * @internal
+     */
+    public static final String INTENT_VALUE_LOCKED_NETWORK_SUBSET = "NETWORK_SUBSET";
+    /**
+     * CORPORATE means ICC is locked on CORPORATE PERSONALIZATION.
+     * @internal
+     */
+    public static final String INTENT_VALUE_LOCKED_CORPORATE = "CORPORATE";
+    /**
+     * SERVICE_PROVIDER means ICC is locked on SERVICE_PROVIDER PERSONALIZATION.
+     * @internal
+     */
+    public static final String INTENT_VALUE_LOCKED_SERVICE_PROVIDER = "SERVICE_PROVIDER";
+    /**
+     * SIM means ICC is locked on SIM PERSONALIZATION.
+     * @internal
+     */
+    public static final String INTENT_VALUE_LOCKED_SIM = "SIM";
+    // Added by M end
+
+    // MTK-START
+    /**
+     * This card type is report by CDMA(VIA) modem.
+     * for CT requset to detect card type then give a warning
+     * @deprecated - use IccCardType instead
+     */
+    @Deprecated public enum CardType {
+        UIM_CARD(1),             //ICC structure, non CT UIM card
+        SIM_CARD(2),             //ICC structure, non CT SIM card
+        UIM_SIM_CARD(3),         //ICC structure, non CT dual mode card
+        UNKNOW_CARD(4),          //card is present, but can't detect type
+        CT_3G_UIM_CARD(5),       //ICC structure, CT 3G UIM card
+        CT_UIM_SIM_CARD(6),      //ICC structure, CT 3G dual mode card
+        PIN_LOCK_CARD(7),        //this card need PIN
+        CT_4G_UICC_CARD(8),      //UICC structure, CT 4G dual mode UICC card
+        NOT_CT_UICC_CARD(9),     //UICC structure, Non CT 4G dual mode UICC card
+        LOCKED_CARD(18),         //card is locked
+        CARD_NOT_INSERTED(255);  //card is not inserted
+
+        private int mValue;
+
+        public int getValue() {
+            return mValue;
+        }
+
+        /**
+         * Get CardType from integer.
+         * ASSERT: Please DON'T directly use CardType.values(), otherwise JE will occur
+         * @param cardTypeInt for cardType index.
+         * @return CardType.
+         */
+        public static IccCardConstants.CardType getCardTypeFromInt(int cardTypeInt) {
+            CardType cardType = CARD_NOT_INSERTED;
+            CardType[] cardTypes = CardType.values();
+            for (int i = 0; i < cardTypes.length; i++) {
+                if (cardTypes[i].getValue() == cardTypeInt) {
+                    cardType = cardTypes[i];
+                    break;
+                }
+            }
+            return cardType;
+        }
+
+        /**
+         * Check if it is 4G card.
+         * @return true if it is 4G card
+         */
+        public boolean is4GCard() {
+            return ((this == CT_4G_UICC_CARD) || (this == NOT_CT_UICC_CARD));
+        }
+
+        /**
+         * Check if it is 3G card.
+         * @return true if it is 3G card
+         */
+        public boolean is3GCard() {
+            return ((this == UIM_CARD) || (this == CT_UIM_SIM_CARD)
+                    || (this == CT_3G_UIM_CARD) || (this == CT_UIM_SIM_CARD));
+        }
+
+        /**
+         * Check if it is dual mode card.
+         * @return true if it is dual mode card
+         */
+        public boolean isDualModeCard() {
+            return ((this == UIM_SIM_CARD) || (this == CT_UIM_SIM_CARD)
+                    || (this == CT_4G_UICC_CARD) || (this == NOT_CT_UICC_CARD));
+        }
+
+        /**
+         * Check if it is OP09 card.
+         * @return true if it is OP09 card
+         */
+        public boolean isOPO9Card() {
+            return ((this == CT_3G_UIM_CARD) || (this == CT_UIM_SIM_CARD)
+                    || (this == CT_4G_UICC_CARD));
+        }
+
+        private CardType(int value) {
+            mValue = value;
+        }
+    }
+    // MTK-END
 }
diff --git a/telephony/java/com/android/internal/telephony/PhoneConstants.java b/telephony/java/com/android/internal/telephony/PhoneConstants.java
index 8bc1402..d3c213d 100644
--- a/telephony/java/com/android/internal/telephony/PhoneConstants.java
+++ b/telephony/java/com/android/internal/telephony/PhoneConstants.java
@@ -199,4 +199,115 @@
     public static final int AUDIO_OUTPUT_ENABLE_SPEAKER = 0;
     public static final int AUDIO_OUTPUT_DISABLE_SPEAKER = 1;
     public static final int AUDIO_OUTPUT_DEFAULT = AUDIO_OUTPUT_ENABLE_SPEAKER;
+
+    // MTK
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    // abnormal mode
+    public static final String LTE_ACCESS_STRATUM_STATE_UNKNOWN  = "unknown";
+    // power saving mode candidate
+    public static final String LTE_ACCESS_STRATUM_STATE_IDLE  = "idle";
+    // normal power mode
+    public static final String LTE_ACCESS_STRATUM_STATE_CONNECTED  = "connected";
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    public static final String LTE_ACCESS_STRATUM_STATE_KEY = "lteAccessStratumState";
+    public static final String SHARED_DEFAULT_APN_KEY = "sharedDefaultApn";
+    public static final String PS_NETWORK_TYPE_KEY = "psNetworkType";
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    /** M: APN type for device management */
+    public static final String APN_TYPE_DM = "dm";
+    /** M: APN type for WAP */
+    public static final String APN_TYPE_WAP = "wap";
+    /** M: APN type for NET */
+    public static final String APN_TYPE_NET = "net";
+    /** M: APN type for CMMAIL */
+    public static final String APN_TYPE_CMMAIL = "cmmail";
+    /** M: APN type for dedicate tethering apn */
+    public static final String APN_TYPE_TETHERING = "tethering";
+    /** M: APN type for RCSE */
+    public static final String APN_TYPE_RCSE = "rcse";
+    /** M: APN type for XCAP */
+    public static final String APN_TYPE_XCAP = "xcap";
+    /** M: APN type for RCS */
+    public static final String APN_TYPE_RCS = "rcs";
+
+    /* M: SS part */
+    // CFU query type
+    public static final String CFU_QUERY_TYPE_PROP = "persist.radio.cfu.querytype";
+    public static final String CFU_QUERY_TYPE_DEF_VALUE = "0";
+    /* M: SS part end */
+
+    /**
+     * used to query current capability switch setting value.
+     * @internal
+     */
+    public static final String PROPERTY_CAPABILITY_SWITCH = "persist.radio.simswitch";
+
+    /// M: CC055: Notify Call state with phoneType @{
+    public static final String PHONE_TYPE_KEY = "phoneType";
+    /// @}
+
+    public static final int EVENT_SUBSCRIPTION_ACTIVATED   = 500;
+    public static final int EVENT_SUBSCRIPTION_DEACTIVATED = 501;
+
+    // Added by M begin
+    // MVNO-API START
+    public static final String MVNO_TYPE_NONE = "";
+    public static final String MVNO_TYPE_SPN = "spn";
+    public static final String MVNO_TYPE_IMSI = "imsi";
+    public static final String MVNO_TYPE_PNN = "pnn";
+    public static final String MVNO_TYPE_GID = "gid";
+    // MVNO-API END
+    // Added by M end
+
+    //[ALPS01577029]-START
+    // The TELEPHONY_MISC_FEATURE_CONFIG for tester to switch some features via engineering mode
+    //Bit 1: To support auto switch rat mode to 2G only for 3M TDD csfb project when we are not in china
+    public static final int MISC_FEATURE_CONFIG_MASK_AUTO_SWITCH_RAT = 0x01;
+    //[ALPS01577029]-END
+
+    //VOLTE IMS STATE
+    public static final int IMS_STATE_DISABLED = 0;
+
+    public static final int IMS_STATE_ENABLE = 1;
+
+    public static final int IMS_STATE_ENABLING = 2;
+
+    public static final int IMS_STATE_DISABLING = 3;
+
+    /**
+     * UT/XCAP Supplementary Service request domain selection constant definitions from IR.92 A.4
+     * IMS Voice Service settings management when using CS access.
+     * UT_CSFB_PS_PREFERRED is to indicate that sending SS request in the PS domain.
+     * @internal
+     */
+    public static final int UT_CSFB_PS_PREFERRED = 0;
+    /**
+     * UT_CSFB_ONCE is to indicate that sending SS request in the CS domain once, and restore to
+     * the PS domain next time.
+     * @internal
+     */
+    public static final int UT_CSFB_ONCE = 1;
+    /**
+     * UT_CSFB_UNTIL_NEXT_BOOT is to indicate that sending SS request in the CS domain until the
+     * UE performs a power-off/power-on or the UE detects a change of USIM/ISIM.
+     # @internal
+     */
+    public static final int UT_CSFB_UNTIL_NEXT_BOOT = 2;
+
+    public static final int STATE_DISCONNECTED = 0;
+    public static final int STATE_CONNECTED = 1;
+    public static final int RAT_MODE_GSM = 0;
+    public static final int RAT_MODE_C2K = 7;
+
+    /// M:Svlte solution2 modify, used in ACTION_RADIO_TECHNOLOGY_CHANGED @{
+    public static final String OLD_PHONE_KEY = "oldphone";
+
+    public static final String OLD_SUBSCRIPTION_KEY  = "oldsubscription";
+
+    public static final String OLD_SLOT_KEY  = "oldslot";
+    /// @}
 }
diff --git a/telephony/java/com/android/internal/telephony/RILConstants.java b/telephony/java/com/android/internal/telephony/RILConstants.java
index 3c90c38..93e131e 100644
--- a/telephony/java/com/android/internal/telephony/RILConstants.java
+++ b/telephony/java/com/android/internal/telephony/RILConstants.java
@@ -77,7 +77,15 @@
     int SIM_SAP_MSG_SIZE_TOO_SMALL = 34;
     int SIM_SAP_CONNECT_OK_CALL_ONGOING = 35;
     int LCE_NOT_SUPPORTED = 36;               /* Link Capacity Estimation (LCE) not supported */
-    int INVALID_PARAMETER = 37;
+    // MTK
+    // int INVALID_PARAMETER = 37;
+    int EXTERNAL_APP_CAUSE_BEGIN = 2000;
+    int BT_SAP_UNDEFINED = 2001;    /*Used in Connect, Disconnect, Reset, Power on when reset fails with no reason. */
+    int BT_SAP_NOT_ACCESSIBLE = 2002;  /*Used in APDU when SIM card can't perform any commands anymore*/
+    int BT_SAP_CARD_REMOVED = 2003; /*Used in Connect, Reset, Power on when reset fails because SIM card doesn't exist*/
+    int INVALID_PARAMETER = 2004;
+    /// M: ALPS02147333 call control part
+    int CC_CALL_HOLD_FAILED_CAUSED_BY_TERMINATED = 6000;
 
     /* NETWORK_MODE_* See ril.h RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE */
     int NETWORK_MODE_WCDMA_PREF     = 0; /* GSM/WCDMA (WCDMA preferred) */
@@ -106,8 +114,20 @@
     int NETWORK_MODE_LTE_TDSCDMA_GSM_WCDMA   = 20; /* TD-SCDMA, GSM/WCDMA and LTE */
     int NETWORK_MODE_TDSCDMA_CDMA_EVDO_GSM_WCDMA  = 21; /*TD-SCDMA,EvDo,CDMA,GSM/WCDMA*/
     int NETWORK_MODE_LTE_TDSCDMA_CDMA_EVDO_GSM_WCDMA = 22; /* TD-SCDMA/LTE/GSM/WCDMA, CDMA, and EvDo */
+    // MTK
+    int MTK_PREFERRED_NETWORK_MODE  = (SystemProperties.getInt("ro.mtk_lte_support", 0) == 1) ? NETWORK_MODE_LTE_GSM_WCDMA : NETWORK_MODE_WCDMA_PREF;
     int PREFERRED_NETWORK_MODE      = SystemProperties.getInt("ro.telephony.default_network",
-            NETWORK_MODE_WCDMA_PREF);
+            MTK_PREFERRED_NETWORK_MODE);
+
+    // MTK
+    int DIAL_STRING_TOO_LONG = 1001;
+    int TEXT_STRING_TOO_LONG = 1002;
+    int SIM_MEM_FULL = 1003;
+    int ADDITIONAL_NUMBER_STRING_TOO_LONG = 1010;
+    int ADN_LIST_NOT_EXIST = 1011;
+    int ADDITIONAL_NUMBER_SAVE_FAILURE = 1012;
+    int EMAIL_SIZE_LIMIT = 1005;
+    int EMAIL_NAME_TOOLONG = 1006;
 
     int CDMA_CELL_BROADCAST_SMS_DISABLED = 1;
     int CDMA_CELL_BROADCAST_SMS_ENABLED  = 0;
@@ -158,6 +178,17 @@
     int LCE_STOPPED = 0;
     int LCE_ACTIVE = 1;
 
+    // MTK
+    /* PHB Storage type, PHB_XDN*/
+    int PHB_ADN = 0;
+    int PHB_FDN = 1;
+    int PHB_MSISDN = 2;
+    int PHB_ECC = 3;
+
+    /* Max PHB entryies to be read at once,
+        Refer to RIL_MAX_PHB_ENTRY defined in the ril_sim.c */
+    int PHB_MAX_ENTRY = 10;
+
 /*
 cat include/telephony/ril.h | \
    egrep '^#define' | \
@@ -334,7 +365,8 @@
     int RIL_REQUEST_STOP_LCE = 133;
     int RIL_REQUEST_PULL_LCEDATA = 134;
     int RIL_REQUEST_GET_ACTIVITY_INFO = 135;
-    int RIL_REQUEST_SIM_GET_ATR = 136;
+    // MTK please
+    // int RIL_REQUEST_SIM_GET_ATR = 136;
 
     int RIL_UNSOL_RESPONSE_BASE = 1000;
     int RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED = 1000;
@@ -384,4 +416,462 @@
     int RIL_UNSOL_STK_CC_ALPHA_NOTIFY = 1044;
     int RIL_UNSOL_LCEDATA_RECV = 1045;
     int RIL_UNSOL_STK_SEND_SMS_RESULT = 11002; /* Samsung STK */
+
+    // MTK
+
+    /* Add MTK proprietary below */
+    int RIL_REQUEST_VENDOR_BASE = 2000;
+    int RIL_REQUEST_GET_COLP = (RIL_REQUEST_VENDOR_BASE + 0);
+    int RIL_REQUEST_SET_COLP = (RIL_REQUEST_VENDOR_BASE + 1);
+    int RIL_REQUEST_GET_COLR = (RIL_REQUEST_VENDOR_BASE + 2);
+    int RIL_REQUEST_GET_CCM = (RIL_REQUEST_VENDOR_BASE + 3);
+    int RIL_REQUEST_GET_ACM = (RIL_REQUEST_VENDOR_BASE + 4);
+    int RIL_REQUEST_GET_ACMMAX = (RIL_REQUEST_VENDOR_BASE + 5);
+    int RIL_REQUEST_GET_PPU_AND_CURRENCY = (RIL_REQUEST_VENDOR_BASE + 6);
+    int RIL_REQUEST_SET_ACMMAX = (RIL_REQUEST_VENDOR_BASE + 7);
+    int RIL_REQUEST_RESET_ACM = (RIL_REQUEST_VENDOR_BASE + 8);
+    int RIL_REQUEST_SET_PPU_AND_CURRENCY = (RIL_REQUEST_VENDOR_BASE + 9);
+    int RIL_REQUEST_MODEM_POWEROFF = (RIL_REQUEST_VENDOR_BASE + 10);
+    int RIL_REQUEST_DUAL_SIM_MODE_SWITCH = (RIL_REQUEST_VENDOR_BASE + 11);
+    int RIL_REQUEST_QUERY_PHB_STORAGE_INFO = (RIL_REQUEST_VENDOR_BASE + 12);
+    int RIL_REQUEST_WRITE_PHB_ENTRY = (RIL_REQUEST_VENDOR_BASE + 13);
+    int RIL_REQUEST_READ_PHB_ENTRY = (RIL_REQUEST_VENDOR_BASE + 14);
+    int RIL_REQUEST_SET_GPRS_CONNECT_TYPE = (RIL_REQUEST_VENDOR_BASE + 15);
+    int RIL_REQUEST_SET_GPRS_TRANSFER_TYPE = (RIL_REQUEST_VENDOR_BASE + 16);
+    int RIL_REQUEST_MOBILEREVISION_AND_IMEI = (RIL_REQUEST_VENDOR_BASE + 17); //Add by mtk80372 for Barcode Number
+    int RIL_REQUEST_QUERY_SIM_NETWORK_LOCK = (RIL_REQUEST_VENDOR_BASE + 18);
+    int RIL_REQUEST_SET_SIM_NETWORK_LOCK = (RIL_REQUEST_VENDOR_BASE + 19);
+    int RIL_REQUEST_SET_SCRI = (RIL_REQUEST_VENDOR_BASE + 20);
+    int RIL_REQUEST_BTSIM_CONNECT = (RIL_REQUEST_VENDOR_BASE  21);
+    int RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF = (RIL_REQUEST_VENDOR_BASE + 22);
+    int RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM = (RIL_REQUEST_VENDOR_BASE + 23);
+    int RIL_REQUEST_BTSIM_TRANSFERAPDU = (RIL_REQUEST_VENDOR_BASE + 24);
+    int RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT = (RIL_REQUEST_VENDOR_BASE + 25);
+    int RIL_REQUEST_QUERY_ICCID = (RIL_REQUEST_VENDOR_BASE + 26);
+    int RIL_REQUEST_USIM_AUTHENTICATION = (RIL_REQUEST_VENDOR_BASE + 27);
+    int RIL_REQUEST_MODEM_POWERON = (RIL_REQUEST_VENDOR_BASE + 28);
+    int RIL_REQUEST_GET_SMS_SIM_MEM_STATUS = (RIL_REQUEST_VENDOR_BASE + 29);
+    /* 3G switch start */
+    int RIL_REQUEST_GET_PHONE_CAPABILITY = (RIL_REQUEST_VENDOR_BASE  30);
+    int RIL_REQUEST_SET_PHONE_CAPABILITY = (RIL_REQUEST_VENDOR_BASE + 31);
+    /* 3G switch end */
+    /* User controlled PLMN selector with Access Technology  begin */
+    int RIL_REQUEST_GET_POL_CAPABILITY = (RIL_REQUEST_VENDOR_BASE + 32);
+    int RIL_REQUEST_GET_POL_LIST = (RIL_REQUEST_VENDOR_BASE + 33);
+    int RIL_REQUEST_SET_POL_ENTRY = (RIL_REQUEST_VENDOR_BASE + 34);
+    /* User controlled PLMN selector with Access Technology  end */
+    /* UPB start */
+    int RIL_REQUEST_QUERY_UPB_CAPABILITY = (RIL_REQUEST_VENDOR_BASE + 35);
+    int RIL_REQUEST_EDIT_UPB_ENTRY = (RIL_REQUEST_VENDOR_BASE + 36);
+    int RIL_REQUEST_DELETE_UPB_ENTRY = (RIL_REQUEST_VENDOR_BASE + 37);
+    int RIL_REQUEST_READ_UPB_GAS_LIST = (RIL_REQUEST_VENDOR_BASE + 38);
+    int RIL_REQUEST_READ_UPB_GRP = (RIL_REQUEST_VENDOR_BASE + 39);
+    int RIL_REQUEST_WRITE_UPB_GRP = (RIL_REQUEST_VENDOR_BASE + 40);
+    /* UPB end */
+    int RIL_REQUEST_SET_SIM_RECOVERY_ON = (RIL_REQUEST_VENDOR_BASE + 41);
+    int RIL_REQUEST_GET_SIM_RECOVERY_ON = (RIL_REQUEST_VENDOR_BASE + 42);
+    int RIL_REQUEST_SET_TRM = (RIL_REQUEST_VENDOR_BASE + 43);
+    int RIL_REQUEST_DETECT_SIM_MISSING = (RIL_REQUEST_VENDOR_BASE + 44);
+    int RIL_REQUEST_GET_CALIBRATION_DATA = (RIL_REQUEST_VENDOR_BASE + 45);
+
+     //For LGE APIs start
+    int RIL_REQUEST_GET_PHB_STRING_LENGTH = (RIL_REQUEST_VENDOR_BASE + 46);
+    int RIL_REQUEST_GET_PHB_MEM_STORAGE = (RIL_REQUEST_VENDOR_BASE + 47);
+    int RIL_REQUEST_SET_PHB_MEM_STORAGE = (RIL_REQUEST_VENDOR_BASE + 48);
+    int RIL_REQUEST_READ_PHB_ENTRY_EXT = (RIL_REQUEST_VENDOR_BASE + 49);
+    int RIL_REQUEST_WRITE_PHB_ENTRY_EXT = (RIL_REQUEST_VENDOR_BASE + 50);
+
+    // requests for read/write EFsmsp
+    int RIL_REQUEST_GET_SMS_PARAMS = (RIL_REQUEST_VENDOR_BASE + 51);
+    int RIL_REQUEST_SET_SMS_PARAMS = (RIL_REQUEST_VENDOR_BASE + 52);
+
+    // NFC SEEK start
+    int RIL_REQUEST_SIM_TRANSMIT_BASIC = (RIL_REQUEST_VENDOR_BASE + 53);
+    int RIL_REQUEST_SIM_TRANSMIT_CHANNEL = (RIL_REQUEST_VENDOR_BASE + 54);
+    int RIL_REQUEST_SIM_GET_ATR = (RIL_REQUEST_VENDOR_BASE + 55);
+    // NFC SEEK end
+
+    // MTK-START, SMS part, CB extension
+    int RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO = (RIL_REQUEST_VENDOR_BASE + 56);
+    int RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO = (RIL_REQUEST_VENDOR_BASE + 57);
+    int RIL_REQUEST_GET_CB_CONFIG_INFO = (RIL_REQUEST_VENDOR_BASE + 58);
+    int RIL_REQUEST_SET_ALL_CB_LANGUAGE_ON = (RIL_REQUEST_VENDOR_BASE  59);
+    // MTK-END, SMS part, CB extension
+
+    int RIL_REQUEST_SET_ETWS = (RIL_REQUEST_VENDOR_BASE + 60);
+
+    // [New R8 modem FD]
+    int RIL_REQUEST_SET_FD_MODE = (RIL_REQUEST_VENDOR_BASE + 61);
+
+    // detach PS service request
+    int RIL_REQUEST_DETACH_PS = (RIL_REQUEST_VENDOR_BASE + 62);
+
+    int RIL_REQUEST_SIM_OPEN_CHANNEL_WITH_SW = (RIL_REQUEST_VENDOR_BASE + 63); // NFC SEEK
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @{
+    int RIL_REQUEST_SET_REG_SUSPEND_ENABLED  = (RIL_REQUEST_VENDOR_BASE + 64);
+    int RIL_REQUEST_RESUME_REGISTRATION  = (RIL_REQUEST_VENDOR_BASE + 65);
+    /// M: [C2K][IR] Support SVLTE IR feature. @}
+    int RIL_REQUEST_STORE_MODEM_TYPE = (RIL_REQUEST_VENDOR_BASE + 66);
+    int RIL_REQUEST_QUERY_MODEM_TYPE = (RIL_REQUEST_VENDOR_BASE + 67);
+    int RIL_REQUEST_SIM_INTERFACE_SWITCH = (RIL_REQUEST_VENDOR_BASE + 68);
+
+    //MTK-START [mtk80776] WiFi Calling
+    int RIL_REQUEST_UICC_SELECT_APPLICATION = (RIL_REQUEST_VENDOR_BASE + 69);
+    int RIL_REQUEST_UICC_DEACTIVATE_APPLICATION = (RIL_REQUEST_VENDOR_BASE + 70);
+    int RIL_REQUEST_UICC_APPLICATION_IO = (RIL_REQUEST_VENDOR_BASE + 71);
+    int RIL_REQUEST_UICC_AKA_AUTHENTICATE = (RIL_REQUEST_VENDOR_BASE + 72);
+    int RIL_REQUEST_UICC_GBA_AUTHENTICATE_BOOTSTRAP = (RIL_REQUEST_VENDOR_BASE + 73);
+    int RIL_REQUEST_UICC_GBA_AUTHENTICATE_NAF = (RIL_REQUEST_VENDOR_BASE + 74);
+    //MTK-END [mtk80776] WiFi Calling
+    int RIL_REQUEST_STK_EVDL_CALL_BY_AP = (RIL_REQUEST_VENDOR_BASE + 75);
+
+    // Femtocell (CSG)
+    int RIL_REQUEST_GET_FEMTOCELL_LIST  = (RIL_REQUEST_VENDOR_BASE + 76);
+    int RIL_REQUEST_ABORT_FEMTOCELL_LIST = (RIL_REQUEST_VENDOR_BASE + 77);
+    int RIL_REQUEST_SELECT_FEMTOCELL = (RIL_REQUEST_VENDOR_BASE + 78);
+
+    // For OPLMN update
+    int RIL_REQUEST_SEND_OPLMN = (RIL_REQUEST_VENDOR_BASE + 79);
+    int RIL_REQUEST_GET_OPLMN_VERSION = (RIL_REQUEST_VENDOR_BASE + 80);
+
+    // For PLMN List abort
+    int RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS = (RIL_REQUEST_VENDOR_BASE + 81);
+    // CSD
+    int RIL_REQUEST_DIAL_UP_CSD = (RIL_REQUEST_VENDOR_BASE + 82);
+
+    // M: For telephony modes update
+    int RIL_REQUEST_SET_TELEPHONY_MODE = (RIL_REQUEST_VENDOR_BASE + 83);
+
+    /// M: CC010: Add RIL interface @{
+    int RIL_REQUEST_HANGUP_ALL = (RIL_REQUEST_VENDOR_BASE + 84);
+    int RIL_REQUEST_FORCE_RELEASE_CALL = (RIL_REQUEST_VENDOR_BASE + 85);
+    int RIL_REQUEST_SET_CALL_INDICATION = (RIL_REQUEST_VENDOR_BASE + 86);
+    int RIL_REQUEST_EMERGENCY_DIAL = (RIL_REQUEST_VENDOR_BASE + 87);
+    int RIL_REQUEST_SET_ECC_SERVICE_CATEGORY = (RIL_REQUEST_VENDOR_BASE + 88);
+    int RIL_REQUEST_SET_ECC_LIST = (RIL_REQUEST_VENDOR_BASE + 89);
+    /// @}
+
+    //New SIM Authentication
+    int RIL_REQUEST_GENERAL_SIM_AUTH = (RIL_REQUEST_VENDOR_BASE + 90);
+    //ISIM
+    int RIL_REQUEST_OPEN_ICC_APPLICATION = (RIL_REQUEST_VENDOR_BASE + 91);
+    int RIL_REQUEST_GET_ICC_APPLICATION_STATUS = (RIL_REQUEST_VENDOR_BASE + 92);
+    //SIM_IO_EX
+    int RIL_REQUEST_SIM_IO_EX = (RIL_REQUEST_VENDOR_BASE + 93);
+
+    // IMS
+    int RIL_REQUEST_SET_IMS_ENABLE = (RIL_REQUEST_VENDOR_BASE + 94);
+    int RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT = (RIL_REQUEST_VENDOR_BASE + 95);
+
+    /* M: SS part */
+    ///M: For query CNAP
+    int RIL_REQUEST_SEND_CNAP = (RIL_REQUEST_VENDOR_BASE + 96);
+    int RIL_REQUEST_SET_CLIP = (RIL_REQUEST_VENDOR_BASE + 97);
+    /* M: SS part end */
+
+    // MTK-START, SMS part, CB extension
+    int RIL_REQUEST_REMOVE_CB_MESSAGE = (RIL_REQUEST_VENDOR_BASE + 104);
+    // MTK-END, SMS part, CB extension
+
+    // NAS configuration for voice call
+    // 0: voice centric
+    // 1: data centric
+    int RIL_REQUEST_SET_DATA_CENTRIC = (RIL_REQUEST_VENDOR_BASE + 105);
+
+    /// M: IMS feature. @{
+    int RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER = (RIL_REQUEST_VENDOR_BASE + 106);
+    int RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER = (RIL_REQUEST_VENDOR_BASE + 107);
+    int RIL_REQUEST_DIAL_WITH_SIP_URI = (RIL_REQUEST_VENDOR_BASE + 108);
+    int RIL_REQUEST_RESUME_CALL = (RIL_REQUEST_VENDOR_BASE + 109);
+    /// @}
+
+    /// M: CC010: Add RIL interface @{
+    int RIL_REQUEST_SET_SPEECH_CODEC_INFO = (RIL_REQUEST_VENDOR_BASE + 110);
+    /// @}
+    /// M: CC33 LTE
+    int RIL_REQUEST_SET_DATA_ON_TO_MD = (RIL_REQUEST_VENDOR_BASE + 111);
+    int RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE = (RIL_REQUEST_VENDOR_BASE + 112);
+
+    /// M: CC010: Add RIL interface @{
+    int RIL_REQUEST_SET_IMS_CALL_STATUS = (RIL_REQUEST_VENDOR_BASE + 113);
+    /// @}
+
+    /// M: For 3G VT only @{
+    int RIL_REQUEST_VT_DIAL = (RIL_REQUEST_VENDOR_BASE + 114);
+    int RIL_REQUEST_VOICE_ACCEPT = (RIL_REQUEST_VENDOR_BASE + 115);
+    int RIL_REQUEST_REPLACE_VT_CALL = (RIL_REQUEST_VENDOR_BASE + 116);
+    /// @}
+
+    //C2K SVLTE remote SIM access
+    int RIL_REQUEST_CONFIG_MODEM_STATUS = (RIL_REQUEST_VENDOR_BASE + 117);
+
+    // M: [C2K] MD IRAT RIL requests.
+    int RIL_REQUEST_SET_ACTIVE_PS_SLOT = RIL_REQUEST_VENDOR_BASE + 118;
+    int RIL_REQUEST_CONFIRM_INTER_3GPP_IRAT_CHANGE = RIL_REQUEST_VENDOR_BASE + 119;
+
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @{
+    int RIL_REQUEST_SET_SVLTE_RAT_MODE = (RIL_REQUEST_VENDOR_BASE + 120);
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @}
+
+    // M: [C2K] AP IRAT RIL requests.
+    int RIL_REQUEST_TRIGGER_LTE_BG_SEARCH = (RIL_REQUEST_VENDOR_BASE + 121);
+
+    /// M: IMS VoLTe conference dial feature. @{
+    int RIL_REQUEST_CONFERENCE_DIAL = (RIL_REQUEST_VENDOR_BASE + 122);
+    /// @}
+
+    /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+    /* To transfer IMS call context to modem */
+    int RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER = (RIL_REQUEST_VENDOR_BASE + 123);
+    /* To update IMS registration status to modem */
+    int RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS = (RIL_REQUEST_VENDOR_BASE + 124);
+    /// @}
+
+    int RIL_REQUEST_RELOAD_MODEM_TYPE = (RIL_REQUEST_VENDOR_BASE + 125);
+
+    /// M: IMS feature. @{
+    int RIL_REQUEST_HOLD_CALL = (RIL_REQUEST_VENDOR_BASE + 126);
+    /// @}
+
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @{
+    int RIL_REQUEST_SET_STK_UTK_MODE = (RIL_REQUEST_VENDOR_BASE + 127);
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @}
+
+    int RIL_REQUEST_SWITCH_ANTENNA = (RIL_REQUEST_VENDOR_BASE + 128);
+
+    // M:[C2K] deactivate link down PDN. @{
+    int RIL_REQUEST_DEACTIVATE_LINK_DOWN_PDN = (RIL_REQUEST_VENDOR_BASE + 129);
+    ///@}
+    int RIL_REQUEST_AT_COMMAND_WITH_PROXY = (RIL_REQUEST_VENDOR_BASE + 130);
+    int RIL_REQUEST_SWITCH_CARD_TYPE = (RIL_REQUEST_VENDOR_BASE + 131);
+
+    int RIL_REQUEST_ENABLE_MD3_SLEEP = (RIL_REQUEST_VENDOR_BASE + 132);
+
+    /// M: IMS ViLTe feature. @{
+    int RIL_REQUEST_VIDEO_CALL_ACCEPT = (RIL_REQUEST_VENDOR_BASE + 133);
+    /// @}
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    int RIL_REQUEST_SET_LTE_ACCESS_STRATUM_REPORT = (RIL_REQUEST_VENDOR_BASE + 134);
+    int RIL_REQUEST_SET_LTE_UPLINK_DATA_TRANSFER = (RIL_REQUEST_VENDOR_BASE + 135);
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    /// M: [EPDG] WiFi disconnect indication @{
+    int RIL_REQUEST_WIFI_DISCONNECT_IND = (RIL_REQUEST_VENDOR_BASE + 137);
+    /// @}
+
+    /// M: EPDG feature. Update PS state from MAL @{
+    int RIL_REQUEST_MAL_PS_RGEGISTRATION_STATE = (RIL_REQUEST_VENDOR_BASE + 138);
+    /// @}
+
+    int RIL_REQUEST_EVDO_SUPPORT_BASE = 2100;
+    int RIL_REQUEST_RADIO_POWER_CARD_SWITCH = (RIL_REQUEST_EVDO_SUPPORT_BASE + 0);
+
+    int RIL_UNSOL_VENDOR_BASE = 3000;
+    int RIL_UNSOL_NEIGHBORING_CELL_INFO = (RIL_UNSOL_VENDOR_BASE + 0);
+    int RIL_UNSOL_NETWORK_INFO = (RIL_UNSOL_VENDOR_BASE + 1);
+    int RIL_UNSOL_PHB_READY_NOTIFICATION = (RIL_UNSOL_VENDOR_BASE + 2);
+    int RIL_UNSOL_SIM_INSERTED_STATUS = (RIL_UNSOL_VENDOR_BASE + 3);
+    int RIL_UNSOL_RADIO_TEMPORARILY_UNAVAILABLE = (RIL_UNSOL_VENDOR_BASE + 4);
+    int RIL_UNSOL_ME_SMS_STORAGE_FULL = (RIL_UNSOL_VENDOR_BASE + 5);
+    int RIL_UNSOL_SMS_READY_NOTIFICATION = (RIL_UNSOL_VENDOR_BASE + 6);
+    int RIL_UNSOL_SCRI_RESULT = (RIL_UNSOL_VENDOR_BASE + 7);
+    int RIL_UNSOL_SIM_MISSING = (RIL_UNSOL_VENDOR_BASE + 8);
+    int RIL_UNSOL_GPRS_DETACH = (RIL_UNSOL_VENDOR_BASE + 9);
+    //MTK-START [mtk04070][120208][ALPS00233196] ATCI for unsolicited response
+    int RIL_UNSOL_ATCI_RESPONSE = (RIL_UNSOL_VENDOR_BASE + 10);
+    //MTK-END [mtk04070][120208][ALPS00233196] ATCI for unsolicited response
+    int RIL_UNSOL_SIM_RECOVERY = (RIL_UNSOL_VENDOR_BASE + 11);
+    int RIL_UNSOL_VIRTUAL_SIM_ON = (RIL_UNSOL_VENDOR_BASE + 12);
+    int RIL_UNSOL_VIRTUAL_SIM_OFF = (RIL_UNSOL_VENDOR_BASE + 13);
+    int RIL_UNSOL_INVALID_SIM = (RIL_UNSOL_VENDOR_BASE + 14);
+    int RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED = (RIL_UNSOL_VENDOR_BASE + 15);
+    int RIL_UNSOL_RESPONSE_ACMT = (RIL_UNSOL_VENDOR_BASE + 16);
+    int RIL_UNSOL_EF_CSP_PLMN_MODE_BIT = (RIL_UNSOL_VENDOR_BASE + 17);
+    int RIL_UNSOL_IMEI_LOCK = (RIL_UNSOL_VENDOR_BASE + 18);
+    int RIL_UNSOL_RESPONSE_MMRR_STATUS_CHANGED = (RIL_UNSOL_VENDOR_BASE + 19);
+    int RIL_UNSOL_SIM_PLUG_OUT = (RIL_UNSOL_VENDOR_BASE + 20);
+    int RIL_UNSOL_SIM_PLUG_IN = (RIL_UNSOL_VENDOR_BASE + 21);
+    int RIL_UNSOL_RESPONSE_ETWS_NOTIFICATION = (RIL_UNSOL_VENDOR_BASE + 22);
+    int RIL_UNSOL_RESPONSE_PLMN_CHANGED = (RIL_UNSOL_VENDOR_BASE + 23);
+    int RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED = (RIL_UNSOL_VENDOR_BASE + 24);
+    int RIL_UNSOL_STK_EVDL_CALL = (RIL_UNSOL_VENDOR_BASE + 25);
+    int RIL_UNSOL_DATA_PACKETS_FLUSH = (RIL_UNSOL_VENDOR_BASE + 26);
+    int RIL_UNSOL_FEMTOCELL_INFO = (RIL_UNSOL_VENDOR_BASE + 27);
+    int RIL_UNSOL_STK_SETUP_MENU_RESET = (RIL_UNSOL_VENDOR_BASE + 28);
+    int RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED = (RIL_UNSOL_VENDOR_BASE + 29);
+    /// M: For updating call ids for conference call after SRVCC is done.
+    int RIL_UNSOL_ECONF_SRVCC_INDICATION = (RIL_UNSOL_VENDOR_BASE + 30);
+    // IMS
+    int RIL_UNSOL_IMS_ENABLE_DONE = (RIL_UNSOL_VENDOR_BASE + 31);
+    int RIL_UNSOL_IMS_DISABLE_DONE = (RIL_UNSOL_VENDOR_BASE + 32);
+    int RIL_UNSOL_IMS_REGISTRATION_INFO = (RIL_UNSOL_VENDOR_BASE + 33);
+
+    //sm cause rac
+    int RIL_UNSOL_RAC_UPDATE = (RIL_UNSOL_VENDOR_BASE + 37);
+
+    //[VoLTE]Conf. call merged/added result
+    int RIL_UNSOL_ECONF_RESULT_INDICATION = (RIL_UNSOL_VENDOR_BASE + 38);
+
+    //Remote SIM ME lock related APIs [Start]
+    int RIL_UNSOL_MELOCK_NOTIFICATION = (RIL_UNSOL_VENDOR_BASE + 39);
+    //Remote SIM ME lock related APIs [END]
+
+    /// M: CC010: Add RIL interface @{
+    int RIL_UNSOL_CALL_FORWARDING = (RIL_UNSOL_VENDOR_BASE + 40);
+    int RIL_UNSOL_CRSS_NOTIFICATION = (RIL_UNSOL_VENDOR_BASE + 41);
+    int RIL_UNSOL_INCOMING_CALL_INDICATION = (RIL_UNSOL_VENDOR_BASE + 42);
+    int RIL_UNSOL_CIPHER_INDICATION = (RIL_UNSOL_VENDOR_BASE + 43);
+    int RIL_UNSOL_CNAP = (RIL_UNSOL_VENDOR_BASE + 44); //obsolete
+    /// @}
+    int RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED = (RIL_UNSOL_VENDOR_BASE + 45);
+    //Combine attach
+    int RIL_UNSOL_DATA_ALLOWED = (RIL_UNSOL_VENDOR_BASE + 46);
+    int RIL_UNSOL_STK_CALL_CTRL = (RIL_UNSOL_VENDOR_BASE + 47);
+    int RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_SUPPORT = (RIL_UNSOL_VENDOR_BASE + 48);
+
+    /// M: IMS feature. @{
+    int RIL_UNSOL_CALL_INFO_INDICATION = (RIL_UNSOL_VENDOR_BASE + 49);
+    /// @}
+
+    int RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO = (RIL_UNSOL_VENDOR_BASE + 50);
+    int RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION = (RIL_UNSOL_VENDOR_BASE + 51);
+    /// M: CC010: Add RIL interface @{
+    int RIL_UNSOL_SPEECH_CODEC_INFO = (RIL_UNSOL_VENDOR_BASE + 52);
+    /// @}
+
+    //MTK-START for MD state change
+    int RIL_UNSOL_MD_STATE_CHANGE = (RIL_UNSOL_VENDOR_BASE + 53);
+    //MTK-END for MD state change
+    // M: CC33 URC
+    int RIL_UNSOL_REMOVE_RESTRICT_EUTRAN = (RIL_UNSOL_VENDOR_BASE + 54);
+
+    // IMS client on AP shall get the information of MO Data Barring and SSAC barring
+    int RIL_UNSOL_MO_DATA_BARRING_INFO = (RIL_UNSOL_VENDOR_BASE + 55);
+    int RIL_UNSOL_SSAC_BARRING_INFO = (RIL_UNSOL_VENDOR_BASE + 56);
+    int RIL_UNSOL_SIP_CALL_PROGRESS_INDICATOR = (RIL_UNSOL_VENDOR_BASE + 57);
+
+    int RIL_UNSOL_ABNORMAL_EVENT = (RIL_UNSOL_VENDOR_BASE + 58);
+
+    /// M: CC071: Add Customer proprietary-IMS RIL interface . @{
+    int RIL_UNSOL_EMERGENCY_BEARER_SUPPORT_NOTIFY = (RIL_UNSOL_VENDOR_BASE + 59);
+    /// @}
+
+    /// M: [C2K] MD IRAT RIL URCs.
+    int RIL_UNSOL_INTER_3GPP_IRAT_STATE_CHANGE = RIL_UNSOL_VENDOR_BASE + 60;
+
+    // M: [C2K] AP IRAT RIL URCs.
+    int RIL_UNSOL_LTE_BG_SEARCH_STATUS = (RIL_UNSOL_VENDOR_BASE + 61);
+
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @{
+    int RIL_UNSOL_GMSS_RAT_CHANGED = (RIL_UNSOL_VENDOR_BASE + 62);
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @}
+
+    int RIL_UNSOL_CDMA_CARD_TYPE = (RIL_UNSOL_VENDOR_BASE + 63);
+
+    // IMS
+    int RIL_UNSOL_IMS_ENABLE_START = (RIL_UNSOL_VENDOR_BASE + 64);
+    int RIL_UNSOL_IMS_DISABLE_START = (RIL_UNSOL_VENDOR_BASE + 65);
+    int RIL_UNSOL_IMSI_REFRESH_DONE = (RIL_UNSOL_VENDOR_BASE + 66);
+    // M: Notify RILJ that the AT+EUSIM was received
+    int RIL_UNSOL_EUSIM_READY = (RIL_UNSOL_VENDOR_BASE + 67);
+    /// M: BIP {
+    int RIL_UNSOL_STK_BIP_PROACTIVE_COMMAND = (RIL_UNSOL_VENDOR_BASE + 68);
+    /// M: BIP }
+    //WorldMode
+    int RIL_UNSOL_WORLD_MODE_CHANGED = (RIL_UNSOL_VENDOR_BASE + 69);
+
+    /// M: For 3G VT only @{
+    int RIL_UNSOL_VT_STATUS_INFO = (RIL_UNSOL_VENDOR_BASE + 70);
+    int RIL_UNSOL_VT_RING_INFO = (RIL_UNSOL_VENDOR_BASE + 71);
+    /// @}
+
+    //External SIM [Start]
+    int RIL_UNSOL_VSIM_OPERATION_INDICATION = (RIL_UNSOL_VENDOR_BASE + 72);
+    //External SIM [End]
+
+    //Reset Attach APN
+    int RIL_UNSOL_SET_ATTACH_APN = (RIL_UNSOL_VENDOR_BASE + 73);
+
+    /// M: MAL @{
+    int RIL_UNSOL_MAL_AT_INFO = (RIL_UNSOL_VENDOR_BASE + 74);
+    //info the current 3G SIM
+    int RIL_UNSOL_MAIN_SIM_INFO = (RIL_UNSOL_VENDOR_BASE + 75);
+    /// @}
+    // M: The event for pluggin in the tray in common slot project
+    int RIL_UNSOL_TRAY_PLUG_IN = (RIL_UNSOL_VENDOR_BASE + 76);
+
+    // M: volte for call mode change notification
+    int RIL_UNSOL_CALLMOD_CHANGE_INDICATOR = (RIL_UNSOL_VENDOR_BASE + 77);
+
+    // M: vilte for video capability notification
+    int RIL_UNSOL_VIDEO_CAPABILITY_INDICATOR = (RIL_UNSOL_VENDOR_BASE + 78);
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    int RIL_UNSOL_LTE_ACCESS_STRATUM_STATE_CHANGE = (RIL_UNSOL_VENDOR_BASE + 79);
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    /* M: Add C2K proprietary start */
+    int RIL_REQUEST_C2K_BASE = 4000;
+    int RIL_REQUEST_GET_NITZ_TIME = (RIL_REQUEST_C2K_BASE + 0);
+    int RIL_REQUEST_QUERY_UIM_INSERTED = (RIL_REQUEST_C2K_BASE + 1);
+    int RIL_REQUEST_SWITCH_HPF = (RIL_REQUEST_C2K_BASE + 2);
+    int RIL_REQUEST_SET_AVOID_SYS = (RIL_REQUEST_C2K_BASE + 3);
+    int RIL_REQUEST_QUERY_AVOID_SYS = (RIL_REQUEST_C2K_BASE + 4);
+    int RIL_REQUEST_QUERY_CDMA_NETWORK_INFO = (RIL_REQUEST_C2K_BASE + 5);
+    int RIL_REQUEST_GET_LOCAL_INFO =  (RIL_REQUEST_C2K_BASE + 6);
+    int RIL_REQUEST_UTK_REFRESH = (RIL_REQUEST_C2K_BASE + 7);
+    int RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS = (RIL_REQUEST_C2K_BASE + 8);
+    int RIL_REQUEST_QUERY_NETWORK_REGISTRATION = (RIL_REQUEST_C2K_BASE + 9);
+    int RIL_REQUEST_AGPS_TCP_CONNIND = (RIL_REQUEST_C2K_BASE + 10);
+    int RIL_REQUEST_AGPS_SET_MPC_IPPORT = (RIL_REQUEST_C2K_BASE + 11);
+    int RIL_REQUEST_AGPS_GET_MPC_IPPORT = (RIL_REQUEST_C2K_BASE + 12);
+    int RIL_REQUEST_SET_MEID = (RIL_REQUEST_C2K_BASE + 13);
+    /// M: [C2K][IR] Support SVLTE IR feature. @{
+    int RIL_REQUEST_RESUME_REGISTRATION_CDMA = (RIL_REQUEST_C2K_BASE + 14);
+    int RIL_REQUEST_SET_REG_SUSPEND_ENABLED_CDMA = (RIL_REQUEST_C2K_BASE + 15);
+    /// M: [C2K][IR] Support SVLTE IR feature. @}
+    int RIL_REQUEST_SET_ETS_DEV = (RIL_REQUEST_C2K_BASE + 16);
+    int RIL_REQUEST_WRITE_MDN = (RIL_REQUEST_C2K_BASE + 17);
+    int RIL_REQUEST_SET_VIA_TRM = (RIL_REQUEST_C2K_BASE + 18);
+    int RIL_REQUEST_SET_ARSI_THRESHOLD = (RIL_REQUEST_C2K_BASE + 19);
+
+    // [C2K] [AP IRAT] RIL request.
+    int RIL_REQUEST_SET_LTE_EARFCN_ENABLED = (RIL_REQUEST_C2K_BASE + 20);
+    // [C2K] [SVLTE] C2K SVLTE CDMA RAT control.
+    int RIL_REQUEST_CONFIG_IRAT_MODE = (RIL_REQUEST_C2K_BASE + 21);
+
+   // [C2K][SVLTE] C2K SVLTE CDMA eHPRD control
+    int RIL_REQUEST_CONFIG_EVDO_MODE = (RIL_REQUEST_C2K_BASE + 22);
+    /* M: SVLTE UTK part start */
+    int RIL_REQUEST_QUERY_UTK_MENU_FROM_MD = (RIL_REQUEST_C2K_BASE + 23);
+    int RIL_REQUEST_QUERY_STK_MENU_FROM_MD = (RIL_REQUEST_C2K_BASE + 24);
+    /* M: SVLTE UTK part end */
+
+    int RIL_UNSOL_C2K_BASE = 5000;
+    int RIL_UNSOL_CDMA_CALL_ACCEPTED = (RIL_UNSOL_C2K_BASE + 0);
+    int RIL_UNSOL_UTK_SESSION_END = (RIL_UNSOL_C2K_BASE + 1);
+    int RIL_UNSOL_UTK_PROACTIVE_COMMAND = (RIL_UNSOL_C2K_BASE + 2);
+    int RIL_UNSOL_UTK_EVENT_NOTIFY = (RIL_UNSOL_C2K_BASE + 3);
+    int RIL_UNSOL_VIA_GPS_EVENT = (RIL_UNSOL_C2K_BASE + 4);
+    int RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE = (RIL_UNSOL_C2K_BASE + 5);
+    /// M: [C2K][IR] Support SVLTE IR feature. @{
+    int RIL_UNSOL_CDMA_PLMN_CHANGED = (RIL_UNSOL_C2K_BASE + 6);
+    /// M: [C2K][IR] Support SVLTE IR feature. @}
+    int RIL_UNSOL_VIA_INVALID_SIM_DETECTED = (RIL_UNSOL_C2K_BASE + 7);
+    /// M: For c2k eng mode
+    int RIL_UNSOL_ENG_MODE_NETWORK_INFO = (RIL_UNSOL_C2K_BASE + 8);
+    // M: [C2K] for ps type changed.
+    int RIL_UNSOL_RESPONSE_DATA_NETWORK_TYPE_CHANGED = (RIL_UNSOL_C2K_BASE + 9);
+    // [C2K] [AP IRAT] URCs
+    int RIL_UNSOL_LTE_EARFCN_INFO = (RIL_UNSOL_C2K_BASE + 10);
+    int RIL_UNSOL_CDMA_IMSI_READY = (RIL_UNSOL_C2K_BASE + 11);
+    // M: Notify RILJ that call fade happened
+    int RIL_UNSOL_CDMA_SIGNAL_FADE = (RIL_UNSOL_C2K_BASE + 12);
+    // M: Notify RILJ that the AT+EFNM was received
+    int RIL_UNSOL_CDMA_TONE_SIGNALS = (RIL_UNSOL_C2K_BASE + 13);
+    // M: add for ECC only
+    int RIL_UNSOL_NETWORK_EXIST = (RIL_UNSOL_C2K_BASE + 14);
+    /* M: Add C2K proprietary end */
 }
diff --git a/telephony/java/com/android/internal/telephony/TelephonyIntents.java b/telephony/java/com/android/internal/telephony/TelephonyIntents.java
index 77b8a67..1466607 100644
--- a/telephony/java/com/android/internal/telephony/TelephonyIntents.java
+++ b/telephony/java/com/android/internal/telephony/TelephonyIntents.java
@@ -417,4 +417,370 @@
      */
     public static final String ACTION_SET_RADIO_CAPABILITY_FAILED =
             "android.intent.action.ACTION_SET_RADIO_CAPABILITY_FAILED";
+
+	// MTK
+
+// M: [LTE][Low Power][UL traffic shaping] Start
+    /**
+     * Broadcast Action: The LTE access stratum state has changed.
+     * The intent will have the following extra values:</p>
+     * <dl>
+     *   <dt>phoneName</dt><dd>A string version of the phone name.</dd>
+     *   <dt>state</dt><dd>One of {@code UNKNOWN}, {@code IDLE},
+     *      or {@code CONNECTED}.</dd>
+     * </dl>
+     *
+     * <p class="note">
+     * Requires the READ_PHONE_STATE permission.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    public static final String ACTION_LTE_ACCESS_STRATUM_STATE_CHANGED
+            = "android.intent.action.LTE_ACCESS_STRATUM_STATE_CHANGED";
+
+    /**
+     * Broadcast Action: The PS network type has changed for low power feature on.
+     * The intent will have the following extra values:</p>
+     * <dl>
+     *   <dt>phoneName</dt><dd>A string version of the phone name.</dd>
+     *   <dt>nwType</dt><dd>One of
+     *          {@code NETWORK_TYPE_UNKNOWN},
+     *          {@code NETWORK_TYPE_GPRS},
+     *          {@code NETWORK_TYPE_EDGE},
+     *          {@code NETWORK_TYPE_UMTS},
+     *          {@code NETWORK_TYPE_HSDPA},
+     *          {@code NETWORK_TYPE_HSUPA},
+     *          {@code NETWORK_TYPE_HSPA} or
+     *          {@code NETWORK_TYPE_LTE}.</dd>
+     * </dl>
+     *
+     * <p class="note">
+     * Requires the READ_PHONE_STATE permission.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    public static final String ACTION_PS_NETWORK_TYPE_CHANGED
+            = "android.intent.action.PS_NETWORK_TYPE_CHANGED";
+
+    /**
+     * Broadcast Action: The shared default apn state has changed.
+     * The intent will have the following extra values:</p>
+     * <dl>
+     *   <dt>phoneName</dt><dd>A string version of the phone name.</dd>
+     *   <dt>state</dt><dd>One of {@code TRUE} or {@code FALSE}.</dd>
+     * </dl>
+     *
+     * <p class="note">
+     * Requires the READ_PHONE_STATE permission.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    public static final String ACTION_SHARED_DEFAULT_APN_STATE_CHANGED
+            = "android.intent.action.SHARED_DEFAULT_APN_STATE_CHANGED";
+// M: [LTE][Low Power][UL traffic shaping] End
+
+    /**
+     * Broadcast Action: An attempt to set phone RAT family has changed.  This has the following
+     * extra values:</p>
+     * <ul>
+     *   <li><em>phones RAT family</em> - A PhoneRatFamily array,
+     *          contain phone ID and new RAT family for each phone.</li>
+     * </ul>
+     * @internal
+     */
+    public static final String ACTION_SET_PHONE_RAT_FAMILY_DONE =
+            "android.intent.action.ACTION_SET_PHONE_RAT_FAMILY_DONE";
+    /**
+     * @internal
+     */
+    public static final String EXTRA_PHONES_RAT_FAMILY = "phonesRatFamily";
+
+    /**
+     * Broadcast Action: An attempt to set phone RAT family has failed.
+     * <ul>
+     *   <li><em>phone ID</em> - A int, indicates the failed phone.</li>
+     * </ul>
+     * @internal
+     */
+    public static final String ACTION_SET_PHONE_RAT_FAMILY_FAILED =
+            "android.intent.action.ACTION_SET_PHONE_RAT_FAMILY_FAILED";
+    /**
+     * @internal
+     */
+    public static final String EXTRA_PHONES_ID = "phoneId";
+
+    // Added by M begin
+
+    /**
+     * <p>Broadcast Action: To activate an application to unlock SIM lock.
+     * The intent will have the following extra value:</p>
+     * <dl>
+     *   <dt>reason</dt><dd>The reason why ss is {@code LOCKED}; null otherwise.</dd>
+     *   <dl>
+     *       <dt>{@code PIN}</dt><dd>locked on PIN1</dd>
+     *       <dt>{@code PUK}</dt><dd>locked on PUK1</dd>
+     *       <dt>{@code NETWORK}</dt><dd>locked on network personalization</dd>
+     *       <dt>{@code NETWORK_SUBSET}</dt><dd>locked on network subset personalization</dd>
+     *       <dt>{@code CORPORATE}</dt><dd>locked on corporate personalization</dd>
+     *       <dt>{@code SERVICE_PROVIDER}</dt><dd>locked on service proiver personalization</dd>
+     *       <dt>{@code SIM}</dt><dd>locked on SIM personalization</dd>
+     *   </dl>
+     * </dl>
+     * @internal
+     */
+     // FIXME: need to add subId, slotId, phoneId extra value comments.
+     public static final String ACTION_UNLOCK_SIM_LOCK
+            = "mediatek.intent.action.ACTION_UNLOCK_SIM_LOCK";
+
+
+     /**
+      * Broadcast Action: The sim card application state has changed. (only support ISIM currently)
+      * The intent will have the following extra values:</p>
+      * <dl>
+      *   <dt>phoneName</dt><dd>A string version of the phone name.</dd>
+      *   <dt>ss</dt><dd>The sim state. One of:
+      *     <dl>
+      *       <dt>{@code ABSENT}</dt><dd>SIM card not found</dd>
+      *       <dt>{@code LOCKED}</dt><dd>SIM card locked (see {@code reason})</dd>
+      *       <dt>{@code READY}</dt><dd>SIM card ready</dd>
+      *       <dt>{@code IMSI}</dt><dd>FIXME: what is this state?</dd>
+      *       <dt>{@code LOADED}</dt><dd>SIM card data loaded</dd>
+      *     </dl></dd>
+      *   <dt>reason</dt><dd>The reason why ss is {@code LOCKED}; null otherwise.</dd>
+      *   <dl>
+      *       <dt>{@code PIN}</dt><dd>locked on PIN1</dd>
+      *       <dt>{@code PUK}</dt><dd>locked on PUK1</dd>
+      *       <dt>{@code NETWORK}</dt><dd>locked on network personalization</dd>
+      *   </dl>
+      *   <dt>appid</dt><dd>The application id.</dd>
+      * </dl>
+      *
+      * <p class="note">This is a protected intent that can only be sent
+      * by the system.
+      */
+      // FIXME: need to add subId, slotId, phoneId extra value comments.
+     public static final String ACTION_SIM_STATE_CHANGED_MULTI_APPLICATION
+             = "mediatek.intent.action.ACTION_SIM_STATE_CHANGED_MULTI_APPLICATION";
+
+    /**
+    * Do SIM Recovery Done.
+    */
+    public static final String ACTION_SIM_RECOVERY_DONE = "com.android.phone.ACTION_SIM_RECOVERY_DONE";
+
+    // ALPS00302698 ENS
+    /**
+       * This event is broadcasted when CSP PLMN is changed
+       * @internal
+       */
+    public static final String ACTION_EF_CSP_CONTENT_NOTIFY = "android.intent.action.ACTION_EF_CSP_CONTENT_NOTIFY";
+    public static final String EXTRA_PLMN_MODE_BIT = "plmn_mode_bit";
+
+    // ALPS00302702 RAT balancing
+    /**
+       * This event is broadcasted when EF-RAT Mode is changed.
+       * @internal
+       */
+    public static final String ACTION_EF_RAT_CONTENT_NOTIFY = "android.intent.action.ACTION_EF_RAT_CONTENT_NOTIFY";
+    /**
+       * To notify the content of EF-RAT
+       * @internal
+       */
+    public static final String EXTRA_EF_RAT_CONTENT = "ef_rat_content";
+    /**
+       * To notify the status of EF-RAT
+       * @internal
+       */
+    public static final String EXTRA_EF_RAT_STATUS = "ef_rat_status";
+
+    public static final String ACTION_COMMON_SLOT_NO_CHANGED = "com.mediatek.phone.ACTION_COMMON_SLOT_NO_CHANGED";
+
+
+  /**
+      * Broadcast Action: ACMT Network Service Status Indicator
+      * The intent will have the following extra values:</p>
+      * <ul>
+      * <li><em>CauseCode</em> - specify the reject cause code from MM/GMM/EMM</li>
+      * <li><em>Cause</em> - the reject cause<li>
+      * </ul>
+      */
+    public static final String ACTION_ACMT_NETWORK_SERVICE_STATUS_INDICATOR
+            = "mediatek.intent.action.acmt_nw_service_status";
+
+    //MTK-START [mtk80589][121026][ALPS00376525] STK dialog pop up caused ISVR
+    public static final String ACTION_IVSR_NOTIFY
+        = "mediatek.intent.action.IVSR_NOTIFY";
+
+    public static final String INTENT_KEY_IVSR_ACTION = "action";
+    //MTK-END [mtk80589][121026][ALPS00376525] STK dialog pop up caused ISVR
+
+   /* ALPS01139189 */
+   /**
+     * This event is broadcasted when frmework start/stop hiding network state update
+     * @internal
+     */
+    public static final String ACTION_HIDE_NETWORK_STATE = "mediatek.intent.action.ACTION_HIDE_NETWORK_STATE";
+    public static final String EXTRA_ACTION = "action";
+    public static final String EXTRA_REAL_SERVICE_STATE = "state";
+
+    /**
+     * This event is broadcasted when the located PLMN is changed
+     * @internal
+     */
+    public static final String ACTION_LOCATED_PLMN_CHANGED = "mediatek.intent.action.LOCATED_PLMN_CHANGED";
+    public static final String EXTRA_ISO = "iso";
+
+  /**
+     * This extra value is the IMS registeration state
+     */
+    public static final String EXTRA_IMS_REG_STATE_KEY = "regState"; // 0: not registered  , 1: registered
+
+    // Femtocell (CSG) START
+    public static final String EXTRA_HNB_NAME   = "hnbName";
+    public static final String EXTRA_CSG_ID     = "csgId";
+    public static final String EXTRA_DOMAIN     = "domain";
+    // Femtocell (CSG) END
+
+    /**
+     * Broadcast Action: The PHB state has changed.
+     * The intent will have the following extra values:</p>
+     * <ul>
+     *   <li><em>ready</em> - The PHB ready state.  True for ready, false for not ready</li>
+     *   <li><em>simId</em> - The SIM ID</li>
+     * </ul>
+     *
+     * <p class="note">
+     * Requires the READ_PHONE_STATE permission.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     * @internal
+     */
+    public static final String ACTION_PHB_STATE_CHANGED
+            = "android.intent.action.PHB_STATE_CHANGED";
+
+    /* SIM switch start */
+    /**
+     * To notify the capability switch procedure start
+     */
+    public static String EVENT_PRE_CAPABILITY_SWITCH = "com.mediatek.PRE_CAPABILITY_SWITCH";
+    /**
+     * To notify the capability switch procedure end
+     */
+    public static String EVENT_CAPABILITY_SWITCH_DONE = "com.mediatek.CAPABILITY_SWITCH_DONE";
+    /**
+     * The target SIM Id where capability is going to set to.
+     * This is an extra information comes with EVENT_CAPABILITY_PRE_SWITCH event.
+     */
+    public static String EXTRA_MAIN_PROTOCOL_SIM = "MAIN_PROTOCOL_SIM";
+    // Added by M end
+
+    /**
+     * Broadcast Action: The modem type changed.
+     * @internal
+     * The intent will have the following extra values:</p>
+     * <ul>
+     *   <li><em>ready</em> - The modem type after switched.</li>
+     * </ul>
+     */
+    public static final String ACTION_MD_TYPE_CHANGE
+            = "android.intent.action.ACTION_MD_TYPE_CHANGE";
+    /** @internal */
+    public static final String EXTRA_MD_TYPE = "mdType";
+
+    /**
+    * This event is broadcasted when Stk Refresh with type REFRESH_RESULT_INIT,
+    * REFRESH_RESULT_RESET, REFRESH_INIT_FULL_FILE_UPDATED, REFRESH_INIT_FILE_UPDATED
+    * @internal
+    */
+    public static final String ACTION_REMOVE_IDLE_TEXT = "android.intent.aciton.stk.REMOVE_IDLE_TEXT";
+
+    /**
+    * @hide
+    */
+    public static final String ACTION_REMOVE_IDLE_TEXT_2 = "android.intent.aciton.stk.REMOVE_IDLE_TEXT_2";
+
+    /// M: IMS feature for SS Runtime  Indication. @{
+    public static final String ACTION_LTE_MESSAGE_WAITING_INDICATION = "android.intent.action.lte.mwi";
+    public static final String EXTRA_LTE_MWI_BODY = "lte_mwi_body";
+    /// @}
+
+    /// M: c2k modify, intents. @{
+    // MCC MNC Change
+    public static final String ACTION_MCC_MNC_CHANGED = "android.intent.action.MCC_MNC_CHANGED";
+    public static final String EXTRA_MCC_MNC_CHANGED_MCC = "mcc";
+    public static final String EXTRA_MCC_MNC_CHANGED_MNC = "mnc";
+    // RADIO AVAILABLE
+    public static final String ACTION_RADIO_AVAILABLE = "android.intent.action.RADIO_AVAILABLE";
+    public static final String EXTRA_RADIO_AVAILABLE_STATE = "radio_available_state";
+    /// @}
+
+    /**
+     * This event is for abnormal event for logger
+    */
+    public static final String ACTION_EXCEPTION_HAPPENED
+        = "com.mediatek.log2server.EXCEPTION_HAPPEND";
+    /**
+    * To identify CDMA card  type.
+    * For CT request, this type used for CDMA modem identify card type and report to framework
+    * <P>Type: int</P>
+    */
+    // MTK START
+    public static final String ACTION_CDMA_CARD_TYPE = "android.intent.action.CDMA_CARD_TYPE";
+    public static final String INTENT_KEY_CDMA_CARD_TYPE = "cdma_card_type";
+    public static final String INTENT_KEY_CDMA_CARD_NEW = "cdma_card_new";
+
+    public static final String ACTION_CDMA_CARD_IMSI = "android.intent.action.CDMA_CARD_IMSI";
+    public static final String INTENT_KEY_CDMA_CARD_CSIM_IMSI = "cdma_card_csim_imsi";
+    public static final String INTENT_KEY_CDMA_CARD_USIM_IMSI = "cdma_card_usim_imsi";
+    public static final String INTENT_KEY_SVLTE_MODE_SLOT_ID = "svlte_mode_slot_id";
+
+    public static final String ACTION_SVLTE_CARD_TYPE = "android.intent.action.SVLTE_CARD_TYPE";
+    public static final String INTENT_KEY_SVLTE_CARD_TYPE = "svlte_card_type";
+    // MTK END
+    /**
+     * Broadcast Action: The modem rat changed.
+     * @hide
+     * The intent will have the following extra values:</p>
+     * <ul>
+     *   <li><em>ready</em> - The modem rat after changed.</li>
+     * </ul>
+     */
+    public static final String ACTION_RAT_CHANGED
+            = "android.intent.action.ACTION_RAT_CHANGED";
+    /** @hide */
+    public static final String EXTRA_RAT = "rat";
+
+    ///M: C2k WP s2 @{
+    /**
+     * Broadcast after all Radio technology switch done.
+     */
+    public static final String ACTION_SET_RADIO_TECHNOLOGY_DONE =
+                    "com.mediatek.phone.ACTION_SET_RADIO_TECHNOLOGY_DONE";
+
+    /**
+     * Broadcast Radio technology switch start.
+     */
+    public static final String ACTION_SET_RADIO_TECHNOLOGY_START =
+                    "com.mediatek.phone.ACTION_SET_RADIO_TECHNOLOGY_START";
+    ///@}
+
+    /**
+     * Broadcast Action: The world mode changed.
+     * The intent will have the following extra values:</p>
+     * <ul>
+     *   <li><em>worldModeState</em> - An int with one of the following values:
+     *          {@link com.mediatek.internal.telephony.worldphone.WorldMode#MD_WM_CHANGED_START} or
+     *          {@link com.mediatek.internal.telephony.worldphone.WorldMode#MD_WM_CHANGED_END}
+     *   </li>
+     * </ul>
+     */
+    public static final String ACTION_WORLD_MODE_CHANGED
+            = "android.intent.action.ACTION_WORLD_MODE_CHANGED";
+    /**
+     * Broadcast world mode change state.
+     */
+    public static final String EXTRA_WORLD_MODE_CHANGE_STATE = "worldModeState";            
 }
diff --git a/telephony/java/com/android/internal/telephony/TelephonyProperties.java b/telephony/java/com/android/internal/telephony/TelephonyProperties.java
index 645c3a1..c79c55f 100644
--- a/telephony/java/com/android/internal/telephony/TelephonyProperties.java
+++ b/telephony/java/com/android/internal/telephony/TelephonyProperties.java
@@ -217,4 +217,84 @@
      *     or Earpiece, based on the default audio routing strategy.
      */
     static final String PROPERTY_VIDEOCALL_AUDIO_OUTPUT = "persist.radio.call.audio.output";
-}
+
+    // MTK
+
+    /**
+    * Indicate Modem version for stack 2.
+    */
+    static final String PROPERTY_BASEBAND_VERSION_2 = "gsm.version.baseband.2";
+
+    //[ALPS01804936]-start:fix JE when change system language to "Burmese"
+    static final String PROPERTY_OPERATOR_ALPHA_2 = "gsm.operator.alpha.2";
+    static final String PROPERTY_OPERATOR_ALPHA_3 = "gsm.operator.alpha.3";
+    static final String PROPERTY_OPERATOR_ALPHA_4 = "gsm.operator.alpha.4";
+    //[ALPS01804936]-end
+
+    // Added by M begin
+    /** The IMSI of the SIM
+     *  Availability: SIM state must be "READY"
+     */
+    static String PROPERTY_ICC_OPERATOR_IMSI   = "gsm.sim.operator.imsi";
+
+    /**
+    * Indicate if chaneing to SIM locale is processing
+    */
+   static final String PROPERTY_SIM_LOCALE_SETTINGS = "gsm.sim.locale.waiting";
+
+    /** PROPERTY_ICC_OPERATOR_DEFAULT_NAME is the operator name for plmn which origins the SIM.
+     *  Availablity: SIM state must be "READY"
+     */
+    static String PROPERTY_ICC_OPERATOR_DEFAULT_NAME = "gsm.sim.operator.default-name";
+    // Added by M end
+
+    static final String PROPERTY_ACTIVE_MD = "ril.active.md";
+
+ /**
+    * Indicate the highest radio access capability(ex: UMTS,LTE,etc.) of modem
+    */
+    static String PROPERTY_BASEBAND_CAPABILITY = "gsm.baseband.capability";
+    static String PROPERTY_BASEBAND_CAPABILITY_MD2 = "gsm.baseband.capability.md2";
+
+ /**
+    * NITZ operator long name,short name, numeric (if ever received from MM information)
+    */
+    static String PROPERTY_NITZ_OPER_CODE = "persist.radio.nitz_oper_code";
+    static String PROPERTY_NITZ_OPER_LNAME = "persist.radio.nitz_oper_lname";
+    static String PROPERTY_NITZ_OPER_SNAME = "persist.radio.nitz_oper_sname";
+
+    /** PROPERTY_TERMINAL_BASED_CALL_WAITING_MODE is the mode for the terminal-based call waiting
+     *  possible values: "disabled_tbcw", "enabled_tbcw_on" and "enabled_tbcw_off".
+     */
+    static String PROPERTY_TERMINAL_BASED_CALL_WAITING_MODE = "persist.radio.terminal-based.cw";
+    static String TERMINAL_BASED_CALL_WAITING_DISABLED = "disabled_tbcw";
+    static String TERMINAL_BASED_CALL_WAITING_ENABLED_ON = "enabled_tbcw_on";
+    static String TERMINAL_BASED_CALL_WAITING_ENABLED_OFF = "enabled_tbcw_off";
+
+    /** PROPERTY_UT_CFU_NOTIFICATION_MODE is the mode for the UT/XCAP CFU notification
+     * possible values: "disabled_ut_cfu_notification", "enabled_ut_cfu_notification_on"
+     * and "enabled_ut_cfu_notification_off".
+     */
+    static String PROPERTY_UT_CFU_NOTIFICATION_MODE = "persist.radio.ut.cfu.mode";
+    static String UT_CFU_NOTIFICATION_MODE_DISABLED = "disabled_ut_cfu_mode";
+    static String UT_CFU_NOTIFICATION_MODE_ON = "enabled_ut_cfu_mode_on";
+    static String UT_CFU_NOTIFICATION_MODE_OFF = "enabled_ut_cfu_mode_off";
+
+     /**
+     * Property to set/get svlte mode
+     * Type:  String(svlte, csfb)
+     */
+    static final String PROPERTY_RADIO_SVLTE_MODE = "persist.radio.svlte.mode";
+
+
+    /**
+     * External SIM enabled properties.
+     */
+    static final String PROPERTY_EXTERNAL_SIM_ENABLED = "gsm.external.sim.enabled";
+
+    /**
+     * External SIM inserted properties.
+     * 1: local SIM inserted, 2: remote sim inserted
+     */
+    static final String PROPERTY_EXTERNAL_SIM_INSERTED = "gsm.external.sim.inserted";
+}
\ No newline at end of file
diff --git a/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.aidl b/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.aidl
new file mode 100644
index 0000000..ffe11c7
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.aidl
@@ -0,0 +1,39 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall 
