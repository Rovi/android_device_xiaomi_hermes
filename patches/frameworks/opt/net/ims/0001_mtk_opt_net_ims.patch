From 7d4852d259875e7829a0854c64ad83a930cb4cf4 Mon Sep 17 00:00:00 2001
From: Lok Jian Ming <jianminglok@hotmail.com>
Date: Thu, 27 Oct 2016 16:08:33 +0800
Subject: [PATCH] Update for Mediatek

---
 Android.mk                                         |   51 +
 packages/Android.mk                                |    1 +
 packages/Ims/Android.mk                            |   23 +
 packages/Ims/AndroidManifest.xml                   |   16 +
 packages/Ims/NOTICE                                |   13 +
 packages/Ims/README                                |   19 +
 packages/Ims/proguard.flags                        |    0
 packages/Ims/src/com/mediatek/ims/ImsAdapter.java  |  651 +++
 packages/Ims/src/com/mediatek/ims/ImsApp.java      |   68 +
 .../Ims/src/com/mediatek/ims/ImsBaseCommands.java  |  474 ++
 .../src/com/mediatek/ims/ImsCallSessionProxy.java  | 1905 +++++++
 .../src/com/mediatek/ims/ImsCommandsInterface.java |   56 +
 .../Ims/src/com/mediatek/ims/ImsConfigStub.java    |  261 +
 .../Ims/src/com/mediatek/ims/ImsEcbmProxy.java     |   61 +
 .../src/com/mediatek/ims/ImsEventDispatcher.java   |  143 +
 .../mediatek/ims/ImsNotificationController.java    |  550 ++
 .../Ims/src/com/mediatek/ims/ImsRILAdapter.java    | 2768 +++++++++
 packages/Ims/src/com/mediatek/ims/ImsService.java  |  902 +++
 packages/Ims/src/com/mediatek/ims/ImsUtStub.java   | 1116 ++++
 .../Ims/src/com/mediatek/ims/MMTelSSTransport.java | 5861 ++++++++++++++++++++
 .../Ims/src/com/mediatek/ims/MMTelSSUtils.java     |  707 +++
 packages/Ims/src/com/mediatek/ims/VaConstants.java |   37 +
 .../mediatek/ims/XcapMobileDataNetworkManager.java |  307 +
 .../ims/internal/CallControlDispatcher.java        |  104 +
 .../com/mediatek/ims/internal/DataDispatcher.java  | 1016 ++++
 .../mediatek/ims/internal/DataDispatcherUtil.java  |   74 +
 .../ims/internal/ImsSimservsDispatcher.java        |  151 +
 .../com/mediatek/ims/internal/ImsVTProvider.java   |  484 ++
 .../mediatek/ims/internal/ImsVTProviderUtil.java   |  582 ++
 .../com/mediatek/ims/internal/ImsXuiManager.java   |   79 +
 .../src/com/mediatek/ims/internal/PcscfAddr.java   |   79 +
 .../src/com/mediatek/ims/internal/PcscfInfo.java   |  160 +
 .../com/mediatek/ims/internal/TimerDispatcher.java |  166 +
 packages/WifiOffload/Android.mk                    |   58 +
 packages/WifiOffload/AndroidManifest.xml           |   16 +
 packages/WifiOffload/README                        |   22 +
 .../jni/com_mediatek_wfo_WifiOffloadService.c      |  283 +
 .../lib/src/com/mediatek/wfo/DisconnectCause.aidl  |    6 +
 .../lib/src/com/mediatek/wfo/DisconnectCause.java  |   50 +
 .../src/com/mediatek/wfo/IWifiOffloadListener.aidl |    9 +
 .../src/com/mediatek/wfo/IWifiOffloadService.aidl  |   15 +
 .../src/com/mediatek/wfo/WifiOffloadManager.java   |   43 +
 packages/WifiOffload/proguard.flags                |    0
 .../src/com/mediatek/wfo/impl/WfoApp.java          |   63 +
 .../com/mediatek/wfo/impl/WifiOffloadService.java  |  719 +++
 packages/simservs/Android.mk                       |   18 +
 packages/simservs/README                           |   23 +
 .../simservs/capability/ActionCapabilities.java    |  134 +
 .../capability/BarringServiceCapability.java       |   56 +
 .../simservs/capability/CapabilitiesType.java      |  125 +
 .../simservs/capability/ConditionCapabilities.java |  227 +
 .../capability/DiversionServiceCapability.java     |   76 +
 .../simservs/capability/MediaConditions.java       |   70 +
 .../simservs/capability/ServiceCapabilities.java   |   29 +
 .../simservs/client/CommunicationDiversion.java    |  346 ++
 .../simservs/client/CommunicationWaiting.java      |   42 +
 .../mediatek/simservs/client/DefaultBehaviour.java |   93 +
 .../client/IncomingCommunicationBarring.java       |  177 +
 .../client/OriginatingIdentityPresentation.java    |   42 +
 ...OriginatingIdentityPresentationRestriction.java |  154 +
 .../client/OutgoingCommunicationBarring.java       |  178 +
 .../src/com/mediatek/simservs/client/SimServs.java |  904 +++
 .../com/mediatek/simservs/client/SimservType.java  |  212 +
 .../client/TerminatingIdentityPresentation.java    |   41 +
 ...TerminatingIdentityPresentationRestriction.java |  129 +
 .../mediatek/simservs/client/policy/Actions.java   |  155 +
 .../simservs/client/policy/Conditions.java         |  733 +++
 .../mediatek/simservs/client/policy/ForwardTo.java |  401 ++
 .../com/mediatek/simservs/client/policy/Rule.java  |  221 +
 .../mediatek/simservs/client/policy/RuleSet.java   |  392 ++
 .../mediatek/simservs/client/policy/Sphere.java    |   29 +
 .../simservs/client/policy/Transformations.java    |   29 +
 .../com/mediatek/simservs/client/policy/Until.java |   29 +
 .../mediatek/simservs/client/policy/Validity.java  |   29 +
 .../com/mediatek/simservs/xcap/Attributable.java   |   33 +
 .../com/mediatek/simservs/xcap/ConfigureType.java  |   17 +
 .../com/mediatek/simservs/xcap/InquireType.java    |  144 +
 .../src/com/mediatek/simservs/xcap/RuleType.java   |   40 +
 .../com/mediatek/simservs/xcap/XcapElement.java    |  575 ++
 .../com/mediatek/simservs/xcap/XcapException.java  |   79 +
 packages/simservs/test/SimservsTest.java           |  565 ++
 packages/xcap/Android.mk                           |   16 +
 packages/xcap/NOTICE                               |   15 +
 packages/xcap/README                               |   19 +
 .../xcap/src/com/mediatek/xcap/XcapClient.java     |  492 ++
 .../xcap/src/com/mediatek/xcap/XcapConstants.java  |   82 +
 .../xcap/src/com/mediatek/xcap/XcapDebugParam.java |  371 ++
 .../xcap/src/com/mediatek/xcap/uri/XcapUri.java    |  418 ++
 packages/xcap/test/XcapTester.java                 |  290 +
 src/java/com/android/ims/ImsManager.java           |  334 +-
 src/java/com/android/ims/ImsServiceBase.java       |   66 +
 src/java/com/android/ims/ImsUt.java                |   87 +
 src/java/com/android/ims/ImsUtInterface.java       |   16 +
 .../com/android/ims/internal/ImsCallSession.java   |   67 +-
 .../android/ims/internal/ImsVideoCallProvider.java |   26 +
 .../ims/internal/ImsVideoCallProviderWrapper.java  |   49 +
 .../mediatek/ims/ImsNotificationController.java    |  446 ++
 src/java/com/mediatek/ims/WfcReasonInfo.java       |  233 +
 src/java/org/gsma/joyn/Build.java                  |   79 +
 src/java/org/gsma/joyn/H264Config.java             |  148 +
 src/java/org/gsma/joyn/ICoreServiceWrapper.aidl    |   73 +
 .../joyn/IJoynServiceRegistrationListener.aidl     |   10 +
 src/java/org/gsma/joyn/Intents.java                |  143 +
 .../org/gsma/joyn/JoynContactFormatException.java  |   40 +
 src/java/org/gsma/joyn/JoynService.java            |  245 +
 .../org/gsma/joyn/JoynServiceConfiguration.java    |  684 +++
 src/java/org/gsma/joyn/JoynServiceException.java   |   36 +
 src/java/org/gsma/joyn/JoynServiceListener.java    |   41 +
 .../joyn/JoynServiceNotAvailableException.java     |   34 +
 .../joyn/JoynServiceNotRegisteredException.java    |   34 +
 .../gsma/joyn/JoynServiceRegistrationListener.java |   36 +
 src/java/org/gsma/joyn/JoynUtils.java              |   86 +
 src/java/org/gsma/joyn/Logger.java                 |  209 +
 src/java/org/gsma/joyn/Permissions.java            |  133 +
 .../org/gsma/joyn/capability/Capabilities.aidl     |    6 +
 .../org/gsma/joyn/capability/Capabilities.java     |  405 ++
 .../gsma/joyn/capability/CapabilitiesListener.java |   34 +
 .../org/gsma/joyn/capability/CapabilitiesLog.java  |  109 +
 .../gsma/joyn/capability/CapabilityService.java    |  452 ++
 .../joyn/capability/ICapabilitiesListener.aidl     |   10 +
 .../gsma/joyn/capability/ICapabilityService.aidl   |   34 +
 .../org/gsma/joyn/capability/package-info.java     |   20 +
 src/java/org/gsma/joyn/chat/Chat.java              |  482 ++
 src/java/org/gsma/joyn/chat/ChatIntent.java        |   71 +
 src/java/org/gsma/joyn/chat/ChatListener.java      |  111 +
 src/java/org/gsma/joyn/chat/ChatLog.java           |  702 +++
 src/java/org/gsma/joyn/chat/ChatMessage.aidl       |    6 +
 src/java/org/gsma/joyn/chat/ChatMessage.java       |  275 +
 src/java/org/gsma/joyn/chat/ChatService.java       |  843 +++
 .../gsma/joyn/chat/ChatServiceConfiguration.aidl   |    6 +
 .../gsma/joyn/chat/ChatServiceConfiguration.java   |  357 ++
 .../org/gsma/joyn/chat/ConferenceEventData.aidl    |    6 +
 .../org/gsma/joyn/chat/ConferenceEventData.java    |  352 ++
 .../chat/ConferenceEventData/ConferenceUser.aidl   |    6 +
 src/java/org/gsma/joyn/chat/Geoloc.aidl            |    6 +
 src/java/org/gsma/joyn/chat/Geoloc.java            |  239 +
 src/java/org/gsma/joyn/chat/GeolocMessage.aidl     |    6 +
 src/java/org/gsma/joyn/chat/GeolocMessage.java     |  123 +
 src/java/org/gsma/joyn/chat/GroupChat.java         |  696 +++
 src/java/org/gsma/joyn/chat/GroupChatIntent.java   |   74 +
 src/java/org/gsma/joyn/chat/GroupChatListener.java |  301 +
 .../gsma/joyn/chat/GroupChatSyncingListener.java   |   21 +
 src/java/org/gsma/joyn/chat/IChat.aidl             |   60 +
 src/java/org/gsma/joyn/chat/IChatListener.aidl     |   30 +
 src/java/org/gsma/joyn/chat/IChatService.aidl      |   73 +
 src/java/org/gsma/joyn/chat/IGroupChat.aidl        |   72 +
 .../org/gsma/joyn/chat/IGroupChatListener.aidl     |   76 +
 .../gsma/joyn/chat/IGroupChatSyncingListener.aidl  |   12 +
 src/java/org/gsma/joyn/chat/INewChatListener.aidl  |   12 +
 .../org/gsma/joyn/chat/IPublicAccountChat.aidl     |   11 +
 .../org/gsma/joyn/chat/ISpamReportListener.aidl    |   10 +
 src/java/org/gsma/joyn/chat/NewChatListener.java   |   51 +
 src/java/org/gsma/joyn/chat/PublicAccountChat.java |   50 +
 .../org/gsma/joyn/chat/SpamReportListener.java     |   44 +
 src/java/org/gsma/joyn/chat/package-info.java      |    5 +
 .../org/gsma/joyn/contacts/ContactsProvider.java   |   75 +
 .../org/gsma/joyn/contacts/ContactsService.java    |  447 ++
 .../org/gsma/joyn/contacts/IContactsService.aidl   |   37 +
 src/java/org/gsma/joyn/contacts/JoynContact.aidl   |    6 +
 src/java/org/gsma/joyn/contacts/JoynContact.java   |  153 +
 src/java/org/gsma/joyn/contacts/package-info.java  |    5 +
 .../org/gsma/joyn/ft/FileSpamReportListener.java   |   44 +
 src/java/org/gsma/joyn/ft/FileTransfer.java        |  393 ++
 src/java/org/gsma/joyn/ft/FileTransferIntent.java  |   98 +
 .../org/gsma/joyn/ft/FileTransferListener.java     |   74 +
 src/java/org/gsma/joyn/ft/FileTransferLog.java     |  150 +
 src/java/org/gsma/joyn/ft/FileTransferService.java |  739 +++
 .../joyn/ft/FileTransferServiceConfiguration.aidl  |    6 +
 .../joyn/ft/FileTransferServiceConfiguration.java  |  197 +
 .../org/gsma/joyn/ft/IFileSpamReportListener.aidl  |   10 +
 src/java/org/gsma/joyn/ft/IFileTransfer.aidl       |   43 +
 .../org/gsma/joyn/ft/IFileTransferListener.aidl    |   20 +
 .../org/gsma/joyn/ft/IFileTransferService.aidl     |   64 +
 .../org/gsma/joyn/ft/INewFileTransferListener.aidl |   24 +
 .../org/gsma/joyn/ft/MultiFileTransferLog.java     |  134 +
 .../org/gsma/joyn/ft/NewFileTransferListener.java  |   97 +
 src/java/org/gsma/joyn/ft/package-info.java        |    5 +
 src/java/org/gsma/joyn/gsh/GeolocSharing.java      |  272 +
 .../org/gsma/joyn/gsh/GeolocSharingIntent.java     |   53 +
 .../org/gsma/joyn/gsh/GeolocSharingListener.java   |   60 +
 .../org/gsma/joyn/gsh/GeolocSharingService.java    |  286 +
 src/java/org/gsma/joyn/gsh/IGeolocSharing.aidl     |   30 +
 .../org/gsma/joyn/gsh/IGeolocSharingListener.aidl  |   18 +
 .../org/gsma/joyn/gsh/IGeolocSharingService.aidl   |   30 +
 .../gsma/joyn/gsh/INewGeolocSharingListener.aidl   |    8 +
 .../gsma/joyn/gsh/NewGeolocSharingListener.java    |   33 +
 src/java/org/gsma/joyn/gsh/package-info.java       |    6 +
 src/java/org/gsma/joyn/ipcall/AudioCodec.aidl      |    6 +
 src/java/org/gsma/joyn/ipcall/AudioCodec.java      |  202 +
 src/java/org/gsma/joyn/ipcall/IIPCall.aidl         |   41 +
 src/java/org/gsma/joyn/ipcall/IIPCallListener.aidl |   17 +
 src/java/org/gsma/joyn/ipcall/IIPCallPlayer.aidl   |   34 +
 .../gsma/joyn/ipcall/IIPCallPlayerListener.aidl    |   16 +
 src/java/org/gsma/joyn/ipcall/IIPCallRenderer.aidl |   34 +
 .../gsma/joyn/ipcall/IIPCallRendererListener.aidl  |   16 +
 src/java/org/gsma/joyn/ipcall/IIPCallService.aidl  |   36 +
 .../org/gsma/joyn/ipcall/INewIPCallListener.aidl   |    8 +
 src/java/org/gsma/joyn/ipcall/IPCall.java          |  361 ++
 src/java/org/gsma/joyn/ipcall/IPCallIntent.java    |   71 +
 src/java/org/gsma/joyn/ipcall/IPCallListener.java  |   56 +
 src/java/org/gsma/joyn/ipcall/IPCallLog.java       |   77 +
 src/java/org/gsma/joyn/ipcall/IPCallPlayer.java    |  167 +
 .../org/gsma/joyn/ipcall/IPCallPlayerListener.java |   53 +
 src/java/org/gsma/joyn/ipcall/IPCallRenderer.java  |  163 +
 .../gsma/joyn/ipcall/IPCallRendererListener.java   |   53 +
 src/java/org/gsma/joyn/ipcall/IPCallService.java   |  415 ++
 .../joyn/ipcall/IPCallServiceConfiguration.aidl    |    6 +
 .../joyn/ipcall/IPCallServiceConfiguration.java    |  108 +
 .../org/gsma/joyn/ipcall/NewIPCallListener.java    |   33 +
 src/java/org/gsma/joyn/ipcall/VideoCodec.aidl      |    6 +
 src/java/org/gsma/joyn/ipcall/VideoCodec.java      |  291 +
 src/java/org/gsma/joyn/ipcall/package-info.java    |    5 +
 src/java/org/gsma/joyn/ish/IImageSharing.aidl      |   33 +
 .../org/gsma/joyn/ish/IImageSharingListener.aidl   |   16 +
 .../org/gsma/joyn/ish/IImageSharingService.aidl    |   34 +
 .../gsma/joyn/ish/INewImageSharingListener.aidl    |    8 +
 src/java/org/gsma/joyn/ish/ImageSharing.java       |  290 +
 src/java/org/gsma/joyn/ish/ImageSharingIntent.java |   71 +
 .../org/gsma/joyn/ish/ImageSharingListener.java    |   59 +
 src/java/org/gsma/joyn/ish/ImageSharingLog.java    |   94 +
 .../org/gsma/joyn/ish/ImageSharingService.java     |  398 ++
 .../joyn/ish/ImageSharingServiceConfiguration.aidl |    6 +
 .../joyn/ish/ImageSharingServiceConfiguration.java |  121 +
 .../org/gsma/joyn/ish/NewImageSharingListener.java |   33 +
 src/java/org/gsma/joyn/ish/package-info.java       |    6 +
 src/java/org/gsma/joyn/package-info.java           |   41 +
 .../org/gsma/joyn/session/IMultimediaSession.aidl  |   31 +
 .../joyn/session/IMultimediaSessionListener.aidl   |   16 +
 .../joyn/session/IMultimediaSessionService.aidl    |   28 +
 .../gsma/joyn/session/MultimediaMessageIntent.java |   56 +
 .../org/gsma/joyn/session/MultimediaSession.java   |  278 +
 .../gsma/joyn/session/MultimediaSessionIntent.java |   56 +
 .../joyn/session/MultimediaSessionListener.java    |   57 +
 .../joyn/session/MultimediaSessionService.java     |  250 +
 src/java/org/gsma/joyn/session/package-info.java   |    4 +
 .../gsma/joyn/vsh/INewVideoSharingListener.aidl    |    8 +
 src/java/org/gsma/joyn/vsh/IVideoPlayer.aidl       |   28 +
 .../org/gsma/joyn/vsh/IVideoPlayerListener.aidl    |   16 +
 src/java/org/gsma/joyn/vsh/IVideoRenderer.aidl     |   29 +
 .../org/gsma/joyn/vsh/IVideoRendererListener.aidl  |   17 +
 src/java/org/gsma/joyn/vsh/IVideoSharing.aidl      |   35 +
 .../org/gsma/joyn/vsh/IVideoSharingListener.aidl   |   12 +
 .../org/gsma/joyn/vsh/IVideoSharingService.aidl    |   33 +
 .../org/gsma/joyn/vsh/NewVideoSharingListener.java |   34 +
 src/java/org/gsma/joyn/vsh/VideoCodec.aidl         |    6 +
 src/java/org/gsma/joyn/vsh/VideoCodec.java         |  276 +
 src/java/org/gsma/joyn/vsh/VideoPlayer.java        |  145 +
 .../org/gsma/joyn/vsh/VideoPlayerListener.java     |   53 +
 src/java/org/gsma/joyn/vsh/VideoRenderer.java      |  140 +
 .../org/gsma/joyn/vsh/VideoRendererListener.java   |   53 +
 src/java/org/gsma/joyn/vsh/VideoSharing.java       |  300 +
 src/java/org/gsma/joyn/vsh/VideoSharingIntent.java |   77 +
 .../org/gsma/joyn/vsh/VideoSharingListener.java    |   44 +
 src/java/org/gsma/joyn/vsh/VideoSharingLog.java    |   77 +
 .../org/gsma/joyn/vsh/VideoSharingService.java     |  397 ++
 .../joyn/vsh/VideoSharingServiceConfiguration.aidl |    6 +
 .../joyn/vsh/VideoSharingServiceConfiguration.java |  101 +
 src/java/org/gsma/joyn/vsh/package-info.java       |    6 +
 258 files changed, 47802 insertions(+), 2 deletions(-)
 create mode 100644 packages/Android.mk
 create mode 100644 packages/Ims/Android.mk
 create mode 100644 packages/Ims/AndroidManifest.xml
 create mode 100644 packages/Ims/NOTICE
 create mode 100644 packages/Ims/README
 create mode 100644 packages/Ims/proguard.flags
 create mode 100644 packages/Ims/src/com/mediatek/ims/ImsAdapter.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/ImsApp.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/ImsBaseCommands.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/ImsCallSessionProxy.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/ImsCommandsInterface.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/ImsConfigStub.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/ImsEcbmProxy.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/ImsEventDispatcher.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/ImsNotificationController.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/ImsRILAdapter.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/ImsService.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/ImsUtStub.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/MMTelSSTransport.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/MMTelSSUtils.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/VaConstants.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/XcapMobileDataNetworkManager.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/internal/CallControlDispatcher.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/internal/DataDispatcher.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/internal/DataDispatcherUtil.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/internal/ImsSimservsDispatcher.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/internal/ImsVTProvider.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/internal/ImsVTProviderUtil.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/internal/ImsXuiManager.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/internal/PcscfAddr.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/internal/PcscfInfo.java
 create mode 100644 packages/Ims/src/com/mediatek/ims/internal/TimerDispatcher.java
 create mode 100644 packages/WifiOffload/Android.mk
 create mode 100644 packages/WifiOffload/AndroidManifest.xml
 create mode 100644 packages/WifiOffload/README
 create mode 100644 packages/WifiOffload/jni/com_mediatek_wfo_WifiOffloadService.c
 create mode 100644 packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.aidl
 create mode 100644 packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.java
 create mode 100644 packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadListener.aidl
 create mode 100644 packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadService.aidl
 create mode 100644 packages/WifiOffload/lib/src/com/mediatek/wfo/WifiOffloadManager.java
 create mode 100644 packages/WifiOffload/proguard.flags
 create mode 100644 packages/WifiOffload/src/com/mediatek/wfo/impl/WfoApp.java
 create mode 100644 packages/WifiOffload/src/com/mediatek/wfo/impl/WifiOffloadService.java
 create mode 100644 packages/simservs/Android.mk
 create mode 100644 packages/simservs/README
 create mode 100644 packages/simservs/src/com/mediatek/simservs/capability/ActionCapabilities.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/capability/BarringServiceCapability.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/capability/CapabilitiesType.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/capability/ConditionCapabilities.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/capability/DiversionServiceCapability.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/capability/MediaConditions.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/capability/ServiceCapabilities.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/CommunicationDiversion.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/CommunicationWaiting.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/DefaultBehaviour.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/IncomingCommunicationBarring.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentation.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentationRestriction.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/OutgoingCommunicationBarring.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/SimServs.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/SimservType.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentation.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentationRestriction.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/Actions.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/Conditions.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/ForwardTo.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/Rule.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/RuleSet.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/Sphere.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/Transformations.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/Until.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/client/policy/Validity.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/xcap/Attributable.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/xcap/ConfigureType.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/xcap/InquireType.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/xcap/RuleType.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/xcap/XcapElement.java
 create mode 100644 packages/simservs/src/com/mediatek/simservs/xcap/XcapException.java
 create mode 100644 packages/simservs/test/SimservsTest.java
 create mode 100644 packages/xcap/Android.mk
 create mode 100644 packages/xcap/NOTICE
 create mode 100644 packages/xcap/README
 create mode 100644 packages/xcap/src/com/mediatek/xcap/XcapClient.java
 create mode 100644 packages/xcap/src/com/mediatek/xcap/XcapConstants.java
 create mode 100644 packages/xcap/src/com/mediatek/xcap/XcapDebugParam.java
 create mode 100644 packages/xcap/src/com/mediatek/xcap/uri/XcapUri.java
 create mode 100644 packages/xcap/test/XcapTester.java
 create mode 100644 src/java/com/mediatek/ims/ImsNotificationController.java
 create mode 100644 src/java/com/mediatek/ims/WfcReasonInfo.java
 create mode 100644 src/java/org/gsma/joyn/Build.java
 create mode 100644 src/java/org/gsma/joyn/H264Config.java
 create mode 100644 src/java/org/gsma/joyn/ICoreServiceWrapper.aidl
 create mode 100644 src/java/org/gsma/joyn/IJoynServiceRegistrationListener.aidl
 create mode 100644 src/java/org/gsma/joyn/Intents.java
 create mode 100644 src/java/org/gsma/joyn/JoynContactFormatException.java
 create mode 100644 src/java/org/gsma/joyn/JoynService.java
 create mode 100644 src/java/org/gsma/joyn/JoynServiceConfiguration.java
 create mode 100644 src/java/org/gsma/joyn/JoynServiceException.java
 create mode 100644 src/java/org/gsma/joyn/JoynServiceListener.java
 create mode 100644 src/java/org/gsma/joyn/JoynServiceNotAvailableException.java
 create mode 100644 src/java/org/gsma/joyn/JoynServiceNotRegisteredException.java
 create mode 100644 src/java/org/gsma/joyn/JoynServiceRegistrationListener.java
 create mode 100644 src/java/org/gsma/joyn/JoynUtils.java
 create mode 100644 src/java/org/gsma/joyn/Logger.java
 create mode 100644 src/java/org/gsma/joyn/Permissions.java
 create mode 100644 src/java/org/gsma/joyn/capability/Capabilities.aidl
 create mode 100644 src/java/org/gsma/joyn/capability/Capabilities.java
 create mode 100644 src/java/org/gsma/joyn/capability/CapabilitiesListener.java
 create mode 100644 src/java/org/gsma/joyn/capability/CapabilitiesLog.java
 create mode 100644 src/java/org/gsma/joyn/capability/CapabilityService.java
 create mode 100644 src/java/org/gsma/joyn/capability/ICapabilitiesListener.aidl
 create mode 100644 src/java/org/gsma/joyn/capability/ICapabilityService.aidl
 create mode 100644 src/java/org/gsma/joyn/capability/package-info.java
 create mode 100644 src/java/org/gsma/joyn/chat/Chat.java
 create mode 100644 src/java/org/gsma/joyn/chat/ChatIntent.java
 create mode 100644 src/java/org/gsma/joyn/chat/ChatListener.java
 create mode 100644 src/java/org/gsma/joyn/chat/ChatLog.java
 create mode 100644 src/java/org/gsma/joyn/chat/ChatMessage.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/ChatMessage.java
 create mode 100644 src/java/org/gsma/joyn/chat/ChatService.java
 create mode 100644 src/java/org/gsma/joyn/chat/ChatServiceConfiguration.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/ChatServiceConfiguration.java
 create mode 100644 src/java/org/gsma/joyn/chat/ConferenceEventData.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/ConferenceEventData.java
 create mode 100644 src/java/org/gsma/joyn/chat/ConferenceEventData/ConferenceUser.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/Geoloc.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/Geoloc.java
 create mode 100644 src/java/org/gsma/joyn/chat/GeolocMessage.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/GeolocMessage.java
 create mode 100644 src/java/org/gsma/joyn/chat/GroupChat.java
 create mode 100644 src/java/org/gsma/joyn/chat/GroupChatIntent.java
 create mode 100644 src/java/org/gsma/joyn/chat/GroupChatListener.java
 create mode 100644 src/java/org/gsma/joyn/chat/GroupChatSyncingListener.java
 create mode 100644 src/java/org/gsma/joyn/chat/IChat.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/IChatListener.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/IChatService.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/IGroupChat.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/IGroupChatListener.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/IGroupChatSyncingListener.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/INewChatListener.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/IPublicAccountChat.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/ISpamReportListener.aidl
 create mode 100644 src/java/org/gsma/joyn/chat/NewChatListener.java
 create mode 100644 src/java/org/gsma/joyn/chat/PublicAccountChat.java
 create mode 100644 src/java/org/gsma/joyn/chat/SpamReportListener.java
 create mode 100644 src/java/org/gsma/joyn/chat/package-info.java
 create mode 100644 src/java/org/gsma/joyn/contacts/ContactsProvider.java
 create mode 100644 src/java/org/gsma/joyn/contacts/ContactsService.java
 create mode 100644 src/java/org/gsma/joyn/contacts/IContactsService.aidl
 create mode 100644 src/java/org/gsma/joyn/contacts/JoynContact.aidl
 create mode 100644 src/java/org/gsma/joyn/contacts/JoynContact.java
 create mode 100644 src/java/org/gsma/joyn/contacts/package-info.java
 create mode 100644 src/java/org/gsma/joyn/ft/FileSpamReportListener.java
 create mode 100644 src/java/org/gsma/joyn/ft/FileTransfer.java
 create mode 100644 src/java/org/gsma/joyn/ft/FileTransferIntent.java
 create mode 100644 src/java/org/gsma/joyn/ft/FileTransferListener.java
 create mode 100644 src/java/org/gsma/joyn/ft/FileTransferLog.java
 create mode 100644 src/java/org/gsma/joyn/ft/FileTransferService.java
 create mode 100644 src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.aidl
 create mode 100644 src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.java
 create mode 100644 src/java/org/gsma/joyn/ft/IFileSpamReportListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ft/IFileTransfer.aidl
 create mode 100644 src/java/org/gsma/joyn/ft/IFileTransferListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ft/IFileTransferService.aidl
 create mode 100644 src/java/org/gsma/joyn/ft/INewFileTransferListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ft/MultiFileTransferLog.java
 create mode 100644 src/java/org/gsma/joyn/ft/NewFileTransferListener.java
 create mode 100644 src/java/org/gsma/joyn/ft/package-info.java
 create mode 100644 src/java/org/gsma/joyn/gsh/GeolocSharing.java
 create mode 100644 src/java/org/gsma/joyn/gsh/GeolocSharingIntent.java
 create mode 100644 src/java/org/gsma/joyn/gsh/GeolocSharingListener.java
 create mode 100644 src/java/org/gsma/joyn/gsh/GeolocSharingService.java
 create mode 100644 src/java/org/gsma/joyn/gsh/IGeolocSharing.aidl
 create mode 100644 src/java/org/gsma/joyn/gsh/IGeolocSharingListener.aidl
 create mode 100644 src/java/org/gsma/joyn/gsh/IGeolocSharingService.aidl
 create mode 100644 src/java/org/gsma/joyn/gsh/INewGeolocSharingListener.aidl
 create mode 100644 src/java/org/gsma/joyn/gsh/NewGeolocSharingListener.java
 create mode 100644 src/java/org/gsma/joyn/gsh/package-info.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/AudioCodec.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/AudioCodec.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IIPCall.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IIPCallListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IIPCallPlayer.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IIPCallPlayerListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IIPCallRenderer.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IIPCallRendererListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IIPCallService.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/INewIPCallListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCall.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallIntent.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallListener.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallLog.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallPlayer.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallPlayerListener.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallRenderer.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallRendererListener.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallService.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/NewIPCallListener.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/VideoCodec.aidl
 create mode 100644 src/java/org/gsma/joyn/ipcall/VideoCodec.java
 create mode 100644 src/java/org/gsma/joyn/ipcall/package-info.java
 create mode 100644 src/java/org/gsma/joyn/ish/IImageSharing.aidl
 create mode 100644 src/java/org/gsma/joyn/ish/IImageSharingListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ish/IImageSharingService.aidl
 create mode 100644 src/java/org/gsma/joyn/ish/INewImageSharingListener.aidl
 create mode 100644 src/java/org/gsma/joyn/ish/ImageSharing.java
 create mode 100644 src/java/org/gsma/joyn/ish/ImageSharingIntent.java
 create mode 100644 src/java/org/gsma/joyn/ish/ImageSharingListener.java
 create mode 100644 src/java/org/gsma/joyn/ish/ImageSharingLog.java
 create mode 100644 src/java/org/gsma/joyn/ish/ImageSharingService.java
 create mode 100644 src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.aidl
 create mode 100644 src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.java
 create mode 100644 src/java/org/gsma/joyn/ish/NewImageSharingListener.java
 create mode 100644 src/java/org/gsma/joyn/ish/package-info.java
 create mode 100644 src/java/org/gsma/joyn/package-info.java
 create mode 100644 src/java/org/gsma/joyn/session/IMultimediaSession.aidl
 create mode 100644 src/java/org/gsma/joyn/session/IMultimediaSessionListener.aidl
 create mode 100644 src/java/org/gsma/joyn/session/IMultimediaSessionService.aidl
 create mode 100644 src/java/org/gsma/joyn/session/MultimediaMessageIntent.java
 create mode 100644 src/java/org/gsma/joyn/session/MultimediaSession.java
 create mode 100644 src/java/org/gsma/joyn/session/MultimediaSessionIntent.java
 create mode 100644 src/java/org/gsma/joyn/session/MultimediaSessionListener.java
 create mode 100644 src/java/org/gsma/joyn/session/MultimediaSessionService.java
 create mode 100644 src/java/org/gsma/joyn/session/package-info.java
 create mode 100644 src/java/org/gsma/joyn/vsh/INewVideoSharingListener.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/IVideoPlayer.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/IVideoPlayerListener.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/IVideoRenderer.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/IVideoRendererListener.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/IVideoSharing.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/IVideoSharingListener.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/IVideoSharingService.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/NewVideoSharingListener.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoCodec.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoCodec.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoPlayer.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoPlayerListener.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoRenderer.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoRendererListener.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoSharing.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoSharingIntent.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoSharingListener.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoSharingLog.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoSharingService.java
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.aidl
 create mode 100644 src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.java
 create mode 100644 src/java/org/gsma/joyn/vsh/package-info.java

diff --git a/Android.mk b/Android.mk
index ee92ea6..dec60bd 100644
--- a/Android.mk
+++ b/Android.mk
@@ -20,9 +20,60 @@ LOCAL_AIDL_INCLUDES := $(LOCAL_PATH)/src/java
 LOCAL_SRC_FILES := \
     $(call all-java-files-under, src/java)
 
+# MTK
+LOCAL_SRC_FILES += \
+    src/java/org/gsma/joyn/IJoynServiceRegistrationListener.aidl\
+    src/java/org/gsma/joyn/capability/ICapabilitiesListener.aidl\
+    src/java/org/gsma/joyn/capability/ICapabilityService.aidl\
+    src/java/org/gsma/joyn/chat/IChat.aidl\
+    src/java/org/gsma/joyn/chat/IChatListener.aidl\
+    src/java/org/gsma/joyn/chat/IChatService.aidl\
+    src/java/org/gsma/joyn/chat/IGroupChatListener.aidl\
+    src/java/org/gsma/joyn/chat/INewChatListener.aidl\
+    src/java/org/gsma/joyn/chat/IGroupChat.aidl\
+    src/java/org/gsma/joyn/chat/IGroupChatSyncingListener.aidl\
+    src/java/org/gsma/joyn/chat/ISpamReportListener.aidl\
+    src/java/org/gsma/joyn/gsh/IGeolocSharingListener.aidl\
+    src/java/org/gsma/joyn/gsh/INewGeolocSharingListener.aidl\
+    src/java/org/gsma/joyn/gsh/IGeolocSharing.aidl\
+    src/java/org/gsma/joyn/gsh/IGeolocSharingService.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCall.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallPlayer.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallRenderer.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallListener.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallPlayerListener.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallRendererListener.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallService.aidl\
+    src/java/org/gsma/joyn/ipcall/INewIPCallListener.aidl\
+    src/java/org/gsma/joyn/ish/IImageSharing.aidl\
+    src/java/org/gsma/joyn/ish/IImageSharingListener.aidl\
+    src/java/org/gsma/joyn/ish/IImageSharingService.aidl\
+    src/java/org/gsma/joyn/ish/INewImageSharingListener.aidl\
+    src/java/org/gsma/joyn/vsh/INewVideoSharingListener.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoSharingListener.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoPlayer.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoPlayerListener.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoRenderer.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoRendererListener.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoSharing.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoSharingService.aidl\
+    src/java/org/gsma/joyn/session/IMultimediaSession.aidl\
+    src/java/org/gsma/joyn/session/IMultimediaSessionListener.aidl\
+    src/java/org/gsma/joyn/session/IMultimediaSessionService.aidl\
+    src/java/org/gsma/joyn/ft/IFileTransfer.aidl\
+    src/java/org/gsma/joyn/ft/IFileTransferService.aidl\
+    src/java/org/gsma/joyn/ft/IFileTransferListener.aidl\
+    src/java/org/gsma/joyn/ft/INewFileTransferListener.aidl\
+    src/java/org/gsma/joyn/ft/IFileSpamReportListener.aidl\
+    src/java/org/gsma/joyn/contacts/IContactsService.aidl\
+    src/java/org/gsma/joyn/ICoreServiceWrapper.aidl \    
+
 #LOCAL_JAVA_LIBRARIES := telephony-common
 
 LOCAL_MODULE_TAGS := optional
 LOCAL_MODULE := ims-common
 
 include $(BUILD_JAVA_LIBRARY)
+
+# build MTK ImsService
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/packages/Android.mk b/packages/Android.mk
new file mode 100644
index 0000000..5053e7d
--- /dev/null
+++ b/packages/Android.mk
@@ -0,0 +1 @@
+include $(call all-subdir-makefiles)
diff --git a/packages/Ims/Android.mk b/packages/Ims/Android.mk
new file mode 100644
index 0000000..5525a9e
--- /dev/null
+++ b/packages/Ims/Android.mk
@@ -0,0 +1,23 @@
+LOCAL_PATH:= $(call my-dir)
+
+# Build the Ims OEM implementation including imsservice, imsadapter, imsriladapter.
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := $(call all-java-files-under, src)
+
+LOCAL_JAVA_LIBRARIES += telephony-common
+#LOCAL_JAVA_LIBRARIES += mediatek-framework
+LOCAL_JAVA_LIBRARIES += ims-common
+LOCAL_STATIC_JAVA_LIBRARIES += wfo-common
+
+# Use SimServs.jar for VoLTE MMTelSS Package
+LOCAL_STATIC_JAVA_LIBRARIES += Simservs
+
+LOCAL_PACKAGE_NAME := ImsService
+LOCAL_CERTIFICATE := platform
+LOCAL_PRIVILEGED_MODULE := true
+
+LOCAL_PROGUARD_ENABLED := disabled
+LOCAL_PROGUARD_FLAGS := $(proguard.flags)
+
+include $(BUILD_PACKAGE)
diff --git a/packages/Ims/AndroidManifest.xml b/packages/Ims/AndroidManifest.xml
new file mode 100644
index 0000000..cc65fdc
--- /dev/null
+++ b/packages/Ims/AndroidManifest.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:androidprv="http://schemas.android.com/apk/prv/res/android"
+        package="com.mediatek.ims"
+        coreApp="true"
+        android:sharedUserId="android.uid.phone"
+>
+
+	<uses-permission android:name="android.permission.READ_PRECISE_PHONE_STATE"/>
+    <uses-permission android:name="android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE"/>
+
+    <application android:name="ImsApp"
+                 android:persistent="true">
+    </application>
+</manifest>
diff --git a/packages/Ims/NOTICE b/packages/Ims/NOTICE
new file mode 100644
index 0000000..83c9081
--- /dev/null
+++ b/packages/Ims/NOTICE
@@ -0,0 +1,13 @@
+Copyright (C) 2011-2014 MediaTek Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
\ No newline at end of file
diff --git a/packages/Ims/README b/packages/Ims/README
new file mode 100644
index 0000000..be12b65
--- /dev/null
+++ b/packages/Ims/README
@@ -0,0 +1,19 @@
+ImsService.apk is a service to provide IMS functionalities like volte, vilte, SS over LTE,
+SMS over LTE.
+
+WHAT IT DOES?
+=============
+ImsService.apk contains
+ - ImsService handle IMS power on/off or registration event.
+ - IMS OEM implementation files handle volte, vilte, ss over LTE or SMS over LTE functionalities.
+ - IMSA make the connection with volte processes to dispatch messages to related modules.
+
+HOW IT WAS BUILT?
+==================
+ImsService.apk is built from MTK internal build process if IMS feature is enable.
+
+HOW TO USE IT?
+==============
+It's a persist APK. It will launch by AMS and create ImsService why application oncreat function
+is called. When ImsService is avaiable it will enable/disable IMS from volte setting to
+register/de-register to server and provide the IMS features.
\ No newline at end of file
diff --git a/packages/Ims/proguard.flags b/packages/Ims/proguard.flags
new file mode 100644
index 0000000..e69de29
diff --git a/packages/Ims/src/com/mediatek/ims/ImsAdapter.java b/packages/Ims/src/com/mediatek/ims/ImsAdapter.java
new file mode 100644
index 0000000..57f020b
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsAdapter.java
@@ -0,0 +1,651 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.LocalSocket;
+import android.net.LocalSocketAddress;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.os.Build;
+import android.os.Handler;
+import android.os.Message;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyIntents;
+import com.mediatek.internal.telephony.ITelephonyEx;
+//import com.android.internal.telephony.gsm.GSMPhone;
+import java.io.BufferedOutputStream;
+import java.io.DataInputStream;
+import java.io.InterruptedIOException;
+import java.io.IOException;
+import java.io.OutputStream;
+
+import static com.mediatek.ims.VaConstants.*;
+
+public class ImsAdapter extends BroadcastReceiver {
+
+    public static class VaEvent {
+        public static final int DEFAULT_MAX_DATA_LENGTH = 40960;
+
+        private int mPhoneId = SubscriptionManager.INVALID_PHONE_INDEX;
+        private int request_id;
+        private int data_len;
+        private int read_offset;
+        private byte data[];
+        private int event_max_data_len = DEFAULT_MAX_DATA_LENGTH;
+
+        /**
+         * The VaEvent constructor with specified phone Id.
+         *
+         * @param phoneId the phone Id of the event
+         * @param rid the request Id of the event
+         */
+        public VaEvent(int phoneId, int rid) {
+            this(phoneId, rid, DEFAULT_MAX_DATA_LENGTH);
+        }
+
+        /**
+         * The VaEvent constructor with specified phone Id.
+         *
+         * @param phoneId the phone Id of the event
+         * @param rid the request Id of the event
+         * @param length the max data length of the event
+         */
+        public VaEvent(int phoneId, int rid, int length) {
+            mPhoneId = phoneId;
+            request_id = rid;
+            event_max_data_len = length;
+            data = new byte[event_max_data_len];
+            data_len = 0;
+            read_offset = 0;
+        }
+
+        public int putInt(int value) {
+            if (data_len > event_max_data_len - 4) {
+                return -1;
+            }
+
+            synchronized (this) {
+                for (int i = 0 ; i < 4 ; ++i) {
+                    data[data_len] = (byte) ((value >> (8 * i)) & 0xFF);
+                    data_len++;
+                }
+            }
+            return 0;
+        }
+
+        public int putShort(int value) {
+            if (data_len > event_max_data_len - 2) {
+                return -1;
+            }
+
+            synchronized (this) {
+                for (int i = 0 ; i < 2 ; ++i) {
+                    data[data_len] = (byte) ((value >> (8 * i)) & 0xFF);
+                    data_len++;
+                }
+            }
+
+            return 0;
+        }
+
+        public int putByte(int value) {
+            if (data_len > event_max_data_len - 1) {
+                return -1;
+            }
+
+            synchronized (this) {
+                data[data_len] = (byte) (value & 0xFF);
+                data_len++;
+            }
+
+            return 0;
+        }
+
+        public int putString(String str, int len) {
+            if (data_len > event_max_data_len - len) {
+                return -1;
+            }
+
+            synchronized (this) {
+                byte s[] = str.getBytes();
+                if (len < str.length()) {
+                    System.arraycopy(s, 0, data, data_len, len);
+                    data_len += len;
+                } else {
+                    int remain = len - str.length();
+                    System.arraycopy(s, 0, data, data_len, str.length());
+                    data_len += str.length();
+                    for (int i = 0 ; i < remain ; i++) {
+                        data[data_len] = 0;
+                        data_len++;
+                    }
+                }
+            }
+
+            return 0;
+        }
+
+        public int putBytes(byte [] value) {
+            int len = value.length;
+
+            if (len > event_max_data_len) {
+                return -1;
+            }
+
+            synchronized (this) {
+                System.arraycopy(value, 0, data, data_len, len);
+                data_len += len;
+            }
+
+            return 0;
+        }
+
+        public byte [] getData() {
+            return data;
+        }
+
+        public int getDataLen() {
+            return data_len;
+        }
+
+        public int getRequestID() {
+            return request_id;
+        }
+
+        public int getPhoneId() {
+            return mPhoneId;
+        }
+
+        public int getInt() {
+            int ret = 0;
+            synchronized (this) {
+                ret = ((data[read_offset + 3] & 0xff) << 24 | (data[read_offset + 2] & 0xff) << 16 | (data[read_offset + 1] & 0xff) << 8 | (data[read_offset] & 0xff));
+                read_offset += 4;
+            }
+            return ret;
+        }
+
+        public int getShort() {
+            int ret = 0;
+            synchronized (this) {
+                ret =  ((data[read_offset + 1] & 0xff) << 8 | (data[read_offset] & 0xff));
+                read_offset += 2;
+            }
+            return ret;
+        }
+
+        // Notice: getByte is to get int8 type from VA, not get one byte.
+        public int getByte() {
+            int ret = 0;
+            synchronized (this) {
+                ret = (data[read_offset] & 0xff);
+                read_offset += 1;
+            }
+            return ret;
+        }
+
+        public byte[] getBytes(int length) {
+            if (length > data_len - read_offset) {
+                return null;
+            }
+
+            byte[] ret = new byte[length];
+
+            synchronized (this) {
+                for (int i = 0 ; i < length ; i++) {
+                    ret[i] = data[read_offset];
+                    read_offset++;
+                }
+                return ret;
+            }
+        }
+
+        public String getString(int len) {
+            byte buf [] = new byte[len];
+
+            synchronized (this) {
+                System.arraycopy(data, read_offset, buf, 0, len);
+                read_offset += len;
+            }
+
+            return (new String(buf)).trim();
+        }
+    }
+
+    public class VaSocketIO extends Thread {
+        private byte buf[];
+
+        private int mTyp = -1;
+        private int mId  = -1;
+        private String mSocketName = null;
+        private LocalSocket mSocket = null;
+        private OutputStream mOut = null;
+        private DataInputStream mDin = null;
+
+        private int mPhoneId = SubscriptionManager.INVALID_PHONE_INDEX;
+
+        Object VaSocketIOThreadLock = new Object();
+
+        public VaSocketIO(String socket_name) {
+            mSocketName = socket_name;
+            // TODO: buffer size confirm
+            buf = new byte[8];
+            Log.d("@M_" + TAG, "VaSocketIO(): Enter");
+        }
+
+        public void run() {
+            Log.d("@M_" + TAG, "VaSocketIO(): Run");
+            while (true) {
+                if (misImsAdapterEnabled) {
+                    boolean doTrm = false;
+                    try {
+                        if (mDin != null) {
+                            // read the Event from mIO
+                            VaEvent event = readEvent();
+
+                            // TODO: need to confirm if event is null or not
+                            if (event != null) {
+                                Message msg = new Message();
+                                msg.obj = event;
+                                mImsEventDispatcher.sendMessage(msg);
+                            }
+                        }
+                    } catch (InterruptedIOException e) {
+                        disconnectSocket();
+                        if (misImsAdapterEnabled && (IS_USER_BUILD || IS_USERDEBUG_BUILD)) {
+                            doTrm = true;
+                        }
+                        e.printStackTrace();
+                        Log.d("@M_" + TAG, "VaSocketIO(): InterruptedIOException (" + (doTrm == true ? "1" : "0") + ")");
+                    } catch (Exception e) {
+                        disconnectSocket();
+                        e.printStackTrace();
+                        if (misImsAdapterEnabled && (IS_USER_BUILD || IS_USERDEBUG_BUILD)) {
+                            doTrm = true;
+                        }
+                        Log.d("@M_" + TAG, "VaSocketIO(): Exception (" + (doTrm == true ? "1" : "0") + ")");
+                    }
+
+                    if (doTrm == true) {
+                        invokeTrm();
+                    }
+                } else {
+                    synchronized (VaSocketIOThreadLock) {
+                        try {
+                            Log.d("@M_" + TAG, "VaSocketIO(): thread \""
+                                    + Thread.currentThread().getId()
+                                    + "\" enter wait state");
+
+                            VaSocketIOThreadLock.wait();
+
+                            Log.d("@M_" + TAG, "VaSocketIO(): thread \""
+                                    + Thread.currentThread().getId()
+                                    + "\" leave wait state");
+
+                        } catch (InterruptedException ie) {
+                            Log.d("@M_" + TAG, "VaSocketIO(): waiting thread \""
+                                    + Thread.currentThread().getId()
+                                    + "\" interrupted ("
+                                    + ie.getMessage()+")");
+                        }
+                    }
+                }
+            }
+        }
+
+        public boolean connectSocket() {
+            Log.d("@M_" + TAG, "connectSocket() Enter");
+
+            if (mSocket != null)  {
+                Log.d("@M_" + TAG, "connectSocket() Reuse current Socket");
+
+                mPhoneId = Util.getDefaultVoltePhoneId();
+
+                // Reuse current Socket
+                return true;
+            }
+
+            try {
+                mSocket = new LocalSocket();
+                LocalSocketAddress addr = new LocalSocketAddress(
+                        mSocketName,
+                        LocalSocketAddress.Namespace.RESERVED);
+
+                mSocket.connect(addr);
+
+                mOut = new BufferedOutputStream(mSocket.getOutputStream(), 4096);
+                mDin = new DataInputStream(mSocket.getInputStream());
+
+                int sendBufferSize = 0;
+                sendBufferSize = mSocket.getSendBufferSize();
+                mSocket.setSendBufferSize(512);
+                sendBufferSize = mSocket.getSendBufferSize();
+
+                mPhoneId = Util.getDefaultVoltePhoneId();
+                Log.d("@M_" + TAG, "connectSocket() update socket phone Id: " + mPhoneId);
+
+            } catch (IOException e) {
+                e.printStackTrace();
+                disconnectSocket();
+                return false;
+            }
+            return true;
+        }
+
+        public void disconnectSocket() {
+            Log.d("@M_" + TAG, "disconnectSocket() Enter, mOut=" + mOut + ",mDin=" + mDin);
+            try {
+                if (mOut != null) {
+                    mOut.close();
+                }
+                if (mDin != null) {
+                    mDin.close();
+                }
+                if (mSocket != null) {
+                    mSocket.close();
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            } finally {
+                mSocket = null;
+                mOut = null;
+                mDin = null;
+                mPhoneId = SubscriptionManager.INVALID_PHONE_INDEX;
+                Log.d("@M_" + TAG, "disconnectSocket() reset socket phone Id");
+            }
+        }
+
+        private void writeBytes(byte [] value, int len) throws IOException {
+            mOut.write(value, 0, len);
+        }
+
+        private void writeInt(int value) throws IOException {
+            for (int i = 0 ; i < 4 ; ++i) {
+                mOut.write((value >> (8 * i)) & 0xff);
+            }
+        }
+
+        public int writeEvent(VaEvent event) {
+            Log.d("@M_" + TAG, "writeEvent Enter");
+            int ret = -1;
+            try {
+                synchronized (this) {
+                    if (mOut != null) {
+                        if (event.getPhoneId() == SubscriptionManager.INVALID_PHONE_INDEX
+                                || event.getPhoneId() != mPhoneId) {
+                            Log.d("@M_" + TAG,
+                                    "writeEvent event phoneId mismatch, event skipped. (event requestId="
+                                            + event.getRequestID()
+                                            + ", phoneId=" + event.getPhoneId()
+                                            + ", socket phoneId=" + mPhoneId
+                                            + ")");
+                        } else {
+                            dumpEvent(event);
+
+                            writeInt(event.getRequestID());
+                            writeInt(event.getDataLen());
+                            writeBytes(event.getData(), event.getDataLen());
+                            mOut.flush();
+                            ret = 0;
+                        }
+                    } else {
+                        Log.d("@M_" + TAG, "mOut is null, socket is not setup");
+                    }
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+                return -1;
+            }
+
+            return ret;
+        }
+
+        private int readInt() throws IOException {
+            mDin.readFully(buf, 0, 4);
+            return ((buf[3]) << 24 | (buf[2] & 0xff) << 16 | (buf[1] & 0xff) << 8 | (buf[0] & 0xff));
+        }
+
+        private void readFully(byte b[], int off, int len) throws IOException {
+            mDin.readFully(b, off, len);
+        }
+
+        private VaEvent readEvent() throws IOException {
+            Log.d("@M_" + TAG, "readEvent Enter");
+            int request_id;
+            int data_len;
+            byte buf [];
+            VaEvent event;
+
+            request_id = readInt();
+            data_len = readInt();
+            buf = new byte[data_len];
+            readFully(buf, 0, data_len);
+
+            int phoneId = Util.getDefaultVoltePhoneId();
+            event = new VaEvent(phoneId, request_id);
+            event.putBytes(buf);
+
+            dumpEvent(event);
+            return event;
+        }
+
+        private void dumpEvent(VaEvent event) {
+            Log.d("@M_" + TAG, "dumpEvent: phone_id:" + event.getPhoneId()
+                    + ",request_id:" + event.getRequestID()
+                    + ",data_len:" + event.getDataLen()
+                    + ",event:" + event.getData());
+        }
+    }
+
+    /* ImsAdapter class */
+    private static final String SOCKET_NAME1 = "volte_imsm";
+//    private static final String SOCKET_NAME2 = "volte_imsa2";
+
+    private static final String TAG = "[ImsAdapter]";
+    private Context mContext;
+    //private GSMPhone mPhone;
+    private VaSocketIO mIO;
+    private static ImsEventDispatcher mImsEventDispatcher;
+
+    private static ImsAdapter mInstance;
+    private static boolean misImsAdapterEnabled = false;
+    private static boolean mImsServiceUp = false;
+
+    private boolean IS_USER_BUILD = "user".equals(Build.TYPE);
+    private boolean IS_USERDEBUG_BUILD = "userdebug".equals(Build.TYPE);
+    private boolean IS_ENG_BUILD = "eng".equals(Build.TYPE);
+
+    public ImsAdapter(Context context) {
+
+        mContext = context;
+
+        if (mInstance == null) {
+            mInstance = this;
+        }
+
+        Log.d("@M_" + TAG, "ImsAdapter(): ImsAdapter Enter");
+        // new the mIO object to communicate with the va
+        mIO = new VaSocketIO(SOCKET_NAME1);
+        mImsEventDispatcher = new ImsEventDispatcher(mContext, mIO);
+
+        mIO.start();
+    }
+
+    public static ImsAdapter getInstance() {
+        return mInstance;
+    }
+
+    public void enableImsAdapter() {
+        Log.d("@M_" + TAG, "enableImsAdapter: misImsAdapterEnabled="
+                + misImsAdapterEnabled);
+
+        if (!misImsAdapterEnabled) {
+            if (mIO.connectSocket() == true) {
+                Log.d("@M_" + TAG, "enalbeImsAdapter(): connectSocket success");
+
+                // start domain event dispatcher to recieve broadcast
+                mImsEventDispatcher.enableRequest();
+
+                misImsAdapterEnabled = true;
+                synchronized (mIO.VaSocketIOThreadLock) {
+                    mIO.VaSocketIOThreadLock.notify();
+                }
+
+                enableImsStack();
+            } else {
+                Log.d("@M_" + TAG, "enableImsAdapter(): connectSocket error");
+
+                // restart MAL
+                if (misImsAdapterEnabled && (IS_USER_BUILD || IS_USERDEBUG_BUILD)) {
+                    invokeTrm();
+                }
+            }
+        }
+    }
+
+    public boolean getImsAdapterEnable() {
+        return misImsAdapterEnabled;
+    }
+
+    public void disableImsAdapter(boolean isNormalDisable) {
+
+        Log.d("@M_" + TAG, "disableImsAdapter(): misImsAdapterEnabled="
+                + misImsAdapterEnabled + ", isNormalDisable="
+                + isNormalDisable);
+
+        if(misImsAdapterEnabled) {
+            disableImsStack();
+
+            mImsEventDispatcher.disableRequest();
+            misImsAdapterEnabled = false;
+        }
+    }
+
+    // for AP side UT, set event and call ImsAdapter.sendTestEvent(event)
+    public void sendTestEvent(VaEvent event) {
+        // Sample Code:
+        // new the event object for Test Event
+        // VaEvent event = new VaEvent(MSG_ID_IMSA_IMCB_TEST_A);
+        // event.putInt(2);
+        // event.putInt(3);
+        mImsEventDispatcher.dispatchCallback(event);
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        final String action = intent.getAction();
+        Log.d("@M_" + TAG, "onReceive, intent action is " + action);
+    }
+
+    public void ImsServiceUp() {
+        mImsServiceUp = true;
+        Log.d("@M_" + TAG, "ImsServiceUp, start to ACTION_IMS_SERVICE_UP intent");
+/*
+        Intent intent = new Intent(ImsManager.ACTION_IMS_SERVICE_UP);
+        mContext.sendBroadcast(intent);
+*/
+    }
+
+    public boolean getImsServiceUp() {
+        return mImsServiceUp;
+    }
+
+    /**
+     * This is a utility class for ImsAdapter related work.
+     */
+    public static class Util {
+
+        /**
+         * To get current the default Volte Phone Id.
+         * Only for single 4G DSDS project, and it should always align to the 4G phone Id.
+         *
+         * @return current default Volte Phone Id. (align to 4G phone Id)
+         */
+        public static int getDefaultVoltePhoneId() {
+            int phoneId = SystemProperties.getInt(PhoneConstants.PROPERTY_CAPABILITY_SWITCH, 1) - 1;
+            if (phoneId < 0 || phoneId >= TelephonyManager.getDefault().getPhoneCount()) {
+                phoneId = SubscriptionManager.INVALID_PHONE_INDEX;
+            }
+            return phoneId;
+        }
+    }
+
+    private ITelephonyEx getITelephonyEx() {
+        return ITelephonyEx.Stub.asInterface(
+                ServiceManager.getService(Context.TELEPHONY_SERVICE_EX));
+    }
+
+    private void enableImsStack() {
+
+        // Send IMS Enable to IMSM
+        VaEvent event = new VaEvent(Util.getDefaultVoltePhoneId(), MSG_ID_IMS_ENABLE_IND);
+        mIO.writeEvent(event);
+
+        return;
+    }
+
+    private void disableImsStack() {
+
+        // Send IMS Disable to IMSM
+        VaEvent event = new VaEvent(Util.getDefaultVoltePhoneId(), MSG_ID_IMS_DISABLE_IND);
+        mIO.writeEvent(event);
+
+        return;
+    }
+
+    private void invokeTrm() {
+        int trmPhoneId = Util.getDefaultVoltePhoneId();
+        Log.d("@M_" + TAG, "VaSocketIO(): recover Phone (trmPhoneId=" + trmPhoneId + ")");
+
+        try {
+            getITelephonyEx().setTrmForPhone(trmPhoneId, 2);
+        } catch (RemoteException re) {
+            Log.d("@M_" + TAG, "VaSocketIO: phone trm exception (re: "+re.getMessage()+")");
+        } catch (NullPointerException npex) {
+        // This could happen before phone restarts due to crashing
+            Log.d("@M_" + TAG, "VaSocketIO: phone trm exception (npex: "+npex.getMessage()+")");
+        }
+    }
+}
+
diff --git a/packages/Ims/src/com/mediatek/ims/ImsApp.java b/packages/Ims/src/com/mediatek/ims/ImsApp.java
new file mode 100644
index 0000000..e8db682
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsApp.java
@@ -0,0 +1,68 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.app.Application;
+import android.content.res.Configuration;
+import android.os.ServiceManager;
+import android.os.UserHandle;
+import android.util.Log;
+
+import com.android.ims.ImsManager;
+
+/**
+ * Top-level Application class for the Phone app.
+ */
+public class ImsApp extends Application {
+    private static final String TAG = "ImsApp";
+
+    public ImsApp() {
+    }
+
+    @Override
+    public void onCreate() {
+        if (UserHandle.myUserId() == 0) {
+            Log.d(TAG, "ImsApp onCreate begin");
+            // We are running as the primary user, so should bring up the
+            // global phone state.
+
+            ImsService imsService = new ImsService(this);
+            ServiceManager.addService(ImsManager.IMS_SERVICE, imsService.asBinder(), true);
+
+            Log.d(TAG, "ImsApp onCreate end");
+        }
+    }
+}
\ No newline at end of file
diff --git a/packages/Ims/src/com/mediatek/ims/ImsBaseCommands.java b/packages/Ims/src/com/mediatek/ims/ImsBaseCommands.java
new file mode 100644
index 0000000..e28c20c
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsBaseCommands.java
@@ -0,0 +1,474 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+
+import android.content.Context;
+import android.os.AsyncResult;
+import android.os.RegistrantList;
+import android.os.Registrant;
+import android.os.Handler;
+
+/**
+ * {@hide}
+ */
+public abstract class ImsBaseCommands implements ImsCommandsInterface {
+    //***** Instance Variables
+    protected Context mContext;
+    protected RadioState mState = RadioState.RADIO_UNAVAILABLE;
+    protected Object mStateMonitor = new Object();
+
+    protected RegistrantList mRadioStateChangedRegistrants = new RegistrantList();
+    protected RegistrantList mOnRegistrants = new RegistrantList();
+    protected RegistrantList mAvailRegistrants = new RegistrantList();
+    protected RegistrantList mOffOrNotAvailRegistrants = new RegistrantList();
+    protected RegistrantList mNotAvailRegistrants = new RegistrantList();
+    protected RegistrantList mCallStateRegistrants = new RegistrantList();
+    protected Registrant mRingRegistrant;
+    protected RegistrantList mRingbackToneRegistrants = new RegistrantList();
+
+    /* M: CC part start */
+    protected RegistrantList mCallForwardingInfoRegistrants = new RegistrantList();
+    protected Registrant mCallRelatedSuppSvcRegistrant;
+    protected Registrant mIncomingCallIndicationRegistrant;
+    protected Registrant mCnapNotifyRegistrant;
+    protected RegistrantList mCipherIndicationRegistrant = new RegistrantList();
+    protected Registrant mSpeechCodecInfoRegistrant;
+    /* M: CC part end */
+
+    // IMS VoLTE
+    protected RegistrantList mEpsNetworkFeatureSupportRegistrants = new RegistrantList();
+    protected RegistrantList mEpsNetworkFeatureInfoRegistrants = new RegistrantList();
+    protected RegistrantList mSrvccHandoverInfoIndicationRegistrants = new RegistrantList();
+
+    //VoLTE
+    protected RegistrantList mImsEnableStartRegistrants = new RegistrantList();
+    protected RegistrantList mImsDisableStartRegistrants = new RegistrantList();
+    protected RegistrantList mImsEnableDoneRegistrants = new RegistrantList();
+    protected RegistrantList mImsDisableDoneRegistrants = new RegistrantList();
+    protected RegistrantList mImsRegistrationInfoRegistrants = new RegistrantList();
+    protected RegistrantList mDedicateBearerActivatedRegistrant = new RegistrantList();
+    protected RegistrantList mDedicateBearerModifiedRegistrant = new RegistrantList();
+    protected RegistrantList mDedicateBearerDeactivatedRegistrant = new RegistrantList();
+
+    /// M: IMS feature. @{
+    /* Register for updating call ids for conference call after SRVCC is done. */
+    protected RegistrantList mEconfSrvccRegistrants = new RegistrantList();
+    /* Register for updating conference call merged/added result. */
+    protected RegistrantList mEconfResultRegistrants = new RegistrantList();
+    /* Register for updating call mode and pau. */
+    protected RegistrantList mCallInfoRegistrants = new RegistrantList();
+    /// @}
+
+    protected Registrant mSsnRegistrant;
+    protected RegistrantList mSrvccStateRegistrants = new RegistrantList();
+    protected RegistrantList mCallProgressIndicatorRegistrants = new RegistrantList();
+    /// M: ViLTE feature, call mode changed event. @{
+    protected RegistrantList mCallModeChangeIndicatorRegistrants = new RegistrantList();
+    protected RegistrantList mVideoCapabilityIndicatorRegistrants = new RegistrantList();
+    /// @}
+
+    public ImsBaseCommands(Context context) {
+        mContext = context;
+    }
+
+    public void registerForNotAvailable(Handler h, int what, Object obj) {
+        Registrant r = new Registrant (h, what, obj);
+
+        synchronized (mStateMonitor) {
+            mNotAvailRegistrants.add(r);
+
+            if (!mState.isAvailable()) {
+                r.notifyRegistrant(new AsyncResult(null, null, null));
+            }
+        }
+    }
+
+    public void unregisterForNotAvailable(Handler h) {
+        synchronized (mStateMonitor) {
+            mNotAvailRegistrants.remove(h);
+        }
+    }
+
+    public void registerForCallStateChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCallStateRegistrants.add(r);
+    }
+
+    public void unregisterForCallStateChanged(Handler h) {
+        mCallStateRegistrants.remove(h);
+    }
+
+    public void setOnCallRing(Handler h, int what, Object obj) {
+        mRingRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnCallRing(Handler h) {
+        if (mRingRegistrant != null && mRingRegistrant.getHandler() == h) {
+            mRingRegistrant.clear();
+            mRingRegistrant = null;
+        }
+    }
+
+    public void registerForRingbackTone(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mRingbackToneRegistrants.add(r);
+    }
+
+    public void unregisterForRingbackTone(Handler h) {
+        mRingbackToneRegistrants.remove(h);
+    }
+
+    public void registerForCallForwardingInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCallForwardingInfoRegistrants.add(r);
+    }
+
+    public void unregisterForCallForwardingInfo(Handler h) {
+        mCallForwardingInfoRegistrants.remove(h);
+    }
+
+    public void setOnCallRelatedSuppSvc(Handler h, int what, Object obj) {
+        mCallRelatedSuppSvcRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnCallRelatedSuppSvc(Handler h) {
+        mCallRelatedSuppSvcRegistrant.clear();
+    }
+
+    public void setOnIncomingCallIndication(Handler h, int what, Object obj) {
+        mIncomingCallIndicationRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unsetOnIncomingCallIndication(Handler h) {
+        mIncomingCallIndicationRegistrant.clear();
+    }
+
+    public void setCnapNotify(Handler h, int what, Object obj) {
+        mCnapNotifyRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetCnapNotify(Handler h) {
+        mCnapNotifyRegistrant.clear();
+    }
+
+    public void registerForCipherIndication(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCipherIndicationRegistrant.add(r);
+    }
+
+    public void unregisterForCipherIndication(Handler h) {
+        mCipherIndicationRegistrant.remove(h);
+    }
+
+    public void setOnSpeechCodecInfo(Handler h, int what, Object obj) {
+        mSpeechCodecInfoRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnSpeechCodecInfo(Handler h) {
+        if (mSpeechCodecInfoRegistrant != null && mSpeechCodecInfoRegistrant.getHandler() == h) {
+            mSpeechCodecInfoRegistrant.clear();
+            mSpeechCodecInfoRegistrant = null;
+        }
+    }
+
+    public void registerForEpsNetworkFeatureSupport(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEpsNetworkFeatureSupportRegistrants.add(r);
+    }
+
+    public void unregisterForEpsNetworkFeatureSupport(Handler h) {
+        mEpsNetworkFeatureSupportRegistrants.remove(h);
+    }
+
+    public void registerForEpsNetworkFeatureInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEpsNetworkFeatureInfoRegistrants.add(r);
+    }
+
+    public void unregisterForEpsNetworkFeatureInfo(Handler h) {
+        mEpsNetworkFeatureInfoRegistrants.remove(h);
+    }
+
+    public void registerForSrvccHandoverInfoIndication(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSrvccHandoverInfoIndicationRegistrants.add(r);
+    }
+    public void unregisterForSrvccHandoverInfoIndication(Handler h) {
+        mSrvccHandoverInfoIndicationRegistrants.remove(h);
+    }
+
+    public void registerForEconfSrvcc(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEconfSrvccRegistrants.add(r);
+    }
+
+    public void unregisterForEconfSrvcc(Handler h) {
+        mEconfSrvccRegistrants.remove(h);
+    }
+
+    public void registerForEconfResult(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEconfResultRegistrants.add(r);
+    }
+
+    public void unregisterForEconfResult(Handler h) {
+        mEconfResultRegistrants.remove(h);
+    }
+
+    public void registerForCallInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCallInfoRegistrants.add(r);
+    }
+
+    public void unregisterForCallInfo(Handler h) {
+        mCallInfoRegistrants.remove(h);
+    }
+
+    // IMS
+    public void registerForImsEnableStart(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsEnableStartRegistrants.add(r);
+    }
+
+    public void unregisterForImsEnableStart(Handler h) {
+        mImsEnableStartRegistrants.remove(h);
+    }
+
+    public void registerForImsDisableStart(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsDisableStartRegistrants.add(r);
+    }
+
+    public void unregisterForImsDisableStart(Handler h) {
+        mImsDisableStartRegistrants.remove(h);
+    }
+
+    public void registerForImsEnableComplete(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsEnableDoneRegistrants.add(r);
+    }
+
+    public void unregisterForImsEnableComplete(Handler h) {
+        mImsEnableDoneRegistrants.remove(h);
+    }
+
+    public void registerForImsDisableComplete(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsDisableDoneRegistrants.add(r);
+    }
+
+    public void unregisterForImsDisableComplete(Handler h) {
+        mImsDisableDoneRegistrants.remove(h);
+    }
+
+    public void registerForImsRegistrationInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsRegistrationInfoRegistrants.add(r);
+    }
+
+    public void unregisterForImsRegistrationInfo(Handler h) {
+        mImsRegistrationInfoRegistrants.remove(h);
+    }
+
+    public void registerForDedicateBearerActivated(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDedicateBearerActivatedRegistrant.add(r);
+    }
+
+    public void unregisterForDedicateBearerActivated(Handler h) {
+        mDedicateBearerActivatedRegistrant.remove(h);
+    }
+
+    public void registerForDedicateBearerModified(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDedicateBearerModifiedRegistrant.add(r);
+    }
+
+    public void unregisterForDedicateBearerModified(Handler h) {
+        mDedicateBearerModifiedRegistrant.remove(h);
+    }
+
+    public void registerForDedicateBearerDeactivated(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDedicateBearerDeactivatedRegistrant.add(r);
+    }
+
+    public void unregisterForDedicateBearerDeactivated(Handler h) {
+        mDedicateBearerDeactivatedRegistrant.remove(h);
+    }
+
+    public void setOnSuppServiceNotification(Handler h, int what, Object obj) {
+        mSsnRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnSuppServiceNotification(Handler h) {
+        if (mSsnRegistrant != null && mSsnRegistrant.getHandler() == h) {
+            mSsnRegistrant.clear();
+            mSsnRegistrant = null;
+        }
+    }
+
+    public void registerForSrvccStateChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mSrvccStateRegistrants.add(r);
+    }
+
+    public void unregisterForSrvccStateChanged(Handler h) {
+        mSrvccStateRegistrants.remove(h);
+    }
+
+    public void registerForCallProgressIndicator(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mCallProgressIndicatorRegistrants.add(r);
+    }
+
+    public void unregisterForCallProgressIndicator(Handler h) {
+        mCallProgressIndicatorRegistrants.remove(h);
+    }
+
+    /// M: For ViLTE feature, register for call mode, video capability change. @{
+    /**
+     * Register for call mode change event. (RIL_UNSOL_CALLMOD_CHANGE_INDICATOR)
+     *
+     * @param h handler
+     * @param what message
+     * @param obj object
+     * @hide
+     */
+    public void registerForCallModeChangeIndicator(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mCallModeChangeIndicatorRegistrants.add(r);
+    }
+
+    /**
+     * Un-register for call mode change event.
+     *
+     * @param h handler
+     * @hide
+     */
+    public void unregisterForCallModeChangeIndicator(Handler h) {
+        mCallModeChangeIndicatorRegistrants.remove(h);
+    }
+
+    /**
+     * Register for video capability change event. (RIL_UNSOL_CALLMOD_CHANGE_INDICATOR)
+     *
+     * @param h handler
+     * @param what message
+     * @param obj object
+     * @hide
+     */
+    public void registerForVideoCapabilityIndicator(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mVideoCapabilityIndicatorRegistrants.add(r);
+    }
+
+    /**
+     * Un-register for video capability change event.
+     *
+     * @param h handler
+     * @hide
+     */
+    public void unregisterForVideoCapabilityIndicator(Handler h) {
+        mVideoCapabilityIndicatorRegistrants.remove(h);
+    }
+    /// @}
+
+    //***** Protected Methods
+    /**
+     * Store new RadioState and send notification based on the changes
+     *
+     * This function is called only by RIL.java when receiving unsolicited
+     * RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED
+     *
+     * RadioState has 3 values : RADIO_OFF, RADIO_UNAVAILABLE, RADIO_ON.
+     *
+     * @param newState new RadioState decoded from RIL_UNSOL_RADIO_STATE_CHANGED
+     */
+    protected void setRadioState(RadioState newState) {
+        RadioState oldState;
+
+        synchronized (mStateMonitor) {
+            oldState = mState;
+            mState = newState;
+
+            if (oldState == mState) {
+                // no state transition
+                return;
+            }
+
+            mRadioStateChangedRegistrants.notifyRegistrants();
+
+            if (mState.isAvailable() && !oldState.isAvailable()) {
+                mAvailRegistrants.notifyRegistrants();
+                onRadioAvailable();
+            }
+
+            if (!mState.isAvailable() && oldState.isAvailable()) {
+                mNotAvailRegistrants.notifyRegistrants();
+            }
+
+            if (mState.isOn() && !oldState.isOn()) {
+                mOnRegistrants.notifyRegistrants();
+            }
+
+            if ((!mState.isOn() || !mState.isAvailable())
+                && !((!oldState.isOn() || !oldState.isAvailable()))
+            ) {
+                mOffOrNotAvailRegistrants.notifyRegistrants();
+            }
+        }
+    }
+
+    protected void onRadioAvailable() {
+    }
+
+    /// M: IMS ViLTE feature. @{
+    /**
+     * accept video call.
+     * @param videoMode accept video as video, voice, video_rx or video_tx.
+     * @param callId  indication to accept which call.
+     * @param result the command result.
+     * @Override
+     */
+    public void acceptVideoCall(int videoMode, int callId) {}
+    /// @}
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsCallSessionProxy.java b/packages/Ims/src/com/mediatek/ims/ImsCallSessionProxy.java
new file mode 100644
index 0000000..f2ee27c
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsCallSessionProxy.java
@@ -0,0 +1,1905 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+import android.net.Uri;
+import android.os.AsyncResult;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+
+import android.telecom.VideoProfile;
+
+import android.telephony.PhoneNumberUtils;
+import android.telephony.Rlog;
+import android.telephony.ServiceState;
+import android.telephony.TelephonyManager;
+
+import android.text.TextUtils;
+
+import com.android.ims.ImsCallProfile;
+import com.android.ims.ImsConferenceState;
+import com.android.ims.ImsConfig;
+import com.android.ims.ImsManager;
+import com.android.ims.ImsReasonInfo;
+import com.android.ims.ImsStreamMediaProfile;
+import com.android.ims.internal.IImsCallSessionListener;
+import com.android.ims.internal.IImsCallSession;
+import com.android.ims.internal.IImsVideoCallProvider;
+import com.android.ims.internal.ImsCallSession;
+
+import com.android.internal.telephony.CommandException;
+import com.android.internal.telephony.CommandException.Error;
+import com.android.internal.telephony.LastCallFailCause;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.gsm.CallFailCause;
+import com.mediatek.ims.WfcReasonInfo;
+import com.mediatek.internal.telephony.ConferenceCallMessageHandler;
+import com.mediatek.internal.telephony.RadioCapabilitySwitchUtil;
+
+import com.mediatek.ims.internal.CallControlDispatcher;
+// For ViLTE feature.
+import com.mediatek.ims.internal.ImsVTProvider;
+
+// ALPS02136981. Prints fomatted debug logs.
+// import com.mediatek.telecom.FormattedLog;
+
+import com.mediatek.wfo.DisconnectCause;
+import com.mediatek.wfo.IWifiOffloadService;
+import com.mediatek.wfo.WifiOffloadManager;
+
+import java.io.FileOutputStream;
+import java.io.OutputStreamWriter;
+import javax.xml.parsers.SAXParser;
+import javax.xml.parsers.SAXParserFactory;
+import java.io.InputStream;
+import java.io.FileInputStream;
+import java.io.BufferedInputStream;
+
+import java.lang.Math;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class ImsCallSessionProxy extends IImsCallSession.Stub {
+    private static final String LOG_TAG = "ImsCallSessionProxy";
+    private static final boolean DBG = true;
+    private static final boolean VDBG = false; // STOPSHIP if true
+
+    private String mCallId;
+    private int mState = ImsCallSession.State.IDLE;
+    private Context mContext;
+    private ImsService mImsService;
+    private ImsRILAdapter mImsRILAdapter;
+    private ImsCallProfile mCallProfile;
+    private IImsCallSessionListener mListener;
+    private final Handler mHandler;
+    private final Handler mServiceHandler;
+    private boolean mHasPendingMo = false;
+    private boolean mIsMerging = false;
+    private boolean mIsOnTerminated = false;
+    private boolean mIsAddRemoveParticipantsCommandOK = false;
+    private String[] mPendingParticipantInfo ;
+    private int mPendingParticipantInfoIndex = 0;
+    private int mPendingParticipantStatistics = 0;
+    private boolean mIsHideHoldEventDuringMerging = false;
+    private String mMergeCallId = "";
+    private ImsCallInfo.State mMergeCallStatus = ImsCallInfo.State.INVALID;
+    private String mMergedCallId = "";
+    private ImsCallInfo.State mMergedCallStatus = ImsCallInfo.State.INVALID;
+    // normal call merge normal call
+    private boolean mNormalCallsMerge = false;
+    // at least one call is merged successfully
+    private boolean mThreeWayMergeSucceeded = false;
+    // count for +ECONF number in normal call merge normal call case
+    private int mEconfCount = 0;
+    private IImsCallSession mConfSession;
+
+    private String mCallNumber;
+
+    // WFC
+    private IWifiOffloadService mWfoService;
+    private int mRatType = WifiOffloadManager.RAN_TYPE_MOBILE_3GPP;
+    private static final int WFC_GET_CAUSE_FAILED = -1;
+
+    // For ViLTE.
+    private ImsVTProvider mVTProvider;
+    private ImsCallProfile mLocalCallProfile;
+    private ImsCallProfile mRemoteCallProfile;
+
+    private enum CallErrorState {
+        IDLE, DIAL, DISCONNECT;
+    };
+
+    private CallErrorState mCallErrorState = CallErrorState.IDLE;
+
+    private Message mDtmfMsg = null;
+    private Messenger mDtmfTarget = null;
+
+    private static final int INVALID_CALL_MODE = 0xFF;
+    private static final int IMS_VOICE_CALL = 20;
+    private static final int IMS_VIDEO_CALL = 21;
+    private static final int IMS_VOICE_CONF = 22;
+    private static final int IMS_VIDEO_CONF = 23;
+    private static final int IMS_VOICE_CONF_PARTS = 24;
+    private static final int IMS_VIDEO_CONF_PARTS = 25;
+
+    //***** Events URC
+    private static final int EVENT_POLL_CALLS_RESULT             = 101;
+    private static final int EVENT_CALL_INFO_INDICATION          = 102;
+    private static final int EVENT_RINGBACK_TONE                 = 103;
+    private static final int EVENT_ECONF_RESULT_INDICATION       = 104;
+    private static final int EVENT_GET_LAST_CALL_FAIL_CAUSE      = 105;
+    private static final int EVENT_CALL_MODE_CHANGE_INDICATION   = 106;
+    private static final int EVENT_VIDEO_CAPABILITY_INDICATION   = 107;
+
+    //***** Events Operation result
+    private static final int EVENT_DIAL_RESULT                   = 201;
+    private static final int EVENT_ACCEPT_RESULT                 = 202;
+    private static final int EVENT_HOLD_RESULT                   = 203;
+    private static final int EVENT_RESUME_RESULT                 = 204;
+    private static final int EVENT_MERGE_RESULT                  = 205;
+    private static final int EVENT_ADD_CONFERENCE_RESULT         = 206;
+    private static final int EVENT_REMOVE_CONFERENCE_RESULT      = 207;
+    private static final int EVENT_SIP_CODE_INDICATION           = 208;
+    private static final int EVENT_DIAL_CONFERENCE_RESULT        = 209;
+    private static final int EVENT_RETRIEVE_MERGE_FAIL_RESULT    = 211;
+    private static final int EVENT_DTMF_DONE    = 212;
+
+    //Constructor for MT call
+    ImsCallSessionProxy(Context context, ImsCallProfile profile, IImsCallSessionListener listener, ImsService imsService, 
+            Handler handler, ImsRILAdapter imsRILAdapter, String callId) {
+        if (DBG) {
+            Rlog.d(LOG_TAG, "ImsSessionProxy RILAdapter:" + imsRILAdapter + "imsService:" + imsService + " callID:" + callId);
+        }
+        mServiceHandler = handler;
+        mHandler = new MyHandler(handler.getLooper());
+        mContext = context;
+        mCallProfile = profile;
+        mLocalCallProfile = profile;
+        mRemoteCallProfile = profile;
+        mListener = listener;
+        mImsService = imsService;
+        mImsRILAdapter = imsRILAdapter;
+        mCallId = callId;
+        mImsRILAdapter.registerForCallInfo(mHandler, EVENT_CALL_INFO_INDICATION, null);
+        mImsRILAdapter.registerForRingbackTone(mHandler, EVENT_RINGBACK_TONE, null);
+        /// M: Register for updating conference call merged/added result.
+        mImsRILAdapter.registerForEconfResult(mHandler, EVENT_ECONF_RESULT_INDICATION, null);
+        mImsRILAdapter.registerForCallProgressIndicator(mHandler, EVENT_SIP_CODE_INDICATION, null);
+        mImsRILAdapter.registerForCallModeChangeIndicator(mHandler,
+                EVENT_CALL_MODE_CHANGE_INDICATION, null);
+        mImsRILAdapter.registerForVideoCapabilityIndicator(mHandler,
+                EVENT_VIDEO_CAPABILITY_INDICATION, null);
+
+        if (SystemProperties.get("ro.mtk_vilte_support").equals("1")) {
+            if (mCallId != null) {
+                //MT:new VT service
+                mVTProvider = new ImsVTProvider(Integer.parseInt(mCallId));
+            } else {
+                //MO:new VT service
+                mVTProvider = new ImsVTProvider();
+            }
+        }
+
+        /* Register for receiving conference call xml message */
+        final IntentFilter filter = new IntentFilter();
+        filter.addAction(CallControlDispatcher.ACTION_IMS_CONFERENCE_CALL_INDICATION);
+        // WFC: Registers the listener to WifiOffloadService for handover event and get rat type
+        // from WifiOffloadService.
+        IBinder b = ServiceManager.getService(WifiOffloadManager.WFO_SERVICE);
+        mWfoService = IWifiOffloadService.Stub.asInterface(b);
+        if (mWfoService != null) {
+            try {
+                mWfoService.registerForHandoverEvent(new IWifiOffloadListenerProxy());
+                mRatType = mWfoService.getRatType();
+            } catch (RemoteException e) {
+                Rlog.e(LOG_TAG, "RemoteException ImsCallSessionProxy()");
+            }
+        }
+        Rlog.d(LOG_TAG, "[WFC]mRatType is " + mRatType);
+
+        context.registerReceiver(mBroadcastReceiver, filter);
+        mConfSession = null;
+    }
+
+    //Constructor for MO call
+    ImsCallSessionProxy(Context context, ImsCallProfile profile, IImsCallSessionListener listener, ImsService imsService,
+            Handler handler, ImsRILAdapter imsRILAdapter) {
+        this(context, profile, listener, imsService, handler, imsRILAdapter, null);
+        if (DBG) {
+            Rlog.d(LOG_TAG, "ImsCallSessionProxy RILAdapter:" + imsRILAdapter);
+        }
+    }
+
+    @Override
+    public void close() {
+        if (DBG) {
+            Rlog.d(LOG_TAG, "ImsCallSessionProxy is closed!!! ");
+        }
+        mState = ImsCallSession.State.INVALID;
+        mImsRILAdapter.unregisterForCallInfo(mHandler);
+        mImsRILAdapter.unregisterForRingbackTone(mHandler);
+        mImsRILAdapter.unregisterForEconfResult(mHandler);
+        mImsRILAdapter.unregisterForCallProgressIndicator(mHandler);
+        mImsRILAdapter.unregisterForCallModeChangeIndicator(mHandler);
+        mImsRILAdapter.unregisterForVideoCapabilityIndicator(mHandler);
+
+        if (mContext != null) {
+            mContext.unregisterReceiver(mBroadcastReceiver);
+        }
+    }
+
+    @Override
+    public String getCallId() {
+        return mCallId;
+    }
+
+    @Override
+    public ImsCallProfile getCallProfile() {
+        return mCallProfile;
+    }
+
+    @Override
+    public ImsCallProfile getLocalCallProfile() {
+        return mLocalCallProfile;
+    }
+
+    @Override
+    public ImsCallProfile getRemoteCallProfile() {
+        return mRemoteCallProfile;
+    }
+
+    @Override
+    public String getProperty(String name) {
+        return mCallProfile.getCallExtra(name);
+    }
+
+    @Override
+    public int getState() {
+        return mState;
+    }
+
+    @Override
+    public boolean isInCall() {
+        return false;
+    }
+
+    @Override
+    public void setListener(IImsCallSessionListener listener) {
+        mListener = listener;
+    }
+
+    @Override
+    public void setMute(boolean muted) {
+        mImsRILAdapter.setMute(muted, null);
+    }
+
+    @Override
+    public void start(String callee, ImsCallProfile profile) {
+        int clirMode = profile.getCallExtraInt(ImsCallProfile.EXTRA_OIR, 0);
+        boolean isVideoCall = false;
+        boolean isEmergencyNumber = false;
+        Message result = mHandler.obtainMessage(EVENT_DIAL_RESULT);
+
+        if (profile.mServiceType == ImsCallProfile.SERVICE_TYPE_EMERGENCY) {
+            isEmergencyNumber = true;
+        }
+
+        if (profile.getVideoStateFromImsCallProfile(profile) !=
+                VideoProfile.STATE_AUDIO_ONLY) {
+            isVideoCall = true;
+        }
+        mImsRILAdapter.start(callee, clirMode, isEmergencyNumber, isVideoCall, result);
+        mHasPendingMo = true;
+        mCallNumber = callee;
+    }
+
+    @Override
+    public void startConference(String[] participants, ImsCallProfile profile) {
+        int clirMode = profile.getCallExtraInt(ImsCallProfile.EXTRA_OIR, 0);
+        boolean isVideoCall = false;
+        Message result = mHandler.obtainMessage(EVENT_DIAL_CONFERENCE_RESULT);
+
+        if (profile.getVideoStateFromImsCallProfile(profile) !=
+                VideoProfile.STATE_AUDIO_ONLY) {
+            isVideoCall = true;
+        }
+        mImsRILAdapter.startConference(participants, clirMode, isVideoCall, result);
+        mHasPendingMo = true;
+    }
+
+    @Override
+    public void accept(int callType, ImsStreamMediaProfile profile) {
+        Rlog.d(LOG_TAG, "accept - original call Type:" + mCallProfile.mCallType
+                + "accept as:" + callType);
+        if (mCallProfile.mCallType == ImsCallProfile.CALL_TYPE_VOICE) {
+            mImsRILAdapter.accept();
+        } else {
+            int videoMode;
+            /* We set the videoMode base on AT+EVTA mode value.
+             * AT+EVTA=<mode>,<call id>
+             * Mode  =1 , accept as audio
+             * Mode  =2 , accept as one way only video (Rx)
+             * Mode  =3 , accept as one way only video (Tx)
+             * For videoMode = 0, we will use ATA command to accept this video call.
+             */
+            switch (callType) {
+                case ImsCallProfile.CALL_TYPE_VT:
+                    videoMode = 0;
+                    break;
+                case ImsCallProfile.CALL_TYPE_VOICE:
+                    videoMode = 1;
+                    break;
+                case ImsCallProfile.CALL_TYPE_VT_RX:
+                    videoMode = 2;
+                    break;
+                case ImsCallProfile.CALL_TYPE_VT_TX:
+                    videoMode = 3;
+                    break;
+                default:
+                    videoMode = 0;
+                    break;
+            }
+            mImsRILAdapter.acceptVideoCall(videoMode, Integer.parseInt(mCallId));
+        }
+    }
+
+    @Override
+    public void reject(int reason) {
+        if (mCallId != null) {
+            mImsRILAdapter.reject(Integer.parseInt(mCallId));
+        } else {
+            Rlog.e(LOG_TAG, "Reject Call fail since there is no call ID. Abnormal Case");
+        }
+    }
+
+    @Override
+    public void terminate(int reason) {
+        if (mCallId != null) {
+            mImsRILAdapter.terminate(Integer.parseInt(mCallId));
+        } else {
+            Rlog.e(LOG_TAG, "Terminate Call fail since there is no call ID. Abnormal Case");
+        }
+    }
+
+    @Override
+    public void hold(ImsStreamMediaProfile profile) {
+        Message result = mHandler.obtainMessage(EVENT_HOLD_RESULT);
+        mImsRILAdapter.hold(Integer.parseInt(mCallId), result);
+    }
+
+    @Override
+    public void resume(ImsStreamMediaProfile profile) {
+        Message result = mHandler.obtainMessage(EVENT_RESUME_RESULT);
+        mImsRILAdapter.resume(Integer.parseInt(mCallId), result);
+    }
+
+    @Override
+    public void merge() {
+        Message result;
+        Rlog.e(LOG_TAG, "Merge callId:" + mCallId);
+        ImsCallInfo myCallInfo = mImsRILAdapter.getCallInfo(mCallId);
+        ImsCallInfo beMergedCallInfo = null;
+
+        if (myCallInfo == null) {
+            Rlog.e(LOG_TAG, "can't find this call callInfo");
+            mergeFailed();
+            return;
+        }
+
+        if (myCallInfo.mState == ImsCallInfo.State.ACTIVE) {
+            beMergedCallInfo = mImsRILAdapter.getCallInfo(ImsCallInfo.State.HOLDING);
+        } else if (myCallInfo.mState == ImsCallInfo.State.HOLDING) {
+            beMergedCallInfo = mImsRILAdapter.getCallInfo(ImsCallInfo.State.ACTIVE);
+        }
+
+        if (beMergedCallInfo == null) {
+            Rlog.e(LOG_TAG, "can't find another call's callInfo");
+            mergeFailed();
+            return;
+        }
+
+        Rlog.d(LOG_TAG, "merge command- my call: conference type=" + myCallInfo.mIsConference +
+                " call status=" + myCallInfo.mState + "beMergedCall: conference type=" +
+                beMergedCallInfo.mIsConference + " call status=" + beMergedCallInfo.mState);
+
+        mMergeCallId = myCallInfo.mCallId;
+        mMergeCallStatus = myCallInfo.mState;
+        mMergedCallId = beMergedCallInfo.mCallId;
+        mMergedCallStatus = beMergedCallInfo.mState;
+
+        if (myCallInfo.mIsConference == false && beMergedCallInfo.mIsConference == false) {
+            //Case 1: Normal call merge normal call
+            result = mHandler.obtainMessage(EVENT_MERGE_RESULT);
+            mImsRILAdapter.merge(result);
+            mIsHideHoldEventDuringMerging = true;
+            mNormalCallsMerge = true;
+        } else if (myCallInfo.mIsConference == true && beMergedCallInfo.mIsConference == true) {
+            // Case 2: conference call merge conference call
+            Rlog.d(LOG_TAG, "conference call merge conference call");
+            result = mHandler.obtainMessage(EVENT_ADD_CONFERENCE_RESULT);
+            mImsRILAdapter.inviteParticipants(Integer.parseInt(mCallId),
+                    beMergedCallInfo.mCallNum, result);
+            return;
+        } else {
+            if (myCallInfo.mIsConference) {
+                Rlog.d(LOG_TAG, "active conference call merge background normal call");
+                result = mHandler.obtainMessage(EVENT_ADD_CONFERENCE_RESULT);
+                mImsRILAdapter.inviteParticipants(Integer.parseInt(mCallId),
+                        beMergedCallInfo.mCallNum, result);
+            } else {
+                Rlog.d(LOG_TAG, "active normal call merge background conference call");
+                result = mHandler.obtainMessage(EVENT_ADD_CONFERENCE_RESULT);
+                mImsRILAdapter.inviteParticipants(Integer.parseInt(beMergedCallInfo.mCallId),
+                        myCallInfo.mCallNum, result);
+            }
+        }
+        mIsMerging = true;
+    }
+
+    @Override
+    public void update(int callType, ImsStreamMediaProfile profile) {
+        // currently MD not support for video downgrade or audio upgrade.
+    }
+
+    @Override
+    public void extendToConference(String[] participants) {
+        // currently MD not support to join multiple participants to join conference call.
+    }
+
+    @Override
+    public void inviteParticipants(String[] participants) {
+        Message result = mHandler.obtainMessage(EVENT_ADD_CONFERENCE_RESULT);
+        mPendingParticipantInfoIndex = 0;
+        mPendingParticipantInfo = participants;
+        mPendingParticipantStatistics = participants.length;
+        if (mCallId != null || mPendingParticipantStatistics == 0) {
+            mImsRILAdapter.inviteParticipants(Integer.parseInt(mCallId),
+                    mPendingParticipantInfo[mPendingParticipantInfoIndex], result);
+        } else {
+            Rlog.e(LOG_TAG, "inviteParticipants fail since no call ID or participants is null" +
+                    " CallID=" + mCallId + " Participant number=" + mPendingParticipantStatistics);
+            if (mListener != null) {
+                try {
+                    mListener.callSessionInviteParticipantsRequestFailed(
+                            ImsCallSessionProxy.this, new ImsReasonInfo());
+                } catch (RemoteException e) {
+                    Rlog.e(LOG_TAG, "RemoteException occurs when InviteParticipantsRequestFailed");
+                }
+            }
+        }
+    }
+
+    @Override
+    public void removeParticipants(String[] participants) {
+        Message result = mHandler.obtainMessage(EVENT_REMOVE_CONFERENCE_RESULT);
+        mPendingParticipantInfoIndex = 0;
+        mPendingParticipantInfo = participants;
+        mPendingParticipantStatistics = participants.length;
+        if (mCallId != null || mPendingParticipantStatistics == 0) {
+            mImsRILAdapter.removeParticipants(Integer.parseInt(mCallId),
+                    mPendingParticipantInfo[mPendingParticipantInfoIndex], result);
+        } else {
+            Rlog.e(LOG_TAG, "removeParticipants fail since no call ID or participants is null" +
+                    " CallID=" + mCallId + " Participant number=" + mPendingParticipantStatistics);
+            if (mListener != null) {
+                try {
+                    mListener.callSessionRemoveParticipantsRequestFailed(
+                            ImsCallSessionProxy.this, new ImsReasonInfo());
+                } catch (RemoteException e) {
+                    Rlog.e(LOG_TAG, "RemoteException occurs when RemoveParticipantsRequestFailed");
+                }
+            }
+        }
+    }
+
+    @Override
+    public void sendDtmf(char c, Message result) {
+        mImsRILAdapter.sendDtmf(c, result);
+    }
+
+    @Override
+    public void startDtmf(char c) {
+        mImsRILAdapter.startDtmf(c, null);
+    }
+
+    @Override
+    public void stopDtmf() {
+        mImsRILAdapter.stopDtmf(null);
+    }
+
+    // Google issue. Original sendDtmf could not pass Message.target to another process,
+    // because Message.writeToParcel didn't write target. Workaround this issue by adding
+    // a new API which passes target by Messenger.
+    @Override
+    public void sendDtmfbyTarget(char c, Message result, Messenger target) {
+        mDtmfMsg = result;
+        mDtmfTarget = target;
+        // Use ImsCallSessionProxy handler to send result back to original Message target.
+        Message local_result = mHandler.obtainMessage(EVENT_DTMF_DONE);
+        mImsRILAdapter.sendDtmf(c, local_result);
+    }
+
+    @Override
+    public void sendUssd(String ussdMessage) {
+    }
+
+    @Override
+    public IImsVideoCallProvider getVideoCallProvider() {
+        Rlog.d(LOG_TAG, "getVideoCallProvider: mVTProvider= " + mVTProvider);
+        if (mVTProvider != null) {
+            return mVTProvider.getInterface();
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public boolean isMultiparty() {
+        return mCallProfile.getCallExtraInt(ImsCallProfile.EXTRA_MPTY, 0) == 1;
+    }
+
+    @Override
+    public boolean isIncomingCallMultiparty() {
+        return mCallProfile.getCallExtraInt(ImsCallProfile.EXTRA_INCOMING_MPTY, 0) == 1;
+    }
+
+    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+
+        /**
+        * To handle IMS conference call message
+        *
+        * @param len    The length of data
+        * @param data   Conference call message
+        */
+
+        private void handleImsConfCallMessage(int len, int callId, String data) {
+            try {
+                if ((data == null) || (data.equals(""))) {
+                    Rlog.e(LOG_TAG, "Failed to handleImsConfCallMessage due to data is empty");
+                    return;
+                }
+
+                Rlog.d(LOG_TAG, "handleVoLteConfCallMessage, data length = " + data.length() +
+                        "callId = " + callId);
+
+                //ALPS02136981. Prints debug messages for ImsPhone.
+                logDebugMessagesWithNotifyFormat("CC", "ConfXMLNotify", "conferenceCall", data);
+
+                // Write conference call data to file
+                String file = "/sdcard/conferenceCall.xml";
+                //For VoLTE testing purpose, mark it temporarily.
+                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(file), "UTF-8");
+                out.write(data, 0, data.length());
+                out.close();
+
+                //Read conference call file and parse it
+                InputStream inStream = new BufferedInputStream(new FileInputStream(file));
+                SAXParserFactory factory = SAXParserFactory.newInstance();
+                SAXParser saxParse = factory.newSAXParser();
+                ConferenceCallMessageHandler xmlData = new ConferenceCallMessageHandler();
+                if (xmlData == null) {
+                    Rlog.e(LOG_TAG, "can't create xmlData object");
+                    return;
+                }
+                saxParse.parse(inStream, xmlData);
+
+                //get user data from xml and fill them into ImsConferenceState data structure.
+                List<ConferenceCallMessageHandler.User> users = xmlData.getUsers();
+                int i = 0;
+                ImsConferenceState imsConferenceState = new ImsConferenceState();
+
+
+                for (ConferenceCallMessageHandler.User u : users) {
+                    i++;
+                    Bundle confInfo = new Bundle();
+                    confInfo.putString(ImsConferenceState.USER,
+                            getUserNameFromSipTelUriString(u.getEntity()));
+                    confInfo.putString(ImsConferenceState.DISPLAY_TEXT, u.getDisplayText());
+                    confInfo.putString(ImsConferenceState.ENDPOINT, u.getEndPoint());
+                    String state = u.getStatus();
+                    if (state.equals(ConferenceCallMessageHandler.STATUS_PENDING)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_PENDING);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_DIALING_OUT)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_DIALING_OUT);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_DIALING_IN)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_DIALING_IN);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_ALERTING)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_ALERTING);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_ON_HOLD)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_ON_HOLD);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_CONNECTED)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_CONNECTED);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_DISCONNECTING)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_DISCONNECTING);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_DISCONNECTED)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_DISCONNECTED);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_MUTED_VIA_FOCUS)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_MUTED_VIA_FOCUS);
+                    } else {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_CONNECT_FAIL);
+                    }
+                    imsConferenceState.mParticipants.put(Integer.toString(i), confInfo);
+                }
+
+                if (mListener != null) {
+                    try {
+                        mListener.callSessionConferenceStateUpdated(ImsCallSessionProxy.this,
+                                imsConferenceState);
+                    } catch (RemoteException e) {
+                        Rlog.e(LOG_TAG, "RemoteException occurs when callSessionConferenceStateUpdated()");
+                    }
+                }
+
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "Failed to handle volte conference call message !!!" + e);
+            }
+        }
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            final String action = intent.getAction();
+            if (DBG) {
+                Rlog.d(LOG_TAG, "received broadcast " + action);
+            }
+            /* Handle IMS conference call xml message */
+            if (mCallId != null) {
+                if (CallControlDispatcher.ACTION_IMS_CONFERENCE_CALL_INDICATION.equals(action)) {
+                    int callId = intent.getIntExtra(CallControlDispatcher.EXTRA_CALL_ID, 3);
+
+                    if (callId == Integer.parseInt(mCallId)) {
+                        String data = intent.getStringExtra(
+                                CallControlDispatcher.EXTRA_MESSAGE_CONTENT);
+                        if ((data != null) && (!data.equals(""))) {
+                            handleImsConfCallMessage(data.length(), callId, data);
+                        }
+                    }
+                }
+            } else {
+                Rlog.e(LOG_TAG, "can't handle conference message since no call ID. Abnormal Case");
+            }
+        }
+    };
+
+    private class MyHandler extends Handler {
+
+        private static final String PAU_NUMBER_FIELD = "<tel:";
+        private static final String PAU_NAME_FIELD = "<name:";
+        private static final String PAU_SIP_NUMBER_FIELD = "<sip:";
+        private static final String PAU_END_FLAG_FIELD = ">";
+
+        public MyHandler(Looper looper) {
+            super(looper, null, true);
+        }
+
+        private String getFieldValueFromPau(String pau, String field) {
+            String value = "";
+            if (TextUtils.isEmpty(pau) || TextUtils.isEmpty(field)) {
+                Rlog.d(LOG_TAG, "getFieldValueFromPau()... pau or field is null !");
+                return value;
+            }
+
+            if (!pau.contains(field)) {
+                Rlog.d(LOG_TAG, "getFieldValueFromPau()... There is no such field in pau !"
+                        + " field / pau :" + field + " / " + pau);
+                return value;
+            }
+
+            int startIndex = pau.indexOf(field);
+            startIndex += field.length();
+            int endIndex = pau.indexOf(PAU_END_FLAG_FIELD, startIndex);
+            value = pau.substring(startIndex, endIndex);
+            return value;
+        }
+
+        private int sipCauseFromCode(int causeCode) {
+            Rlog.d(LOG_TAG, "sipCauseFromCode: causeCode = " + causeCode);
+
+            switch (causeCode) {
+                case CallFailCause.USER_BUSY:
+                    return ImsReasonInfo.CODE_SIP_BUSY;
+
+                case CallFailCause.TEMPORARY_FAILURE:
+                case CallFailCause.CHANNEL_NOT_AVAIL:
+                    return ImsReasonInfo.CODE_SIP_TEMPRARILY_UNAVAILABLE;
+
+                case CallFailCause.QOS_NOT_AVAIL:
+                    return ImsReasonInfo.CODE_SIP_NOT_ACCEPTABLE;
+
+                case CallFailCause.NO_CIRCUIT_AVAIL:
+                case CallFailCause.FACILITY_NOT_IMPLEMENT:
+                case CallFailCause.PROTOCOL_ERROR_UNSPECIFIED:
+                    return ImsReasonInfo.CODE_SIP_SERVER_INTERNAL_ERROR;
+
+                case CallFailCause.ACM_LIMIT_EXCEEDED:
+                    return ImsReasonInfo.CODE_LOCAL_CALL_EXCEEDED;
+
+                case CallFailCause.CALL_BARRED:
+                case CallFailCause.FDN_BLOCKED:
+                    return ImsReasonInfo.CODE_LOCAL_ILLEGAL_STATE;
+
+                case CallFailCause.BEARER_NOT_AVAIL:
+                case CallFailCause.INTERWORKING_UNSPECIFIED:
+                /* sip 510 not implemented */
+                case CallFailCause.FACILITY_REJECTED:
+                /* sip 502 bad gateway */
+                case CallFailCause.ACCESS_INFORMATION_DISCARDED:
+                    return ImsReasonInfo.CODE_SIP_SERVER_ERROR;
+
+                case CallFailCause.NO_USER_RESPONDING:
+                    return ImsReasonInfo.CODE_TIMEOUT_NO_ANSWER;
+
+                case CallFailCause.USER_ALERTING_NO_ANSWER:
+                    return ImsReasonInfo.CODE_USER_NOANSWER;
+
+                case CallFailCause.CALL_REJECTED:
+                    return ImsReasonInfo.CODE_SIP_USER_REJECTED;
+
+                case CallFailCause.NORMAL_UNSPECIFIED:
+                    return ImsReasonInfo.CODE_USER_TERMINATED_BY_REMOTE;
+
+                case CallFailCause.UNOBTAINABLE_NUMBER:
+                case CallFailCause.INVALID_NUMBER_FORMAT:
+                    return ImsReasonInfo.CODE_SIP_BAD_ADDRESS;
+
+                case CallFailCause.RESOURCE_UNAVAILABLE:
+                case CallFailCause.SWITCHING_CONGESTION:
+                case CallFailCause.SERVICE_NOT_AVAILABLE:
+                case CallFailCause.NETWORK_OUT_OF_ORDER:
+                case CallFailCause.INCOMPATIBLE_DESTINATION:
+                    return ImsReasonInfo.CODE_SIP_SERVICE_UNAVAILABLE;
+
+                case CallFailCause.BEARER_NOT_AUTHORIZED:
+                case CallFailCause.INCOMING_CALL_BARRED_WITHIN_CUG:
+                    return ImsReasonInfo.CODE_SIP_FORBIDDEN;
+
+                case CallFailCause.CHANNEL_UNACCEPTABLE:
+                case CallFailCause.BEARER_NOT_IMPLEMENT:
+                    return ImsReasonInfo.CODE_SIP_NOT_ACCEPTABLE;
+
+                case CallFailCause.NO_ROUTE_TO_DESTINATION:
+                    return ImsReasonInfo.CODE_SIP_NOT_FOUND;
+
+                case CallFailCause.OPERATOR_DETERMINED_BARRING:
+                    return ImsReasonInfo.CODE_SIP_REQUEST_CANCELLED;
+
+                case CallFailCause.RECOVERY_ON_TIMER_EXPIRY:
+                    return ImsReasonInfo.CODE_SIP_REQUEST_TIMEOUT;
+
+                /* SIP 481: call/transaction doesn't exist */
+                case CallFailCause.INVALID_TRANSACTION_ID_VALUE:
+                    return ImsReasonInfo.CODE_SIP_CLIENT_ERROR;
+
+                /* [VoLTE]Normal call failed, need to dial as ECC */
+                case CallFailCause.IMS_EMERGENCY_REREG:
+                    return ImsReasonInfo.CODE_SIP_REDIRECTED_EMERGENCY;
+
+                case CallFailCause.ERROR_UNSPECIFIED:
+                case CallFailCause.NORMAL_CLEARING:
+                default:
+                    // WFC: Because +CEER doesn't carry fail cause for WifiCalling, we need to get
+                    // fail cause from WifiOffloadService
+                    int wfcReason = getWfcDisconnectCause(causeCode);
+                    if (wfcReason != WFC_GET_CAUSE_FAILED) {
+                        return wfcReason;
+                    }
+
+                    int serviceState = mImsService.getImsServiceState();
+
+                    Rlog.d(LOG_TAG, "serviceState = " + serviceState);
+
+                    if (serviceState == ServiceState.STATE_POWER_OFF) {
+                        return ImsReasonInfo.CODE_LOCAL_POWER_OFF;
+                    } else if (serviceState == ServiceState.STATE_OUT_OF_SERVICE) {
+                        return ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN;
+                    } else if (causeCode == CallFailCause.NORMAL_CLEARING) {
+                        return ImsReasonInfo.CODE_USER_TERMINATED_BY_REMOTE;
+                    } else {
+                        // If nothing else matches, report unknown call drop reason
+                        // to app, not NORMAL call end.
+                        return ImsReasonInfo.CODE_UNSPECIFIED;
+                    }
+                }
+        }
+
+        private boolean isCallModeUpdated(int callMode, int videoState) {
+            Rlog.d(LOG_TAG, "updateCallMode- callMode:" + callMode + "videoState:" + videoState);
+            boolean isChanged = false;
+            int oldCallMode = mCallProfile.mCallType;
+
+            if (callMode == IMS_VIDEO_CALL || callMode == IMS_VIDEO_CONF ||
+                    callMode == IMS_VIDEO_CONF_PARTS) {
+                switch(videoState) {
+                    case 0:  //pause
+                        mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT_NODIR;
+                        break;
+                    case 1:  //send only
+                        mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT_TX;
+                        break;
+                    case 2:  // recv only
+                        mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT_RX;
+                        break;
+                    case 3:  // send and recv
+                        mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT;
+                        break;
+                    default:
+                        mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT;
+                        break;
+                }
+
+                if (mCallProfile.mCallType != oldCallMode) {
+                    isChanged = true;
+                }
+            } else if (callMode == IMS_VOICE_CALL || callMode == IMS_VOICE_CONF ||
+                    callMode == IMS_VOICE_CONF_PARTS) {
+                mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VOICE;
+                if (mCallProfile.mCallType != oldCallMode) {
+                    isChanged = true;
+                }
+            }
+
+            return isChanged;
+        }
+
+        private void retrieveMergeFail() {
+
+            ImsCallInfo mergeCallInfo = null;
+            ImsCallInfo mergedCallInfo = null;
+            boolean     isNotifyMergeFail = false;
+
+            Rlog.d(LOG_TAG, "retrieveMergeFail");
+            if (mMergeCallId != null && !mMergeCallId.equals("")) {
+                mergeCallInfo = mImsRILAdapter.getCallInfo(mMergeCallId);
+            }
+
+            if (mMergedCallId != null && !mMergedCallId.equals("")) {
+                mergedCallInfo = mImsRILAdapter.getCallInfo(mMergedCallId);
+            }
+
+            if (mergeCallInfo != null && mergedCallInfo != null) {
+                Rlog.d(LOG_TAG, "retrieveMergeFail- MergeCallInfo: callId=" + mergeCallInfo.mCallId
+                        + " call status=" + mergeCallInfo.mState + " MergedCallInfo: callId=" +
+                        mergedCallInfo.mCallId + " call status=" + mergedCallInfo.mState);
+                if (mergeCallInfo.mState == ImsCallInfo.State.ACTIVE &&
+                        mergedCallInfo.mState == ImsCallInfo.State.HOLDING) {
+                    //Nothing Change
+                    isNotifyMergeFail = true;
+                } else if (mergeCallInfo.mState == ImsCallInfo.State.ACTIVE &&
+                        mergedCallInfo.mState == ImsCallInfo.State.ACTIVE) {
+                    // 2 active call and hold the merged call
+                    Rlog.d(LOG_TAG, "retrieveMergeFail- two active call and hold merged call");
+                    Message result = mHandler.obtainMessage(EVENT_RETRIEVE_MERGE_FAIL_RESULT);
+                    mImsRILAdapter.hold(Integer.parseInt(mMergedCallId), result);
+                } else if (mergeCallInfo.mState == ImsCallInfo.State.HOLDING &&
+                        mergedCallInfo.mState == ImsCallInfo.State.HOLDING) {
+                    // 2 hold call and resume merge call
+                    Rlog.d(LOG_TAG, "retrieveMergeFail- two hold call and resume merge call");
+                    Message result = mHandler.obtainMessage(EVENT_RETRIEVE_MERGE_FAIL_RESULT);
+                    mImsRILAdapter.resume(Integer.parseInt(mMergeCallId), result);
+                } else {
+                    /*
+                     *Sincemerge call is become hold and merged call is become active,
+                     *we need to swap two calls
+                     */
+                    Rlog.d(LOG_TAG, "retrieveMergeFail- swap two calls");
+                    Message result = mHandler.obtainMessage(EVENT_RETRIEVE_MERGE_FAIL_RESULT);
+                    mImsRILAdapter.swap(result);
+                }
+            } else if (mergeCallInfo == null || mergedCallInfo == null) {
+                //Only one call is exist and maintain the call state to original state
+                if (mergeCallInfo != null) {
+                    Rlog.d(LOG_TAG, "retrieveMergeFail- only merge call is left");
+                    if (mergeCallInfo.mState != ImsCallInfo.State.ACTIVE) {
+                        Message result = mHandler.obtainMessage(EVENT_RETRIEVE_MERGE_FAIL_RESULT);
+                        mImsRILAdapter.resume(Integer.parseInt(mMergeCallId), result);
+                    } else {
+                        isNotifyMergeFail = true;
+                    }
+                } else if (mergedCallInfo != null) {
+                    Rlog.d(LOG_TAG, "retrieveMergeFail- only merged call is left");
+                    if (mergedCallInfo.mState != ImsCallInfo.State.HOLDING) {
+                        Message result = mHandler.obtainMessage(EVENT_RETRIEVE_MERGE_FAIL_RESULT);
+                        mImsRILAdapter.hold(Integer.parseInt(mMergedCallId), result);
+                    } else {
+                        isNotifyMergeFail = true;
+                    }
+                }
+            }
+
+            if (isNotifyMergeFail) {
+                mergeFailed();
+            }
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            AsyncResult ar;
+            int callMode = INVALID_CALL_MODE;
+            if (DBG) {
+                Rlog.d(LOG_TAG, "receive message by ImsCallSessionProxy - CallId:" + mCallId);
+            }
+
+            switch (msg.what) {
+                case EVENT_CALL_INFO_INDICATION:
+                    /* +ECPI:<call_id>, <msg_type>, <is_ibt>, <is_tch>, <dir>, <call_mode>[, <number>, <toa>], "",<cause>
+                     *
+                     * if msg_type = DISCONNECT_MSG or ALL_CALLS_DISC_MSG,
+                     * +ECPI:<call_id>, <msg_type>, <is_ibt>, <is_tch>,,,"",,"",<cause>
+                     *
+                     * if others,
+                     * +ECPI:<call_id>, <msg_type>, <is_ibt>, <is_tch>, <dir>, <call_mode>[, <number>, <toa>], ""
+                     *
+                     *      0  O  CSMCC_SETUP_MSG
+                     *      1  X  CSMCC_DISCONNECT_MSG
+                     *      2  O  CSMCC_ALERT_MSG
+                     *      3  X  CSMCC_CALL_PROCESS_MSG
+                     *      4  X  CSMCC_SYNC_MSG
+                     *      5  X  CSMCC_PROGRESS_MSG
+                     *      6  O  CSMCC_CALL_CONNECTED_MSG
+                     *   129  X  CSMCC_ALL_CALLS_DISC_MSG
+                     *   130  O  CSMCC_MO_CALL_ID_ASSIGN_MSG
+                     *   131  O  CSMCC_STATE_CHANGE_HELD
+                     *   132  O  CSMCC_STATE_CHANGE_ACTIVE
+                     *   133  O  CSMCC_STATE_CHANGE_DISCONNECTED
+                     *   134  X  CSMCC_STATE_CHANGE_MO_DISCONNECTING
+                     */
+                    ar = (AsyncResult) msg.obj;
+                    String[] callInfo = (String[]) ar.result;
+                    int msgType = 0;
+                    boolean isCallProfileUpdated = false;
+
+                    if (DBG) Rlog.d(LOG_TAG, "receive EVENT_CALL_INFO_INDICATION");
+                    if ((callInfo[1] != null) && (!callInfo[1].equals(""))) {
+                        msgType = Integer.parseInt(callInfo[1]);
+                    }
+
+                    if ((callInfo[5] != null) && (!callInfo[5].equals(""))) {
+                        callMode = Integer.parseInt(callInfo[5]);
+                    }
+
+                    if (mIsMerging && (!callInfo[0].equals(mCallId))) {
+                        switch (msgType) {
+                            case 130:
+                                Rlog.d(LOG_TAG, "IMS: +ECPI : conference assign call id");
+                                ImsCallProfile imsCallProfile = new ImsCallProfile();
+                                if ((callInfo[6] != null) && (!callInfo[6].equals(""))) {
+                                    imsCallProfile.setCallExtra(ImsCallProfile.EXTRA_OI,
+                                            callInfo[6]);
+                                    /*
+                                    *we assume the remote uri information is same as telephone
+                                    * number and update the remote ui information after getting pau.
+                                    */
+                                    imsCallProfile.setCallExtra(ImsCallProfile.EXTRA_REMOTE_URI,
+                                            callInfo[6]);
+                                    imsCallProfile.setCallExtraInt(ImsCallProfile.EXTRA_OIR,
+                                            ImsCallProfile.OIR_PRESENTATION_NOT_RESTRICTED);
+                                } else {
+                                    imsCallProfile.setCallExtraInt(ImsCallProfile.EXTRA_OIR,
+                                            ImsCallProfile.OIR_PRESENTATION_NOT_RESTRICTED);
+                                }
+
+                                mConfSession = new ImsCallSessionProxy(mContext,imsCallProfile,
+                                        null, mImsService, mServiceHandler, mImsRILAdapter, callInfo[0]);
+                                try {
+                                    mListener.callSessionMergeStarted(ImsCallSessionProxy.this,
+                                            mConfSession, mCallProfile);
+                                } catch (RemoteException e) {
+                                    Rlog.e(LOG_TAG, "RemoteException when session merged started");
+                                }
+                                break;
+                            default:
+                                break;
+                        }
+                    } else if (mCallId != null && mCallId.equals(callInfo[0])) {
+                        switch (msgType) {
+                            case 0:
+                                mState = ImsCallSession.State.ESTABLISHING;
+                                Rlog.d(LOG_TAG, "IMS: +ECPI : incoming call");
+                                if ((callInfo[5] != null) && (!callInfo[5].equals(""))) {
+                                    callMode = Integer.parseInt(callInfo[5]);
+                                }
+
+                                if (callMode == IMS_VIDEO_CALL || callMode == IMS_VIDEO_CONF ||
+                                        callMode == IMS_VIDEO_CONF_PARTS) {
+                                    mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT;
+                                } else {
+                                    mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VOICE;
+                                }
+
+                                if (callMode == IMS_VOICE_CONF ||
+                                        callMode == IMS_VIDEO_CONF ||
+                                        callMode == IMS_VOICE_CONF_PARTS ||
+                                        callMode == IMS_VIDEO_CONF_PARTS) {
+                                    mCallProfile.setCallExtraInt(
+                                            ImsCallProfile.EXTRA_INCOMING_MPTY, 1);
+
+                                    // ALPS02136981. Prints debug messages for ImsPhone.
+                                    mCallNumber = "conferenceCall";
+                                } else {
+                                    mCallProfile.setCallExtraInt(
+                                            ImsCallProfile.EXTRA_INCOMING_MPTY, 0);
+
+                                    // ALPS02136981. Prints debug messages for ImsPhone.
+                                    mCallNumber = callInfo[6];
+                                }
+
+                                if ((callInfo[6] != null) && (!callInfo[6].equals(""))) {
+                                    mCallProfile.setCallExtra(ImsCallProfile.EXTRA_OI, callInfo[6]);
+                                    /*
+                                    * we assume the remote uri information is same as telephone
+                                    * number and update the remote ui information after getting pau.
+                                    */
+                                    mCallProfile.setCallExtra(ImsCallProfile.EXTRA_REMOTE_URI,
+                                            callInfo[6]);
+                                }
+                                mCallProfile.setCallExtraInt(ImsCallProfile.EXTRA_OIR,
+                                            ImsCallProfile.OIR_PRESENTATION_NOT_RESTRICTED);
+                                /* ServiceID may need to refine in the future */
+                                int serviceId = 1;
+
+                                Rlog.d(LOG_TAG, "IMS: sendIncomingCallIntent() call_id = "
+                                        + mCallId + " dialString = " +  callInfo[6]);
+
+                                //ALPS02136981. Prints debug messages for ImsPhone.
+                                logDebugMessagesWithNotifyFormat("CC", "MT", mCallNumber, "");
+
+                                Intent intent = new Intent(ImsManager.ACTION_IMS_INCOMING_CALL);
+                                intent.putExtra(ImsManager.EXTRA_CALL_ID, mCallId);
+                                intent.putExtra(ImsManager.EXTRA_DIAL_STRING, callInfo[6]);
+                                intent.putExtra(ImsManager.EXTRA_SERVICE_ID, serviceId);
+                                mContext.sendBroadcast(intent);
+                                break;
+                            case 2: // CSMCC_ALERT_MSG
+                                int isIbt = 1;
+
+                                if (callInfo[2] != null) {
+                                    isIbt = Integer.parseInt(callInfo[2]);
+                                }
+
+                                // ALPS02136981. Prints debug messages for ImsPhone.
+                                if (callMode == IMS_VOICE_CONF ||
+                                        callMode == IMS_VIDEO_CONF ||
+                                        callMode == IMS_VOICE_CONF_PARTS ||
+                                        callMode == IMS_VIDEO_CONF_PARTS) {
+                                    mCallNumber = "conferenceCall";
+                                }
+                                logDebugMessagesWithNotifyFormat(
+                                        "CC", "Alerting", mCallNumber, " isIbt=" + isIbt);
+
+                                if (isIbt == 0) {
+                                    mCallProfile.mMediaProfile.mAudioDirection =
+                                            ImsStreamMediaProfile.DIRECTION_INACTIVE;
+                                }
+
+                                updatePau(callInfo[8]);
+
+                                if (mListener != null) {
+                                    try {
+                                        mListener.callSessionProgressing(ImsCallSessionProxy.this,
+                                                mCallProfile.mMediaProfile);
+                                    } catch (RemoteException e) {
+                                        Rlog.e(LOG_TAG, "RemoteException callSessionProgressing");
+                                    }
+                                }
+                                mHasPendingMo = false;
+                                break;
+                            case 6: //CSMCC_CALL_CONNECTED_MSG
+                                mState = ImsCallSession.State.ESTABLISHED;
+                                mCallProfile.mMediaProfile.mAudioDirection =
+                                        ImsStreamMediaProfile.DIRECTION_SEND_RECEIVE;
+
+                                updateMultipartyState(callMode);
+
+                                // ALPS02136981. Prints debug messages for ImsPhone.
+                                logDebugMessagesWithNotifyFormat("CC", "Active", mCallNumber, "");
+
+                                updatePau(callInfo[8]);
+
+                                if (mListener != null) {
+                                    try {
+                                        /* There may not has alerting message while dial
+                                         * conference call. We need to reset mHasPendingMO.
+                                         */
+                                        if (mHasPendingMo) {
+                                            mListener.callSessionProgressing(
+                                                    ImsCallSessionProxy.this,
+                                                    mCallProfile.mMediaProfile);
+                                        }
+                                        mListener.callSessionStarted(ImsCallSessionProxy.this,
+                                                mCallProfile);
+                                    } catch (RemoteException e) {
+                                        Rlog.e(LOG_TAG, "RemoteException callSessionStarted()");
+                                    }
+                                }
+                                mHasPendingMo = false;
+                                break;
+                            case 131: //CSMCC_STATE_CHANGE_HELD
+                                // ALPS02136981. Prints debug messages for ImsPhone.
+                                logDebugMessagesWithNotifyFormat("CC", "Onhold", mCallNumber, "");
+
+                                updatePau(callInfo[8]);
+
+                                if (mListener != null) {
+                                    if (mIsHideHoldEventDuringMerging == false) {
+                                        try {
+                                            mListener.callSessionHeld(ImsCallSessionProxy.this,
+                                                    mCallProfile);
+                                        } catch (RemoteException e) {
+                                            Rlog.e(LOG_TAG, "RemoteException callSessionHeld");
+                                        }
+                                    } else {
+                                        try {
+                                            mListener.callSessionPauInfoChanged(
+                                                    ImsCallSessionProxy.this, mCallProfile);
+                                        } catch (RemoteException e) {
+                                            Rlog.e(LOG_TAG,
+                                                "RemoteException callSessionPauInfoChanged");
+                                        }
+                                    }
+                                }
+                                break;
+                            case 132: //CSMCC_STATE_CHANGE_ACTIVE
+                                updatePau(callInfo[8]);
+
+                                if (mListener != null) {
+                                    if (mState == ImsCallSession.State.ESTABLISHED) {
+                                        try {
+                                            // ALPS02136981. Prints debug messages for ImsPhone.
+                                            logDebugMessagesWithNotifyFormat("CC", "Active", mCallNumber, "");
+
+                                            mListener.callSessionResumed(
+                                                    ImsCallSessionProxy.this, mCallProfile);
+                                        } catch (RemoteException e) {
+                                            Rlog.e(LOG_TAG, "RemoteException SessionResumed");
+                                        }
+                                    } else {
+                                        try {
+                                            mListener.callSessionPauInfoChanged(
+                                                    ImsCallSessionProxy.this, mCallProfile);
+                                        } catch (RemoteException e) {
+                                            Rlog.e(LOG_TAG,
+                                                "RemoteException callSessionPauInfoChanged");
+                                        }
+                                    }
+                                }
+                                break;
+                            case 133: //CSMCC_STATE_CHANGE_DISCONNECTED
+                                // ALPS02136981. Prints debug messages for ImsPhone.
+                                logDebugMessagesWithNotifyFormat("CC", "Disconnected", mCallNumber, "");
+
+                                mIsOnTerminated = true;
+                                mState = ImsCallSession.State.TERMINATED;
+                                if (mHasPendingMo) {
+                                    mHasPendingMo = false;
+                                    mCallErrorState = CallErrorState.DIAL;
+                                } else {
+                                    mCallErrorState = CallErrorState.DISCONNECT;
+                                }
+                                Message result = mHandler.obtainMessage(
+                                        EVENT_GET_LAST_CALL_FAIL_CAUSE);
+                                mImsRILAdapter.getLastCallFailCause(result);
+                                break;
+                            default:
+                                break;
+                        }
+                    } else if (mCallId == null && msgType == 130) {
+                        Rlog.d(LOG_TAG, "IMS: receive 130 URC, call_id = " + callInfo[0]);
+                        mState = ImsCallSession.State.ESTABLISHING;
+                        mCallId = callInfo[0];
+                        if (mVTProvider != null) {
+                            mVTProvider.setId(Integer.parseInt(mCallId));
+                        }
+                    }
+                    break;
+                case EVENT_RINGBACK_TONE:
+                    ar = (AsyncResult) msg.obj;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_RINGBACK_TONE");
+                    }
+                    break;
+                case EVENT_ECONF_RESULT_INDICATION:
+                    ar = (AsyncResult) msg.obj;
+                    handleEconfIndication((String[]) ar.result);
+                    break;
+                case EVENT_DIAL_RESULT:
+                case EVENT_DIAL_CONFERENCE_RESULT:
+                    ar = (AsyncResult) msg.obj;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive DIAL_RESULT or DIAL_CONFERENCE_RESULT");
+                    }
+                    if (ar.exception != null) {
+                        if (DBG) {
+                            Rlog.d(LOG_TAG, "dial call failed!!");
+                        }
+                        if (mListener != null) {
+
+                            Message result = mHandler.obtainMessage(
+                                    EVENT_GET_LAST_CALL_FAIL_CAUSE);
+                            mCallErrorState = CallErrorState.DIAL;
+                            mImsRILAdapter.getLastCallFailCause(result);
+                            mHasPendingMo = false;
+                        }
+                    }
+                    break;
+                case EVENT_HOLD_RESULT:
+                    ar = (AsyncResult) msg.obj;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_HOLD_RESULT");
+                    }
+                    if (mListener != null) {
+                        if (ar.exception != null) {
+                            if (DBG) {
+                                Rlog.d(LOG_TAG, "hold call failed!!");
+                            }
+                            try {
+                                ImsReasonInfo imsReasonInfo = null;
+                                if ((ar.exception instanceof CommandException)
+                                        && (((CommandException) (ar.exception)).getCommandError()
+                                            == Error.CC_CALL_HOLD_FAILED_CAUSED_BY_TERMINATED)) {
+                                    imsReasonInfo = new ImsReasonInfo(
+                                            ImsReasonInfo.CODE_LOCAL_CALL_TERMINATED, 0);
+                                } else {
+                                    imsReasonInfo = new ImsReasonInfo();
+                                }
+                                mListener.callSessionHoldFailed(ImsCallSessionProxy.this,
+                                        imsReasonInfo);
+                            } catch (RemoteException e) {
+                                Rlog.e(LOG_TAG, "RemoteException callSessionHoldFailed()");
+                            }
+                        } else {
+                            if (DBG) {
+                                Rlog.d(LOG_TAG, "hold call successed!!");
+                            }
+                        }
+                    }
+                    break;
+                case EVENT_RESUME_RESULT:
+                    ar = (AsyncResult) msg.obj;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_RESUME_RESULT");
+                    }
+                    if (mListener != null) {
+                        if (ar.exception != null) {
+                            if (DBG) {
+                                Rlog.d(LOG_TAG, "resume call failed!!");
+                            }
+                            try {
+                                mListener.callSessionResumeFailed(ImsCallSessionProxy.this,
+                                        new ImsReasonInfo());
+                            } catch (RemoteException e) {
+                                Rlog.e(LOG_TAG, "RemoteException callSessionResumeFailed()");
+                            }
+                        } else {
+                            if (DBG) {
+                                Rlog.d(LOG_TAG, "resume call successed");
+                            }
+                        }
+                    }
+                    break;
+                case EVENT_MERGE_RESULT:
+                    ar = (AsyncResult) msg.obj;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_MERGE_RESULT");
+                    }
+                    if (mListener != null) {
+                        if (ar.exception != null) {
+                            if (DBG) {
+                                Rlog.d(LOG_TAG, "merge call failed!!");
+                            }
+                            // ALPS02136981. Prints debug messages for ImsPhone.
+                            logDebugMessagesWithNotifyFormat(
+                                    "CC", "ConfCreated", "conferenceCall", " failed");
+
+                            retrieveMergeFail();
+                        }
+                    }
+                    break;
+                case EVENT_RETRIEVE_MERGE_FAIL_RESULT:
+
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_RETRIEVE_MERGE_FAIL_RESULT");
+                    }
+                    // Don't care the retrieve result and just notify merge fail to ImsPhone.
+                    mergeFailed();
+                    break;
+                case EVENT_ADD_CONFERENCE_RESULT:
+                    ar = (AsyncResult) msg.obj;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_ADD_CONFERENCE_RESULT");
+                    }
+
+                    if (mIsMerging) {
+                        if (ar.exception != null) {
+                            retrieveMergeFail();
+                        } else {
+                            /*
+                             * We only know the merge command is accepted by server for now.
+                             * The merge result will be notified by receiving +ECONF URC.
+                             */
+                        }
+                    } else {
+                        if (mIsOnTerminated == true) {
+                            break;
+                        }
+
+                        if (ar.exception == null) {
+                            mIsAddRemoveParticipantsCommandOK = true;
+                        }
+                        mPendingParticipantInfoIndex ++;
+
+                        if (mPendingParticipantInfoIndex < mPendingParticipantStatistics) {
+                            Message result = mHandler.obtainMessage(EVENT_ADD_CONFERENCE_RESULT);
+
+                            mImsRILAdapter.inviteParticipants(Integer.parseInt(mCallId),
+                                    mPendingParticipantInfo[mPendingParticipantInfoIndex], result);
+
+                        } else {
+                            if (mListener != null) {
+                                if (mIsAddRemoveParticipantsCommandOK == false) {
+                                    try {
+                                        mListener.callSessionInviteParticipantsRequestFailed(
+                                                ImsCallSessionProxy.this, new ImsReasonInfo());
+                                    } catch (RemoteException e) {
+                                        Rlog.e(LOG_TAG, "RemoteException InviteFailed()");
+                                    }
+                                } else {
+                                    try {
+                                        mListener.callSessionInviteParticipantsRequestDelivered(
+                                                ImsCallSessionProxy.this);
+                                    } catch (RemoteException e) {
+                                        Rlog.e(LOG_TAG, "RemoteException InviteDelivered()");
+                                    }
+                                }
+                            }
+                            mIsAddRemoveParticipantsCommandOK = false;
+                        }
+                    }
+                    break;
+                case EVENT_REMOVE_CONFERENCE_RESULT:
+                    ar = (AsyncResult) msg.obj;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_REMOVE_CONFERENCE_RESULT");
+                    }
+
+                    if (mIsOnTerminated == true) {
+                        break;
+                    }
+
+                    if (ar.exception == null) {
+                        mIsAddRemoveParticipantsCommandOK = true;
+                    }
+
+                    mPendingParticipantInfoIndex ++;
+                    if (mPendingParticipantInfoIndex < mPendingParticipantStatistics) {
+                        Message result = mHandler.obtainMessage(EVENT_ADD_CONFERENCE_RESULT);
+
+                        mImsRILAdapter.removeParticipants(Integer.parseInt(mCallId),
+                                mPendingParticipantInfo[mPendingParticipantInfoIndex], result);
+                    } else {
+                        if (mListener != null) {
+                            if (mIsAddRemoveParticipantsCommandOK == false) {
+                                try {
+                                    mListener.callSessionRemoveParticipantsRequestFailed(
+                                            ImsCallSessionProxy.this, new ImsReasonInfo());
+                                } catch (RemoteException e) {
+                                    Rlog.e(LOG_TAG, "RemoteException RemoveFailed()");
+                                }
+                            } else {
+                                try {
+                                    mListener.callSessionRemoveParticipantsRequestDelivered(
+                                            ImsCallSessionProxy.this);
+                                } catch (RemoteException e) {
+                                    Rlog.e(LOG_TAG, "RemoteException RemoveDelivered()");
+                                }
+                            }
+                        }
+                        mIsAddRemoveParticipantsCommandOK = false;
+                    }
+                    break;
+                case EVENT_GET_LAST_CALL_FAIL_CAUSE:
+                    ar = (AsyncResult) msg.obj;
+                    ImsReasonInfo imsReasonInfo;
+                    int sipCauseCode = ImsReasonInfo.CODE_UNSPECIFIED;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_GET_LAST_CALL_FAIL_CAUSE");
+                    }
+
+                    if (ar.exception != null) {
+                        imsReasonInfo = new ImsReasonInfo();
+                    } else {
+                        LastCallFailCause failCause = (LastCallFailCause) ar.result;
+                        sipCauseCode = sipCauseFromCode(failCause.causeCode);
+                        imsReasonInfo = new ImsReasonInfo(sipCauseCode, 0);
+                    }
+
+                    switch (mCallErrorState) {
+                        case DIAL :
+                            if (mListener != null) {
+                                try {
+                                    mListener.callSessionStartFailed(ImsCallSessionProxy.this,
+                                            imsReasonInfo);
+                                } catch (RemoteException e) {
+                                    Rlog.e(LOG_TAG, "RemoteException callSessionStartFailed()");
+                                }
+                            }
+                            break;
+                        case DISCONNECT :
+                            if (mListener != null) {
+                                try {
+                                    mListener.callSessionTerminated(ImsCallSessionProxy.this,
+                                            imsReasonInfo);
+                                } catch (RemoteException e) {
+                                    Rlog.e(LOG_TAG, "RemoteException callSessionTerminated()");
+                                }
+                            }
+                            break;
+                        default:
+                            break;
+                    }
+                    break;
+                case EVENT_SIP_CODE_INDICATION:
+                    ar = (AsyncResult) msg.obj;
+                    int[] sipMessage = (int[]) ar.result;
+                    if (DBG) {
+                        /* ESIPCPI: <call_id>,<dir>,<SIP_msg_type>,<method>,<response_code> */
+                        if (mCallId != null) {
+                            if (sipMessage != null && sipMessage[0] == Integer.parseInt(mCallId)) {
+                                Rlog.d(LOG_TAG, "receive sip cause =" + sipMessage[4]);
+                            }
+                        }
+                    }
+                    break;
+                case EVENT_CALL_MODE_CHANGE_INDICATION:
+                    ar = (AsyncResult) msg.obj;
+                    String[] callModeInfo = (String[]) ar.result;
+
+                    /* +EIMSCMODE: <call id>,<call mode>,<video state>,<audio direction>,<PAU> */
+                    if (callModeInfo != null && callModeInfo[0].equals(mCallId)) {
+                        int videoState = 2; // assum video state: send_recv is default value
+                        if ((callModeInfo[1] != null) && (!callModeInfo[1].equals(""))) {
+                            callMode = Integer.parseInt(callModeInfo[1]);
+                        }
+                        if ((callModeInfo[2] != null) && (!callModeInfo[2].equals(""))) {
+                            videoState = Integer.parseInt(callModeInfo[2]);
+                        }
+
+                        if (DBG) {
+                            Rlog.d(LOG_TAG, "receive EVENT_CALL_MODE_CHANGE_INDICATION mode=" +
+                                    callMode + "video state:" + videoState);
+                        }
+                        if (isCallModeUpdated(callMode, videoState)) {
+                            if (mListener != null) {
+                                try {
+                                    mListener.callSessionUpdated(ImsCallSessionProxy.this,
+                                            mCallProfile);
+                                } catch (RemoteException e) {
+                                    Rlog.e(LOG_TAG, "RemoteException callSessionUpdated()");
+                                }
+                            }
+                        }
+                        notifyMultipartyStateChanged(callMode);
+                        if (callModeInfo.length >= 5) {
+                            notifyPauInfoChanged(callModeInfo[4]);
+                        }
+                    }
+                    break;
+                case EVENT_VIDEO_CAPABILITY_INDICATION:
+                    ar = (AsyncResult) msg.obj;
+                    String[] videoCapabilityInfo = (String[]) ar.result;
+                    if (DBG) {
+                        //+EIMSVCAP: <call ID>, <local video capability>, <remote video capability>
+                        boolean  lVideoCapability = false;
+                        boolean  rVideoCapability = false;
+                        if (videoCapabilityInfo != null &&
+                                videoCapabilityInfo[0].equals(mCallId)) {
+                            if ((videoCapabilityInfo[1] != null) &&
+                                    (!videoCapabilityInfo[1].equals(""))) {
+                                lVideoCapability = Boolean.parseBoolean(videoCapabilityInfo[1]);
+                                if (lVideoCapability) {
+                                    mLocalCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT;
+                                } else {
+                                    mLocalCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VOICE;
+                                }
+                            }
+                            if ((videoCapabilityInfo[2] != null) &&
+                                    (!videoCapabilityInfo[2].equals(""))) {
+                                rVideoCapability = Boolean.parseBoolean(videoCapabilityInfo[2]);
+                                if (rVideoCapability) {
+                                    mRemoteCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT;
+                                } else {
+                                    mRemoteCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VOICE;
+                                }
+                            }
+
+                            Rlog.d(LOG_TAG, "receive EVENT_VIDEO_CAPABILITY_INDICATION local " +
+                                    "video capability:" + lVideoCapability +
+                                    " remote video capability:" + rVideoCapability);
+                        }
+                    }
+                    break;
+                case EVENT_DTMF_DONE:
+                    // Send message to original target handler.
+                    if (mDtmfTarget != null && mDtmfMsg != null) {
+                        try {
+                            mDtmfTarget.send(mDtmfMsg);
+                        } catch (RemoteException e) {
+                            Rlog.e(LOG_TAG, "RemoteException handleMessge() for DTMF");
+                        }
+                    }
+                    mDtmfTarget = null;
+                    mDtmfMsg = null;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        private void handleEconfIndication(String[] result) {
+            // +ECONF:<conf_call_id>,<op>,<num>,<result>,<cause>[,<joined_call_id>]
+            if (DBG) {
+                Rlog.d(LOG_TAG, "receive EVENT_ECONF_RESULT_INDICATION mCallId:" + mCallId
+                        + ", conf_call_id:" + result[0] + "joined_call_id:" + result[5]);
+            }
+
+            // Prevent timing issue in ImsCall.processMergeComplete(), it will check if the
+            // session is still alive, by marking this session "terminating"
+            // TODO: check which parameter means original call id
+            if (mCallId != null && mCallId.equals(result[5]) && result[3].equals("0")) {
+                mState = ImsCallSession.State.TERMINATING;
+            }
+
+            if (mIsMerging != true) {
+                return;
+            }
+
+            if (mNormalCallsMerge) {
+                // normal call merge normal call
+                mEconfCount++;
+                if (result[3].equals("0")) {
+                    mThreeWayMergeSucceeded = true;
+                }
+                if (mEconfCount == 2 && mThreeWayMergeSucceeded) {
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "3 way conference merge succeeded");
+                    }
+                    // ALPS02136981. Prints debug messages for ImsPhone.
+                    logDebugMessagesWithNotifyFormat(
+                            "CC", "ConfCreated", "conferenceCall", " successed");
+
+                    mergeCompleted();
+                    mNormalCallsMerge = false;
+                } else if (mEconfCount == 2 && mThreeWayMergeSucceeded != true) {
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "3 way conference merge failed!!");
+                    }
+                    // ALPS02136981. Prints debug messages for ImsPhone.
+                    logDebugMessagesWithNotifyFormat(
+                            "CC", "ConfCreated", "conferenceCall", " failed");
+
+                    retrieveMergeFail();
+                    /// ALPS02383993: Terminate the conference if merge failed @{
+                    int confCallId = Integer.parseInt(result[0]);
+                    mImsRILAdapter.terminate(confCallId);
+                    /// @}
+                    mNormalCallsMerge = false;
+                }
+            } else {
+                // conference call merge normal call
+                if (result[3].equals("0")) {
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "conference call merge normal call successed");
+                    }
+                    // ALPS02136981. Prints debug messages for ImsPhone.
+                    logDebugMessagesWithNotifyFormat(
+                            "CC", "ConfCreated", "conferenceCall", " successed");
+
+                    mergeCompleted();
+                } else {
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "conference call merge normal call failed!!");
+                    }
+                    // ALPS02136981. Prints debug messages for ImsPhone.
+                    logDebugMessagesWithNotifyFormat(
+                            "CC", "ConfCreated", "conferenceCall", " failed");
+
+                    retrieveMergeFail();
+                }
+            }
+        }
+
+        private boolean updateMultipartyState(int callMode) {
+            boolean isMultipartyMode = (callMode == IMS_VOICE_CONF || callMode == IMS_VIDEO_CONF
+                    || callMode == IMS_VOICE_CONF_PARTS || callMode == IMS_VIDEO_CONF_PARTS);
+            if (isMultiparty() == isMultipartyMode) {
+                return false;
+            } else if (isMultipartyMode == true) {
+                mCallProfile.setCallExtraInt(ImsCallProfile.EXTRA_MPTY, 1);
+                mCallNumber = "conferenceCall";
+            } else {
+                mCallProfile.setCallExtraInt(
+                        ImsCallProfile.EXTRA_MPTY, 0);
+            }
+            return true;
+        }
+
+        private void notifyMultipartyStateChanged(int callMode) {
+            boolean stateChanged = updateMultipartyState(callMode);
+            if (stateChanged == false) {
+                return;
+            }
+            if (DBG) {
+                Rlog.d(LOG_TAG, "notifyMultipartyStateChanged isMultiparty(): " + isMultiparty());
+            }
+            if (mListener != null) {
+                try {
+                    mListener.callSessionMultipartyStateChanged(ImsCallSessionProxy.this,
+                            isMultiparty());
+                } catch (RemoteException e) {
+                    Rlog.e(LOG_TAG, "RemoteException callSessionMultipartyStateChanged()");
+                }
+            }
+        }
+
+        private boolean updatePau(String pau) {
+            if (pau == null || pau.equals("")) {
+                return false;
+            }
+            String sipNumber = getFieldValueFromPau(pau, PAU_SIP_NUMBER_FIELD);
+            Rlog.d(LOG_TAG, "updatePau()... sipNumber: " + sipNumber);
+            if (!sipNumber.equals(mCallProfile.getCallExtra(ImsCallProfile.EXTRA_REMOTE_URI))) {
+                mCallProfile.setCallExtra(ImsCallProfile.EXTRA_REMOTE_URI, sipNumber);
+            }
+            if (pau.equals(mCallProfile.getCallExtra(ImsCallProfile.EXTRA_PAU))) {
+                return false;
+            }
+            mCallProfile.setCallExtra(ImsCallProfile.EXTRA_PAU, pau);
+            return true;
+        }
+
+        private void notifyPauInfoChanged(String pau) {
+            if (updatePau(pau) == false) {
+                return;
+            }
+
+            if (mListener == null) {
+                return;
+            }
+            try {
+                mListener.callSessionPauInfoChanged(ImsCallSessionProxy.this, mCallProfile);
+            } catch (RemoteException e) {
+                Rlog.e(LOG_TAG,
+                        "RemoteException callSessionPauInfoChanged");
+            }
+        }
+
+        private int getWfcDisconnectCause(int causeCode) {
+            Rlog.d(LOG_TAG, "[WFC] getWfcDisconnectCause mRatType = " + mRatType);
+            if (mWfoService == null || mRatType != WifiOffloadManager.RAN_TYPE_WIFI
+                    || causeCode == CallFailCause.NORMAL_CLEARING) {
+                return WFC_GET_CAUSE_FAILED;
+            }
+
+            DisconnectCause disconnectCause = null;
+            try {
+                disconnectCause = mWfoService.getDisconnectCause();
+            } catch (RemoteException e) {
+                Rlog.e(LOG_TAG, "RemoteException in getWfcDisconnectCause()");
+            }
+            if (disconnectCause == null) {
+                return WFC_GET_CAUSE_FAILED;
+            }
+            int wfcErrorCause = disconnectCause.getErrorCause();
+            Rlog.d(LOG_TAG, "[WFC] wfcErrorCause = " + wfcErrorCause);
+            if (wfcErrorCause == WfcReasonInfo.CODE_WFC_WIFI_SIGNAL_LOST) {
+                return ImsReasonInfo.CODE_SIP_WIFI_SIGNAL_LOST;
+            } else if ((wfcErrorCause == WfcReasonInfo.CODE_WFC_UNABLE_TO_COMPLETE_CALL)
+                    || (wfcErrorCause == WfcReasonInfo.CODE_WFC_UNABLE_TO_COMPLETE_CALL_CD)) {
+                return ImsReasonInfo.CODE_SIP_HANDOVER_WIFI_FAIL;
+            } else if (wfcErrorCause ==
+                    WfcReasonInfo.CODE_WFC_NO_AVAILABLE_QUALIFIED_MOBILE_NETWORK) {
+                return ImsReasonInfo.CODE_SIP_HANDOVER_LTE_FAIL;
+            } else {
+                return WFC_GET_CAUSE_FAILED;
+            }
+        }
+    }
+
+    private void mergeCompleted() {
+        if (mListener != null) {
+            try {
+                mListener.callSessionMergeComplete(mConfSession);
+            } catch (RemoteException e) {
+                Rlog.e(LOG_TAG, "RemoteException callSessionMerged()");
+            }
+        }
+        mIsMerging = false;
+        mIsHideHoldEventDuringMerging = false;
+    }
+
+    private void mergeFailed() {
+        if (mListener != null) {
+            try {
+                mListener.callSessionMergeFailed(ImsCallSessionProxy.this,
+                        new ImsReasonInfo());
+            } catch (RemoteException e) {
+                Rlog.e(LOG_TAG, "RemoteException callSessionMergeFailed()");
+            }
+        }
+       mMergeCallId = "";
+       mMergeCallStatus = ImsCallInfo.State.INVALID;
+       mMergedCallId = "";
+       mMergedCallStatus = ImsCallInfo.State.INVALID;
+
+       mIsMerging = false;
+       mIsHideHoldEventDuringMerging = false;
+       if (mConfSession instanceof ImsCallSessionProxy) {
+           ((ImsCallSessionProxy) mConfSession).close();
+       }
+    }
+
+    /**
+     * Logs unified debug log messages, for "Notify".
+     * Format: [category][Module][Notify][Action][call-number][local-call-ID] Msg. String.
+     * P.S. uses the RIL call ID as the local call ID.
+     *
+     * @param category currently we only have 'CC' category.
+     * @param action the action name. (e.q. Active, MT, Onhold, etc.)
+     * @param isConf is conference
+     * @param msg the optional messages
+     * @hide
+     */
+    void logDebugMessagesWithNotifyFormat(
+            String category, String action, String callNumber, String msg) {
+        if (category == null || action == null) {
+            // return if no mandatory tags.
+            return;
+        }
+
+        /*
+        FormattedLog formattedLog = new FormattedLog.Builder()
+                .setCategory(category)
+                .setServiceName("ImsPhone")
+                .setOpType(FormattedLog.OpType.NOTIFY)
+                .setActionName(action)
+                .setCallNumber(callNumber)
+                .setCallId(getCallId())
+                .setExtraMessage(msg)
+                .buildDebugMsg();
+        */
+        String s = "[" + category + "][ImsPhone][Notify][" + action + "]["
+                + callNumber + "][" + getCallId() + "] " + msg;
+
+        /*
+        if (formattedLog != null) {
+            Rlog.d(LOG_TAG, formattedLog.toString());
+        }
+        */
+        Rlog.d(LOG_TAG, s);
+    }
+
+    /**
+     * A listener type for receiving notification on WFC handover events.
+     */
+    private class IWifiOffloadListenerProxy extends WifiOffloadManager.Listener {
+        @Override
+        public void onHandover(int stage, int ratType) {
+            if (ratType == mRatType || stage == WifiOffloadManager.HANDOVER_START) {
+                return;
+            }
+            if (mListener != null) {
+                try {
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "onHandover");
+                    }
+                    mListener.callSessionHandover(ImsCallSessionProxy.this, mRatType, ratType,
+                            new ImsReasonInfo());
+                } catch (RemoteException e) {
+                    Rlog.e(LOG_TAG, "RemoteException onHandover()");
+                }
+            }
+            mRatType = ratType;
+        }
+    }
+
+    /**
+     * Get the user name (i.e. phone number or Sip account) from a Sip/Tel Uri string.
+     * Reference RFC 3966.
+     *
+     * @param uriString the string of the Sip/Tel URI.
+     * @return the string of user name.
+     * @hide
+     * @internal
+     */
+    private String getUserNameFromSipTelUriString(String uriString) {
+        if (uriString == null) {
+            return null;
+        }
+
+        Uri uri = Uri.parse(uriString);
+
+        // Gets the address part, i.e. everything between 'sip:' and the fragment separator '#'.
+        // ex: '+8618407404132@10.185.184.137:5087;transport=UDP'
+        // or '1234;phone-context=munich.example.com;isub=@1134'
+        String address = uri.getSchemeSpecificPart();
+        if (address == null) {
+            return null;
+        }
+
+        // Gets user name, i.e. everything before '@'.
+        // ex: '+8618407404132' or '1234;phone-context=munich.example.com;isub='
+        String userName = PhoneNumberUtils.getUsernameFromUriNumber(address);
+        if (userName == null) {
+            return null;
+        }
+
+        // Gets pure user name part, i.e. everything before ';' or ','.
+        // ex: '+8618407404132' or '1234'
+        int pIndex = userName.indexOf(';');    //WAIT
+        int wIndex = userName.indexOf(',');    //PAUSE
+
+        if (pIndex >= 0 && wIndex >= 0) {
+            return userName.substring(0, Math.min(pIndex, wIndex) + 1);
+        } else if (pIndex >= 0) {
+            return userName.substring(0, pIndex + 1);
+        } else if (wIndex >= 0) {
+            return userName.substring(0, wIndex + 1);
+        } else {
+            return userName;
+        }
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsCommandsInterface.java b/packages/Ims/src/com/mediatek/ims/ImsCommandsInterface.java
new file mode 100644
index 0000000..2f18cce
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsCommandsInterface.java
@@ -0,0 +1,56 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+
+/**
+ * {@hide}
+ */
+public interface ImsCommandsInterface {
+    enum RadioState {
+        RADIO_OFF,         /* Radio explicitly powered off (eg CFUN=0) */
+        RADIO_UNAVAILABLE, /* Radio unavailable (eg, resetting or not booted) */
+        RADIO_ON;          /* Radio is on */
+
+        public boolean isOn() /* and available...*/ {
+            return this == RADIO_ON;
+        }
+
+        public boolean isAvailable() {
+            return this != RADIO_UNAVAILABLE;
+        }
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsConfigStub.java b/packages/Ims/src/com/mediatek/ims/ImsConfigStub.java
new file mode 100644
index 0000000..2dff992
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsConfigStub.java
@@ -0,0 +1,261 @@
+package com.mediatek.ims;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+
+import com.android.ims.ImsConfig;
+import com.android.ims.ImsConfigListener;
+import com.android.ims.internal.IImsConfig;
+
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * IMSConfig class for handle the IMS MO configruation.
+ *
+ * The implementation is based on 3GPP 24.167  3GPP IMS Management Object (MO); Stage 3
+ *
+ *  @hide
+ */
+public class ImsConfigStub extends IImsConfig.Stub {
+    private static final String TAG = "ImsConfigService";
+
+    private static final int  MAX_BYTE_COUNT               = 256;
+
+    private Context mContext;
+    private String  mAtCmdResult = "";
+    private static TelephonyManager sTelephonyManager = null;
+    private String  mPcscf;
+    private static final String PROPERTY_VOLTE_ENALBE = "ro.mtk.volte.enable";
+
+    /**
+     *
+     * Construction function for ImsConfigStub.
+     *
+     * @param context the application context
+     *
+     */
+    public ImsConfigStub(Context context) {
+        mContext = context;
+        mPcscf = "";
+    }
+
+    /**
+     * Gets the value for ims service/capabilities parameters from the master
+     * value storage. Synchronous blocking call.
+     *
+     * @param item as defined in com.android.ims.ImsConfig#ConfigConstants.
+     * @return value in Integer format.
+     */
+    @Override
+    public int getProvisionedValue(int item) {
+        return handleGetMasterValue(item);
+    }
+
+
+    /**
+     * Gets the value for ims service/capabilities parameters from the master
+     * value storage. Synchronous blocking call.
+     *
+     * @param item as defined in com.android.ims.ImsConfig#ConfigConstants.
+     * @return value in String format.
+     */
+    @Override
+    public String getProvisionedStringValue(int item) {
+        if (sTelephonyManager == null) {
+            sTelephonyManager = (TelephonyManager) mContext.getSystemService(
+                                    Context.TELEPHONY_SERVICE);
+        }
+
+        return "";
+    }
+
+    /**
+     * Sets the value for IMS service/capabilities parameters by the operator device
+     * management entity. It sets the config item value in the provisioned storage
+     * from which the master value is derived. Synchronous blocking call.
+     *
+     * @param item as defined in com.android.ims.ImsConfig#ConfigConstants.
+     * @param value in Integer format.
+     */
+    @Override
+    public int setProvisionedValue(int item, int value) {
+        return handleProvisionedValue(item, value);
+    }
+
+    /**
+     * Sets the value for IMS service/capabilities parameters by the operator device
+     * management entity. It sets the config item value in the provisioned storage
+     * from which the master value is derived.  Synchronous blocking call.
+     *
+     * @param item as defined in com.android.ims.ImsConfig#ConfigConstants.
+     * @param value in String format.
+     */
+    @Override
+    public int setProvisionedStringValue(int item, String value) {
+
+        return 0;
+
+    }
+
+    /**
+     * Gets the value of the specified IMS feature item for specified network type.
+     * This operation gets the feature config value from the master storage (i.e. final
+     * value) asynchronous non-blocking call.
+     *
+     * @param feature as defined in com.android.ims.ImsConfig#FeatureConstants.
+     * @param network as defined in android.telephony.TelephonyManager#NETWORK_TYPE_XXX.
+     * @param listener feature value returned asynchronously through listener.
+     */
+    @Override
+    public void getFeatureValue(int feature, int network, ImsConfigListener listener) {
+    switch (feature) {
+        case ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE:
+        case ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE:
+            int value = android.provider.Settings.Global.getInt(
+                    mContext.getContentResolver(),
+                    android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED,
+                    ImsConfig.FeatureValueConstants.OFF);
+            if (listener != null) {
+                try {
+                    listener.onGetFeatureResponse(feature, network, value,
+                            ImsConfig.OperationStatusConstants.SUCCESS);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "RemoteException occurs when onGetFeatureResponse.");
+                }
+            }
+            break;
+        default:
+            break;
+    }
+
+    }
+
+    /**
+     * Sets the value for IMS feature item for specified network type.
+     * This operation stores the user setting in setting db from which master db
+     * is dervied.
+     *
+     * @param feature as defined in com.android.ims.ImsConfig#FeatureConstants.
+     * @param network as defined in android.telephony.TelephonyManager#NETWORK_TYPE_XXX.
+     * @param value as defined in com.android.ims.ImsConfig#FeatureValueConstants.
+     * @param listener provided if caller needs to be notified for set result.
+     */
+    @Override
+    public void setFeatureValue(int feature, int network, int value, ImsConfigListener listener) {
+
+        switch (feature) {
+            case ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE:
+            case ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE:
+                int oldValue = SystemProperties.getInt(PROPERTY_VOLTE_ENALBE, 0);
+                if( value != oldValue) {
+                    if (value ==1) {
+                        SystemProperties.set(PROPERTY_VOLTE_ENALBE,"1");
+                    } else {
+                        SystemProperties.set(PROPERTY_VOLTE_ENALBE,"0");
+                    }
+                }
+                break;
+            default:
+                break;
+        }
+    }
+
+    /**
+     * Gets the value for IMS volte provisioned.
+     * This should be the same as the operator provisioned value if applies.
+     *
+     * @return boolean
+     */
+    @Override
+    public boolean getVolteProvisioned() {
+        return true;
+    }
+
+    /**
+     * Gets the value for IMS feature item for video call quality.
+     *
+     * @param listener, provided if caller needs to be notified for set result.
+     * @return void
+     */
+    public void getVideoQuality(ImsConfigListener listener) {
+
+    }
+
+    /**
+     * Sets the value for IMS feature item video quality.
+     *
+     * @param quality, defines the value of video quality.
+     * @param listener, provided if caller needs to be notified for set result.
+     * @return void
+     */
+     public void setVideoQuality(int quality, ImsConfigListener listener) {
+
+     }
+
+    private String getAtCmdLine(int item) {
+        String atCmdString = "";
+        Log.i(TAG, "getAtCmdLine:" + item);
+        return atCmdString;
+    }
+
+    private String getAtCmdSetLine(int item, int value) {
+        String atCmdString = "";
+        Log.i(TAG, "getAtCmdLine:" + item);
+        return atCmdString;
+    }
+
+    private synchronized int handleGetMasterValue(int item) {
+        Log.i(TAG, "handleGetMasterValue:" + item);
+
+        String retValue = executeCommandResponse(getAtCmdLine(item));
+
+        if (retValue.length() >  0) {
+            try {
+                return Integer.parseInt(retValue);
+            } catch (NumberFormatException ne) {
+                ne.printStackTrace();
+            }
+        }
+
+        return 0;
+    }
+
+    private synchronized int handleProvisionedValue(int item, int value) {
+        Log.i(TAG, "handleProvisionedValue:" + item + ":" + value);
+        // Not support from now, ignore it
+        // executeCommandResponse(getAtCmdSetLine(item, value));
+        return 24;
+    }
+
+    private synchronized String executeCommandResponse(String atCmdLine) {
+        String atCmdResult = "";
+
+        if (sTelephonyManager == null) {
+            sTelephonyManager = (TelephonyManager)
+                                mContext.getSystemService(Context.TELEPHONY_SERVICE);
+        }
+
+        byte[] rawData = atCmdLine.getBytes();
+        byte[] cmdByte = new byte[rawData.length + 1];
+        byte[] respByte = new byte[MAX_BYTE_COUNT + 1];
+        System.arraycopy(rawData, 0, cmdByte, 0, rawData.length);
+        cmdByte[cmdByte.length - 1] = 0;
+
+        if (sTelephonyManager.invokeOemRilRequestRaw(cmdByte, respByte) > 0) {
+            atCmdResult = new String(respByte);
+        }
+
+        //Handle CME ERROR
+        if (atCmdResult.indexOf("+CME ERROR") != -1) {
+            atCmdResult = "";
+        }
+        return atCmdResult;
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsEcbmProxy.java b/packages/Ims/src/com/mediatek/ims/ImsEcbmProxy.java
new file mode 100644
index 0000000..af44369
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsEcbmProxy.java
@@ -0,0 +1,61 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import com.android.ims.internal.IImsEcbm;
+import com.android.ims.internal.IImsEcbmListener;
+
+public class ImsEcbmProxy extends IImsEcbm.Stub {
+    private static final String LOG_TAG = "ImsEcbmProxy";
+    private IImsEcbmListener mListener;
+
+    ImsEcbmProxy() {
+    }
+    /**
+      * Sets the listener.
+      */
+     public void setListener(IImsEcbmListener listener) {
+         mListener = listener;
+     }
+
+     /**
+      * Requests Modem to come out of ECBM mode
+      */
+     public void exitEmergencyCallbackMode() {
+
+     }
+
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsEventDispatcher.java b/packages/Ims/src/com/mediatek/ims/ImsEventDispatcher.java
new file mode 100644
index 0000000..eac446c
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsEventDispatcher.java
@@ -0,0 +1,143 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.content.Context;
+import android.os.Handler;
+import android.os.Message;
+
+//import com.mediatek.ims.ImsAdapter;
+import com.mediatek.ims.ImsAdapter.VaEvent;
+import com.mediatek.ims.ImsAdapter.VaSocketIO;
+
+import com.mediatek.ims.internal.ImsSimservsDispatcher;
+import com.mediatek.ims.internal.TimerDispatcher;
+import com.mediatek.ims.internal.CallControlDispatcher;
+import com.mediatek.ims.internal.DataDispatcher;
+
+import static com.mediatek.ims.VaConstants.*;
+
+import java.util.ArrayList;
+
+
+
+
+public class ImsEventDispatcher extends Handler {
+
+    private Context mContext;
+    private VaSocketIO mSocket;
+    private ArrayList<VaEventDispatcher> mVaEventDispatcher = new ArrayList<VaEventDispatcher>();
+    private static final String TAG = "ImsEventDispatcher";
+
+    public ImsEventDispatcher(Context context, VaSocketIO IO) {
+        mContext = context;
+        mSocket = IO;
+
+        createDispatcher();
+    }
+
+    public interface VaEventDispatcher {
+        void vaEventCallback(VaEvent event);
+        void enableRequest();
+        void disableRequest();
+    }
+
+    void enableRequest() {
+        for (VaEventDispatcher dispatcher : mVaEventDispatcher) {
+            dispatcher.enableRequest();
+        }
+    }
+
+    void disableRequest() {
+        for (VaEventDispatcher dispatcher : mVaEventDispatcher) {
+            dispatcher.disableRequest();
+        }
+    }
+
+    /* modify the following for domain owners */
+
+    /* Event Dispatcher */
+    private CallControlDispatcher mCallControlDispatcher;
+    private DataDispatcher mDataDispatcher;
+    private TimerDispatcher mTimerDispatcher;
+    private ImsSimservsDispatcher mSimservsDispatcher;
+
+    private void createDispatcher() {
+
+        mCallControlDispatcher = new CallControlDispatcher(mContext, mSocket);
+        mVaEventDispatcher.add(mCallControlDispatcher);
+
+        mDataDispatcher = new DataDispatcher(mContext, mSocket);
+        mVaEventDispatcher.add(mDataDispatcher);
+
+        mTimerDispatcher = new TimerDispatcher(mContext, mSocket);
+        mVaEventDispatcher.add(mTimerDispatcher);
+
+        mSimservsDispatcher = new ImsSimservsDispatcher(mContext, mSocket);
+        mVaEventDispatcher.add(mSimservsDispatcher);
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        dispatchCallback((VaEvent) msg.obj);
+    }
+
+    /* dispatch Callback */
+    void dispatchCallback(VaEvent event) {
+
+        switch (event.getRequestID()) {
+            case MSG_ID_NOTIFY_XUI_IND:
+                mSimservsDispatcher.vaEventCallback(event);
+                break;
+
+            case MSG_ID_NOTIFY_SS_PROGRESS_INDICATION :
+                mCallControlDispatcher.vaEventCallback(event);
+                break;
+
+            case MSG_ID_REQUEST_PCSCF_DISCOVERY:
+            case MSG_ID_WRAP_IMSM_IMSPA_PDN_ACT_REQ:
+            case MSG_ID_WRAP_IMSM_IMSPA_INFORMATION_REQ:
+            case MSG_ID_WRAP_IMSM_IMSPA_PDN_DEACT_REQ:
+                mDataDispatcher.vaEventCallback(event);
+                break;
+
+            case MSG_ID_REQUEST_TIMER_CREATE:
+            case MSG_ID_REQUEST_TIMER_CANCEL:
+                mTimerDispatcher.vaEventCallback(event);
+                break;
+        }
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsNotificationController.java b/packages/Ims/src/com/mediatek/ims/ImsNotificationController.java
new file mode 100644
index 0000000..406c07b
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsNotificationController.java
@@ -0,0 +1,550 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.app.KeyguardManager;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.database.ContentObserver;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.NetworkInfo.DetailedState;
+import android.net.Uri;
+import android.net.wifi.WifiManager;
+import android.os.Handler;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.telephony.ServiceState;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import com.android.ims.ImsConfig;
+import com.android.ims.ImsManager;
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.TelephonyIntents;
+
+// import com.mediatek.common.MPlugin;
+// import com.mediatek.common.wfc.IImsNotificationControllerExt;
+
+/** Class to show WFC related notifications like registration & WFC call.
+ */
+public class ImsNotificationController {
+
+    BroadcastReceiver mBr = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            // TODO Auto-generated method stub
+            if (DBG) Log.d(TAG, "Intent action:" + intent.getAction());
+
+            /* Restore screen lock state, even if intent received may not provide its effect */
+            if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
+                mIsScreenLock = true;
+                handleScreenOff();
+            } else {
+                mIsScreenLock = mKeyguardManager.isKeyguardLocked();
+            }
+            if (DBG) Log.d(TAG, "on receive:screen lock:" + mIsScreenLock);
+
+            if (intent.getAction().equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
+                String simState = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
+                Log.d(TAG, "simState:" + simState);
+                // Check Sim absent case
+                if (simState.equals(IccCardConstants.INTENT_VALUE_ICC_ABSENT)) {
+                    mIsSimPresent = false;
+                    if (DBG) Log.d(TAG, "SIM not present");
+                } else if (simState.equals(IccCardConstants.INTENT_VALUE_ICC_NOT_READY)) {
+                    mIsSimPresent = true;
+                    if (mImsState == WfcReasonInfo.CODE_WFC_INCORRECT_SIM_CARD_ERROR) {
+                        if (DBG) Log.d(TAG, "Reset to default,if incorrect sim error was present");
+                        mImsState = WfcReasonInfo.CODE_WFC_DEFAULT;
+                        mWfcCapabilityPresent = false;
+                        removeWfcNotification();
+                    }
+                }
+            }
+            if (DBG) Log.d(TAG, "SIM present:" + mIsSimPresent);
+            if (isWifiEnabled() && ImsManager.isWfcEnabledByUser(context)
+                        && !mIsSimPresent) {
+                mImsState = WfcReasonInfo.CODE_WFC_INCORRECT_SIM_CARD_ERROR;
+                mWfcCapabilityPresent = false;
+                displayWfcErrorNotification(false);
+                return;
+            }
+
+            /* ALPS02260621: Need to save phone_type as there is no provision of getting it
+                     * without having phone object.
+                     */
+       /* if (intent.getAction().equals(PhoneConstants.ACTION_SUBSCRIPTION_PHONE_STATE_CHANGED)) {
+                String state = intent.getStringExtra(TelephonyManager.EXTRA_STATE);
+                int phoneType = intent.getIntExtra(PhoneConstants.PHONE_TYPE_KEY,
+                        RILConstants.NO_PHONE);
+                if (phoneType == RILConstants.IMS_PHONE) {
+                    if (TelephonyManager.EXTRA_STATE_OFFHOOK.equals(state)
+                            || TelephonyManager.EXTRA_STATE_RINGING.equals(state)) {
+                        mPhoneType = RILConstants.IMS_PHONE;
+                    } else {
+                        mPhoneType = RILConstants.NO_PHONE;
+                    }
+                }
+            }
+            if (DBG) {
+                Log.d(TAG, "mPhoneType:" + mPhoneType);
+            }*/
+
+             if (Settings.Global.getInt(context.getContentResolver(),
+                    Settings.Global.WFC_IMS_ENABLED,
+                    ImsConfig.FeatureValueConstants.OFF)
+                    == ImsConfig.FeatureValueConstants.OFF
+                    || !isWifiEnabled() || !isWifiConnected()) {
+                if (DBG) Log.d(TAG, "WFC off or Wifi off or not connected");
+                if (mImsState > WfcReasonInfo.CODE_WFC_DEFAULT) {
+                    if (DBG) Log.d(TAG, "remove error noti, return");
+                    removeWfcNotification();
+                    return;
+                }
+            }
+             
+            if (intent.getAction().equals(ImsManager.ACTION_IMS_STATE_CHANGED)) {
+                handleImsStateChange(intent);
+            } else if (intent.getAction().equals(PhoneConstants
+                    .ACTION_SUBSCRIPTION_PHONE_STATE_CHANGED)) {
+                /* ALPS02260621: Need to save phone_type as there is no provision of getting it
+                  * without having phone object.
+                  */
+                String state = intent.getStringExtra(TelephonyManager.EXTRA_STATE);
+                int phoneType = intent.getIntExtra(PhoneConstants.PHONE_TYPE_KEY,
+                        RILConstants.NO_PHONE);
+                if (phoneType == RILConstants.IMS_PHONE) {
+                    if (TelephonyManager.EXTRA_STATE_OFFHOOK.equals(state)
+                            || TelephonyManager.EXTRA_STATE_RINGING.equals(state)) {
+                        mPhoneType = RILConstants.IMS_PHONE;
+                    } else {
+                        mPhoneType = RILConstants.NO_PHONE;
+                    }
+                }
+                handleCallIntent(state, phoneType);
+            } else if (intent.getAction().equals(ImsManager.ACTION_IMS_SERVICE_DOWN)) {
+                removeWfcNotification();
+            } else if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
+                handleScreenOn();
+            } else if (intent.getAction().equals(Intent.ACTION_USER_PRESENT)) {
+                handleScreenUnlock();
+            }
+            Log.d(TAG, "mPhoneType:" + mPhoneType);
+        }
+    };
+
+    private static final boolean DBG = true;
+    private static final String TAG = "ImsNotificationController";
+    private static final String ACTION_LAUNCH_WFC_SETTINGS
+            = "android.settings.WIFI_CALLING_SETTINGS";
+    private static final String ACTION_LAUNCH_WFC_INVALID_SIM_ALERT
+            = "mediatek.settings.WFC_INVALID_SIM_DIALOG_LAUNCH";
+
+    /**
+    * Wfc registration notification ID. This is
+     * the ID of the Notification given to the NotificationManager.
+     * Note: Id should be unique within APP.
+     */
+    private static final int WFC_NOTIFICATION = 0x10;
+
+    // MTK TODO
+    private static final int WFC_REGISTERED_ICON =
+            0;  // com.mediatek.internal.R.drawable.wfc_notify_registration_success;
+    private static final int WFC_CALL_ICON =
+            0;  // com.mediatek.internal.R.drawable.wfc_notify_ongoing_call;
+    private static final int WFC_ERROR_ICON =
+            0;  // com.mediatek.internal.R.drawable.wfc_notify_registration_error;
+
+    private static final int WFC_REGISTERED_TITLE =
+            0;  // com.mediatek.internal.R.string.success_notification_title;
+    private static final int WFC_CALL_TITLE =
+            0;  // com.mediatek.internal.R.string.ongoing_call_notification_title;
+    private static final int WFC_ERROR_TITLE =
+            0;  // com.mediatek.internal.R.string.network_error_notification_title;
+
+    private static final int WFC_REGISTERED_SUMMARY =
+            0;  // com.mediatek.internal.R.string.success_notification_summary;
+
+    // Current WFC state.
+    // Can be: 1) Success: WFC registered (2) DEFAULT: WFC on but not registered
+    // (3) Various error codes: defined in WfcReasonInfo
+    private int mImsState = WfcReasonInfo.CODE_WFC_DEFAULT;
+
+    private boolean mWfcCapabilityPresent = false;
+    private boolean mWfcCallOngoing = false;
+    private boolean mIsScreenLock = false;
+    private boolean mIsSimPresent = true;
+
+    /*  Vars required for ImsNotificationController initialization */
+    private Context mContext;
+    private long mSubId;
+    private int mPhoneType = RILConstants.NO_PHONE;
+
+    private NotificationManager mNotificationManager;
+    private WifiManager mWifiManager;
+    private ConnectivityManager mConnectivityManager;
+    private KeyguardManager mKeyguardManager;
+    private ContentObserver mWfcSwitchContentObserver;
+
+    /* IMSN Plugin */
+    // IImsNotificationControllerExt mImsnExt;
+
+    /** Constructor.
+     * @param context context
+     * @param subId subId
+     */
+    public ImsNotificationController(Context context, long subId) {
+        if (DBG) {
+            Log.d(TAG, "in constructor: subId:" + subId);
+        }
+        mContext = context;
+        mSubId = subId;
+        mNotificationManager =
+                (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
+        mWifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
+        mConnectivityManager =
+                (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        mKeyguardManager = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
+        mIsScreenLock =  mKeyguardManager.isKeyguardLocked();
+        registerReceiver();
+        registerForWfcSwitchChange();
+
+         /* IMSN plugin part */
+        // mImsnExt = getIMSNPlugin(context);
+    }
+
+    /** Stop the Imsnotification controller.
+     */
+    public void stop() {
+        if (DBG) Log.d(TAG, "in destroy Instance");
+        unRegisterReceiver();
+        unRegisterForWfcSwitchChange();
+        /* Cancel visible notifications, if any */
+        mNotificationManager.cancelAll();
+    }
+
+    private void registerReceiver() {
+        IntentFilter filter = new IntentFilter(ImsManager.ACTION_IMS_STATE_CHANGED);
+        filter.addAction(PhoneConstants.ACTION_SUBSCRIPTION_PHONE_STATE_CHANGED);
+        filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
+        filter.addAction(ImsManager.ACTION_IMS_SERVICE_DOWN);
+        filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(Intent.ACTION_SCREEN_ON);
+        filter.addAction(Intent.ACTION_USER_PRESENT);
+        mContext.registerReceiver(mBr, filter);
+    }
+
+    private void unRegisterReceiver() {
+        mContext.unregisterReceiver(mBr);
+    }
+
+    private void handleCallIntent(String state, int phoneType) {
+        //String state = intent.getStringExtra(TelephonyManager.EXTRA_STATE);
+        //int phoneType = intent.getIntExtra(PhoneConstants.PHONE_TYPE_KEY, RILConstants.NO_PHONE);
+        if (DBG) Log.d(TAG, "in handleCallIntent, phone state:" + state);
+        if (DBG) Log.d(TAG, "in handleCallIntent, phone type:" + phoneType);
+        if (phoneType == RILConstants.IMS_PHONE) {
+            if (TelephonyManager.EXTRA_STATE_OFFHOOK.equals(state)
+                    || TelephonyManager.EXTRA_STATE_RINGING.equals(state)) {
+                mWfcCallOngoing = true;
+                displayWfcCallNotification();
+            } else {
+                mWfcCallOngoing = false;
+                displayWfcRegistrationNotification(false);
+            }
+        } else if (phoneType == RILConstants.GSM_PHONE && mWfcCallOngoing) {
+            mWfcCallOngoing = false;
+            displayWfcRegistrationNotification(false);
+        }
+    }
+
+    private void handleImsStateChange(Intent intent) {
+        if (intent.getAction().equals(ImsManager.ACTION_IMS_STATE_CHANGED)) {
+            mImsState = intent.getIntExtra(ImsManager.EXTRA_IMS_REG_STATE_KEY,
+                    ServiceState.STATE_OUT_OF_SERVICE);
+            if (DBG) Log.d(TAG, "in handleImsStateChange, serviceState:" + mImsState);
+            if (mImsState != ServiceState.STATE_IN_SERVICE) {
+                removeWfcNotification();
+            } else {
+                handleInStateService(intent);
+            }
+        }
+        if (DBG) Log.d(TAG, "exit handleImsStateChange, imsState:" + mImsState);
+    }
+
+    private void handleInStateService(Intent intent) {
+        if (DBG) Log.d(TAG, "in handleInStateService");
+        /*handle for registration icon*/
+        boolean[] enabledFeatures = intent
+                .getBooleanArrayExtra(ImsManager.EXTRA_IMS_ENABLE_CAP_KEY);
+        if (DBG) Log.d(TAG, "wifi capability:" + enabledFeatures[ImsConfig.FeatureConstants
+                .FEATURE_TYPE_VOICE_OVER_WIFI]);
+        if (enabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI] == true) {
+            mWfcCapabilityPresent = true;
+            /* Capabilities have been change to WIFI, so set wfc status as Success.
+             * It is done to cover handover cases in which IMS_STATE_CHANGE is not
+             * received before capability_change intent
+            */
+            mImsState = WfcReasonInfo.CODE_WFC_SUCCESS;
+            /* ALPS02187200: Query phone state to check whether UE is in Call
+             * when capability change to Wifi.This case can happen during handover from
+             * LTE to Wifi when call is ongoing.
+             */
+            TelephonyManager tm = (TelephonyManager) mContext
+                    .getSystemService(Context.TELEPHONY_SERVICE);
+            // TODO: for multiSim
+            /* ALPS02260621: check phone_type before showing call icon*/
+            if ((tm.getCallState() == TelephonyManager.CALL_STATE_OFFHOOK
+                            || tm.getCallState() == TelephonyManager.CALL_STATE_RINGING)
+                        && mPhoneType == RILConstants.IMS_PHONE) {
+                mWfcCallOngoing = true;
+                displayWfcCallNotification();
+            } else {
+                displayWfcRegistrationNotification(true);
+            }
+        } else {
+            mWfcCapabilityPresent = false;
+            /* Capabilities have been change to other than WIFI, so set wfc status as OFF */
+            mImsState = WfcReasonInfo.CODE_WFC_DEFAULT;
+            removeWfcNotification();
+        }
+    }
+
+
+
+    /* Listening screen off intent because no intent for screen lock present in SDK now
+     * So, treating screen Off as screen lock
+     * Remove notification, if screen off
+     */
+    private void handleScreenOff() {
+        mNotificationManager.cancel(WFC_NOTIFICATION);
+    }
+
+    /* Screen on but check if screen is locked or not. If unlocked, show notification. */
+    private void handleScreenOn() {
+        if (!mIsScreenLock) {
+            if (DBG) Log.d(TAG, "screen not locked & screen on, show notification");
+            showNotification();
+        }
+    }
+
+    /* Intent received when user unlocks. Show notification. */
+    private void handleScreenUnlock() {
+        showNotification();
+    }
+
+    private void showNotification() {
+        if (mWfcCallOngoing) {
+            displayWfcCallNotification();
+        } else if (mWfcCapabilityPresent) {
+            displayWfcRegistrationNotification(false);
+        }
+    }
+
+    private void displayWfcCallNotification() {
+        if (DBG) Log.d(TAG, "in call handling, screen lock:" + mIsScreenLock);
+        if (!mIsScreenLock && mImsState == WfcReasonInfo.CODE_WFC_SUCCESS
+                    && mWfcCapabilityPresent) {
+            // TODO: to handle fake SRVCC case(wfc registered but during call setup it goes on CS).
+            //Need RAT type of call setup
+            Notification noti = new Notification.Builder(mContext)
+                    .setContentTitle(mContext.getResources().getString(WFC_CALL_TITLE))
+                    .setSmallIcon(WFC_CALL_ICON)
+                    .setOngoing(true)
+                    .setVisibility(Notification.VISIBILITY_SECRET)
+                    .build();
+            mNotificationManager.notify(WFC_NOTIFICATION, noti);
+            if (DBG) Log.d(TAG, "showing wfc call notification");
+        }
+    }
+
+    private void displayWfcRegistrationNotification(boolean showTicker) {
+        if (DBG) Log.d(TAG, "in registration handling, screen lock:" + mIsScreenLock);
+        if (!mIsScreenLock && mImsState == WfcReasonInfo.CODE_WFC_SUCCESS && mWfcCapabilityPresent
+            && mWfcCallOngoing == false) {
+            Notification noti = new Notification.Builder(mContext)
+                    .setContentTitle(mContext.getResources().getString(WFC_REGISTERED_TITLE))
+                    .setContentText(mContext.getResources().getString(WFC_REGISTERED_SUMMARY))
+                    .setSmallIcon(WFC_REGISTERED_ICON)
+                    .setOngoing(true)
+                    .setVisibility(Notification.VISIBILITY_SECRET)
+                    .build();
+            if (showTicker) {
+                noti.tickerText = mContext.getResources().getString(WFC_REGISTERED_TITLE);
+            }
+            Intent intent = new Intent(ACTION_LAUNCH_WFC_SETTINGS);
+            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
+            /*
+            if (mImsnExt != null) {
+                intent = mImsnExt.getIntent(IImsNotificationControllerExt.REGISTRATION, intent);
+            }
+            */
+            noti.contentIntent = PendingIntent.getActivity(mContext, 0, intent, 0);
+            noti.flags |= Notification.FLAG_NO_CLEAR;
+            mNotificationManager.notify(WFC_NOTIFICATION, noti);
+            if (DBG) Log.d(TAG, "showing wfc registration notification");
+        }
+    }
+
+
+    private void displayWfcErrorNotification(boolean showTicker) {
+            if (DBG) Log.d(TAG, "in error handling, screen lock:" + mIsScreenLock);
+            if (!mIsScreenLock && mImsState > WfcReasonInfo.CODE_WFC_DEFAULT) {
+            if (DBG) Log.d(TAG, "WFC error:" + mImsState);
+            Notification noti = new Notification.Builder(mContext)
+                    .setContentTitle(mContext.getResources().getString(WFC_ERROR_TITLE))
+                    .setContentText(mContext.getResources().getString(WfcReasonInfo
+                            .getImsStatusCodeString(mImsState)))
+                    .setSmallIcon(WFC_ERROR_ICON)
+                    .setOngoing(true)
+                    .setVisibility(Notification.VISIBILITY_SECRET)
+                    .build();
+            if (showTicker) {
+                noti.tickerText = mContext.getResources().getString(WFC_ERROR_TITLE);
+            }
+            Intent intent;
+            //if (mImsState == WfcReasonInfo.CODE_WFC_INCORRECT_SIM_CARD_ERROR) {
+                intent = new Intent(ACTION_LAUNCH_WFC_INVALID_SIM_ALERT);
+                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            //}
+            /*
+            if (mImsnExt != null) {
+                intent = mImsnExt.getIntent(IImsNotificationControllerExt.ERROR, intent);
+            }
+            */
+            noti.contentIntent = PendingIntent.getActivity(mContext, 0, intent, 0);
+            noti.flags |= Notification.FLAG_NO_CLEAR;
+            mNotificationManager.notify(WFC_NOTIFICATION, noti);
+            if (DBG) Log.d(TAG, "showing wfc error notification");
+            mWfcCallOngoing = false;
+        }
+    }
+
+    private void removeWfcNotification() {
+        if (DBG) Log.d(TAG, "removing wfc notification, if any");
+        mNotificationManager.cancel(WFC_NOTIFICATION);
+        mImsState = WfcReasonInfo.CODE_WFC_DEFAULT;
+        mWfcCapabilityPresent = false;
+        mWfcCallOngoing = false;
+    }
+
+    public int getRegistrationStatus() {
+        return mImsState;
+    }
+
+    private boolean isWifiEnabled() {
+        int wifiState = mWifiManager.getWifiState();
+        if (DBG) Log.d(TAG, "wifi state:" + wifiState);
+        return (wifiState != WifiManager.WIFI_STATE_DISABLED);
+    }
+
+    private boolean isWifiConnected() {
+        NetworkInfo networkInfo = mConnectivityManager
+                .getNetworkInfo(ConnectivityManager.TYPE_WIFI);
+        if (networkInfo != null) {
+            if (DBG) Log.d(TAG, "networkInfo:" + networkInfo.isConnected());
+            if (DBG) Log.d(TAG, "networkInfo:" + networkInfo.getDetailedState());
+        }
+        return (networkInfo != null && (networkInfo.isConnected()
+                    || networkInfo.getDetailedState() == DetailedState.CAPTIVE_PORTAL_CHECK));
+    }
+
+    /* Observes WFC settings changes. Needed for cases when WFC is switch OFF but
+     * state_changes intent is received. Ex: WFC error & user switches WCF OFF.
+     */
+    private void registerForWfcSwitchChange() {
+        mWfcSwitchContentObserver = new ContentObserver(new Handler()) {
+
+            @Override
+            public void onChange(boolean selfChange) {
+                this.onChange(selfChange, Settings.Global.getUriFor(Settings
+                        .Global.WFC_IMS_ENABLED));
+            }
+
+            @Override
+            public void onChange(boolean selfChange, Uri uri) {
+                if (Settings.Global.getInt(mContext.getContentResolver(),
+                    Settings.Global.WFC_IMS_ENABLED,
+                    ImsConfig.FeatureValueConstants.OFF)
+                    == ImsConfig.FeatureValueConstants.OFF) {
+                    if (DBG) Log.d(TAG, "contentObserver:WFC OFF");
+                    if (mImsState > WfcReasonInfo.CODE_WFC_DEFAULT) {
+                        if (DBG) Log.d(TAG, "remove error notification");
+                        removeWfcNotification();
+                    }
+                } else {
+                    if (DBG) Log.d(TAG, "contentObserver:WFC ON");
+                    if (isWifiEnabled() && !mIsSimPresent) {
+                        if (DBG) Log.d(TAG, "show error notification");
+                        mImsState = WfcReasonInfo.CODE_WFC_INCORRECT_SIM_CARD_ERROR;
+                        mWfcCapabilityPresent = false;
+                        displayWfcErrorNotification(false);
+                    }
+                }
+            }
+        };
+        mContext.getContentResolver().registerContentObserver(
+                Settings.Global.getUriFor(Settings.Global.WFC_IMS_ENABLED),
+                false, mWfcSwitchContentObserver);
+    }
+
+    private void unRegisterForWfcSwitchChange() {
+        mContext.getContentResolver().unregisterContentObserver(mWfcSwitchContentObserver);
+        mWfcSwitchContentObserver = null;
+    }
+
+    /*
+    private IImsNotificationControllerExt getIMSNPlugin(Context context) {
+        IImsNotificationControllerExt ext;
+        ext = (IImsNotificationControllerExt) MPlugin.createInstance(
+                IImsNotificationControllerExt.class.getName(), context);
+        return ext;
+    }
+    */
+}
+
diff --git a/packages/Ims/src/com/mediatek/ims/ImsRILAdapter.java b/packages/Ims/src/com/mediatek/ims/ImsRILAdapter.java
new file mode 100644
index 0000000..6aaf611
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsRILAdapter.java
@@ -0,0 +1,2768 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.ims;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.net.LocalSocket;
+import android.net.LocalSocketAddress;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.PowerManager;
+import android.os.PowerManager.WakeLock;
+import android.os.SystemProperties;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.Rlog;
+import android.telephony.TelephonyManager;
+import android.util.SparseArray;
+
+import com.android.internal.telephony.CommandException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.gsm.SuppServiceNotification;
+import com.android.internal.telephony.imsphone.ImsPhone;
+import com.android.internal.telephony.LastCallFailCause;
+import com.android.internal.telephony.UUSInfo;
+
+/// M: CC053: MoMS [Mobile Managerment] @{
+// import android.os.IBinder;
+// import android.os.Binder;
+// import android.content.pm.PackageManager;
+// import android.os.ServiceManager;
+// import com.mediatek.common.mom.IMobileManagerService;
+// import com.mediatek.common.mom.MobileManagerUtils;
+// import com.mediatek.common.mom.SubPermissions;
+/// @}
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+import java.util.List;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+/// M: CC012: DTMF request special handling @{
+import java.util.Vector;
+/// @}
+
+/**
+ * {@hide}
+ */
+class RILRequest {
+    static final String LOG_TAG = "IMSRILRequest";
+
+    //***** Class Variables
+    static Random sRandom = new Random();
+    static AtomicInteger sNextSerial = new AtomicInteger(0);
+    private static Object sPoolSync = new Object();
+    private static RILRequest sPool = null;
+    private static int sPoolSize = 0;
+    private static final int MAX_POOL_SIZE = 4;
+    private Context mContext;
+
+    //***** Instance Variables
+    int mSerial;
+    int mRequest;
+    Message mResult;
+    Parcel mParcel;
+    RILRequest mNext;
+
+    /**
+     * Retrieves a new RILRequest instance from the pool.
+     *
+     * @param request RIL_REQUEST_*
+     * @param result sent when operation completes
+     * @return a RILRequest instance from the pool.
+     */
+    static RILRequest obtain(int request, Message result) {
+        RILRequest rr = null;
+
+        synchronized(sPoolSync) {
+            if (sPool != null) {
+                rr = sPool;
+                sPool = rr.mNext;
+                rr.mNext = null;
+                sPoolSize--;
+            }
+        }
+
+        if (rr == null) {
+            rr = new RILRequest();
+        }
+
+        rr.mSerial = sNextSerial.getAndIncrement();
+
+        rr.mRequest = request;
+        rr.mResult = result;
+        rr.mParcel = Parcel.obtain();
+
+        if (result != null && result.getTarget() == null) {
+            throw new NullPointerException("Message target must not be null");
+        }
+
+        // first elements in any RIL Parcel
+        rr.mParcel.writeInt(request);
+        rr.mParcel.writeInt(rr.mSerial);
+
+        return rr;
+    }
+
+    /**
+     * Returns a RILRequest instance to the pool.
+     *
+     * Note: This should only be called once per use.
+     */
+    void release() {
+        synchronized (sPoolSync) {
+            if (sPoolSize < MAX_POOL_SIZE) {
+                mNext = sPool;
+                sPool = this;
+                sPoolSize++;
+                mResult = null;
+            }
+        }
+    }
+
+    private RILRequest() {
+    }
+
+    static void
+    resetSerial() {
+        // use a random so that on recovery we probably don't mix old requests
+        // with new.
+        sNextSerial.set(sRandom.nextInt());
+    }
+
+    String
+    serialString() {
+        //Cheesy way to do %04d
+        StringBuilder sb = new StringBuilder(8);
+        String sn;
+
+        long adjustedSerial = (((long)mSerial) - Integer.MIN_VALUE)%10000;
+
+        sn = Long.toString(adjustedSerial);
+
+        //sb.append("J[");
+        sb.append('[');
+        for (int i = 0, s = sn.length() ; i < 4 - s; i++) {
+            sb.append('0');
+        }
+
+        sb.append(sn);
+        sb.append(']');
+        return sb.toString();
+    }
+
+    void
+    onError(int error, Object ret) {
+        CommandException ex;
+
+        ex = CommandException.fromRilErrno(error);
+
+        if (ImsRILAdapter.IMS_RILA_LOGD) Rlog.d(LOG_TAG, serialString() + "< "
+            + ImsRILAdapter.requestToString(mRequest)
+            + " error: " + ex + " ret=" + ImsRILAdapter.retToString(mRequest, ret));
+
+        if (mResult != null) {
+            AsyncResult.forMessage(mResult, ret, ex);
+            mResult.sendToTarget();
+        }
+
+        if (mParcel != null) {
+            mParcel.recycle();
+            mParcel = null;
+        }
+    }
+}
+
+/**
+ * IMS RIL dial normal MO call information.
+ *
+ * {@hide}
+ */
+class MoCallInfo {
+    String mCallee;
+    int mClirMode;
+    boolean mIsEmergency;
+    boolean mIsVideoCall;
+    Message mResult;
+
+    //***** Constructors
+    public MoCallInfo(String callee, int clirMode, boolean isEmergency,
+            boolean isVideoCall, Message result) {
+        mCallee = callee;
+        mClirMode = clirMode;
+        mIsEmergency = isEmergency;
+        mIsVideoCall = isVideoCall;
+        mResult = result;
+    }
+}
+
+/**
+ * IMS RIL dial conference call information.
+ *
+ * {@hide}
+ */
+class ConferenceCallDialInfo {
+    String[] mParticipants;
+    int mClirMode;
+    boolean mIsVideoCall;
+    Message mResult;
+
+    //***** Constructors
+    public ConferenceCallDialInfo(String[] participants, int clirMode,
+            boolean isVideoCall, Message result) {
+        mParticipants = participants;
+        mClirMode = clirMode;
+        mIsVideoCall = isVideoCall;
+        mResult = result;
+    }
+}
+
+/**
+ * IMS RIL call information.
+ *
+ * {@hide}
+ */
+class ImsCallInfo {
+    /* State is indicated for call status */
+    enum State {
+        ACTIVE,
+        HOLDING,
+        ALERTING,   // MO call only
+        INCOMING,   // MT call only
+        INVALID;
+    }
+
+    String mCallNum;
+    String mCallId;
+    boolean mIsConference;
+    State mState;
+
+    //***** Constructors
+    public ImsCallInfo(String callId, String callNum, boolean isConference, State state) {
+        mCallId = callId;
+        mCallNum = callNum;
+        mIsConference = isConference;
+        mState = state;
+    }
+}
+
+/**
+ * IMS RIL Adapter implementation.
+ *
+ * {@hide}
+ */
+public class ImsRILAdapter extends ImsBaseCommands implements ImsCommandsInterface {
+    static final String IMS_RILA_LOG_TAG = "IMS_RILA";
+
+    //***** Instance Variables
+    Context mContext;
+    LocalSocket mSocket;
+    HandlerThread mSenderThread;
+    ImsRILSender mSender;
+    Thread mReceiverThread;
+    ImsRILReceiver mReceiver;
+    WakeLock mWakeLock;
+    final int mWakeLockTimeout;
+    // The number of wakelock requests currently active.  Don't release the lock
+    // until dec'd to 0
+    int mWakeLockCount;
+
+    SparseArray<RILRequest> mRequestList = new SparseArray<RILRequest>();
+
+    /**
+     * Property to override DEFAULT_WAKE_LOCK_TIMEOUT
+     */
+    static final String PROPERTY_WAKE_LOCK_TIMEOUT = "ro.ril.wake_lock_timeout";
+    /**
+     * Wake lock timeout should be longer than the longest timeout in
+     * the vendor ril.
+     */
+    private static final int DEFAULT_WAKE_LOCK_TIMEOUT = 60000;
+
+    //***** Events
+    static final int EVENT_SEND                 = 1;
+    static final int EVENT_WAKE_LOCK_TIMEOUT    = 2;
+
+    // match with constant in ril_ims.c
+    static final int RIL_MAX_COMMAND_BYTES = (8 * 1024);
+    static final int RESPONSE_SOLICITED = 0;
+    static final int RESPONSE_UNSOLICITED = 1;
+    static final int SOCKET_OPEN_RETRY_MILLIS = 4 * 1000;
+    static final boolean IMS_RILA_LOGD = true;
+    static final int MAX_CONNECTIONS = 7;
+
+    private static final int INVALID_CALL_MODE = 0xFF;
+    private static final int IMS_VOICE_CALL = 20;
+    private static final int IMS_VIDEO_CALL = 21;
+    private static final int IMS_VOICE_CONF = 22;
+    private static final int IMS_VIDEO_CONF = 23;
+    private static final int IMS_VOICE_CONF_PARTS = 24;
+    private static final int IMS_VIDEO_CONF_PARTS = 25;
+
+    private static final int  MAX_BYTE_COUNT = 256;
+
+    private MoCallInfo mMoCall = null;
+    private ConferenceCallDialInfo mConferenceCallDialInfo = null;
+
+    // Adapter Defined Event
+    private static final int EVENT_AT_CMD_DONE = 100;
+
+    private HashMap<String, ImsCallInfo> mCallConnections = new HashMap<String, ImsCallInfo>();
+
+    private Handler mHandler = new Handler() {
+        public void handleMessage(Message msg) {
+            AsyncResult ar;
+            switch (msg.what) {
+                case EVENT_AT_CMD_DONE:
+                    Rlog.i(IMS_RILA_LOG_TAG, "IMS: Adapter receive EVENT_AT_CMD_DONE");
+                    ar = (AsyncResult) msg.obj;
+                    handleAtCmdResponseAndDial(ar);
+                    break;
+                default:
+                    break;
+            }
+        }
+    };
+
+    /// M: CC009: DTMF request special handling @{
+    /* DTMF request will be ignored when duplicated sending */
+    private class dtmfQueueHandler {
+
+        public dtmfQueueHandler() {
+            mDtmfStatus = DTMF_STATUS_STOP;
+        }
+
+        public void start() {
+            mDtmfStatus = DTMF_STATUS_START;
+        }
+
+        public void stop() {
+            mDtmfStatus = DTMF_STATUS_STOP;
+        }
+
+        public boolean isStart() {
+            return (mDtmfStatus == DTMF_STATUS_START);
+        }
+
+        public void add(RILRequest o) {
+            mDtmfQueue.addElement(o);
+        }
+
+        public void remove(RILRequest o) {
+            mDtmfQueue.remove(o);
+        }
+
+        public void remove(int idx) {
+            mDtmfQueue.removeElementAt(idx);
+        }
+
+        public RILRequest get() {
+            return (RILRequest) mDtmfQueue.get(0);
+        }
+
+        public int size() {
+            return mDtmfQueue.size();
+        }
+
+        public void setPendingRequest(RILRequest r) {
+            mPendingCHLDRequest = r;
+        }
+
+        public RILRequest getPendingRequest() {
+            return mPendingCHLDRequest;
+        }
+
+        public void setSendChldRequest() {
+            mIsSendChldRequest = true;
+        }
+
+        public void resetSendChldRequest() {
+            mIsSendChldRequest = false;
+        }
+
+        public boolean hasSendChldRequest() {
+            riljLog("mIsSendChldRequest = " + mIsSendChldRequest);
+            return mIsSendChldRequest;
+        }
+
+        public final int MAXIMUM_DTMF_REQUEST = 32;
+        private final boolean DTMF_STATUS_START = true;
+        private final boolean DTMF_STATUS_STOP = false;
+
+        private boolean mDtmfStatus = DTMF_STATUS_STOP;
+        private Vector mDtmfQueue = new Vector(MAXIMUM_DTMF_REQUEST);
+
+        private RILRequest mPendingCHLDRequest = null;
+        private boolean mIsSendChldRequest = false;
+    }
+
+    private dtmfQueueHandler mDtmfReqQueue = new dtmfQueueHandler();
+    /// @}
+
+    //***** Constructors
+    public ImsRILAdapter(Context context) {
+        super(context);
+        mContext = context;
+        Rlog.i(IMS_RILA_LOG_TAG, "IMS:ImsRILAdapter constructor");
+
+        PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
+        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, IMS_RILA_LOG_TAG);
+        mWakeLock.setReferenceCounted(false);
+        mWakeLockTimeout = SystemProperties.getInt(PROPERTY_WAKE_LOCK_TIMEOUT,
+                DEFAULT_WAKE_LOCK_TIMEOUT);
+        mWakeLockCount = 0;
+
+        // initialize IMS RIL sender
+        mSenderThread = new HandlerThread("ImsRILSender");
+        mSenderThread.start();
+        Looper looper = mSenderThread.getLooper();
+        mSender = new ImsRILSender(looper);
+
+        // initialize IMS RIL receiver
+        mReceiver = new ImsRILReceiver();
+        mReceiverThread = new Thread(mReceiver, "ImsRILReceiver");
+        mReceiverThread.start();
+
+    }
+
+    public void setMute(boolean enableMute, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_MUTE, response);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                            + " " + enableMute);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(enableMute ? 1 : 0);
+
+        send(rr);
+    }
+
+    /**
+    * dial volte or vilte call.
+    *
+    * @param callee dialing number string
+    * @param clirMode to present the dialing number or not
+    * @param isEmergency indicate is emergency call or not
+    * @param isVideoCall indicate is belong to vilte call or volte call
+    * @param result command result
+    *
+    */
+    public void start(String callee, int clirMode, boolean isEmergency,
+            boolean isVideoCall, Message result) {
+        String atCmdString = "DIALSOURCE_IMS";
+
+        if (mMoCall != null) Rlog.e(IMS_RILA_LOG_TAG, "IMS: mMoCall is not null when dial !!");
+
+        // New Mo Call Wrapper, used when OEM Hook Raw response return
+        mMoCall = new MoCallInfo(callee, clirMode, isEmergency, isVideoCall, result);
+        executeCommandResponse(atCmdString);
+    }
+
+    /**
+    * dial volte or vilte conference call.
+    *
+    * @param participants participants dialing number string
+    * @param clirMode to present the dialing number or not
+    * @param isVideoCall indicate is belong to vilte call or volte call
+    * @param result command result
+    *
+    */
+    public void startConference(String[] participants, int clirMode,
+            boolean isVideoCall, Message result) {
+        String atCmdString = "DIALSOURCE_IMS";
+
+        if (mConferenceCallDialInfo != null) {
+            Rlog.e(IMS_RILA_LOG_TAG, "IMS: ConferenceCallDialInfo is not null when dial !!");
+        }
+
+        // New Mo Call Wrapper, used when OEM Hook Raw response return
+        mConferenceCallDialInfo = new ConferenceCallDialInfo(participants, clirMode,
+                isVideoCall, result);
+        executeCommandResponse(atCmdString);
+    }
+
+    public void accept() {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_ANSWER, null);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+
+    }
+
+    /**
+     * accept video call.
+     *
+     * @param videoMode indicate to the accept video call as video, audio, video_rx, or video_tx.
+     * @param callId indicate which call we want to accept.
+     *
+     */
+    public void acceptVideoCall(int videoMode, int callId) {
+        if (IMS_RILA_LOGD) {
+            riljLog("acceptVideoCall : callId = " + callId + ", videoMode = " + videoMode);
+        }
+
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_VIDEO_CALL_ACCEPT, null);
+
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeInt(videoMode);
+        rr.mParcel.writeInt(callId);
+
+        if (IMS_RILA_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + videoMode + ", " + callId);
+        }
+        send(rr);
+    }
+
+    public void reject(int callId) {
+        if (IMS_RILA_LOGD) riljLog("IMS reject : callId = " + callId);
+
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP, null);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " +
+                callId);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callId);
+
+        send(rr);
+    }
+
+    public void terminate(int callId) {
+        if (IMS_RILA_LOGD) riljLog("IMS terminate : callId = " + callId);
+
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP, null);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " +
+                callId);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callId);
+
+        send(rr);
+    }
+
+    /**
+     * To hold the call.
+     * @param callId toIndicate which call session to hold.
+     * @param result command result.
+     */
+    public void hold(int callId, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_HOLD_CALL, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callId);
+
+        if (IMS_RILA_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    /**
+     * To resume the call.
+     * @param callId toIndicate which call session to resume.
+     * @param result command result.
+     */
+    public void resume(int callId, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RESUME_CALL, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callId);
+
+        if (IMS_RILA_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    public void merge(Message result) {
+        /// M: CC053: MoMS [Mobile Managerment] @{
+        // 3. Permission Control for Conference call
+        /*
+        if (MobileManagerUtils.isSupported()) {
+            if (!checkMoMSSubPermission(SubPermissions.MAKE_CONFERENCE_CALL)) {
+                return;
+            }
+        }
+        */
+        /// @}
+
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_CONFERENCE, result);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        /// M: CC012: DTMF request special handling @{
+        handleChldRelatedRequest(rr);
+        ///@}
+    }
+
+    public void sendDtmf(char c, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_DTMF, result);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mParcel.writeString(Character.toString(c));
+
+        send(rr);
+
+    }
+
+    /**
+     * Start to paly a DTMF tone on the active call. Ignored if there is no active call
+     * or there is a playing DTMF tone.
+     * @param c should be one of 0-9, '*' or '#'. Other values will be
+     * @param result is present the command is OK or fail
+     */
+    public void startDtmf(char c, Message result) {
+        /// M: CC012: DTMF request special handling @{
+        /* DTMF request will be ignored when the count of requests reaches 32 */
+        synchronized (mDtmfReqQueue) {
+            riljLog("startDtmf: queue size: " + mDtmfReqQueue.size());
+
+            if (!mDtmfReqQueue.hasSendChldRequest() &&
+                mDtmfReqQueue.size() < mDtmfReqQueue.MAXIMUM_DTMF_REQUEST) {
+                if (!mDtmfReqQueue.isStart()) {
+                    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DTMF_START, result);
+
+                    rr.mParcel.writeString(Character.toString(c));
+                    mDtmfReqQueue.start();
+                    mDtmfReqQueue.add(rr);
+                    if (mDtmfReqQueue.size() == 1) {
+                        riljLog("send start dtmf");
+                        if (IMS_RILA_LOGD) {
+                            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+                        }
+                        send(rr);
+                    }
+                } else {
+                    riljLog("DTMF status conflict, want to start DTMF when status is " +
+                        mDtmfReqQueue.isStart());
+                }
+            }
+        }
+        /// @}
+    }
+
+    /**
+     * Stop the playing DTMF tone. Ignored if there is no playing DTMF
+     * tone or no active call.
+     * @param result is present the command is OK or fail
+     */
+    public void stopDtmf(Message result) {
+        /// M: CC012: DTMF request special handling @{
+        /* DTMF request will be ignored when the count of requests reaches 32 */
+        synchronized (mDtmfReqQueue) {
+            riljLog("stopDtmf: queue size: " + mDtmfReqQueue.size());
+
+            if (!mDtmfReqQueue.hasSendChldRequest() &&
+                mDtmfReqQueue.size() < mDtmfReqQueue.MAXIMUM_DTMF_REQUEST) {
+                if (mDtmfReqQueue.isStart()) {
+                    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DTMF_STOP, result);
+
+                    mDtmfReqQueue.stop();
+                    mDtmfReqQueue.add(rr);
+                    if (mDtmfReqQueue.size() == 1) {
+                        riljLog("send stop dtmf");
+                        if (IMS_RILA_LOGD) riljLog(rr.serialString() +
+                            "> " + requestToString(rr.mRequest));
+                        send(rr);
+                    }
+                } else {
+                    riljLog("DTMF status conflict, want to start DTMF when status is " +
+                        mDtmfReqQueue.isStart());
+                }
+            }
+        }
+        /// @}
+    }
+    public void setCallIndication(int mode, int callId, int seqNum) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_CALL_INDICATION, null);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeInt(mode);
+        rr.mParcel.writeInt(callId);
+        rr.mParcel.writeInt(seqNum);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " " + mode + ", " + callId + ", " + seqNum);
+
+        send(rr);
+
+    }
+
+    public void turnOnIms(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_IMS_ENABLE, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(1);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void turnOffIms(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_IMS_ENABLE, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(0);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+
+    }
+
+    /// M: IMS feature(Can't work in 3G domain). @{
+    public void addConferenceMember(int confCallId, String address, int callIdToAdd,
+        Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER, response);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(Integer.toString(confCallId));
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeString(Integer.toString(callIdToAdd));
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void removeConferenceMember(int confCallId, String address, int callIdToRemove,
+        Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER, response);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(Integer.toString(confCallId));
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeString(Integer.toString(callIdToRemove));
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+    /// @}
+
+    /**
+    * Add a new member to VoLTE conference call according to the parameter - address.
+    *
+    * @param confCallId IMS(VoLTE) conference call id
+    * @param participant The address(phone number or SIP URI)
+    * @param response Command response.
+    *
+    */
+    public void inviteParticipants(int confCallId, String participant, Message response) {
+        int participantCallId = -1;
+        ImsCallInfo callInfo;
+        for (Map.Entry<String, ImsCallInfo> entry : mCallConnections.entrySet()) {
+            callInfo = entry.getValue();
+            if (participant.equals(callInfo.mCallNum)) {
+                participantCallId = Integer.parseInt(callInfo.mCallId);
+                break;
+            }
+        }
+
+        addConferenceMember(confCallId, participant, participantCallId, response);
+    }
+
+    /**
+    * remove a member from VoLTE conference call according to the parameter - address.
+    *
+    * @param confCallId IMS(VoLTE) conference call id.
+    * @param participant The address(phone number or SIP URI).
+    * @param response Command response.
+    *
+    */
+    public void removeParticipants(int confCallId, String participant, Message response) {
+        int participantCallId = -1;
+        ImsCallInfo callInfo;
+        for (Map.Entry<String, ImsCallInfo> entry : mCallConnections.entrySet()) {
+            callInfo = entry.getValue();
+            if (participant.equals(callInfo.mCallNum)) {
+                participantCallId = Integer.parseInt(callInfo.mCallId);
+                break;
+            }
+        }
+
+        removeConferenceMember(confCallId, participant, participantCallId, response);
+    }
+
+    /**
+    * To get last call fail cause.
+    *
+    * @param response Command response.
+    *
+    */
+    public void getLastCallFailCause(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_LAST_CALL_FAIL_CAUSE, response);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+    * To release all calls.
+    * @param response Command response.
+    */
+    public void hangupAllCall(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP_ALL, response);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+    * To get callinfo by call Id.
+    * @param callId callId.
+    * @return reture the specified callinfo
+    */
+    public ImsCallInfo getCallInfo(String callId) {
+        return mCallConnections.get(callId);
+    }
+
+    /**
+    * To get callinfo by state.
+    * @param state call state.
+    * @return reture the specified callinfo
+    */
+    public ImsCallInfo getCallInfo(ImsCallInfo.State state) {
+        ImsCallInfo callInfo;
+        for (Map.Entry<String, ImsCallInfo> entry : mCallConnections.entrySet()) {
+            callInfo = entry.getValue();
+            Rlog.d(IMS_RILA_LOG_TAG, "getCallInfo- callID:" + callInfo.mCallId + "call num:" +
+                    callInfo.mCallNum + "call State:" + callInfo.mState);
+            if (callInfo.mState == state) {
+                return callInfo;
+            }
+        }
+        return null;
+    }
+
+    /**
+    * To swap calls.
+    * @param result Command response.
+    */
+    public void swap(Message result) {
+        RILRequest rr
+                = RILRequest.obtain(
+                        RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE,
+                                        result);
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        /// M: CC012: DTMF request special handling @{
+        handleChldRelatedRequest(rr);
+        /// @}
+
+    }
+
+    /**
+    * To send WFC profile information to modem
+    * @param wfcPreference WFC preference selected by User
+    */
+    public void sendWfcProfileInfo(int wfcPreference) {
+        String s[] = new String[2];
+        s[0] = "AT+EWFCP=" + wfcPreference;
+        s[1] = "";
+        Rlog.d(IMS_RILA_LOG_TAG, "At cmnd:" + s[0]);
+        invokeOemRilRequestStrings(s, null);
+    }
+
+    public void invokeOemRilRequestStrings(String[] strings, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_OEM_HOOK_STRINGS, response);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mParcel.writeStringArray(strings);
+
+        send(rr);
+    }
+    private static int readRilMessage(InputStream is, byte[] buffer)
+            throws IOException {
+        int countRead;
+        int offset;
+        int remaining;
+        int messageLength;
+
+        // First, read in the length of the message
+        offset = 0;
+        remaining = 4;
+        do {
+            countRead = is.read(buffer, offset, remaining);
+
+            if (countRead < 0) {
+                Rlog.e(IMS_RILA_LOG_TAG, "Hit EOS reading message length");
+                return -1;
+            }
+
+            offset += countRead;
+            remaining -= countRead;
+        } while (remaining > 0);
+
+        messageLength = ((buffer[0] & 0xff) << 24)
+                | ((buffer[1] & 0xff) << 16)
+                | ((buffer[2] & 0xff) << 8)
+                | (buffer[3] & 0xff);
+
+        // Then, re-use the buffer and read in the message itself
+        offset = 0;
+        remaining = messageLength;
+        do {
+            countRead = is.read(buffer, offset, remaining);
+
+            if (countRead < 0) {
+                Rlog.e(IMS_RILA_LOG_TAG, "Hit EOS reading message.  messageLength=" + messageLength
+                        + " remaining=" + remaining);
+                return -1;
+            }
+
+            offset += countRead;
+            remaining -= countRead;
+        } while (remaining > 0);
+
+        return messageLength;
+    }
+
+    class ImsRILSender extends Handler implements Runnable {
+        public ImsRILSender(Looper looper) {
+            super(looper);
+        }
+
+        // Only allocated once
+        byte[] dataLength = new byte[4];
+
+        //***** Runnable implementation
+        @Override
+        public void
+        run() {
+            //setup if needed
+        }
+
+
+        //***** Handler implementation
+        @Override public void
+        handleMessage(Message msg) {
+            RILRequest rr = (RILRequest)(msg.obj);
+            RILRequest req = null;
+
+            switch (msg.what) {
+                case EVENT_SEND:
+                    try {
+                        LocalSocket s;
+
+                        s = mSocket;
+
+                        if (s == null) {
+                            rr.onError(RADIO_NOT_AVAILABLE, null);
+                            rr.release();
+                            decrementWakeLock();
+                            return;
+                        }
+
+                        byte[] data;
+                        data = rr.mParcel.marshall();
+                        synchronized (mRequestList) {
+                            mRequestList.append(rr.mSerial, rr);
+                            rr.mParcel.recycle();
+                            rr.mParcel = null;
+                        }
+
+                        if (data.length > RIL_MAX_COMMAND_BYTES) {
+                            throw new RuntimeException(
+                                    "Parcel larger than max bytes allowed! "
+                                                          + data.length);
+                        }
+
+                        // parcel length in big endian
+                        dataLength[0] = dataLength[1] = 0;
+                        dataLength[2] = (byte)((data.length >> 8) & 0xff);
+                        dataLength[3] = (byte)((data.length) & 0xff);
+
+                        //Rlog.v(IMS_RILA_LOG_TAG, "writing packet: " + data.length + " bytes");
+
+                        s.getOutputStream().write(dataLength);
+                        s.getOutputStream().write(data);
+                    } catch (IOException ex) {
+                        Rlog.e(IMS_RILA_LOG_TAG, "IOException", ex);
+                        req = findAndRemoveRequestFromList(rr.mSerial);
+                        // make sure this request has not already been handled,
+                        // eg, if RILReceiver cleared the list.
+                        if (req != null) {
+                            rr.onError(RADIO_NOT_AVAILABLE, null);
+                            rr.release();
+                            decrementWakeLock();
+                        }
+                    } catch (RuntimeException exc) {
+                        Rlog.e(IMS_RILA_LOG_TAG, "Uncaught exception ", exc);
+                        req = findAndRemoveRequestFromList(rr.mSerial);
+                        // make sure this request has not already been handled,
+                        // eg, if RILReceiver cleared the list.
+                        if (req != null) {
+                            rr.onError(GENERIC_FAILURE, null);
+                            rr.release();
+                            decrementWakeLock();
+                        }
+                    }
+                    break;
+
+                case EVENT_WAKE_LOCK_TIMEOUT:
+                    // Haven't heard back from the last request.  Assume we're
+                    // not getting a response and  release the wake lock.
+
+                    // The timer of WAKE_LOCK_TIMEOUT is reset with each
+                    // new send request. So when WAKE_LOCK_TIMEOUT occurs
+                    // all requests in mRequestList already waited at
+                    // least DEFAULT_WAKE_LOCK_TIMEOUT but no response.
+                    //
+                    // Note: Keep mRequestList so that delayed response
+                    // can still be handled when response finally comes.
+
+                    synchronized (mRequestList) {
+                        if (clearWakeLock()) {
+                            if (IMS_RILA_LOGD) {
+                                int count = mRequestList.size();
+                                Rlog.d(IMS_RILA_LOG_TAG, "WAKE_LOCK_TIMEOUT " +
+                                        " mRequestList=" + count);
+                                for (int i = 0; i < count; i++) {
+                                    rr = mRequestList.valueAt(i);
+                                    Rlog.d(IMS_RILA_LOG_TAG, i + ": [" + rr.mSerial + "] "
+                                            + requestToString(rr.mRequest));
+                                }
+                            }
+                        }
+                    }
+                    break;
+            }
+        }
+    }
+
+    class ImsRILReceiver implements Runnable {
+        byte[] buffer;
+
+        ImsRILReceiver() {
+            buffer = new byte[RIL_MAX_COMMAND_BYTES];
+        }
+
+        @Override
+        public void
+        run() {
+            int retryCount = 0;
+            String imsRilSocket = "rild-ims";
+
+            try { for (;; ) {
+                LocalSocket s = null;
+                LocalSocketAddress l;
+
+                try {
+                    s = new LocalSocket();
+                    l = new LocalSocketAddress(imsRilSocket,
+                            LocalSocketAddress.Namespace.RESERVED);
+                    s.connect(l);
+                } catch (IOException ex) {
+                    try {
+                        if (s != null) {
+                            s.close();
+                        }
+                    } catch (IOException ex2) {
+                        //ignore failure to close after failure to connect
+                        Rlog.e(IMS_RILA_LOG_TAG, "Failed to close the socket");
+                    }
+
+                    // don't print an error message after the the first time
+                    // or after the 8th time
+
+                    if (retryCount == 8) {
+                        Rlog.e(IMS_RILA_LOG_TAG,
+                            "Couldn't find '" + imsRilSocket
+                            + "' socket after " + retryCount
+                            + " times, continuing to retry silently");
+                    } else if (retryCount > 0 && retryCount < 8) {
+                        Rlog.i(IMS_RILA_LOG_TAG,
+                            "Couldn't find '" + imsRilSocket
+                            + "' socket; retrying after timeout");
+                    }
+
+                    try {
+                        Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
+                    } catch (InterruptedException er) {
+                    }
+
+                    retryCount++;
+                    continue;
+                }
+
+                retryCount = 0;
+
+                mSocket = s;
+                Rlog.i(IMS_RILA_LOG_TAG, "Connected to '" + imsRilSocket + "' socket");
+
+                int length = 0;
+                try {
+                    InputStream is = mSocket.getInputStream();
+
+                    for (;; ) {
+                        Parcel p;
+
+                        length = readRilMessage(is, buffer);
+
+                        if (length < 0) {
+                            // End-of-stream reached
+                            break;
+                        }
+
+                        p = Parcel.obtain();
+                        p.unmarshall(buffer, 0, length);
+                        p.setDataPosition(0);
+
+                        //Rlog.v(IMS_RILA_LOG_TAG, "Read packet: " + length + " bytes");
+
+                        processResponse(p);
+                        p.recycle();
+                    }
+                } catch (java.io.IOException ex) {
+                    Rlog.i(IMS_RILA_LOG_TAG, "'" + imsRilSocket + "' socket closed",
+                          ex);
+                } catch (Throwable tr) {
+                    Rlog.e(IMS_RILA_LOG_TAG, "Uncaught exception read length=" + length +
+                        "Exception:" + tr.toString());
+                }
+
+                Rlog.i(IMS_RILA_LOG_TAG, "Disconnected from '" + imsRilSocket
+                      + "' socket");
+
+                setRadioState (RadioState.RADIO_UNAVAILABLE);
+
+                try {
+                    mSocket.close();
+                } catch (IOException ex) {
+                }
+
+                mSocket = null;
+                //RILRequest.resetSerial();
+
+                // Clear request list on close
+                //clearRequestList(RADIO_NOT_AVAILABLE, false);
+            } } catch (Throwable tr) {
+                Rlog.e(IMS_RILA_LOG_TAG, "Uncaught exception", tr);
+            }
+
+            /* We're disconnected so we don't know the ril version */
+            //notifyRegistrantsRilConnectionChanged(-1);
+        }
+    }
+
+    /**
+     * Holds a PARTIAL_WAKE_LOCK whenever
+     * a) There is outstanding RIL request sent to RIL deamon and no replied
+     * b) There is a request pending to be sent out.
+     *
+     * There is a WAKE_LOCK_TIMEOUT to release the lock, though it shouldn't
+     * happen often.
+     */
+
+    private void acquireWakeLock() {
+        synchronized (mWakeLock) {
+            mWakeLock.acquire();
+            mWakeLockCount++;
+
+            mSender.removeMessages(EVENT_WAKE_LOCK_TIMEOUT);
+            Message msg = mSender.obtainMessage(EVENT_WAKE_LOCK_TIMEOUT);
+            mSender.sendMessageDelayed(msg, mWakeLockTimeout);
+        }
+    }
+
+    private void decrementWakeLock() {
+        synchronized (mWakeLock) {
+            if (mWakeLockCount > 1) {
+                mWakeLockCount--;
+            } else {
+                mWakeLockCount = 0;
+                mWakeLock.release();
+                mSender.removeMessages(EVENT_WAKE_LOCK_TIMEOUT);
+            }
+        }
+    }
+
+    // true if we had the wakelock
+    private boolean clearWakeLock() {
+        synchronized (mWakeLock) {
+            if (mWakeLockCount == 0 && mWakeLock.isHeld() == false) return false;
+            Rlog.d(IMS_RILA_LOG_TAG, "NOTE: mWakeLockCount is " + mWakeLockCount +
+                "at time of clearing");
+            mWakeLockCount = 0;
+            mWakeLock.release();
+            mSender.removeMessages(EVENT_WAKE_LOCK_TIMEOUT);
+            return true;
+        }
+    }
+
+    private void send(RILRequest rr) {
+        Message msg;
+
+        if (mSocket == null) {
+            rr.onError(RADIO_NOT_AVAILABLE, null);
+            rr.release();
+            return;
+        }
+
+        msg = mSender.obtainMessage(EVENT_SEND, rr);
+
+        acquireWakeLock();
+
+        msg.sendToTarget();
+    }
+
+    private void processResponse(Parcel p) {
+        int type;
+        Rlog.i(IMS_RILA_LOG_TAG, " IMS processResponse()");
+
+        type = p.readInt();
+        if (type == RESPONSE_UNSOLICITED) {
+            processUnsolicited(p);
+        } else if (type == RESPONSE_SOLICITED) {
+            Rlog.i(IMS_RILA_LOG_TAG, "IMS: receive the RESPONSE_SOLICITED !!");
+            RILRequest rr = processSolicited (p);
+            if (rr != null) {
+                rr.release();
+                decrementWakeLock();
+            }
+        }
+    }
+
+   private RILRequest
+   processSolicited (Parcel p) {
+       int serial, error;
+       boolean found = false;
+
+       serial = p.readInt();
+       error = p.readInt();
+
+       RILRequest rr;
+
+       rr = findAndRemoveRequestFromList(serial);
+
+       if (rr == null) {
+           Rlog.w(IMS_RILA_LOG_TAG, "Unexpected solicited response! sn: "
+                           + serial + " error: " + error);
+           return null;
+       }
+
+       /// M: CC012: DTMF request special handling @{
+       /* DTMF request will be ignored when the count of requests reaches 32 */
+       if ((rr.mRequest == RIL_REQUEST_DTMF_START) ||
+           (rr.mRequest == RIL_REQUEST_DTMF_STOP)) {
+           synchronized (mDtmfReqQueue) {
+               mDtmfReqQueue.remove(rr);
+               riljLog("remove first item in dtmf queue done, size = " + mDtmfReqQueue.size());
+               if (mDtmfReqQueue.size() > 0) {
+                   RILRequest rr2 = mDtmfReqQueue.get();
+                   if (IMS_RILA_LOGD) riljLog(rr2.serialString() + "> " + requestToString(rr2.mRequest));
+                   send(rr2);
+               } else {
+                   if (mDtmfReqQueue.getPendingRequest() != null) {
+                       riljLog("send pending switch request");
+                       send(mDtmfReqQueue.getPendingRequest());
+                       mDtmfReqQueue.setSendChldRequest();
+                       mDtmfReqQueue.setPendingRequest(null);
+                   }
+               }
+           }
+       }
+       /// @}
+       Object ret = null;
+
+       /// M: CC012: DTMF request special handling @{
+       if (rr.mRequest == RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE ||
+           rr.mRequest == RIL_REQUEST_CONFERENCE ||
+           rr.mRequest == RIL_REQUEST_SEPARATE_CONNECTION ||
+           rr.mRequest == RIL_REQUEST_EXPLICIT_CALL_TRANSFER) {
+           riljLog("clear mIsSendChldRequest");
+           mDtmfReqQueue.resetSendChldRequest();
+       }
+       /// @}
+
+       if (error == 0 || p.dataAvail() > 0) {
+           // either command succeeds or command fails but with data payload
+           try {switch (rr.mRequest) {
+
+           case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
+           case RIL_REQUEST_GET_IMSI: ret =  responseString(p); break;
+           case RIL_REQUEST_HANGUP: ret =  responseVoid(p); break;
+           case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: ret =  responseVoid(p); break;
+           case RIL_REQUEST_CONFERENCE: ret =  responseVoid(p); break;
+           case RIL_REQUEST_UDUB: ret =  responseVoid(p); break;
+           case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: ret =  responseFailCause(p); break;
+           case RIL_REQUEST_VOICE_REGISTRATION_STATE: ret =  responseStrings(p); break;
+           case RIL_REQUEST_DATA_REGISTRATION_STATE: ret =  responseStrings(p); break;
+           case RIL_REQUEST_OPERATOR: ret =  responseStrings(p); break;
+           case RIL_REQUEST_RADIO_POWER: ret =  responseVoid(p); break;
+           case RIL_REQUEST_DTMF: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
+           case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
+           case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
+           case RIL_REQUEST_SET_CLIR: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SET_CALL_FORWARD: ret =  responseVoid(p); break;
+           case RIL_REQUEST_QUERY_CALL_WAITING: ret =  responseInts(p); break;
+           case RIL_REQUEST_SET_CALL_WAITING: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+           case RIL_REQUEST_GET_IMEI: ret =  responseString(p); break;
+           case RIL_REQUEST_GET_IMEISV: ret =  responseString(p); break;
+           case RIL_REQUEST_ANSWER: ret =  responseVoid(p); break;
+           case RIL_REQUEST_QUERY_FACILITY_LOCK: ret =  responseInts(p); break;
+           case RIL_REQUEST_SET_FACILITY_LOCK: ret =  responseInts(p); break;
+           case RIL_REQUEST_CHANGE_BARRING_PASSWORD: ret =  responseVoid(p); break;
+           case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: ret =  responseInts(p); break;
+           case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: ret =  responseVoid(p); break;
+           case RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS: ret =  responseVoid(p); break;
+           case RIL_REQUEST_DTMF_START: ret =  responseVoid(p); break;
+           case RIL_REQUEST_DTMF_STOP: ret =  responseVoid(p); break;
+           case RIL_REQUEST_BASEBAND_VERSION: ret =  responseString(p); break;
+           case RIL_REQUEST_SEPARATE_CONNECTION: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SET_MUTE: ret =  responseVoid(p); break;
+           case RIL_REQUEST_GET_MUTE: ret =  responseInts(p); break;
+           case RIL_REQUEST_QUERY_CLIP: ret =  responseInts(p); break;
+           case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+           case RIL_REQUEST_RESET_RADIO: ret =  responseVoid(p); break;
+           case RIL_REQUEST_OEM_HOOK_RAW: ret =  responseRaw(p); break;
+           case RIL_REQUEST_OEM_HOOK_STRINGS: ret =  responseStrings(p); break;
+           case RIL_REQUEST_SCREEN_STATE: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: ret =  responseVoid(p); break;
+           case RIL_REQUEST_WRITE_SMS_TO_SIM: ret =  responseInts(p); break;
+           case RIL_REQUEST_DELETE_SMS_ON_SIM: ret =  responseVoid(p); break;
+           case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: ret =  responseInts(p); break;
+           case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SET_TTY_MODE: ret =  responseVoid(p); break;
+           case RIL_REQUEST_QUERY_TTY_MODE: ret =  responseInts(p); break;
+           case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+           case RIL_REQUEST_VOICE_RADIO_TECH: ret = responseInts(p); break;
+           case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE: ret = responseVoid(p); break;
+           case RIL_REQUEST_SET_INITIAL_ATTACH_APN: ret = responseVoid(p); break;
+           case RIL_REQUEST_SET_DATA_PROFILE: ret = responseVoid(p); break;
+           case RIL_REQUEST_IMS_REGISTRATION_STATE: ret = responseInts(p); break;
+           /// M: CC010: Add RIL interface @{
+           case RIL_REQUEST_HANGUP_ALL: ret =  responseVoid(p); break;
+           case RIL_REQUEST_FORCE_RELEASE_CALL: ret = responseVoid(p); break;
+           case RIL_REQUEST_SET_CALL_INDICATION: ret = responseVoid(p); break;
+           case RIL_REQUEST_EMERGENCY_DIAL: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SET_ECC_SERVICE_CATEGORY: ret = responseVoid(p); break;
+           case RIL_REQUEST_SET_ECC_LIST: ret = responseVoid(p); break;
+           /// @}
+           /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+           case RIL_REQUEST_SET_SPEECH_CODEC_INFO: ret = responseVoid(p); break;
+           /// @}
+           /// M: For 3G VT only @{
+           case RIL_REQUEST_VT_DIAL: ret = responseVoid(p); break;
+           case RIL_REQUEST_VOICE_ACCEPT: ret = responseVoid(p); break;
+           case RIL_REQUEST_REPLACE_VT_CALL: ret = responseVoid(p); break;
+           /// @}
+           /// M: IMS feature. @{
+           case RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER: responseString(p); break;
+           case RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER: responseString(p); break;
+           case RIL_REQUEST_DIAL_WITH_SIP_URI: ret = responseVoid(p); break;
+           case RIL_REQUEST_RESUME_CALL: ret = responseVoid(p); break;
+           case RIL_REQUEST_HOLD_CALL: ret = responseVoid(p); break;
+           /// @}
+
+           //MTK-START SS
+           case RIL_REQUEST_GET_COLP: ret = responseInts(p); break;
+           case RIL_REQUEST_SET_COLP: ret = responseVoid(p); break;
+           case RIL_REQUEST_GET_COLR: ret = responseInts(p); break;
+           //MTK-END SS
+
+           // IMS
+           case RIL_REQUEST_SET_IMS_ENABLE: ret = responseVoid(p); break;
+           case RIL_REQUEST_SIM_GET_ATR: ret = responseString(p); break;
+           // M: Fast Dormancy
+           case RIL_REQUEST_SET_SCRI: ret = responseVoid(p); break;
+           case RIL_REQUEST_SET_FD_MODE: ret = responseInts(p); break;
+
+           /// M: SVLTE Remove access feature
+           case RIL_REQUEST_CONFIG_MODEM_STATUS: ret = responseVoid(p); break;
+
+           /// M: IMS VoLTE conference dial feature. @{
+           case RIL_REQUEST_CONFERENCE_DIAL: ret =  responseVoid(p); break;
+           /// @}
+           case RIL_REQUEST_RELOAD_MODEM_TYPE: ret =  responseVoid(p); break;
+           /// M: CC010: Add RIL interface @{
+           case RIL_REQUEST_SET_IMS_CALL_STATUS: ret = responseVoid(p); break;
+           /// @}
+
+           /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+           case RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER: ret = responseVoid(p); break;
+           case RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS: ret = responseVoid(p); break;
+           /// @}
+           /// M: IMS ViLTE feature. @{
+           case RIL_REQUEST_VIDEO_CALL_ACCEPT: ret = responseVoid(p); break;
+           /// @}
+           default:
+               throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
+           //break;
+           }} catch (Throwable tr) {
+               // Exceptions here usually mean invalid RIL responses
+
+               Rlog.w(IMS_RILA_LOG_TAG, rr.serialString() + "< "
+                       + requestToString(rr.mRequest)
+                       + " exception, possible invalid RIL response", tr);
+
+               if (rr.mResult != null) {
+                   AsyncResult.forMessage(rr.mResult, null, tr);
+                   rr.mResult.sendToTarget();
+               }
+               return rr;
+           }
+       }
+
+       if (rr.mRequest == RIL_REQUEST_SHUTDOWN) {
+           // Set RADIO_STATE to RADIO_UNAVAILABLE to continue shutdown process
+           // regardless of error code to continue shutdown procedure.
+           riljLog("Response to RIL_REQUEST_SHUTDOWN received. Error is " +
+                   error + " Setting Radio State to Unavailable regardless of error.");
+           setRadioState(RadioState.RADIO_UNAVAILABLE);
+       }
+
+       if (error != 0) {
+           rr.onError(error, ret);
+       } else {
+
+           if (IMS_RILA_LOGD) riljLog(rr.serialString() + "< " + requestToString(rr.mRequest)
+                   + " " + retToString(rr.mRequest, ret));
+
+           if (rr.mResult != null) {
+               AsyncResult.forMessage(rr.mResult, ret, null);
+               rr.mResult.sendToTarget();
+           }
+       }
+       return rr;
+   }
+
+    private RILRequest findAndRemoveRequestFromList(int serial) {
+        RILRequest rr = null;
+        synchronized (mRequestList) {
+            rr = mRequestList.get(serial);
+            if (rr != null) {
+                mRequestList.remove(serial);
+            }
+        }
+
+        return rr;
+    }
+
+    private Object responseVoid(Parcel p) {
+        return null;
+    }
+
+    private Object responseString(Parcel p) {
+        String response;
+
+        response = p.readString();
+
+        return response;
+    }
+
+    private Object responseStrings(Parcel p) {
+        int num;
+        String response[];
+
+        response = p.readStringArray();
+
+        return response;
+    }
+
+    private Object
+    responseRaw(Parcel p) {
+        int num;
+        byte response[];
+
+        response = p.createByteArray();
+
+        return response;
+    }
+
+    private Object responseInts(Parcel p) {
+        int numInts;
+        int response[];
+
+        numInts = p.readInt();
+
+        response = new int[numInts];
+
+        for (int i = 0 ; i < numInts ; i++) {
+            response[i] = p.readInt();
+        }
+
+        return response;
+    }
+
+    private Object
+    responseCallRing(Parcel p){
+        char response[] = new char[4];
+
+        response[0] = (char) p.readInt();    // isPresent
+        response[1] = (char) p.readInt();    // signalType
+        response[2] = (char) p.readInt();    // alertPitch
+        response[3] = (char) p.readInt();    // signal
+
+        return response;
+    }
+
+    private Object
+    responseSuppServiceNotification(Parcel p) {
+        SuppServiceNotification notification = new SuppServiceNotification();
+
+        notification.notificationType = p.readInt();
+        notification.code = p.readInt();
+        notification.index = p.readInt();
+        notification.type = p.readInt();
+        notification.number = p.readString();
+
+        return notification;
+    }
+
+    private Object
+    responseFailCause(Parcel p) {
+        LastCallFailCause failCause = new LastCallFailCause();
+        failCause.causeCode = p.readInt();
+        if (p.dataAvail() > 0) {
+          failCause.vendorCause = p.readString();
+        }
+        return failCause;
+    }
+
+    static String responseToString(int request)
+    {
+        switch(request) {
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: return "UNSOL_RESPONSE_RADIO_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: return "UNSOL_RESPONSE_CALL_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_NEW_SMS: return "UNSOL_RESPONSE_NEW_SMS";
+            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT: return "UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT";
+            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM: return "UNSOL_RESPONSE_NEW_SMS_ON_SIM";
+            case RIL_UNSOL_ON_USSD: return "UNSOL_ON_USSD";
+            case RIL_UNSOL_ON_USSD_REQUEST: return "UNSOL_ON_USSD_REQUEST";
+            case RIL_UNSOL_NITZ_TIME_RECEIVED: return "UNSOL_NITZ_TIME_RECEIVED";
+            case RIL_UNSOL_SIGNAL_STRENGTH: return "UNSOL_SIGNAL_STRENGTH";
+            case RIL_UNSOL_DATA_CALL_LIST_CHANGED: return "UNSOL_DATA_CALL_LIST_CHANGED";
+            case RIL_UNSOL_SUPP_SVC_NOTIFICATION: return "UNSOL_SUPP_SVC_NOTIFICATION";
+            case RIL_UNSOL_STK_SESSION_END: return "UNSOL_STK_SESSION_END";
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND: return "UNSOL_STK_PROACTIVE_COMMAND";
+            case RIL_UNSOL_STK_EVENT_NOTIFY: return "UNSOL_STK_EVENT_NOTIFY";
+            case RIL_UNSOL_STK_CALL_SETUP: return "UNSOL_STK_CALL_SETUP";
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL: return "UNSOL_SIM_SMS_STORAGE_FULL";
+            case RIL_UNSOL_SIM_REFRESH: return "UNSOL_SIM_REFRESH";
+            case RIL_UNSOL_CALL_RING: return "UNSOL_CALL_RING";
+            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED: return "UNSOL_RESPONSE_SIM_STATUS_CHANGED";
+            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS: return "UNSOL_RESPONSE_CDMA_NEW_SMS";
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS: return "UNSOL_RESPONSE_NEW_BROADCAST_SMS";
+            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL: return "UNSOL_CDMA_RUIM_SMS_STORAGE_FULL";
+            case RIL_UNSOL_RESTRICTED_STATE_CHANGED: return "UNSOL_RESTRICTED_STATE_CHANGED";
+            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE: return "UNSOL_ENTER_EMERGENCY_CALLBACK_MODE";
+            case RIL_UNSOL_CDMA_CALL_WAITING: return "UNSOL_CDMA_CALL_WAITING";
+            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS: return "UNSOL_CDMA_OTA_PROVISION_STATUS";
+            case RIL_UNSOL_CDMA_INFO_REC: return "UNSOL_CDMA_INFO_REC";
+            case RIL_UNSOL_OEM_HOOK_RAW: return "UNSOL_OEM_HOOK_RAW";
+            case RIL_UNSOL_RINGBACK_TONE: return "UNSOL_RINGBACK_TONE";
+            case RIL_UNSOL_RESEND_INCALL_MUTE: return "UNSOL_RESEND_INCALL_MUTE";
+            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED: return "CDMA_SUBSCRIPTION_SOURCE_CHANGED";
+            case RIL_UNSOl_CDMA_PRL_CHANGED: return "UNSOL_CDMA_PRL_CHANGED";
+            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE: return "UNSOL_EXIT_EMERGENCY_CALLBACK_MODE";
+            case RIL_UNSOL_RIL_CONNECTED: return "UNSOL_RIL_CONNECTED";
+            case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED: return "UNSOL_VOICE_RADIO_TECH_CHANGED";
+            case RIL_UNSOL_CELL_INFO_LIST: return "UNSOL_CELL_INFO_LIST";
+            case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
+                return "UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED";
+            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
+                    return "RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED";
+            case RIL_UNSOL_SRVCC_STATE_NOTIFY:
+                    return "UNSOL_SRVCC_STATE_NOTIFY";
+            case RIL_UNSOL_SIP_CALL_PROGRESS_INDICATOR:
+                    return "UNSOL_SIP_CALL_PROGRESS_INDICATOR";
+            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED: return "RIL_UNSOL_HARDWARE_CONFIG_CHANGED";
+            /* M: CC part start */
+            case RIL_UNSOL_CALL_FORWARDING: return "UNSOL_CALL_FORWARDING";
+            case RIL_UNSOL_CRSS_NOTIFICATION: return "UNSOL_CRSS_NOTIFICATION";
+            case RIL_UNSOL_INCOMING_CALL_INDICATION: return "UNSOL_INCOMING_CALL_INDICATION";
+            case RIL_UNSOL_CIPHER_INDICATION: return "RIL_UNSOL_CIPHER_INDICATION";
+            case RIL_UNSOL_CNAP: return "RIL_UNSOL_CNAP";
+            case RIL_UNSOL_SPEECH_CODEC_INFO: return "UNSOL_SPEECH_CODEC_INFO";
+            /* M: CC part end */
+            //MTK-START multiple application support
+            case RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED: return "RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED";
+            //MTK-END multiple application support
+            case RIL_UNSOL_SIM_MISSING: return "UNSOL_SIM_MISSING";
+            case RIL_UNSOL_VIRTUAL_SIM_ON: return "UNSOL_VIRTUAL_SIM_ON";
+            case RIL_UNSOL_VIRTUAL_SIM_OFF: return "UNSOL_VIRTUAL_SIM_ON_OFF";
+            case RIL_UNSOL_SIM_RECOVERY: return "UNSOL_SIM_RECOVERY";
+            case RIL_UNSOL_SIM_PLUG_OUT: return "UNSOL_SIM_PLUG_OUT";
+            case RIL_UNSOL_SIM_PLUG_IN: return "UNSOL_SIM_PLUG_IN";
+            case RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED: return "RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED";
+            case RIL_UNSOL_DATA_ALLOWED: return "RIL_UNSOL_DATA_ALLOWED";
+            case RIL_UNSOL_PHB_READY_NOTIFICATION: return "UNSOL_PHB_READY_NOTIFICATION";
+            case RIL_UNSOL_IMEI_LOCK: return "UNSOL_IMEI_LOCK";
+            case RIL_UNSOL_RESPONSE_ACMT: return "UNSOL_ACMT_INFO";
+            case RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_MMRR_STATUS_CHANGED: return "UNSOL_RESPONSE_MMRR_STATUS_CHANGED";
+            case RIL_UNSOL_NEIGHBORING_CELL_INFO: return "UNSOL_NEIGHBORING_CELL_INFO";
+            case RIL_UNSOL_NETWORK_INFO: return "UNSOL_NETWORK_INFO";
+            case RIL_UNSOL_IMS_ENABLE_DONE: return "RIL_UNSOL_IMS_ENABLE_DONE";
+            case RIL_UNSOL_IMS_DISABLE_DONE: return "RIL_UNSOL_IMS_DISABLE_DONE";
+            case RIL_UNSOL_IMS_REGISTRATION_INFO: return "RIL_UNSOL_IMS_REGISTRATION_INFO";
+            case RIL_UNSOL_STK_SETUP_MENU_RESET: return "RIL_UNSOL_STK_SETUP_MENU_RESET";
+            case RIL_UNSOL_RESPONSE_PLMN_CHANGED: return "RIL_UNSOL_RESPONSE_PLMN_CHANGED";
+            case RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED: return "RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED";
+            //Remote SIM ME lock related APIs [Start]
+            case RIL_UNSOL_MELOCK_NOTIFICATION: return "RIL_UNSOL_MELOCK_NOTIFICATION";
+            //Remote SIM ME lock related APIs [End]
+            // M: Fast Dormancy
+            case RIL_UNSOL_SCRI_RESULT: return "RIL_UNSOL_SCRI_RESULT";
+            case RIL_UNSOL_STK_EVDL_CALL: return "RIL_UNSOL_STK_EVDL_CALL";
+            case RIL_UNSOL_STK_CALL_CTRL: return "RIL_UNSOL_STK_CALL_CTRL";
+
+            /// M: IMS feature. @{
+            case RIL_UNSOL_ECONF_SRVCC_INDICATION: return "RIL_UNSOL_ECONF_SRVCC_INDICATION";
+            //For updating conference call merged/added result.
+            case RIL_UNSOL_ECONF_RESULT_INDICATION: return "RIL_UNSOL_ECONF_RESULT_INDICATION";
+            //For updating call mode and pau information.
+            case RIL_UNSOL_CALL_INFO_INDICATION : return "RIL_UNSOL_CALL_INFO_INDICATION";
+            /// @}
+
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO: return "RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO";
+            case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION: return "RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION";
+            // M: CC33 LTE.
+            case RIL_UNSOL_RAC_UPDATE: return "RIL_UNSOL_RAC_UPDATE";
+            case RIL_UNSOL_REMOVE_RESTRICT_EUTRAN: return "RIL_UNSOL_REMOVE_RESTRICT_EUTRAN";
+
+            //MTK-START for MD state change
+            case RIL_UNSOL_MD_STATE_CHANGE: return "RIL_UNSOL_MD_STATE_CHANGE";
+            //MTK-END for MD state change
+            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY: return "UNSOL_STK_CC_ALPHA_NOTIFY";
+            //IMS
+            case RIL_UNSOL_IMS_ENABLE_START: return "RIL_UNSOL_IMS_ENABLE_START";
+            case RIL_UNSOL_IMS_DISABLE_START: return "RIL_UNSOL_IMS_DISABLE_START";
+            //IMS feature for ViLTE related URC.
+            case RIL_UNSOL_CALLMOD_CHANGE_INDICATOR: return "RIL_UNSOL_CALLMOD_CHANGE_INDICATOR";
+            case RIL_UNSOL_VIDEO_CAPABILITY_INDICATOR:
+                return "RIL_UNSOL_VIDEO_CAPABILITY_INDICATOR";
+            default: return "<unknown response>";
+        }
+    }
+
+    static String requestToString(int request) {
+        switch(request) {
+            case RIL_REQUEST_GET_SIM_STATUS: return "GET_SIM_STATUS";
+            case RIL_REQUEST_ENTER_SIM_PIN: return "ENTER_SIM_PIN";
+            case RIL_REQUEST_ENTER_SIM_PUK: return "ENTER_SIM_PUK";
+            case RIL_REQUEST_ENTER_SIM_PIN2: return "ENTER_SIM_PIN2";
+            case RIL_REQUEST_ENTER_SIM_PUK2: return "ENTER_SIM_PUK2";
+            case RIL_REQUEST_CHANGE_SIM_PIN: return "CHANGE_SIM_PIN";
+            case RIL_REQUEST_CHANGE_SIM_PIN2: return "CHANGE_SIM_PIN2";
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
+                return "ENTER_NETWORK_DEPERSONALIZATION";
+            case RIL_REQUEST_GET_CURRENT_CALLS: return "GET_CURRENT_CALLS";
+            case RIL_REQUEST_DIAL: return "DIAL";
+            case RIL_REQUEST_GET_IMSI: return "GET_IMSI";
+            case RIL_REQUEST_HANGUP: return "HANGUP";
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: return "HANGUP_WAITING_OR_BACKGROUND";
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
+                return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
+                return "REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
+            case RIL_REQUEST_CONFERENCE: return "CONFERENCE";
+            case RIL_REQUEST_UDUB: return "UDUB";
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: return "LAST_CALL_FAIL_CAUSE";
+            case RIL_REQUEST_SIGNAL_STRENGTH: return "SIGNAL_STRENGTH";
+            case RIL_REQUEST_VOICE_REGISTRATION_STATE: return "VOICE_REGISTRATION_STATE";
+            case RIL_REQUEST_DATA_REGISTRATION_STATE: return "DATA_REGISTRATION_STATE";
+            case RIL_REQUEST_OPERATOR: return "OPERATOR";
+            case RIL_REQUEST_RADIO_POWER: return "RADIO_POWER";
+            case RIL_REQUEST_DTMF: return "DTMF";
+            case RIL_REQUEST_SEND_SMS: return "SEND_SMS";
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: return "SEND_SMS_EXPECT_MORE";
+            case RIL_REQUEST_SETUP_DATA_CALL: return "SETUP_DATA_CALL";
+            case RIL_REQUEST_SIM_IO: return "SIM_IO";
+            case RIL_REQUEST_SEND_USSD: return "SEND_USSD";
+            case RIL_REQUEST_CANCEL_USSD: return "CANCEL_USSD";
+            case RIL_REQUEST_GET_CLIR: return "GET_CLIR";
+            case RIL_REQUEST_SET_CLIR: return "SET_CLIR";
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: return "QUERY_CALL_FORWARD_STATUS";
+            case RIL_REQUEST_SET_CALL_FORWARD: return "SET_CALL_FORWARD";
+            case RIL_REQUEST_QUERY_CALL_WAITING: return "QUERY_CALL_WAITING";
+            case RIL_REQUEST_SET_CALL_WAITING: return "SET_CALL_WAITING";
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: return "SMS_ACKNOWLEDGE";
+            case RIL_REQUEST_GET_IMEI: return "GET_IMEI";
+            case RIL_REQUEST_GET_IMEISV: return "GET_IMEISV";
+            case RIL_REQUEST_ANSWER: return "ANSWER";
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: return "DEACTIVATE_DATA_CALL";
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: return "QUERY_FACILITY_LOCK";
+            case RIL_REQUEST_SET_FACILITY_LOCK: return "SET_FACILITY_LOCK";
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: return "CHANGE_BARRING_PASSWORD";
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: return "QUERY_NETWORK_SELECTION_MODE";
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
+                return "SET_NETWORK_SELECTION_AUTOMATIC";
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: return "SET_NETWORK_SELECTION_MANUAL";
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : return "QUERY_AVAILABLE_NETWORKS ";
+            case RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS:
+                return "ABORT_QUERY_AVAILABLE_NETWORKS";
+            case RIL_REQUEST_DTMF_START: return "DTMF_START";
+            case RIL_REQUEST_DTMF_STOP: return "DTMF_STOP";
+            case RIL_REQUEST_BASEBAND_VERSION: return "BASEBAND_VERSION";
+            case RIL_REQUEST_SEPARATE_CONNECTION: return "SEPARATE_CONNECTION";
+            case RIL_REQUEST_SET_MUTE: return "SET_MUTE";
+            case RIL_REQUEST_GET_MUTE: return "GET_MUTE";
+            case RIL_REQUEST_QUERY_CLIP: return "QUERY_CLIP";
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: return "LAST_DATA_CALL_FAIL_CAUSE";
+            case RIL_REQUEST_DATA_CALL_LIST: return "DATA_CALL_LIST";
+            case RIL_REQUEST_RESET_RADIO: return "RESET_RADIO";
+            case RIL_REQUEST_OEM_HOOK_RAW: return "OEM_HOOK_RAW";
+            case RIL_REQUEST_OEM_HOOK_STRINGS: return "OEM_HOOK_STRINGS";
+            case RIL_REQUEST_SCREEN_STATE: return "SCREEN_STATE";
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: return "SET_SUPP_SVC_NOTIFICATION";
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: return "WRITE_SMS_TO_SIM";
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: return "DELETE_SMS_ON_SIM";
+            case RIL_REQUEST_SET_BAND_MODE: return "SET_BAND_MODE";
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: return "QUERY_AVAILABLE_BAND_MODE";
+            case RIL_REQUEST_STK_GET_PROFILE: return "REQUEST_STK_GET_PROFILE";
+            case RIL_REQUEST_STK_SET_PROFILE: return "REQUEST_STK_SET_PROFILE";
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: return "REQUEST_STK_SEND_ENVELOPE_COMMAND";
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
+                return "REQUEST_STK_SEND_TERMINAL_RESPONSE";
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
+                return "REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: return "REQUEST_EXPLICIT_CALL_TRANSFER";
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
+                return "REQUEST_SET_PREFERRED_NETWORK_TYPE";
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
+                return "REQUEST_GET_PREFERRED_NETWORK_TYPE";
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: return "REQUEST_GET_NEIGHBORING_CELL_IDS";
+            case RIL_REQUEST_SET_LOCATION_UPDATES: return "REQUEST_SET_LOCATION_UPDATES";
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
+                return "RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE";
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
+                return "RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE";
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
+                return "RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE";
+            case RIL_REQUEST_SET_TTY_MODE: return "RIL_REQUEST_SET_TTY_MODE";
+            case RIL_REQUEST_QUERY_TTY_MODE: return "RIL_REQUEST_QUERY_TTY_MODE";
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
+                return "RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
+                return "RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
+            case RIL_REQUEST_CDMA_FLASH: return "RIL_REQUEST_CDMA_FLASH";
+            case RIL_REQUEST_CDMA_BURST_DTMF: return "RIL_REQUEST_CDMA_BURST_DTMF";
+            case RIL_REQUEST_CDMA_SEND_SMS: return "RIL_REQUEST_CDMA_SEND_SMS";
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: return "RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE";
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
+                return "RIL_REQUEST_GSM_GET_BROADCAST_CONFIG";
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
+                return "RIL_REQUEST_GSM_SET_BROADCAST_CONFIG";
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
+                return "RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG";
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
+                return "RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG";
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
+                return "RIL_REQUEST_GSM_BROADCAST_ACTIVATION";
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
+                return "RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY";
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
+                return "RIL_REQUEST_CDMA_BROADCAST_ACTIVATION";
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: return "RIL_REQUEST_CDMA_SUBSCRIPTION";
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: return "RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM";
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: return "RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM";
+            case RIL_REQUEST_DEVICE_IDENTITY: return "RIL_REQUEST_DEVICE_IDENTITY";
+            case RIL_REQUEST_GET_SMSC_ADDRESS: return "RIL_REQUEST_GET_SMSC_ADDRESS";
+            case RIL_REQUEST_SET_SMSC_ADDRESS: return "RIL_REQUEST_SET_SMSC_ADDRESS";
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
+                return "REQUEST_EXIT_EMERGENCY_CALLBACK_MODE";
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
+                return "RIL_REQUEST_REPORT_SMS_MEMORY_STATUS";
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
+                return "RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING";
+            case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
+                return "RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE";
+            case RIL_REQUEST_ISIM_AUTHENTICATION: return "RIL_REQUEST_ISIM_AUTHENTICATION";
+            case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
+                return "RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
+            case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
+                return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
+            case RIL_REQUEST_VOICE_RADIO_TECH: return "RIL_REQUEST_VOICE_RADIO_TECH";
+            case RIL_REQUEST_GET_CELL_INFO_LIST: return "RIL_REQUEST_GET_CELL_INFO_LIST";
+            case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
+                return "RIL_REQUEST_SET_CELL_INFO_LIST_RATE";
+            case RIL_REQUEST_SET_INITIAL_ATTACH_APN: return "RIL_REQUEST_SET_INITIAL_ATTACH_APN";
+            case RIL_REQUEST_SET_DATA_PROFILE: return "RIL_REQUEST_SET_DATA_PROFILE";
+            case RIL_REQUEST_IMS_REGISTRATION_STATE: return "RIL_REQUEST_IMS_REGISTRATION_STATE";
+            case RIL_REQUEST_IMS_SEND_SMS: return "RIL_REQUEST_IMS_SEND_SMS";
+            case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC: return "RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC";
+            case RIL_REQUEST_SIM_OPEN_CHANNEL: return "RIL_REQUEST_SIM_OPEN_CHANNEL";
+            case RIL_REQUEST_SIM_CLOSE_CHANNEL: return "RIL_REQUEST_SIM_CLOSE_CHANNEL";
+            case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
+                return "RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL";
+            case RIL_REQUEST_NV_READ_ITEM: return "RIL_REQUEST_NV_READ_ITEM";
+            case RIL_REQUEST_NV_WRITE_ITEM: return "RIL_REQUEST_NV_WRITE_ITEM";
+            case RIL_REQUEST_NV_WRITE_CDMA_PRL: return "RIL_REQUEST_NV_WRITE_CDMA_PRL";
+            case RIL_REQUEST_NV_RESET_CONFIG: return "RIL_REQUEST_NV_RESET_CONFIG";
+            case RIL_REQUEST_SET_UICC_SUBSCRIPTION: return "RIL_REQUEST_SET_UICC_SUBSCRIPTION";
+            case RIL_REQUEST_ALLOW_DATA: return "RIL_REQUEST_ALLOW_DATA";
+            case RIL_REQUEST_GET_HARDWARE_CONFIG: return "GET_HARDWARE_CONFIG";
+            case RIL_REQUEST_SIM_AUTHENTICATION: return "RIL_REQUEST_SIM_AUTHENTICATION";
+            case RIL_REQUEST_SHUTDOWN: return "RIL_REQUEST_SHUTDOWN";
+            case RIL_REQUEST_SET_RADIO_CAPABILITY:
+                    return "RIL_REQUEST_SET_RADIO_CAPABILITY";
+            case RIL_REQUEST_GET_RADIO_CAPABILITY:
+                    return "RIL_REQUEST_GET_RADIO_CAPABILITY";
+            /// M: CC010: Add RIL interface @{
+            case RIL_REQUEST_HANGUP_ALL: return "HANGUP_ALL";
+            case RIL_REQUEST_FORCE_RELEASE_CALL: return "FORCE_RELEASE_CALL";
+            case RIL_REQUEST_SET_CALL_INDICATION: return "SET_CALL_INDICATION";
+            case RIL_REQUEST_EMERGENCY_DIAL: return "EMERGENCY_DIAL";
+            case RIL_REQUEST_SET_ECC_SERVICE_CATEGORY: return "SET_ECC_SERVICE_CATEGORY";
+            case RIL_REQUEST_SET_ECC_LIST: return "SET_ECC_LIST";
+            /// @}
+            /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+            case RIL_REQUEST_SET_SPEECH_CODEC_INFO: return "SET_SPEECH_CODEC_INFO";
+            /// @}
+            /// M: For 3G VT only @{
+            case RIL_REQUEST_VT_DIAL: return "RIL_REQUEST_VT_DIAL";
+            case RIL_REQUEST_VOICE_ACCEPT: return "VOICE_ACCEPT";
+            case RIL_REQUEST_REPLACE_VT_CALL: return "RIL_REQUEST_REPLACE_VT_CALL";
+            /// @}
+
+            /// M: IMS feature. @{
+            case RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER:
+                return "RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER";
+            case RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER:
+                return "RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER";
+            case RIL_REQUEST_DIAL_WITH_SIP_URI: return "RIL_REQUEST_DIAL_WITH_SIP_URI";
+            case RIL_REQUEST_RESUME_CALL: return "RIL_REQUEST_RESUNME_CALL";
+            case RIL_REQUEST_HOLD_CALL: return "RIL_REQUEST_HOLD_CALL";
+            /// @}
+
+            //MTK-START SS
+            case RIL_REQUEST_GET_COLP: return "GET_COLP";
+            case RIL_REQUEST_SET_COLP: return "SET_COLP";
+            case RIL_REQUEST_GET_COLR: return "GET_COLR";
+            //MTK-END SS
+
+            //MTK-START SIM ME lock
+            case RIL_REQUEST_QUERY_SIM_NETWORK_LOCK: return "QUERY_SIM_NETWORK_LOCK";
+            case RIL_REQUEST_SET_SIM_NETWORK_LOCK: return "SET_SIM_NETWORK_LOCK";
+            //MTK-END SIM ME lock
+            //ISIM
+            case RIL_REQUEST_GENERAL_SIM_AUTH: return "RIL_REQUEST_GENERAL_SIM_AUTH";
+            case RIL_REQUEST_OPEN_ICC_APPLICATION: return "RIL_REQUEST_OPEN_ICC_APPLICATION";
+            case RIL_REQUEST_GET_ICC_APPLICATION_STATUS:
+                return "RIL_REQUEST_GET_ICC_APPLICATION_STATUS";
+            case RIL_REQUEST_SIM_IO_EX: return "SIM_IO_EX";
+
+            // PHB Start
+            case RIL_REQUEST_QUERY_PHB_STORAGE_INFO: return "RIL_REQUEST_QUERY_PHB_STORAGE_INFO";
+            case RIL_REQUEST_WRITE_PHB_ENTRY: return "RIL_REQUEST_WRITE_PHB_ENTRY";
+            case RIL_REQUEST_READ_PHB_ENTRY: return "RIL_REQUEST_READ_PHB_ENTRY";
+            case RIL_REQUEST_QUERY_UPB_CAPABILITY: return "RIL_REQUEST_QUERY_UPB_CAPABILITY";
+            case RIL_REQUEST_EDIT_UPB_ENTRY: return "RIL_REQUEST_EDIT_UPB_ENTRY";
+            case RIL_REQUEST_DELETE_UPB_ENTRY: return "RIL_REQUEST_DELETE_UPB_ENTRY";
+            case RIL_REQUEST_READ_UPB_GAS_LIST: return "RIL_REQUEST_READ_UPB_GAS_LIST";
+            case RIL_REQUEST_READ_UPB_GRP: return "RIL_REQUEST_READ_UPB_GRP";
+            case RIL_REQUEST_WRITE_UPB_GRP: return "RIL_REQUEST_WRITE_UPB_GRP";
+            case RIL_REQUEST_GET_PHB_STRING_LENGTH: return "RIL_REQUEST_GET_PHB_STRING_LENGTH";
+            case RIL_REQUEST_GET_PHB_MEM_STORAGE: return "RIL_REQUEST_GET_PHB_MEM_STORAGE";
+            case RIL_REQUEST_SET_PHB_MEM_STORAGE: return "RIL_REQUEST_SET_PHB_MEM_STORAGE";
+            case RIL_REQUEST_READ_PHB_ENTRY_EXT: return "RIL_REQUEST_READ_PHB_ENTRY_EXT";
+            case RIL_REQUEST_WRITE_PHB_ENTRY_EXT: return "RIL_REQUEST_WRITE_PHB_ENTRY_EXT";
+            // PHB End
+
+            /* M: network part start */
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT:
+                return "SET_NETWORK_SELECTION_MANUAL_WITH_ACT";
+            case RIL_REQUEST_GET_POL_CAPABILITY: return "RIL_REQUEST_GET_POL_CAPABILITY";
+            case RIL_REQUEST_GET_POL_LIST: return "RIL_REQUEST_GET_POL_LIST";
+            case RIL_REQUEST_SET_POL_ENTRY: return "RIL_REQUEST_SET_POL_ENTRY";
+            case RIL_REQUEST_SET_TRM: return "RIL_REQUEST_SET_TRM";
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT:
+                return "QUERY_AVAILABLE_NETWORKS_WITH_ACT";
+            //Femtocell (CSG) feature START
+            case RIL_REQUEST_GET_FEMTOCELL_LIST: return "RIL_REQUEST_GET_FEMTOCELL_LIST";
+            case RIL_REQUEST_ABORT_FEMTOCELL_LIST: return "RIL_REQUEST_ABORT_FEMTOCELL_LIST";
+            case RIL_REQUEST_SELECT_FEMTOCELL: return "RIL_REQUEST_SELECT_FEMTOCELL";
+            //Femtocell (CSG) feature END
+            /* M: network part end */
+            case RIL_REQUEST_STK_EVDL_CALL_BY_AP: return "RIL_REQUEST_STK_EVDL_CALL_BY_AP";
+            case RIL_REQUEST_QUERY_MODEM_TYPE: return "RIL_REQUEST_QUERY_MODEM_TYPE";
+            case RIL_REQUEST_STORE_MODEM_TYPE: return "RIL_REQUEST_STORE_MODEM_TYPE";
+            case RIL_REQUEST_SIM_GET_ATR: return "SIM_GET_ATR";
+            case RIL_REQUEST_SIM_OPEN_CHANNEL_WITH_SW: return "SIM_OPEN_CHANNEL_WITH_SW";
+
+            // IMS
+            case RIL_REQUEST_SET_IMS_ENABLE: return "RIL_REQUEST_SET_IMS_ENABLE";
+
+            // M: Fast Dormancy
+            case RIL_REQUEST_SET_SCRI: return "RIL_REQUEST_SET_SCRI";
+            case RIL_REQUEST_SET_FD_MODE: return "RIL_REQUEST_SET_FD_MODE";
+            // MTK-START, SMS part
+            case RIL_REQUEST_GET_SMS_PARAMS: return "RIL_REQUEST_GET_SMS_PARAMS";
+            case RIL_REQUEST_SET_SMS_PARAMS: return "RIL_REQUEST_SET_SMS_PARAMS";
+            case RIL_REQUEST_GET_SMS_SIM_MEM_STATUS: return "RIL_REQUEST_GET_SMS_SIM_MEM_STATUS";
+            case RIL_REQUEST_SET_ETWS: return "RIL_REQUEST_SET_ETWS";
+            case RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO:
+                return "RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO";
+            case RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO:
+                return "RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO";
+            case RIL_REQUEST_GET_CB_CONFIG_INFO: return "RIL_REQUEST_GET_CB_CONFIG_INFO";
+            case RIL_REQUEST_REMOVE_CB_MESSAGE: return "RIL_REQUEST_REMOVE_CB_MESSAGE";
+            // MTK-END, SMS part
+            case RIL_REQUEST_SET_DATA_CENTRIC: return "RIL_REQUEST_SET_DATA_CENTRIC";
+
+            case RIL_REQUEST_MODEM_POWEROFF: return "MODEM_POWEROFF";
+            case RIL_REQUEST_MODEM_POWERON: return "MODEM_POWERON";
+            // M: CC33 LTE.
+            case RIL_REQUEST_SET_DATA_ON_TO_MD: return "RIL_REQUEST_SET_DATA_ON_TO_MD";
+            case RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE:
+                return "RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE";
+            case RIL_REQUEST_BTSIM_CONNECT: return "RIL_REQUEST_BTSIM_CONNECT";
+            case RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF:
+                return "RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF";
+            case RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM:
+                return "RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM";
+            case RIL_REQUEST_BTSIM_TRANSFERAPDU: return "RIL_REQUEST_SEND_BTSIM_TRANSFERAPDU";
+
+            /// M: IMS VoLTE conference dial feature. @{
+            case RIL_REQUEST_CONFERENCE_DIAL: return "RIL_REQUEST_CONFERENCE_DIAL";
+            /// @}
+            case RIL_REQUEST_RELOAD_MODEM_TYPE: return "RIL_REQUEST_RELOAD_MODEM_TYPE";
+            /// M: CC010: Add RIL interface @{
+            case RIL_REQUEST_SET_IMS_CALL_STATUS: return "RIL_REQUEST_SET_IMS_CALL_STATUS";
+            /// @}
+
+            /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+            case RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER:
+                return "RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER";
+            case RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS:
+                return "RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS";
+            /// @}
+
+            /// M: SVLTE remote SIM access feature
+            case RIL_REQUEST_CONFIG_MODEM_STATUS: return "RIL_REQUEST_CONFIG_MODEM_STATUS";
+            /* M: C2K part start */
+            case RIL_REQUEST_GET_NITZ_TIME: return "RIL_REQUEST_GET_NITZ_TIME";
+            case RIL_REQUEST_QUERY_UIM_INSERTED: return "RIL_REQUEST_QUERY_UIM_INSERTED";
+            case RIL_REQUEST_SWITCH_HPF: return "RIL_REQUEST_SWITCH_HPF";
+            case RIL_REQUEST_SET_AVOID_SYS: return "RIL_REQUEST_SET_AVOID_SYS";
+            case RIL_REQUEST_QUERY_AVOID_SYS: return "RIL_REQUEST_QUERY_AVOID_SYS";
+            case RIL_REQUEST_QUERY_CDMA_NETWORK_INFO: return "RIL_REQUEST_QUERY_CDMA_NETWORK_INFO";
+            case RIL_REQUEST_GET_LOCAL_INFO: return "RIL_REQUEST_GET_LOCAL_INFO";
+            case RIL_REQUEST_UTK_REFRESH: return "RIL_REQUEST_UTK_REFRESH";
+            case RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS:
+                return "RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS";
+            case RIL_REQUEST_QUERY_NETWORK_REGISTRATION:
+                return "RIL_REQUEST_QUERY_NETWORK_REGISTRATION";
+            case RIL_REQUEST_AGPS_TCP_CONNIND: return "RIL_REQUEST_AGPS_TCP_CONNIND";
+            case RIL_REQUEST_AGPS_SET_MPC_IPPORT: return "RIL_REQUEST_AGPS_SET_MPC_IPPORT";
+            case RIL_REQUEST_AGPS_GET_MPC_IPPORT: return "RIL_REQUEST_AGPS_GET_MPC_IPPORT";
+            case RIL_REQUEST_SET_MEID: return "RIL_REQUEST_SET_MEID";
+            case RIL_REQUEST_SET_ETS_DEV: return "RIL_REQUEST_SET_ETS_DEV";
+            case RIL_REQUEST_WRITE_MDN: return "RIL_REQUEST_WRITE_MDN";
+            case RIL_REQUEST_SET_VIA_TRM: return "RIL_REQUEST_SET_VIA_TRM";
+            case RIL_REQUEST_SET_ARSI_THRESHOLD: return "RIL_REQUEST_SET_ARSI_THRESHOLD";
+            case RIL_REQUEST_QUERY_UTK_MENU_FROM_MD: return "RIL_REQUEST_QUERY_UTK_MENU_FROM_MD";
+            case RIL_REQUEST_QUERY_STK_MENU_FROM_MD: return "RIL_REQUEST_QUERY_STK_MENU_FROM_MD";
+            /* M: C2K part end */
+            // M: [C2K][MD IRAT]RIL
+            case RIL_REQUEST_SET_ACTIVE_PS_SLOT: return "RIL_REQUEST_SET_ACTIVE_PS_SLOT";
+            case RIL_REQUEST_CONFIRM_INTER_3GPP_IRAT_CHANGE:
+                return "RIL_REQUEST_CONFIRM_INTER_3GPP_IRAT_CHANGE";
+            case RIL_REQUEST_DEACTIVATE_LINK_DOWN_PDN:
+                return "RIL_REQUEST_DEACTIVATE_LINK_DOWN_PDN";
+            /// @}
+            /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @{
+            case RIL_REQUEST_SET_SVLTE_RAT_MODE: return "RIL_REQUEST_SET_SVLTE_RAT_MODE";
+            /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @}
+
+            /// M: [C2K][IR] Support SVLTE IR feature. @{
+            case RIL_REQUEST_SET_REG_SUSPEND_ENABLED: return "RIL_REQUEST_SET_REG_SUSPEND_ENABLED";
+            case RIL_REQUEST_RESUME_REGISTRATION: return "RIL_REQUEST_RESUME_REGISTRATION";
+            case RIL_REQUEST_SET_REG_SUSPEND_ENABLED_CDMA:
+                return "RIL_REQUEST_SET_REG_SUSPEND_ENABLED_CDMA";
+            case RIL_REQUEST_RESUME_REGISTRATION_CDMA:
+                return "RIL_REQUEST_RESUME_REGISTRATION_CDMA";
+            case RIL_REQUEST_CONFIG_EVDO_MODE:
+                return "RIL_REQUEST_CONFIG_EVDO_MODE";
+            /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+            case RIL_REQUEST_SET_STK_UTK_MODE:
+                return "RIL_REQUEST_SET_STK_UTK_MODE";
+
+            // M: Notify RILJ that call fade happened
+            case RIL_UNSOL_CDMA_SIGNAL_FADE:
+                return "RIL_UNSOL_CDMA_SIGNAL_FADE";
+            // M: Notify RILJ that the AT+EFNM was received
+            case RIL_UNSOL_CDMA_TONE_SIGNALS:
+                return "RIL_UNSOL_CDMA_TONE_SIGNALS";
+
+            case RIL_REQUEST_SWITCH_ANTENNA: return "RIL_REQUEST_SWITCH_ANTENNA";
+            /// M: IMS ViLTE feature. @{
+            case RIL_REQUEST_VIDEO_CALL_ACCEPT: return "RIL_REQUEST_VIDEO_CALL_ACCEPT";
+            /// @}
+            default: return "<unknown request>";
+        }
+
+    }
+
+    static String retToString(int req, Object ret) {
+        if (ret == null) return "";
+
+        StringBuilder sb;
+        String s;
+        int length;
+        if (ret instanceof int[]) {
+            int[] intArray = (int[]) ret;
+            length = intArray.length;
+            sb = new StringBuilder("{");
+            if (length > 0) {
+                int i = 0;
+                sb.append(intArray[i++]);
+                while (i < length) {
+                    sb.append(", ").append(intArray[i++]);
+                }
+            }
+            sb.append("}");
+            s = sb.toString();
+        } else if (ret instanceof String[]) {
+            String[] strings = (String[]) ret;
+            length = strings.length;
+            sb = new StringBuilder("{");
+            if (length > 0) {
+                int i = 0;
+                sb.append(strings[i++]);
+                while (i < length) {
+                    sb.append(", ").append(strings[i++]);
+                }
+            }
+            sb.append("}");
+            s = sb.toString();
+        } else {
+            s = ret.toString();
+        }
+        return s;
+    }
+
+    private void riljLog(String msg) {
+        Rlog.d(IMS_RILA_LOG_TAG, msg
+                + "");
+    }
+
+    private void riljLogv(String msg) {
+        Rlog.v(IMS_RILA_LOG_TAG, msg
+                + "");
+    }
+
+    private void unsljLog(int response) {
+        riljLog("[UNSL]< " + responseToString(response));
+    }
+
+    private void unsljLogMore(int response, String more) {
+        riljLog("[UNSL]< " + responseToString(response) + " " + more);
+    }
+
+    private void unsljLogRet(int response, Object ret) {
+        riljLog("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
+    }
+
+    private void unsljLogvRet(int response, Object ret) {
+        riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
+    }
+
+    private void processUnsolicited(Parcel p) {
+        Rlog.i(IMS_RILA_LOG_TAG, " IMS processUnsolicited !!");
+                int response;
+                Object ret;
+                response = p.readInt();
+                try { switch(response) {
+                    case RIL_UNSOL_CALL_INFO_INDICATION : ret = responseStrings(p); break;
+                    case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: ret =  responseVoid(p); break;
+                    case RIL_UNSOL_IMS_REGISTRATION_INFO: ret = responseInts(p); break;
+                    case RIL_UNSOL_INCOMING_CALL_INDICATION: ret = responseStrings(p); break;
+                    case RIL_UNSOL_RINGBACK_TONE: ret = responseInts(p); break;
+                    case RIL_UNSOL_CIPHER_INDICATION: ret = responseStrings(p); break;
+                    case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_SUPPORT: ret = responseInts(p); break;
+                    case RIL_UNSOL_ECONF_SRVCC_INDICATION: ret = responseInts(p); break;
+                    case RIL_UNSOL_ECONF_RESULT_INDICATION: ret = responseStrings(p); break;
+                    case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO: ret = responseInts(p); break;
+                    case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION:ret = responseInts(p); break;
+                    case RIL_UNSOL_SPEECH_CODEC_INFO: ret =  responseInts(p); break;
+                    case RIL_UNSOL_CALL_RING: ret =  responseCallRing(p); break;
+                    case RIL_UNSOL_SUPP_SVC_NOTIFICATION: ret = responseSuppServiceNotification(p); break;
+                    case RIL_UNSOL_SRVCC_STATE_NOTIFY: ret = responseInts(p); break;
+                    case RIL_UNSOL_SIP_CALL_PROGRESS_INDICATOR: ret = responseInts(p); break;
+                    // IMS
+                    case RIL_UNSOL_IMS_ENABLE_DONE: ret = responseVoid(p); break;
+                    case RIL_UNSOL_IMS_DISABLE_DONE: ret = responseVoid(p); break;
+                    case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: ret =  responseVoid(p); break;
+                    // IMS
+                    case RIL_UNSOL_IMS_ENABLE_START: ret = responseVoid(p); break;
+                    case RIL_UNSOL_IMS_DISABLE_START: ret = responseVoid(p); break;
+                    // For ViLTE related URC.
+                    case RIL_UNSOL_CALLMOD_CHANGE_INDICATOR: ret = responseStrings(p); break;
+                    case RIL_UNSOL_VIDEO_CAPABILITY_INDICATOR: ret = responseStrings(p); break;
+                    default:
+                        throw new RuntimeException("Unrecognized unsol response: " + response);
+                    //break; (implied)
+                } } catch (Throwable tr) {
+                    Rlog.e(IMS_RILA_LOG_TAG, "Exception processing unsol response: " + response +
+                        "Exception:" + tr.toString());
+                    return;
+                }
+
+                switch(response) {
+                    case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
+                        /* has bonus radio state int */
+                        RadioState newState = getRadioStateFromInt(p.readInt());
+                        if (IMS_RILA_LOGD) unsljLogMore(response, newState.toString());
+
+                        switchToRadioState(newState);
+                    break;
+                    //For updating call mode and pau information.
+                    case RIL_UNSOL_CALL_INFO_INDICATION:
+                        if (ret == null) {
+                            break;
+                        }
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mCallInfoRegistrants != null) {
+                            mCallInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+
+                        String[] callInfo = (String[]) ret;
+
+                        if (callInfo[0] == null || callInfo[1] == null) {
+                            riljLog("RIL_UNSOL_CALL_INFO_INDICATION something wrong");
+                            break;
+                        }
+
+                        int msgType = Integer.parseInt(callInfo[1]);
+                        int callId = Integer.parseInt(callInfo[0]);
+                        int callMode = INVALID_CALL_MODE;
+                        boolean isConferenceCall = false;
+                        if ((callInfo[5] != null) && (!callInfo[5].equals(""))) {
+                            callMode = Integer.parseInt(callInfo[5]);
+                        }
+
+                        if (callMode == IMS_VOICE_CONF ||
+                                callMode == IMS_VIDEO_CONF ||
+                                callMode == IMS_VOICE_CONF_PARTS ||
+                                callMode == IMS_VIDEO_CONF_PARTS) {
+                            isConferenceCall = true;
+                        }
+
+                        ImsCallInfo imsCallInfo;
+                        switch(msgType) {
+                            case 0:   //record callstring to mCallConnections for MT case.
+                                {
+                                    ImsCallInfo.State state = ImsCallInfo.State.INCOMING;
+                                    mCallConnections.put(callInfo[0],
+                                            new ImsCallInfo(callInfo[0], callInfo[6],
+                                                    isConferenceCall, state));
+                                    break;
+                                }
+                            case 130:   //record callstring to mCallConnections for MO case.
+                                {
+                                    ImsCallInfo.State state = ImsCallInfo.State.ALERTING;
+                                    mCallConnections.put(callInfo[0],
+                                            new ImsCallInfo(callInfo[0], callInfo[6],
+                                                    isConferenceCall, state));
+                                    break;
+                                }
+                            case 2:   //record callstring to mCallConnections for MO case.
+                                {
+                                    imsCallInfo = mCallConnections.get(callInfo[0]);
+                                    imsCallInfo.mIsConference = isConferenceCall;
+                                    mCallConnections.put(callInfo[0], imsCallInfo);
+                                    break;
+                                }
+                            case 131:
+                                {
+                                    imsCallInfo = mCallConnections.get(callInfo[0]);
+                                    imsCallInfo.mState = ImsCallInfo.State.HOLDING;
+                                    imsCallInfo.mIsConference = isConferenceCall;
+                                    mCallConnections.put(callInfo[0], imsCallInfo);
+                                    break;
+                                }
+                            case 132:
+                                {
+                                    imsCallInfo = mCallConnections.get(callInfo[0]);
+                                    imsCallInfo.mState = ImsCallInfo.State.ACTIVE;
+                                    imsCallInfo.mIsConference = isConferenceCall;
+                                    mCallConnections.put(callInfo[0], imsCallInfo);
+                                    break;
+                                }
+                            case 133: //clear callstring  when call is disconnected.
+                                mCallConnections.remove(callInfo[0]);
+                                break;
+                            default:
+                                break;
+                        }
+                        break;
+                    case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mCallStateRegistrants != null) {
+                            mCallStateRegistrants
+                                    .notifyRegistrants(new AsyncResult(null, null, null));
+                        }
+                        break;
+                    case RIL_UNSOL_IMS_REGISTRATION_INFO:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mImsRegistrationInfoRegistrants != null) {
+                            mImsRegistrationInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_INCOMING_CALL_INDICATION:
+                        if (IMS_RILA_LOGD) unsljLogvRet(response, ret);
+                        if (mIncomingCallIndicationRegistrant != null) {
+                            mIncomingCallIndicationRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_RINGBACK_TONE:
+                        if (IMS_RILA_LOGD) unsljLogvRet(response, ret);
+                        if (mRingbackToneRegistrants != null) {
+                            boolean playtone = (((int[]) ret)[0] == 1);
+                            mRingbackToneRegistrants.notifyRegistrants(
+                                                new AsyncResult(null, playtone, null));
+                        }
+                        break;
+                    case RIL_UNSOL_CIPHER_INDICATION:
+                        if (IMS_RILA_LOGD) unsljLogvRet(response, ret);
+
+                        int simCipherStatus = Integer.parseInt(((String[]) ret)[0]);
+                        int sessionStatus = Integer.parseInt(((String[]) ret)[1]);
+                        int csStatus = Integer.parseInt(((String[]) ret)[2]);
+                        int psStatus = Integer.parseInt(((String[]) ret)[3]);
+
+                        riljLog("RIL_UNSOL_CIPHER_INDICATION :" + simCipherStatus + " " + sessionStatus + " " + csStatus + " " + psStatus);
+
+                        int[] cipherResult = new int[3];
+
+                        cipherResult[0] = simCipherStatus;
+                        cipherResult[1] = csStatus;
+                        cipherResult[2] = psStatus;
+
+                        if (mCipherIndicationRegistrant != null) {
+                            mCipherIndicationRegistrant.notifyRegistrants(
+                                new AsyncResult(null, cipherResult, null));
+                        }
+                        break;
+                    case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_SUPPORT:
+                        if (IMS_RILA_LOGD) unsljLogvRet(response, ret);
+                        if (mEpsNetworkFeatureSupportRegistrants != null) {
+                            mEpsNetworkFeatureSupportRegistrants.notifyRegistrants(
+                                                new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    /// M: IMS feature. @{
+                    //For updating call ids for conference call after SRVCC is done.
+                    case RIL_UNSOL_ECONF_SRVCC_INDICATION:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mEconfSrvccRegistrants != null) {
+                            mEconfSrvccRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+
+                    //For updating conference call merged/added result.
+                    case RIL_UNSOL_ECONF_RESULT_INDICATION:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mEconfResultRegistrants != null) {
+                             riljLog("Notify ECONF result");
+                             String[] econfResult = (String[]) ret;
+                             riljLog("ECONF result = " + econfResult[3]);
+                             mEconfResultRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mEpsNetworkFeatureInfoRegistrants != null) {
+                           mEpsNetworkFeatureInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+
+                    case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mSrvccHandoverInfoIndicationRegistrants != null) {
+                            mSrvccHandoverInfoIndicationRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    /// @}
+                    case RIL_UNSOL_SPEECH_CODEC_INFO:
+                        if (IMS_RILA_LOGD) unsljLogvRet(response, ret);
+
+                        if (mSpeechCodecInfoRegistrant != null) {
+                            mSpeechCodecInfoRegistrant.notifyRegistrant(
+                                new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_CALL_RING:
+                        Rlog.d(IMS_RILA_LOG_TAG, "IMS: receive RIL_UNSOL_CALL_RING");
+                        if (IMS_RILA_LOGD) unsljLogRet(response, ret);
+
+                        if (mRingRegistrant != null) {
+                            mRingRegistrant.notifyRegistrant(
+                                    new AsyncResult (null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
+                        if (IMS_RILA_LOGD) unsljLogRet(response, ret);
+                        if (mSsnRegistrant != null) {
+                            mSsnRegistrant.notifyRegistrant(
+                                                new AsyncResult (null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_SRVCC_STATE_NOTIFY:
+                        if (IMS_RILA_LOGD) unsljLogRet(response, ret);
+                        if (mSrvccStateRegistrants != null) {
+                            mSrvccStateRegistrants
+                                    .notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_SIP_CALL_PROGRESS_INDICATOR:
+                        if (IMS_RILA_LOGD) unsljLogRet(response, ret);
+                        if (mCallProgressIndicatorRegistrants != null) {
+                            mCallProgressIndicatorRegistrants
+                                    .notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_IMS_ENABLE_DONE:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mImsEnableDoneRegistrants != null) {
+                            mImsEnableDoneRegistrants.notifyRegistrants();
+                        }
+                        break;
+                    case RIL_UNSOL_IMS_DISABLE_DONE:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mImsDisableDoneRegistrants != null) {
+                            mImsDisableDoneRegistrants.notifyRegistrants();
+                        }
+                        break;
+                    case RIL_UNSOL_IMS_ENABLE_START:
+                        if (IMS_RILA_LOGD) {
+                            unsljLog(response);
+                        }
+                        if (mImsEnableStartRegistrants != null) {
+                            mImsEnableStartRegistrants.notifyRegistrants();
+                        }
+                        break;
+                    case RIL_UNSOL_IMS_DISABLE_START:
+                        if (IMS_RILA_LOGD) {
+                            unsljLog(response);
+                        }
+                        if (mImsDisableStartRegistrants != null) {
+                            mImsDisableStartRegistrants.notifyRegistrants();
+                        }
+                        break;
+                    case RIL_UNSOL_CALLMOD_CHANGE_INDICATOR:
+                        if (IMS_RILA_LOGD) {
+                            unsljLogRet(response, ret);
+                        }
+                        if (mCallModeChangeIndicatorRegistrants != null) {
+                            mCallModeChangeIndicatorRegistrants
+                                    .notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_VIDEO_CAPABILITY_INDICATOR:
+                        if (IMS_RILA_LOGD) {
+                            unsljLogRet(response, ret);
+                        }
+                        if (mVideoCapabilityIndicatorRegistrants != null) {
+                            mVideoCapabilityIndicatorRegistrants
+                                    .notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    default:
+                        break;
+                }
+
+    }
+
+    private synchronized String executeCommandResponse(String atCmdLine) {
+        String atCmdResult = "";
+        String cmd[] = new String[2];
+        cmd[0] = atCmdLine;
+        cmd[1] = "";
+
+        Rlog.d(IMS_RILA_LOG_TAG, "IMS: invokeOemRilRequestRaw() ");
+
+        try {
+            invokeOemRilRequestStrings(cmd,
+                mHandler.obtainMessage(EVENT_AT_CMD_DONE));
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+        }
+        return atCmdResult;
+    }
+
+    private void handleAtCmdResponseAndDial(AsyncResult ar) {
+        // Receive OEM Hook Raw response, then dial
+        if (mMoCall == null && mConferenceCallDialInfo == null) {
+            Rlog.e(IMS_RILA_LOG_TAG, "IMS: mMoCall is null when calling");
+            return;
+        }
+
+
+        if (mConferenceCallDialInfo != null) {
+            conferenceDial(mConferenceCallDialInfo.mParticipants,
+                    mConferenceCallDialInfo.mClirMode,
+                    mConferenceCallDialInfo.mIsVideoCall,
+                    mConferenceCallDialInfo.mResult);
+        } else {
+            if (mMoCall.mIsVideoCall) {
+                vtDial(mMoCall.mCallee, mMoCall.mClirMode, null, mMoCall.mResult);
+            } else {
+                if (mMoCall.mIsEmergency) {
+                    int serviceCategory =
+                        PhoneNumberUtils.getServiceCategoryFromEcc(mMoCall.mCallee);
+                    setEccServiceCategory(serviceCategory);
+                    emergencyDial(mMoCall.mCallee, mMoCall.mClirMode,
+                        null, mMoCall.mResult);
+                } else {
+                    dial(mMoCall.mCallee, mMoCall.mClirMode, mMoCall.mResult);
+                }
+            }
+        }
+
+        // Clear MOCall or ConferenceCall information
+        mMoCall = null;
+        mConferenceCallDialInfo = null;
+    }
+
+    /// M: CC053: MoMS [Mobile Managerment] @{
+    // 3. Permission Control for Conference call
+    /**
+    * To check sub-permission for MoMS before using API.
+    *
+    * @param subPermission  The permission to be checked.
+    *
+    * @return Return true if the permission is granted else return false.
+    */
+    private boolean checkMoMSSubPermission(String subPermission) {
+
+        Rlog.d(IMS_RILA_LOG_TAG, "checkMoMSSubPermission(\"" + subPermission + "\"): no-op!");
+        /*
+        try {
+            IMobileManagerService mMobileManager;
+            IBinder binder = ServiceManager.getService(Context.MOBILE_SERVICE);
+            mMobileManager = IMobileManagerService.Stub.asInterface(binder);
+            int result = mMobileManager.checkPermission(subPermission, Binder.getCallingUid());
+            if (result != PackageManager.PERMISSION_GRANTED) {
+                riljLog("[Error]Subpermission is not granted!!");
+                return false;
+            }
+        } catch (Exception e) {
+            riljLog("[Error]Failed to chcek permission: " +  subPermission);
+            return false;
+        }
+        */
+
+        return true;
+    }
+    /// @}
+
+    /// M: CC012: DTMF request special handling @{
+    /*
+     * to protect modem status we need to avoid two case :
+     * 1. DTMF start -> CHLD request -> DTMF stop
+     * 2. CHLD request -> DTMF request
+     */
+    private void handleChldRelatedRequest(RILRequest rr) {
+        synchronized (mDtmfReqQueue) {
+            int queueSize = mDtmfReqQueue.size();
+            int i, j;
+            if (queueSize > 0) {
+                RILRequest rr2 = mDtmfReqQueue.get();
+                if (rr2.mRequest == RIL_REQUEST_DTMF_START) {
+                    // need to send the STOP command
+                    if (IMS_RILA_LOGD) {
+                        riljLog("DTMF queue isn't 0, send stop dtmf and pending switch");
+                    }
+                    if (queueSize > 1) {
+                        j = 2;
+                    } else {
+                        // need to create a new STOP command
+                        j = 1;
+                    }
+                    if (IMS_RILA_LOGD) riljLog("queue size  " + mDtmfReqQueue.size());
+
+                    for (i = queueSize - 1; i >= j; i--) {
+                        mDtmfReqQueue.remove(i);
+                    }
+                    if (IMS_RILA_LOGD) {
+                        riljLog("queue size  after " + mDtmfReqQueue.size());
+                    }
+                    if (mDtmfReqQueue.size() == 1) {
+                        // only start command, we need to add stop command
+                        RILRequest rr3 = RILRequest.obtain(RIL_REQUEST_DTMF_STOP, null);
+                        if (IMS_RILA_LOGD) riljLog("add dummy stop dtmf request");
+                        mDtmfReqQueue.stop();
+                        mDtmfReqQueue.add(rr3);
+                    }
+                }
+                else {
+                    // first request is STOP, just remove it and send switch
+                    if (IMS_RILA_LOGD) {
+                        riljLog("DTMF queue isn't 0, first request is STOP, penging switch");
+                    }
+                    j = 1;
+                    for (i = queueSize - 1; i >= j; i--) {
+                        mDtmfReqQueue.remove(i);
+                    }
+                }
+                mDtmfReqQueue.setPendingRequest(rr);
+            } else {
+                if (IMS_RILA_LOGD) riljLog("DTMF queue is 0, send switch Immediately");
+                mDtmfReqQueue.setSendChldRequest();
+                send(rr);
+            }
+        }
+    }
+    /// @}
+
+    public void
+    dial (String address, int clirMode, Message result) {
+        dial(address, clirMode, null, result);
+    }
+
+    public void
+    dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        if (!PhoneNumberUtils.isUriNumber(address)) {
+           RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
+
+           rr.mParcel.writeString(address);
+           rr.mParcel.writeInt(clirMode);
+
+           if (uusInfo == null) {
+              rr.mParcel.writeInt(0); // UUS information is absent
+           } else {
+              rr.mParcel.writeInt(1); // UUS information is present
+              rr.mParcel.writeInt(uusInfo.getType());
+              rr.mParcel.writeInt(uusInfo.getDcs());
+              rr.mParcel.writeByteArray(uusInfo.getUserData());
+           }
+
+           if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+           send(rr);
+        } else {
+           RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL_WITH_SIP_URI, result);
+
+           rr.mParcel.writeString(address);
+           if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+           send(rr);
+        }
+    }
+
+    public void
+    emergencyDial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_EMERGENCY_DIAL, result);
+
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeInt(clirMode);
+        rr.mParcel.writeInt(0); // UUS information is absent
+
+        if (uusInfo == null) {
+            rr.mParcel.writeInt(0); // UUS information is absent
+        } else {
+            rr.mParcel.writeInt(1); // UUS information is present
+            rr.mParcel.writeInt(uusInfo.getType());
+            rr.mParcel.writeInt(uusInfo.getDcs());
+            rr.mParcel.writeByteArray(uusInfo.getUserData());
+        }
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /* M: IMS VoLTE conference dial feature start*/
+    /**
+     * Dial conference call.
+     * @param participants participants' dailing number.
+     * @param clirMode indication to present the dialing number or not.
+     * @param isVideoCall indicate the call is belong to video call or voice call.
+     * @param result the command result.
+     */
+    public void
+    conferenceDial(String[] participants, int clirMode, boolean isVideoCall, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CONFERENCE_DIAL, result);
+
+        int numberOfParticipants = participants.length;
+        /* numberOfStrings is including
+         * 1. isvideoCall
+         * 2. numberofparticipants
+         * 3. participants numbers
+         * 4. clirmod
+         */
+        int numberOfStrings = 1 + 1 + numberOfParticipants + 1 ;
+        List<String> participantList = Arrays.asList(participants);
+
+        if (IMS_RILA_LOGD) {
+            Rlog.d(IMS_RILA_LOG_TAG, "conferenceDial: numberOfParticipants "
+                    + numberOfParticipants + "numberOfStrings:" + numberOfStrings);
+        }
+
+        rr.mParcel.writeInt(numberOfStrings);
+
+        if (isVideoCall) {
+            rr.mParcel.writeString(Integer.toString(1));
+        } else {
+            rr.mParcel.writeString(Integer.toString(0));
+        }
+
+        rr.mParcel.writeString(Integer.toString(numberOfParticipants));
+
+        for (String dialNumber : participantList) {
+            rr.mParcel.writeString(dialNumber);
+            if (IMS_RILA_LOGD) {
+                Rlog.d(IMS_RILA_LOG_TAG, "conferenceDial: dialnumber " + dialNumber);
+            }
+        }
+        rr.mParcel.writeString(Integer.toString(clirMode));
+        if (IMS_RILA_LOGD) {
+            Rlog.d(IMS_RILA_LOG_TAG, "conferenceDial: clirMode " + clirMode);
+        }
+
+        if (IMS_RILA_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+
+    }
+    /* IMS VoLTE conference dial feature end*/
+
+    public void setEccServiceCategory(int serviceCategory) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_ECC_SERVICE_CATEGORY, null);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(serviceCategory);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+            + " " + serviceCategory);
+
+        send(rr);
+    }
+
+    /// M: For 3G VT only @{
+    public void
+    vtDial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_VT_DIAL, result);
+
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeInt(clirMode);
+
+        if (uusInfo == null) {
+            rr.mParcel.writeInt(0); // UUS information is absent
+        } else {
+            rr.mParcel.writeInt(1); // UUS information is present
+            rr.mParcel.writeInt(uusInfo.getType());
+            rr.mParcel.writeInt(uusInfo.getDcs());
+            rr.mParcel.writeByteArray(uusInfo.getUserData());
+        }
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void
+    acceptVtCallWithVoiceOnly(int callId, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_VOICE_ACCEPT, result);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " +
+                requestToString(rr.mRequest) + " " + callId);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callId);
+
+        send(rr);
+    }
+
+    public void replaceVtCall(int index, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_REPLACE_VT_CALL, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(index);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+    /// @}
+
+    private void switchToRadioState(RadioState newState) {
+        setRadioState(newState);
+    }
+
+    private RadioState getRadioStateFromInt(int stateInt) {
+        RadioState state;
+
+        /* RIL_RadioState ril.h */
+        switch(stateInt) {
+            case 0: state = RadioState.RADIO_OFF; break;
+            case 1: state = RadioState.RADIO_UNAVAILABLE; break;
+            case 10: state = RadioState.RADIO_ON; break;
+
+            default:
+                throw new RuntimeException(
+                            "Unrecognized IMS_RIL_RadioState: " + stateInt);
+        }
+        return state;
+    }
+
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsService.java b/packages/Ims/src/com/mediatek/ims/ImsService.java
new file mode 100644
index 0000000..865c9ee
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsService.java
@@ -0,0 +1,902 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.database.ContentObserver;
+import android.net.Uri;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.provider.Settings;
+
+import android.telephony.Rlog;
+import android.telephony.ServiceState;
+
+import com.android.ims.ImsCallProfile;
+import com.android.ims.ImsConfig;
+import com.android.ims.ImsManager;
+import com.android.ims.ImsReasonInfo;
+import com.android.ims.ImsServiceClass;
+import com.android.ims.internal.IImsRegistrationListener;
+import com.android.ims.internal.IImsCallSession;
+import com.android.ims.internal.IImsCallSessionListener;
+import com.android.ims.internal.IImsEcbm;
+import com.android.ims.internal.IImsUt;
+import com.android.ims.internal.IImsConfig;
+import com.android.ims.internal.IImsService;
+
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyIntents;
+
+import com.mediatek.ims.ImsAdapter;
+import com.mediatek.ims.ImsConfigStub;
+import com.mediatek.ims.WfcReasonInfo;
+import com.mediatek.internal.telephony.RadioCapabilitySwitchUtil;
+import com.mediatek.wfo.DisconnectCause;
+import com.mediatek.wfo.IWifiOffloadService;
+import com.mediatek.wfo.WifiOffloadManager;
+
+public class ImsService extends IImsService.Stub {
+    private static final String LOG_TAG = "ImsService";
+    private static final boolean DBG = true;
+    private static final boolean VDBG = false; // STOPSHIP if true
+
+    private ImsAdapter mImsAdapter = null;
+    private ImsRILAdapter  mImsRILAdapter = null;
+    private IImsCallSession mPendingMT = null;
+    private Context mContext;
+
+    private static IWifiOffloadService sWifiOffloadService = null;
+    private IWifiOffloadServiceDeathRecipient mDeathRecipient =
+            new IWifiOffloadServiceDeathRecipient();
+
+    private static ImsConfigStub sImsConfig = null;
+    private static ImsUtStub sImsUtStub = null;
+
+    private final Handler mHandler;
+    private IImsRegistrationListener mListener = null;
+    private int mImsRegInfo = ServiceState.STATE_POWER_OFF;
+    private int mImsExtInfo = 0;
+    private int mServiceId = 0;
+    private int mImsState = PhoneConstants.IMS_STATE_DISABLED;
+    private int mActivePhoneId = 0;
+    private int mRegErrorCode = ImsReasonInfo.CODE_UNSPECIFIED;
+    private int mRAN = WifiOffloadManager.RAN_TYPE_MOBILE_3GPP;
+
+    //***** Event Constants
+    private static final int EVENT_IMS_REGISTRATION_INFO = 1;
+    protected static final int EVENT_RADIO_NOT_AVAILABLE    = 2;
+    protected static final int EVENT_SET_IMS_ENABLED_DONE   = 3;
+    protected static final int EVENT_SET_IMS_DISABLE_DONE   = 4;
+    protected static final int EVENT_IMS_DISABLED_URC   = 5;
+    private static final int EVENT_VIRTUAL_SIM_ON = 6;
+    protected static final int EVENT_INCOMING_CALL_INDICATION = 7;
+    protected static final int EVENT_CALL_INFO_INDICATION = 8;
+    protected static final int EVENT_CALL_RING = 9;
+    protected static final int EVENT_IMS_ENABLING_URC   = 10;
+    protected static final int EVENT_IMS_ENABLED_URC   = 11;
+    protected static final int EVENT_IMS_DISABLING_URC   = 12;
+    ///M : WFC @{
+    protected static final int EVENT_SIP_CODE_INDICATION = 13;
+    /// @}
+
+    private static final int IMS_ALLOW_INCOMING_CALL_INDICATION = 0;
+    private static final int IMS_DISALLOW_INCOMING_CALL_INDICATION = 1;
+
+    //***** IMS Feature Support
+    private static final int IMS_VOICE_OVER_LTE = 1;
+    private static final int IMS_RCS_OVER_LTE = 2;
+    private static final int IMS_SMS_OVER_LTE = 4;
+    private static final int IMS_VIDEO_OVER_LTE = 8;
+    private static final int IMS_VOICE_OVER_WIFI = 16;
+
+    //Refer to ImsConfig FeatureConstants
+    private static final int IMS_MAX_FEATURE_SUPPORT_SIZE = 4;
+
+    ///M : WFC @{
+    private ImsNotificationController mNotificationController = null;
+    /// @}
+
+    /** events id definition */
+    /// M: Simulate IMS Registration @{
+    private boolean mImsRegistry = false;
+    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            ///M : WFC @{
+            if ("ACTION_IMS_SIMULATE".equals(intent.getAction())){
+            /// @}
+                mImsRegistry = intent.getBooleanExtra("registry", false);
+                Rlog.w(LOG_TAG, "Simulate IMS Registration: " + mImsRegistry);
+                int[] result = new int[] {
+                    (mImsRegistry ? 1 : 0),
+                    15,
+                    mActivePhoneId};
+                AsyncResult ar = new AsyncResult(null, result, null);
+                mHandler.sendMessage(mHandler.obtainMessage(EVENT_IMS_REGISTRATION_INFO, ar));
+            } else if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {
+                if (sWifiOffloadService == null){
+                    //first use wifioffloadservice and new the object.
+                    checkAndBindWifiOffloadService();
+                }
+                if (sWifiOffloadService != null) {
+                    try {
+                        sWifiOffloadService.registerForHandoverEvent(
+                                createWifiOffloadListenerProxy());
+                    } catch (RemoteException e) {
+                        Rlog.e(LOG_TAG, "can't register handover event");
+                    }
+                } else {
+                    Rlog.e(LOG_TAG, "can't get WifiOffloadService");
+                }
+            }
+        }
+    };
+    /// @}
+
+    public ImsService(Context context) {
+        mImsAdapter = new ImsAdapter(context);
+        mImsRILAdapter = new ImsRILAdapter(context);
+
+        Rlog.d(LOG_TAG, " mImsRILAdapter= " + mImsRILAdapter);
+
+        mContext = context;
+        mHandler = new MyHandler();
+
+        if (sImsConfig == null) {
+            sImsConfig = new ImsConfigStub(mContext);
+        }
+
+        mImsRILAdapter.registerForImsRegistrationInfo(mHandler, EVENT_IMS_REGISTRATION_INFO, null);
+        mImsRILAdapter.registerForImsEnableStart(mHandler, EVENT_IMS_ENABLING_URC, null);
+        mImsRILAdapter.registerForImsEnableComplete(mHandler, EVENT_IMS_ENABLED_URC, null);
+        mImsRILAdapter.registerForImsDisableStart(mHandler, EVENT_IMS_DISABLING_URC, null);
+        mImsRILAdapter.registerForImsDisableComplete(mHandler, EVENT_IMS_DISABLED_URC, null);
+        mImsRILAdapter.setOnIncomingCallIndication(mHandler, EVENT_INCOMING_CALL_INDICATION, null);
+        mImsRILAdapter.setOnCallRing(mHandler, EVENT_CALL_RING, null);
+        mImsRILAdapter.registerForCallProgressIndicator(mHandler, EVENT_SIP_CODE_INDICATION, null);
+        /// register for radio state changed
+        mImsRILAdapter.registerForNotAvailable(mHandler, EVENT_RADIO_NOT_AVAILABLE, null);
+        /// M: Simulate IMS Registration @{
+        final IntentFilter filter = new IntentFilter();
+        filter.addAction("ACTION_IMS_SIMULATE");
+        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
+
+        if (SystemProperties.get("ro.mtk_wfc_support").equals("1")) {
+            /* Register for Content Observer */
+            // TODO: where to unregister it: in close()??
+            registerForWfcPreferenceChange(mHandler);
+            /* Send wfc preference info to Modem */
+            setWfcProfileInfo();
+            mNotificationController = new ImsNotificationController(context, 1);
+            Rlog.d(LOG_TAG, "noticontroller created" + mNotificationController);
+        }
+
+        context.registerReceiver(mBroadcastReceiver, filter);
+
+        if (SystemProperties.getInt("ro.mtk.volte.enable", 0)==1) {
+            turnOnIms(RadioCapabilitySwitchUtil.getMainCapabilityPhoneId());
+        }else {
+            turnOffIms(RadioCapabilitySwitchUtil.getMainCapabilityPhoneId());
+        }
+        /// @}
+    }
+
+    public void enableImsAdapter() {
+        mImsAdapter.enableImsAdapter();
+    }
+
+    public void disableImsAdapter(boolean isNormalDisable) {
+        mImsAdapter.disableImsAdapter(isNormalDisable);
+        mImsState = PhoneConstants.IMS_STATE_DISABLED;
+    }
+
+    @Override
+    public boolean isConnected(int serviceId, int serviceType, int callType) {
+        /* temp solution: always return ImsAdapter if enable */
+        return mImsAdapter.getImsAdapterEnable();
+    }
+
+    @Override
+    public int open(int phoneId, int serviceClass, PendingIntent incomingCallIntent,
+            IImsRegistrationListener listener) {
+        if (mListener != null) {
+            Rlog.e(LOG_TAG, "IMS: it did not close IMS servide before open() !!");
+        }
+        setRegistrationListener(1, listener);
+        return 1;
+    }
+
+    @Override
+    public void close(int serviceId) {
+        // remove registration listener
+        mListener = null;
+    }
+
+    @Override
+    public boolean isOpened(int serviceId) {
+        /* temp solution: always return ImsAdapter if enable */
+        return mImsAdapter.getImsAdapterEnable();
+    }
+
+    /**
+     * Used for turning on IMS when its in OFF state.
+     */
+
+    @Override
+    public void turnOnIms(int phoneId) {
+        Rlog.d(LOG_TAG, "turnOnIms, mActivePhoneId = " + mActivePhoneId +
+            " phoneId = " + phoneId);
+        phoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+        Rlog.d(LOG_TAG, "turnOnIms, MainCapabilityPhoneId = " + phoneId);
+
+        boolean isPhoneIdChanged = false;
+        if (mActivePhoneId != phoneId) {
+            mActivePhoneId = phoneId;
+            isPhoneIdChanged = true;
+        }
+        mImsRILAdapter.turnOnIms(mHandler.obtainMessage(EVENT_SET_IMS_ENABLED_DONE));
+        mImsState = PhoneConstants.IMS_STATE_ENABLING;
+    }
+
+    /**
+     * Used for turning off IMS when its in ON state.
+     * When IMS is OFF, device will behave as CSFB'ed.
+     */
+    @Override
+    public void turnOffIms(int phoneId) {
+        Rlog.d(LOG_TAG, "turnOffIms, mActivePhoneId = " + mActivePhoneId +
+            " phoneId = " + phoneId);
+        phoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+        Rlog.d(LOG_TAG, "turnOffIms, MainCapabilityPhoneId = " + phoneId);
+
+        boolean isPhoneIdChanged = false;
+        if (mActivePhoneId != phoneId) {
+            mActivePhoneId = phoneId;
+            isPhoneIdChanged = true;
+        }
+        mImsRILAdapter.turnOffIms(mHandler.obtainMessage(EVENT_SET_IMS_DISABLE_DONE));
+        mImsState = PhoneConstants.IMS_STATE_DISABLING;
+    }
+
+    @Override
+    public void setRegistrationListener(int serviceId, IImsRegistrationListener listener) {
+        mListener = listener;
+        if (mImsRegInfo != ServiceState.STATE_POWER_OFF) {
+            notifyRegistrationStateChange(mImsRegInfo);
+        }
+        if ((mImsRegInfo == ServiceState.STATE_IN_SERVICE)) {
+            notifyRegistrationCapabilityChange(mImsExtInfo);
+        }
+    }
+
+    @Override
+    public ImsCallProfile createCallProfile(int serviceId, int serviceType, int callType) {
+        return new ImsCallProfile(serviceType, callType);
+    }
+
+    @Override
+    public IImsCallSession createCallSession(int serviceId, ImsCallProfile profile, IImsCallSessionListener listener) {
+        // This API is for outgoing call to create IImsCallSession
+        return new ImsCallSessionProxy(mContext, profile, listener, this, mHandler, mImsRILAdapter);
+    }
+
+    @Override
+    public IImsCallSession getPendingCallSession(int serviceId, String callId) {
+        // This API is for incoming call to create IImsCallSession
+        if (mPendingMT == null) {
+            return null;
+        }
+
+        IImsCallSession pendingMT = mPendingMT;
+
+        try {
+            if (pendingMT.getCallId().equals(callId)) {
+                mPendingMT = null;
+                return pendingMT;
+            }
+        } catch (RemoteException e) {
+            // error handling. Currently no-op
+        }
+
+        return null;
+    }
+
+    /**
+     * Ut interface for the supplementary service configuration.
+     */
+    @Override
+    public IImsUt getUtInterface(int serviceId) {
+        if (sImsUtStub == null) {
+            sImsUtStub = new ImsUtStub(mContext);
+        }
+        return sImsUtStub;
+    }
+
+    /**
+     * Config interface to get/set IMS service/capability parameters.
+     */
+    @Override
+    public IImsConfig getConfigInterface(int phoneId) {
+        if (sImsConfig == null) {
+            sImsConfig = new ImsConfigStub(mContext);
+        }
+        return sImsConfig;
+    }
+
+    /**
+     * ECBM interface for Emergency Callback mode mechanism.
+     */
+    @Override
+    public IImsEcbm getEcbmInterface(int serviceId) {
+        /* leave blank */
+        return new ImsEcbmProxy();
+    }
+
+    /**
+      * Used to set current TTY Mode.
+      */
+    @Override
+    public void setUiTTYMode(int serviceId, int uiTtyMode, Message onComplete) {
+        return;
+    }
+
+    /**
+     *call interface for allowing/refusing the incoming call indication send to App.
+     *@hide
+     */
+    public void setCallIndication(String callId, int seqNum, boolean isAllow) {
+        /* leave blank */
+        if (isAllow) {
+            ImsCallProfile imsCallProfile = new ImsCallProfile();
+            if (mPendingMT != null) {
+                try {
+                    mPendingMT.close();
+                } catch (RemoteException e) {
+                    // error handling. Currently no-op
+                    Rlog.e(LOG_TAG, "setCallIndication: can't close pending MT");
+                }
+            }
+            mPendingMT = new ImsCallSessionProxy(mContext, imsCallProfile,
+                    null, ImsService.this, mHandler, mImsRILAdapter, callId);
+            mImsRILAdapter.setCallIndication(IMS_ALLOW_INCOMING_CALL_INDICATION,
+                    Integer.parseInt(callId), seqNum);
+        } else {
+            mImsRILAdapter.setCallIndication(IMS_DISALLOW_INCOMING_CALL_INDICATION,
+                    Integer.parseInt(callId), seqNum);
+        }
+    }
+
+    /**
+     * Use to query ims enable/disable status.
+     *@return ims status
+     *@hide
+     */
+    public int getImsState() {
+        return mImsState;
+    }
+
+    /**
+     * Use to query ims registration information.
+     *@return true if the ims is registered or false if the ims is unregistered.
+     *@hide
+     */
+    public boolean getImsRegInfo(int phoneId) {
+        if (phoneId != mActivePhoneId) {
+            Rlog.d(LOG_TAG, "IMS: getImsRegInfo() phoneId = " + phoneId +
+                " mActivePhoneId = " + mActivePhoneId);
+            return false;
+        }
+
+        if (mImsRegInfo == ServiceState.STATE_IN_SERVICE) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Use to query ims registration extension information.
+     *@return string ims extension information.
+     *@hide
+     */
+    public String getImsExtInfo() {
+        return Integer.toHexString(mImsExtInfo);
+    }
+
+    /**
+     * Use to query ims service state .
+     *@return mImsRegInfo for service state information.
+     *@hide
+     */
+    public int getImsServiceState() {
+        return mImsRegInfo;
+    }
+
+    /**
+     * Use to hang up all calls .
+     *@hide
+     */
+    public void hangupAllCall() {
+        mImsRILAdapter.hangupAllCall(null);
+    }
+
+    /**
+     *sned the incoming call intent  to ImsPhoneCallTracker.
+     *@hide
+     */
+    private void sendIncomingCallIndication(AsyncResult ar) {
+        // +EAIC:<call_id>,<number>,<type>,<call_mode>,<seq_no>
+        String callId = ((String[]) ar.result)[0];
+        String dialString = ((String[]) ar.result)[1];
+        String seqNum = ((String[]) ar.result)[4];
+        int serviceId = 1;
+
+        Rlog.d(LOG_TAG, "IMS: sendIncomingCallIndication() call_id = " + callId +
+                " dialString = " +  dialString + " seqNum = " + seqNum);
+
+        Intent intent = new Intent(ImsManager.ACTION_IMS_INCOMING_CALL_INDICATION);
+        intent.putExtra(ImsManager.EXTRA_CALL_ID, callId);
+        intent.putExtra(ImsManager.EXTRA_DIAL_STRING, dialString);
+        intent.putExtra(ImsManager.EXTRA_SEQ_NUM, Integer.parseInt(seqNum));
+        intent.putExtra(ImsManager.EXTRA_SERVICE_ID, serviceId);
+        mContext.sendBroadcast(intent);
+    }
+
+    /**
+     *create wifiOffloadListnerProxy.
+     *@return return wifiOffloadLisetnerProxy
+     *@hide
+     */
+    private IWifiOffloadListenerProxy createWifiOffloadListenerProxy() {
+        IWifiOffloadListenerProxy proxy =
+                new IWifiOffloadListenerProxy();
+        return proxy;
+    }
+
+    /**
+     *transfer AP wifi call mode to MD wifi call mode.
+     *@param wfcMode which is used in AP side.     
+     *@return return rilWfcMode which is used in MD side.
+     *@hide
+     */
+    private int mapToMDWfcProfile(int wfcMode) {
+
+        int rilWfcMode = ImsConfig.WfcModeFeatureValueConstants.WIFI_PREFERRED;
+
+        switch (wfcMode) {
+            case ImsConfig.WfcModeFeatureValueConstants.WIFI_ONLY:
+                rilWfcMode = 3;
+                break;
+            case ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED:
+                rilWfcMode = 2;
+                break;
+            case ImsConfig.WfcModeFeatureValueConstants.WIFI_PREFERRED:
+                rilWfcMode = 1;
+                break;
+            default:
+                break;
+        }
+        return rilWfcMode;
+    }
+
+    /**
+     *notify MD wifi profile is changed.
+     *@hide
+     */
+    private void setWfcProfileInfo() {
+        int wfcMode = android.provider.Settings.Global.getInt(mContext.getContentResolver(),
+                android.provider.Settings.Global.WFC_IMS_MODE,
+                ImsConfig.WfcModeFeatureValueConstants.WIFI_PREFERRED);
+        int rilWfcMode = mapToMDWfcProfile(wfcMode);
+        mImsRILAdapter.sendWfcProfileInfo(rilWfcMode);
+    }
+
+    /**
+     * Adapter class for {@link IWifiOffloadListener}.
+     */
+    private class IWifiOffloadListenerProxy extends WifiOffloadManager.Listener {
+
+        @Override
+        public void onHandover(int stage, int ratType) {
+            if (DBG) {
+                Rlog.d(LOG_TAG,"onHandover");
+            }
+
+            mRAN = ratType;
+
+            if ((stage == WifiOffloadManager.HANDOVER_END &&
+                    mImsRegInfo == ServiceState.STATE_IN_SERVICE)) {
+                notifyRegistrationCapabilityChange(mImsExtInfo);
+            }
+        }
+    }
+
+    public ImsRILAdapter getImsRILAdapter() {
+        if (mImsRILAdapter == null) {
+            Rlog.d(LOG_TAG, "IMS: getImsRILAdapter, mImsRILAdapter is null ");
+        }
+
+        return mImsRILAdapter;
+    }
+
+    /**
+     * Death recipient class for monitoring IMS service.
+     *
+     * @param phoneId  to indicate which phone.
+     */
+    private void checkAndBindWifiOffloadService() {
+        IBinder b = ServiceManager.getService(WifiOffloadManager.WFO_SERVICE);
+
+        if (b != null) {
+            try {
+                b.linkToDeath(mDeathRecipient, 0);
+            } catch (RemoteException e) {
+            }
+        }
+
+        sWifiOffloadService = IWifiOffloadService.Stub.asInterface(b);
+        Rlog.d(LOG_TAG, "checkAndBindWifiOffloadService: sWifiOffloadService = " +
+                sWifiOffloadService);
+    }
+
+    /**
+     * Death recipient class for monitoring WifiOffload service.
+     */
+    private class IWifiOffloadServiceDeathRecipient implements IBinder.DeathRecipient {
+        @Override
+        public void binderDied() {
+            sWifiOffloadService = null;
+        }
+    }
+
+
+    /**
+     *notify upper application ims registration information.
+     *@param imsRegInfo   the registration inforamtion.
+     *@hide
+     */
+    private void notifyRegistrationStateChange(int imsRegInfo) {
+        if (mListener == null) {
+            return;
+        }
+
+        if (DBG) {
+            Rlog.d(LOG_TAG, "IMS: notifyRegistrationStateChange imsRegInfo= " + imsRegInfo);
+        }
+
+        if (imsRegInfo == ServiceState.STATE_IN_SERVICE) {
+            try {
+                mListener.registrationConnected();
+                if (sWifiOffloadService != null) {
+                    mRAN = sWifiOffloadService.getRatType();
+                }
+                mRegErrorCode = ImsReasonInfo.CODE_UNSPECIFIED;
+            } catch (RemoteException e) {
+                // error handling. Currently no-op 
+                Rlog.e(LOG_TAG, "IMS: notifyStateChange fail on access WifiOffloadService");
+            }
+        } else {
+            try {
+                ImsReasonInfo imsReasonInfo = null;
+
+                if(sWifiOffloadService != null && 
+                        sWifiOffloadService.getRatType() == WifiOffloadManager.RAN_TYPE_WIFI) {
+                    // wfc disconnect
+                    DisconnectCause wifiDisconnectCause = sWifiOffloadService.getDisconnectCause();
+                    int wifiErrorCode = wifiDisconnectCause.getErrorCause();
+                    imsReasonInfo= new ImsReasonInfo(ImsReasonInfo.CODE_REGISTRATION_ERROR,
+                            wifiErrorCode,Integer.toString(wifiErrorCode));
+                } else {
+                    // volte disconnect
+                    imsReasonInfo= new ImsReasonInfo(ImsReasonInfo.CODE_REGISTRATION_ERROR,
+                            mRegErrorCode,Integer.toString(mRegErrorCode));
+                }
+
+                mListener.registrationDisconnected(imsReasonInfo);
+            } catch (RemoteException e) {
+                // error handling. Currently no-op
+            }
+        }
+    }
+
+    /**
+     *notify upper application ims feature capability information.
+     *@param imsExtInfo   the ims feature capability inforamtion.
+     *@hide
+     */
+    private void notifyRegistrationCapabilityChange(int imsExtInfo) {
+        if (mListener == null) {
+            return;
+        }
+
+        int[] enabledFeatures = new int[IMS_MAX_FEATURE_SUPPORT_SIZE];
+        int[] disabledFeatures = new int[IMS_MAX_FEATURE_SUPPORT_SIZE];
+
+        for (int i = 0; i < IMS_MAX_FEATURE_SUPPORT_SIZE; i++) {
+            enabledFeatures[i] = -1;
+            disabledFeatures[i] = -1;
+        }
+
+        if (mRAN != WifiOffloadManager.RAN_TYPE_WIFI &&
+                (imsExtInfo & IMS_VOICE_OVER_LTE) == IMS_VOICE_OVER_LTE) {
+            enabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE] =
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE;
+        } else {
+            disabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE] =
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE;
+        }
+
+        if ((imsExtInfo & IMS_VIDEO_OVER_LTE) == IMS_VIDEO_OVER_LTE) {
+            enabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE] =
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE;
+        } else {
+            disabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE] =
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE;
+        }
+        /// WFC @{
+        if (mRAN == WifiOffloadManager.RAN_TYPE_WIFI &&
+                (imsExtInfo & IMS_VOICE_OVER_LTE) == IMS_VOICE_OVER_LTE) {
+            enabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI] =
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI;
+            Rlog.d(LOG_TAG, "[WFC]IMS_VOICE_OVER_WIFI");
+        } else {
+            disabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI] =
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI;
+        }
+        ///@}
+
+        // currently modem not support video over wifi
+        disabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_WIFI] =
+                ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_WIFI;
+
+        try {
+            mListener.registrationFeatureCapabilityChanged(ImsServiceClass.MMTEL,
+                    enabledFeatures, disabledFeatures);
+        } catch (RemoteException e) {
+            // error handling. Currently no-op
+        }
+    }
+
+    /*
+    * Observes WFC preference settings changes .
+    */
+    private void registerForWfcPreferenceChange(Handler handler) {
+        ContentObserver contentObserver = new ContentObserver(handler) {
+
+            @Override
+            public void onChange(boolean selfChange) {
+                this.onChange(selfChange, Settings.System.getUriFor(Settings.Global.WFC_IMS_MODE));
+            }
+
+            @Override
+            public void onChange(boolean selfChange, Uri uri) {
+                Uri i = android.provider.Settings.Global
+                        .getUriFor(android.provider.Settings.Global.WFC_IMS_MODE);
+                int wfc_preference = Settings.System.getInt(mContext.getContentResolver(),
+                        Settings.Global.WFC_IMS_MODE,
+                        ImsConfig.WfcModeFeatureValueConstants.WIFI_PREFERRED);
+                int ril_wfc_preference = mapToMDWfcProfile(wfc_preference);
+                if (DBG) Rlog.d(LOG_TAG, "uri:" + uri + ", db_uri:" + i);
+                if (DBG) Rlog.d(LOG_TAG, "wfc_preference:" + wfc_preference);
+                if (i != null && i.equals(uri)) {
+                    /* send change to modem */
+                    mImsRILAdapter.sendWfcProfileInfo(ril_wfc_preference);
+                }
+            }
+        };
+
+        mContext.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(Settings.Global.WFC_IMS_MODE),
+                false, contentObserver);
+    }
+
+    /**
+     *Ims service Message hanadler.
+     *@hide
+     */
+    private class MyHandler extends Handler {
+
+        @Override
+        public void handleMessage(Message msg) {
+            AsyncResult ar;
+            Intent intent;
+            switch (msg.what) {
+                case EVENT_IMS_REGISTRATION_INFO:
+                    if (DBG) Rlog.d(LOG_TAG, "receive EVENT_IMS_REGISTRATION_INFO");
+
+                    /**
+                     * According to 3GPP TS 27.007 +CIREGU format
+                     *
+                     * AsyncResult.result is an Object[]
+                     * ((Object[])AsyncResult.result)[0] is integer type to indicate the IMS regiration status.
+                     *                                    0: not registered
+                     *                                    1: registered
+                     * ((Object[])AsyncResult.result)[1] is numeric value in hexadecimal format to indicate the IMS capability.
+                     *                                    1: RTP-based transfer of voice according to MMTEL (see 3GPP TS 24.173 [87])
+                     *                                    2: RTP-based transfer of text according to MMTEL (see 3GPP TS 24.173 [87])
+                     *                                    4: SMS using IMS functionality (see 3GPP TS 24.341[101])
+                     *                                    8: RTP-based transfer of video according to MMTEL (see 3GPP TS 24.183 [87])
+                     *
+                     */
+                    ar = (AsyncResult) msg.obj;
+                    /// M: Fix DSDS bug
+                    /// Do not notify AP when socket_id from RILD is not equal the active phone id. @{
+                    int socketId = ((int[]) ar.result)[2];
+                    if (socketId != mActivePhoneId) {
+                        Rlog.d(LOG_TAG, "IMS: drop IMS reg info, socketId = " + socketId +
+                            " mActivePhoneId = " + mActivePhoneId);
+                        break;
+                    }
+                    /// @}
+
+                    int newImsRegInfo = ServiceState.STATE_POWER_OFF;
+                    if (((int[]) ar.result)[0] == 1) {
+                        newImsRegInfo = ServiceState.STATE_IN_SERVICE;
+                    } else {
+                        newImsRegInfo = ServiceState.STATE_OUT_OF_SERVICE;
+                    }
+                    /// M: Simulate IMS Registration @{
+                    if (SystemProperties.getInt("persist.ims.simulate", 0) == 1) {
+                        newImsRegInfo = (mImsRegistry ?
+                                ServiceState.STATE_IN_SERVICE : ServiceState.STATE_OUT_OF_SERVICE);
+                        Rlog.d(LOG_TAG, "Override EVENT_IMS_REGISTRATION_INFO: newImsRegInfo=" +
+                                newImsRegInfo);
+                    }
+                    /// @}
+                    int newImsExtInfo = ((int[]) ar.result)[1];
+
+                    /* notify upper application the IMS registration status is chagned */
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "newReg:" + newImsRegInfo + " oldReg:" + mImsRegInfo);
+                    }
+
+                    mImsRegInfo = newImsRegInfo;
+                    notifyRegistrationStateChange(mImsRegInfo);
+
+                    /* notify upper application the IMS capability is chagned when IMS is registered */
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "newRegExt:" + newImsExtInfo + "oldRegExt:" + mImsExtInfo);
+                    }
+
+                    if ((mImsRegInfo == ServiceState.STATE_IN_SERVICE)) {
+                        mImsExtInfo = newImsExtInfo;
+                    } else {
+                        mImsExtInfo = 0;
+                    }
+                    notifyRegistrationCapabilityChange(mImsExtInfo);
+                    break;
+                case EVENT_IMS_ENABLING_URC:
+                    //+EIMS: 1
+                    //Since MD doens't send IMS_ENABLED_URC to AP we should handle initial here.
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_IMS_ENABLING_URC, mActivePhoneId = "
+                                + mActivePhoneId);
+                    }
+                    // notify AP Ims Service is up
+                    intent = new Intent(ImsManager.ACTION_IMS_SERVICE_UP);
+                    intent.putExtra(ImsManager.EXTRA_PHONE_ID, mActivePhoneId);
+                    mContext.sendBroadcast(intent);
+                    // enable ImsAdapter
+                    enableImsAdapter();
+                    mImsState = PhoneConstants.IMS_STATE_ENABLE;
+                    if (SystemProperties.get("ro.mtk_wfc_support").equals("1")) {
+                        setWfcProfileInfo();
+                    }
+                    break;
+                case EVENT_IMS_ENABLED_URC:
+                    //+EIMCFLAG: 1
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_IMS_ENABLED_URC");
+                    }
+                    break;
+                case EVENT_IMS_DISABLING_URC:
+                    //+EIMS: 0
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_IMS_DISABLING_URC");
+                    }
+                    break;
+                case EVENT_IMS_DISABLED_URC:
+                    //+EIMCFLAG: 0
+                    if (DBG) Rlog.d(LOG_TAG, "receive EVENT_IMS_DISABLED_URC");
+                    int phoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+                    Rlog.d(LOG_TAG, "IMS: phoneId = " + phoneId);
+                    intent = new Intent(ImsManager.ACTION_IMS_SERVICE_DOWN);
+                    intent.putExtra(ImsManager.EXTRA_PHONE_ID, phoneId);
+                    mContext.sendBroadcast(intent);
+
+                    disableImsAdapter(true);
+                    mImsState = PhoneConstants.IMS_STATE_DISABLED;
+                    break;
+                case EVENT_SET_IMS_ENABLED_DONE:
+                    // Only log for tracking set ims enable command response
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_SET_IMS_ENABLED_DONE");
+                    }
+                    break;
+                case EVENT_SET_IMS_DISABLE_DONE:
+                    // Only log for tracking set ims disable command response
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_SET_IMS_DISABLE_DONE");
+                    }
+                    break;
+                case EVENT_INCOMING_CALL_INDICATION:
+                    Rlog.d(LOG_TAG, "receive EVENT_INCOMING_CALL_INDICATION");
+                    ar = (AsyncResult) msg.obj;
+                    sendIncomingCallIndication(ar);
+                    break;
+                case EVENT_CALL_RING:
+                    Rlog.d(LOG_TAG, "receive EVENT_CALL_RING");
+                    break;
+                case EVENT_RADIO_NOT_AVAILABLE:
+                    Rlog.d(LOG_TAG, "receive EVENT_RADIO_NOT_AVAILABLE");
+                    mContext.sendBroadcast(new Intent(ImsManager.ACTION_IMS_SERVICE_DOWN));
+                    disableImsAdapter(false);
+                    break;
+                case EVENT_SIP_CODE_INDICATION:
+                    ar = (AsyncResult) msg.obj;
+                    int[] sipMessage = (int[]) ar.result;
+                    /* ESIPCPI: <call_id>,<dir>,<SIP_msg_type>,<method>,<response_code> */
+                    if (sipMessage != null) {
+                        Rlog.d(LOG_TAG, "Method =" + sipMessage[3] + "Reg cause =" + sipMessage[4]);
+                        if (sipMessage[3] == 0 ||
+                                sipMessage[3] == 9) {
+                            /* Save the WFC registration error for later use */
+                            mRegErrorCode = sipMessage[4];
+                        }
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+
+    @Override
+    public int getRegistrationStatus() {
+        if (mNotificationController == null) return WfcReasonInfo.CODE_WFC_DEFAULT;
+        return mNotificationController.getRegistrationStatus();
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsUtStub.java b/packages/Ims/src/com/mediatek/ims/ImsUtStub.java
new file mode 100644
index 0000000..10e182c
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsUtStub.java
@@ -0,0 +1,1116 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.content.Context;
+import android.os.AsyncResult;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.RemoteException;
+import android.util.Log;
+
+import com.android.ims.ImsCallForwardInfo;
+/// For OP01 UT
+import com.android.ims.ImsCallForwardInfoEx;
+import com.android.ims.ImsReasonInfo;
+import com.android.ims.ImsSsInfo;
+import com.android.ims.ImsUtInterface;
+import com.android.ims.internal.IImsUt;
+import com.android.ims.internal.IImsUtListener;
+import com.android.internal.telephony.CallForwardInfo;
+
+import java.net.UnknownHostException;
+
+/// For OP01 UT
+import com.android.internal.telephony.CallForwardInfoEx;
+import com.android.internal.telephony.CommandsInterface;
+import com.mediatek.simservs.xcap.XcapException;
+
+
+import static com.android.internal.telephony.imsphone.ImsPhoneMmiCode.UT_BUNDLE_KEY_CLIR;
+import static com.android.internal.telephony.imsphone.ImsPhoneMmiCode.UT_BUNDLE_KEY_SSINFO;
+
+/**
+ * ImsUT class for handle the IMS UT interface.
+ *
+ * The implementation is based on IR.92
+ *
+ *  @hide
+ */
+public class ImsUtStub extends IImsUt.Stub {
+    private static final String TAG = "ImsUtService";
+    private static final boolean DBG = true;
+
+    private Context mContext;
+
+    private static final Object mLock = new Object();
+    private static int sRequestId = 0;
+    private IImsUtListener mListener = null;
+    private MMTelSSTransport mMMTelSSTSL;
+    private ResultHandler mHandler;
+
+    static final int IMS_UT_EVENT_GET_CB = 1000;
+    static final int IMS_UT_EVENT_GET_CF = 1001;
+    static final int IMS_UT_EVENT_GET_CW = 1002;
+    static final int IMS_UT_EVENT_GET_CLIR = 1003;
+    static final int IMS_UT_EVENT_GET_CLIP = 1004;
+    static final int IMS_UT_EVENT_GET_COLR = 1005;
+    static final int IMS_UT_EVENT_GET_COLP = 1006;
+    static final int IMS_UT_EVENT_SET_CB = 1007;
+    static final int IMS_UT_EVENT_SET_CF = 1008;
+    static final int IMS_UT_EVENT_SET_CW = 1009;
+    static final int IMS_UT_EVENT_SET_CLIR = 1010;
+    static final int IMS_UT_EVENT_SET_CLIP = 1011;
+    static final int IMS_UT_EVENT_SET_COLR = 1012;
+    static final int IMS_UT_EVENT_SET_COLP = 1013;
+    /// For OP01 UT @{
+    static final int IMS_UT_EVENT_GET_CF_TIME_SLOT = 1014;
+    static final int IMS_UT_EVENT_SET_CF_TIME_SLOT = 1015;
+    /// @}
+
+    static final int HTTP_ERROR_CODE_403 = 403;
+
+    /**
+    *
+    * Construction function for ImsConfigStub.
+    *
+    * @param context the application context
+    *
+    */
+   public ImsUtStub(Context context) {
+       mContext = context;
+       mMMTelSSTSL = MMTelSSTransport.getInstance();
+       mMMTelSSTSL.registerUtService(mContext);
+
+       HandlerThread thread = new HandlerThread("ImsUtStubResult");
+       thread.start();
+       Looper looper = thread.getLooper();
+       mHandler = new ResultHandler(looper);
+   }
+
+   private class ResultHandler extends Handler {
+       public ResultHandler(Looper looper) {
+            super(looper);
+       }
+
+       @Override
+       public void handleMessage(Message msg) {
+           if (DBG) {
+               Log.d(TAG, "handleMessage(): event = " + msg.what + ", requestId = " + msg.arg1);
+           }
+           switch (msg.what) {
+               case IMS_UT_EVENT_GET_CB:
+                   if (null != mListener) {
+                       AsyncResult ar = (AsyncResult) msg.obj;
+
+                       if (null == ar.exception) {
+                           int[] result = (int []) ar.result;
+                           ImsSsInfo[] info = new ImsSsInfo[1];
+                           info[0] = new ImsSsInfo();
+                           info[0].mStatus = result[0];
+                           // TODO: add ServiceClass information
+                           if (DBG) {
+                               Log.d(TAG, "IMS_UT_EVENT_GET_CB: status = " + result[0]);
+                           }
+
+                           try {
+                               mListener.utConfigurationCallBarringQueried(ImsUtStub.this,
+                                       msg.arg1, info);
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in utConfigurationCallBarringQueried");
+                               e.printStackTrace();
+                           }
+                       } else if (ar.exception instanceof UnknownHostException) {
+                           if (DBG) {
+                               Log.d(TAG, "IMS_UT_EVENT_GET_CB: UnknownHostException.");
+                           }
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                   msg.arg1,
+                                   new ImsReasonInfo(ImsReasonInfo.CODE_UT_UNKNOWN_HOST, 0));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CB: "
+                                       + "UnknownHostException utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       } else if (ar.exception instanceof XcapException) {
+                           XcapException xcapException = (XcapException) ar.exception;
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                   msg.arg1,
+                                   xcapExceptionToImsReasonInfo(xcapException));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CB: "
+                                       + "utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       } else {
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this, msg.arg1,
+                                       new ImsReasonInfo(ImsReasonInfo.CODE_UT_NETWORK_ERROR,
+                                               0));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CB: "
+                                       + "utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       }
+                   }
+                   break;
+               case IMS_UT_EVENT_GET_CF:
+                   if (null != mListener) {
+                       AsyncResult ar = (AsyncResult) msg.obj;
+
+                       if (null == ar.exception) {
+                           CallForwardInfo[] cfInfo = (CallForwardInfo[]) ar.result;
+                           ImsCallForwardInfo[] imsCfInfo = null;
+
+                           if (cfInfo != null && cfInfo.length != 0) {
+                               imsCfInfo = new ImsCallForwardInfo[cfInfo.length];
+                               for (int i = 0; i < cfInfo.length; i++) {
+                                   if (DBG) {
+                                       Log.d(TAG, "IMS_UT_EVENT_GET_CF: cfInfo[" + i + "] = "
+                                               + cfInfo[i]);
+                                   }
+                                   imsCfInfo[i] = getImsCallForwardInfo(cfInfo[i]);
+                               }
+                           }
+
+                           try {
+                               mListener.utConfigurationCallForwardQueried(ImsUtStub.this,
+                                       msg.arg1, imsCfInfo);
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in utConfigurationCallForwardQueried");
+                               e.printStackTrace();
+                           }
+                       } else {
+                           if (ar.exception instanceof XcapException) {
+                               XcapException xcapException = (XcapException) ar.exception;
+                               try {
+                                   mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                       msg.arg1,
+                                       xcapExceptionToImsReasonInfo(xcapException));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CF: "
+                                           + "utConfigurationQueryFailed");
+                                   e.printStackTrace();
+                               }
+                           } else if (ar.exception instanceof UnknownHostException) {
+                               if (DBG) {
+                                   Log.d(TAG, "IMS_UT_EVENT_GET_CF: UnknownHostException.");
+                               }
+                               try {
+                                   mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                       msg.arg1,
+                                       new ImsReasonInfo(ImsReasonInfo.CODE_UT_UNKNOWN_HOST, 0));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CF: "
+                                           + "UnknownHostException utConfigurationQueryFailed");
+                                   e.printStackTrace();
+                               }
+                           } else {
+                               try {
+                                   mListener.utConfigurationQueryFailed(ImsUtStub.this, msg.arg1,
+                                           new ImsReasonInfo(ImsReasonInfo.CODE_UT_NETWORK_ERROR,
+                                                   0));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CF: "
+                                           + "utConfigurationQueryFailed");
+                                   e.printStackTrace();
+                               }
+                           }
+                       }
+                   }
+                   break;
+               case IMS_UT_EVENT_GET_CW:
+                   if (null != mListener) {
+                       AsyncResult ar = (AsyncResult) msg.obj;
+
+                       if (null == ar.exception) {
+                           int[] result = (int []) ar.result;
+                           ImsSsInfo[] info = new ImsSsInfo[1];
+                           info[0] = new ImsSsInfo();
+                           info[0].mStatus = result[0];
+                           // TODO: add ServiceClass information
+                           if (DBG) {
+                               Log.d(TAG, "IMS_UT_EVENT_GET_CW: status = " + result[0]);
+                           }
+
+                           try {
+                               mListener.utConfigurationCallWaitingQueried(ImsUtStub.this,
+                                       msg.arg1, info);
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in utConfigurationCallWaitingQueried");
+                               e.printStackTrace();
+                           }
+                       } else if (ar.exception instanceof UnknownHostException) {
+                           if (DBG) {
+                               Log.d(TAG, "IMS_UT_EVENT_GET_CW: UnknownHostException.");
+                           }
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                   msg.arg1,
+                                   new ImsReasonInfo(ImsReasonInfo.CODE_UT_UNKNOWN_HOST, 0));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CW: "
+                                       + "UnknownHostException utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       } else if (ar.exception instanceof XcapException) {
+                           XcapException xcapException = (XcapException) ar.exception;
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                   msg.arg1,
+                                   xcapExceptionToImsReasonInfo(xcapException));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CW: "
+                                       + "utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       } else {
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this, msg.arg1,
+                                       new ImsReasonInfo(ImsReasonInfo.CODE_UT_NETWORK_ERROR,
+                                               0));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CW: "
+                                       + "utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       }
+                   }
+                   break;
+               case IMS_UT_EVENT_GET_CLIR:
+                   if (null != mListener) {
+                       AsyncResult ar = (AsyncResult) msg.obj;
+
+                       if (null == ar.exception) {
+                           int[] result = (int []) ar.result;
+                           Bundle info = new Bundle();
+                           info.putIntArray(UT_BUNDLE_KEY_CLIR, result);
+
+                           try {
+                               mListener.utConfigurationQueried(ImsUtStub.this, msg.arg1, info);
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CLIR: "
+                                       + "utConfigurationQueried");
+                               e.printStackTrace();
+                           }
+                       } else if (ar.exception instanceof UnknownHostException) {
+                           if (DBG) {
+                               Log.d(TAG, "IMS_UT_EVENT_GET_CLIR: UnknownHostException.");
+                           }
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                   msg.arg1,
+                                   new ImsReasonInfo(ImsReasonInfo.CODE_UT_UNKNOWN_HOST, 0));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CLIR: "
+                                       + "UnknownHostException utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       } else if (ar.exception instanceof XcapException) {
+                           XcapException xcapException = (XcapException) ar.exception;
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                   msg.arg1,
+                                   xcapExceptionToImsReasonInfo(xcapException));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CLIR: "
+                                       + "utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       } else {
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this, msg.arg1,
+                                       new ImsReasonInfo(ImsReasonInfo.CODE_UT_NETWORK_ERROR,
+                                               0));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CLIR: "
+                                       + "utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       }
+                   }
+                   break;
+               case IMS_UT_EVENT_GET_CLIP:
+               case IMS_UT_EVENT_GET_COLR: // fall through
+               case IMS_UT_EVENT_GET_COLP: // fall through
+                   if (null != mListener) {
+                       AsyncResult ar = (AsyncResult) msg.obj;
+
+                       if (null == ar.exception) {
+                           int[] result = (int []) ar.result;
+                           ImsSsInfo ssInfo = new ImsSsInfo();
+                           ssInfo.mStatus = result[0];
+                           Bundle info = new Bundle();
+                           info.putParcelable(UT_BUNDLE_KEY_SSINFO, ssInfo);
+
+                           try {
+                               mListener.utConfigurationQueried(ImsUtStub.this, msg.arg1, info);
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in utConfigurationQueried, event = "
+                                       + msg.what);
+                               e.printStackTrace();
+                           }
+                       } else {
+                           if (ar.exception instanceof XcapException) {
+                               XcapException xcapException = (XcapException) ar.exception;
+                               try {
+                                   mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                       msg.arg1,
+                                       xcapExceptionToImsReasonInfo(xcapException));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException in utConfigurationQueryFailed, "
+                                           + "event = " + msg.what);
+                                   e.printStackTrace();
+                               }
+                           } else if (ar.exception instanceof UnknownHostException) {
+                               if (DBG) {
+                                   Log.d(TAG, "UnknownHostException. event = " + msg.what);
+                               }
+                               try {
+                                   mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                       msg.arg1,
+                                       new ImsReasonInfo(ImsReasonInfo.CODE_UT_UNKNOWN_HOST, 0));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException UnknownHostException "
+                                           + "utConfigurationQueryFailed, event" + msg.what);
+                                   e.printStackTrace();
+                               }
+                           } else {
+                               try {
+                                   mListener.utConfigurationQueryFailed(ImsUtStub.this, msg.arg1,
+                                           new ImsReasonInfo(ImsReasonInfo.CODE_UT_NETWORK_ERROR,
+                                                   0));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException in utConfigurationQueryFailed, "
+                                           + "event = " + msg.what);
+                                   e.printStackTrace();
+                               }
+                           }
+                       }
+                   }
+                   break;
+               case IMS_UT_EVENT_SET_CB:
+               case IMS_UT_EVENT_SET_CF: // fall through
+               case IMS_UT_EVENT_SET_CW: // fall through
+               case IMS_UT_EVENT_SET_CLIR: // fall through
+               case IMS_UT_EVENT_SET_CLIP: // fall through
+               case IMS_UT_EVENT_SET_COLR: // fall through
+               case IMS_UT_EVENT_SET_COLP: // fall through
+               case IMS_UT_EVENT_SET_CF_TIME_SLOT: // For OP01 UT
+                   if (null != mListener) {
+                       AsyncResult ar = (AsyncResult) msg.obj;
+
+                       if (null == ar.exception) {
+                           if (DBG) {
+                               Log.d(TAG, "utConfigurationUpdated(): "
+                                       + "event = " + msg.what);
+                           }
+                           try {
+                               mListener.utConfigurationUpdated(ImsUtStub.this, msg.arg1);
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in utConfigurationUpdated, event = "
+                                       + msg.what);
+                               e.printStackTrace();
+                           }
+                       } else {
+                           if (ar.exception instanceof XcapException) {
+                               XcapException xcapException = (XcapException) ar.exception;
+                               try {
+                                   mListener.utConfigurationUpdateFailed(ImsUtStub.this,
+                                       msg.arg1,
+                                       xcapExceptionToImsReasonInfo(xcapException));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException in utConfigurationUpdateFailed, "
+                                           + "event = " + msg.what);
+                                   e.printStackTrace();
+                               }
+                           } else if (ar.exception instanceof UnknownHostException) {
+                               if (DBG) {
+                                   Log.d(TAG, "UnknownHostException. event = " + msg.what);
+                               }
+                               try {
+                                   mListener.utConfigurationUpdateFailed(ImsUtStub.this,
+                                       msg.arg1,
+                                       new ImsReasonInfo(ImsReasonInfo.CODE_UT_UNKNOWN_HOST, 0));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException UnknownHostException "
+                                           + "utConfigurationUpdateFailed, event" + msg.what);
+                                   e.printStackTrace();
+                               }
+                           } else {
+                               try {
+                                   mListener.utConfigurationUpdateFailed(ImsUtStub.this, msg.arg1,
+                                           new ImsReasonInfo(ImsReasonInfo.CODE_UT_NETWORK_ERROR,
+                                                   0));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException in utConfigurationUpdateFailed, "
+                                           + "event = " + msg.what);
+                                   e.printStackTrace();
+                               }
+                           }
+                       }
+                   }
+                   break;
+                /// For OP01 UT @{
+                case IMS_UT_EVENT_GET_CF_TIME_SLOT:
+                    if (null != mListener) {
+                        AsyncResult ar = (AsyncResult) msg.obj;
+
+                        if (null == ar.exception) {
+                            CallForwardInfoEx[] cfInfo = (CallForwardInfoEx[]) ar.result;
+                            ImsCallForwardInfoEx[] imsCfInfo = null;
+
+                            if (cfInfo != null && cfInfo.length != 0) {
+                                imsCfInfo = new ImsCallForwardInfoEx[cfInfo.length];
+                                for (int i = 0; i < cfInfo.length; i++) {
+                                    ImsCallForwardInfoEx info = new ImsCallForwardInfoEx();
+                                    info.mCondition =
+                                            getConditionFromCFReason(cfInfo[i].reason);
+                                    info.mStatus = cfInfo[i].status;
+                                    info.mServiceClass = cfInfo[i].serviceClass;
+                                    info.mToA = cfInfo[i].toa;
+                                    info.mNumber = cfInfo[i].number;
+                                    info.mTimeSeconds = cfInfo[i].timeSeconds;
+                                    info.mTimeSlot = cfInfo[i].timeSlot;
+                                    imsCfInfo[i] = info;
+                                }
+                            }
+
+                            try {
+                                mListener.utConfigurationCallForwardInTimeSlotQueried(
+                                        ImsUtStub.this, msg.arg1, imsCfInfo);
+                            } catch (RemoteException e) {
+                                Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CF_TIME_SLOT"
+                                        + " utConfigurationCallForwardInTimeSlotQueried");
+                                e.printStackTrace();
+                            }
+                        } else {
+                            if (ar.exception instanceof XcapException) {
+                                XcapException xcapException = (XcapException) ar.exception;
+                                try {
+                                    mListener.utConfigurationQueryFailed(
+                                            ImsUtStub.this, msg.arg1,
+                                            xcapExceptionToImsReasonInfo(xcapException));
+                                } catch (RemoteException e) {
+                                    Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CF_TIME_SLOT"
+                                            + " utConfigurationQueryFailed");
+                                    e.printStackTrace();
+                                }
+                            } else if (ar.exception instanceof UnknownHostException) {
+                                if (DBG) {
+                                    Log.d(TAG, "IMS_UT_EVENT_GET_CF_TIME_SLOT: "
+                                            + "UnknownHostException.");
+                                }
+                                try {
+                                    mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                        msg.arg1,
+                                        new ImsReasonInfo(ImsReasonInfo.CODE_UT_UNKNOWN_HOST, 0));
+                                } catch (RemoteException e) {
+                                    Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CF_TIME_SLOT: "
+                                            + "UnknownHostException utConfigurationQueryFailed");
+                                    e.printStackTrace();
+                                }
+                            } else {
+                                try {
+                                    mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                            msg.arg1,
+                                            new ImsReasonInfo(
+                                                    ImsReasonInfo.CODE_UT_NETWORK_ERROR, 0));
+                                } catch (RemoteException e) {
+                                    Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CF_TIME_SLOT"
+                                            + " utConfigurationQueryFailed");
+                                    e.printStackTrace();
+                                }
+                            }
+                        }
+                    }
+                    break;
+                    /// @}
+               default:
+                   Log.d(TAG, "Unknown Event: " + msg.what);
+                   break;
+           }
+       }
+   };
+
+    /**
+     * Closes the object. This object is not usable after being closed.
+     */
+    public void close() {
+    }
+
+    private String getFacilityFromCBType(int cbType) {
+        switch (cbType) {
+            case ImsUtInterface.CB_BAIC:
+                return CommandsInterface.CB_FACILITY_BAIC;
+            case ImsUtInterface.CB_BAOC:
+                return CommandsInterface.CB_FACILITY_BAOC;
+            case ImsUtInterface.CB_BOIC:
+                return CommandsInterface.CB_FACILITY_BAOIC;
+            case ImsUtInterface.CB_BOIC_EXHC:
+                return CommandsInterface.CB_FACILITY_BAOICxH;
+            case ImsUtInterface.CB_BIC_WR:
+                return CommandsInterface.CB_FACILITY_BAICr;
+            // TODO: Barring of Anonymous Communication Rejection (ACR)
+            case ImsUtInterface.CB_BIC_ACR:
+                return "ACR";
+            case ImsUtInterface.CB_BA_ALL:
+                return CommandsInterface.CB_FACILITY_BA_ALL;
+            case ImsUtInterface.CB_BA_MO:
+                return CommandsInterface.CB_FACILITY_BA_MO;
+            case ImsUtInterface.CB_BA_MT:
+                return CommandsInterface.CB_FACILITY_BA_MT;
+            // TODO: Barring of Specific Incoming calls
+            case ImsUtInterface.CB_BS_MT:
+                return "BS_MT";
+            default:
+                return null;
+        }
+    }
+
+    private int getCFActionFromAction(int cfAction) {
+        switch(cfAction) {
+            case ImsUtInterface.ACTION_DEACTIVATION:
+                return CommandsInterface.CF_ACTION_DISABLE;
+            case ImsUtInterface.ACTION_ACTIVATION:
+                return CommandsInterface.CF_ACTION_ENABLE;
+            case ImsUtInterface.ACTION_ERASURE:
+                return CommandsInterface.CF_ACTION_ERASURE;
+            case ImsUtInterface.ACTION_REGISTRATION:
+                return CommandsInterface.CF_ACTION_REGISTRATION;
+            default:
+                break;
+        }
+
+        return CommandsInterface.CF_ACTION_DISABLE;
+    }
+
+    private int getCFReasonFromCondition(int condition) {
+        switch(condition) {
+            case ImsUtInterface.CDIV_CF_UNCONDITIONAL:
+                return CommandsInterface.CF_REASON_UNCONDITIONAL;
+            case ImsUtInterface.CDIV_CF_BUSY:
+                return CommandsInterface.CF_REASON_BUSY;
+            case ImsUtInterface.CDIV_CF_NO_REPLY:
+                return CommandsInterface.CF_REASON_NO_REPLY;
+            case ImsUtInterface.CDIV_CF_NOT_REACHABLE:
+                return CommandsInterface.CF_REASON_NOT_REACHABLE;
+            case ImsUtInterface.CDIV_CF_ALL:
+                return CommandsInterface.CF_REASON_ALL;
+            case ImsUtInterface.CDIV_CF_ALL_CONDITIONAL:
+                return CommandsInterface.CF_REASON_ALL_CONDITIONAL;
+            case ImsUtInterface.CDIV_CF_NOT_LOGGED_IN:
+                return CommandsInterface.CF_REASON_NOT_REGISTERED;
+            default:
+                break;
+        }
+
+        return CommandsInterface.CF_REASON_NOT_REACHABLE;
+    }
+
+    private int getConditionFromCFReason(int reason) {
+        switch(reason) {
+            case CommandsInterface.CF_REASON_UNCONDITIONAL:
+                return ImsUtInterface.CDIV_CF_UNCONDITIONAL;
+            case CommandsInterface.CF_REASON_BUSY:
+                return ImsUtInterface.CDIV_CF_BUSY;
+            case CommandsInterface.CF_REASON_NO_REPLY:
+                return ImsUtInterface.CDIV_CF_NO_REPLY;
+            case CommandsInterface.CF_REASON_NOT_REACHABLE:
+                return ImsUtInterface.CDIV_CF_NOT_REACHABLE;
+            case CommandsInterface.CF_REASON_ALL:
+                return ImsUtInterface.CDIV_CF_ALL;
+            case CommandsInterface.CF_REASON_ALL_CONDITIONAL:
+                return ImsUtInterface.CDIV_CF_ALL_CONDITIONAL;
+            case CommandsInterface.CF_REASON_NOT_REGISTERED:
+                return ImsUtInterface.CDIV_CF_NOT_LOGGED_IN;
+            default:
+                break;
+        }
+
+        return ImsUtInterface.INVALID;
+    }
+
+    private ImsCallForwardInfo getImsCallForwardInfo(CallForwardInfo info) {
+        ImsCallForwardInfo imsCfInfo = new ImsCallForwardInfo();
+        imsCfInfo.mCondition = getConditionFromCFReason(info.reason);
+        imsCfInfo.mStatus = info.status;
+        //imsCfInfo.mServiceClass = info.serviceClass; // TODO: Add video service class
+        imsCfInfo.mToA = info.toa;
+        imsCfInfo.mNumber = info.number;
+        imsCfInfo.mTimeSeconds = info.timeSeconds;
+        return imsCfInfo;
+    }
+
+    /**
+     * Retrieves the configuration of the call barring.
+     * @param cbType Call Barring Type
+     * @return the request ID
+     */
+    public int queryCallBarring(int cbType) {
+        int requestId;
+        String facility;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCallBarring(): requestId = " + requestId);
+        }
+
+        facility = getFacilityFromCBType(cbType);
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_CB, requestId, 0, null);
+        mMMTelSSTSL.queryFacilityLock(facility, null, CommandsInterface.SERVICE_CLASS_VOICE, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Retrieves the configuration of the call forward.
+     * @param condition Call Forward condition
+     * @param number Forwarded to number
+     * @return the request ID
+     */
+    public int queryCallForward(int condition, String number) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCallForward(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_CF, requestId, 0, null);
+        mMMTelSSTSL.queryCallForwardStatus(getCFReasonFromCondition(condition),
+                CommandsInterface.SERVICE_CLASS_VOICE, number, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Retrieves the configuration of the call waiting.
+     * @return the request ID
+     */
+    public int queryCallWaiting() {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCallWaiting(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_CW, requestId, 0, null);
+        mMMTelSSTSL.queryCallWaiting(CommandsInterface.SERVICE_CLASS_VOICE, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Retrieves the default CLIR setting.
+     * @return the request ID
+     */
+    public int queryCLIR() {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCLIR(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_CLIR, requestId, 0, null);
+        mMMTelSSTSL.getCLIR(msg);
+
+        return requestId;
+    }
+
+    /**
+     * Retrieves the CLIP call setting.
+     * @return the request ID
+     */
+    public int queryCLIP() {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCLIP(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_CLIP, requestId, 0, null);
+        mMMTelSSTSL.queryCLIP(msg);
+
+        return requestId;
+    }
+
+    /**
+     * Retrieves the COLR call setting.
+     * @return the request ID
+     */
+    public int queryCOLR() {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCOLR(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_COLR, requestId, 0, null);
+        mMMTelSSTSL.getCOLR(msg);
+
+        return requestId;
+    }
+
+    /**
+     * Retrieves the COLP call setting.
+     * @return the request ID
+     */
+    public int queryCOLP() {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCOLP(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_COLP, requestId, 0, null);
+        mMMTelSSTSL.getCOLP(msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates or retrieves the supplementary service configuration.
+     * @param ssInfo supplementary service information
+     * @return the request ID
+     */
+    public int transact(Bundle ssInfo) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the call barring.
+     * @param cbType Call Barring Type
+     * @param enable lock state
+     * @param barrList barring list
+     * @return the request ID
+     */
+    public int updateCallBarring(int cbType, boolean enable, String[] barrList) {
+        int requestId;
+        String facility;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCallBarring(): requestId = " + requestId);
+        }
+
+        facility = getFacilityFromCBType(cbType);
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_CB, requestId, 0, null);
+        mMMTelSSTSL.setFacilityLock(facility, enable, null,
+                CommandsInterface.SERVICE_CLASS_VOICE, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the call forward.
+     * @param action the call forwarding action
+     * @param condition the call forwarding condition
+     * @param number the call forwarded to number
+     * @param timeSeconds seconds for no reply
+     * @return the request ID
+     */
+    public int updateCallForward(int action, int condition, String number, int serviceClass,
+                                     int timeSeconds) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCallForward(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_CF, requestId, 0, null);
+        mMMTelSSTSL.setCallForward(getCFActionFromAction(action),
+                getCFReasonFromCondition(condition), serviceClass,
+                number, timeSeconds, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the call waiting.
+     * @param enable activate flag
+     * @return the request ID
+     */
+    public int updateCallWaiting(boolean enable, int serviceClass) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCallWaiting(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_CW, requestId, 0, null);
+        mMMTelSSTSL.setCallWaiting(enable, serviceClass, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the CLIR supplementary service.
+     * @param clirMode CLIR mode
+     * @return the request ID
+     */
+    public int updateCLIR(int clirMode) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCLIR(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_CLIR, requestId, 0, null);
+        mMMTelSSTSL.setCLIR(clirMode, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the CLIP supplementary service.
+     * @param enable activate flag
+     * @return the request ID
+     */
+    public int updateCLIP(boolean enable) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCLIP(): requestId = " + requestId);
+        }
+
+        int enableClip = (enable) ? 1 : 0;
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_CLIP, requestId, 0, null);
+        mMMTelSSTSL.setCLIP(enableClip, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the COLR supplementary service.
+     * @param presentation presentation flag
+     * @return the request ID
+     */
+    public int updateCOLR(int presentation) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCOLR(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_COLR, requestId, 0, null);
+        mMMTelSSTSL.setCOLR(presentation, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the COLP supplementary service.
+     * @param enable activate flag
+     * @return the request ID
+     */
+    public int updateCOLP(boolean enable) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCOLP(): requestId = " + requestId);
+        }
+
+        int enableColp = (enable) ? 1 : 0;
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_COLP, requestId, 0, null);
+        mMMTelSSTSL.setCOLP(enableColp, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Sets the listener.
+     * @param listener callback interface
+     */
+    public void setListener(IImsUtListener listener) {
+        mListener = listener;
+    }
+
+    /**
+     * Convert XcapExcaption to ImsReasonInfo.
+     * @param xcapEx the XcapExcaption
+     * @return the converted ImsReasonInfo
+     */
+    ImsReasonInfo xcapExceptionToImsReasonInfo(XcapException xcapEx) {
+        ImsReasonInfo reason;
+
+        if ((DBG) && (xcapEx != null)) {
+            Log.d(TAG, "xcapExceptionToImsReasonInfo(): XcapException: "
+                    + "code = " + xcapEx.getExceptionCodeCode()
+                    + ", http error = " + xcapEx.getHttpErrorCode()
+                    + ", isConnectionError = " + xcapEx.isConnectionError());
+        }
+
+        if ((xcapEx != null) && (xcapEx.getHttpErrorCode() == HTTP_ERROR_CODE_403)) {
+            reason = new ImsReasonInfo(ImsReasonInfo.CODE_UT_XCAP_403_FORBIDDEN, 0);
+        } else {
+            reason = new ImsReasonInfo(ImsReasonInfo.CODE_UT_NETWORK_ERROR, 0);
+        }
+
+        return reason;
+    }
+
+    /// For OP01 UT @{
+    /**
+     * Retrieves the configuration of the call forward in a time slot.
+     */
+    public int queryCallForwardInTimeSlot(int condition) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCallForwardInTimeSlot(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_CF_TIME_SLOT,
+                requestId, 0, null);
+        mMMTelSSTSL.queryCallForwardInTimeSlotStatus(
+                getCFReasonFromCondition(condition),
+                CommandsInterface.SERVICE_CLASS_VOICE,
+                msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the call forward in a time slot.
+     */
+    public int updateCallForwardInTimeSlot(int action, int condition,
+            String number, int timeSeconds, long[] timeSlot) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCallForwardInTimeSlot(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_CF_TIME_SLOT, requestId, 0, null);
+        mMMTelSSTSL.setCallForwardInTimeSlot(getCFActionFromAction(action),
+                getCFReasonFromCondition(condition),
+                CommandsInterface.SERVICE_CLASS_VOICE,
+                number, timeSeconds, timeSlot, msg);
+
+        return requestId;
+    }
+    /// @}
+
+    // xen0n
+
+    @Override
+    public int queryCFForServiceClass(int condition, String number, int serviceClass) {
+        Log.e(TAG, "queryCFForServiceClass(" + condition + ", \"" + number + "\", " + serviceClass + "): stub!");
+        return 0;
+    }
+
+    @Override
+    public int updateCallBarring(int cbType, int action, String[] barrList) {
+        Log.e(TAG, "updateCallBarring: stub!");
+        return 0;
+    }
+
+}
diff --git a/packages/Ims/src/com/mediatek/ims/MMTelSSTransport.java b/packages/Ims/src/com/mediatek/ims/MMTelSSTransport.java
new file mode 100644
index 0000000..ab4af48
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/MMTelSSTransport.java
@@ -0,0 +1,5861 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2013. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+
+import android.net.Network;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.PowerManager;
+import android.os.SystemProperties;
+import android.os.PowerManager.WakeLock;
+import android.telephony.Rlog;
+import android.telephony.SubscriptionManager;
+
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+
+import com.android.internal.telephony.CallForwardInfo;
+import com.android.internal.telephony.CallForwardInfoEx;
+import com.android.internal.telephony.CommandException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.TelephonyProperties;
+
+import java.net.Authenticator;
+import java.net.PasswordAuthentication;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.mediatek.gba.GbaHttpUrlCredential;
+import com.mediatek.simservs.client.SimServs;
+import com.mediatek.simservs.client.CommunicationDiversion;
+import com.mediatek.simservs.client.CommunicationWaiting;
+import com.mediatek.simservs.client.IncomingCommunicationBarring;
+import com.mediatek.simservs.client.SimservType;
+import com.mediatek.simservs.client.OriginatingIdentityPresentation;
+import com.mediatek.simservs.client.OriginatingIdentityPresentationRestriction;
+import com.mediatek.simservs.client.TerminatingIdentityPresentation;
+import com.mediatek.simservs.client.TerminatingIdentityPresentationRestriction;
+
+import com.mediatek.simservs.client.OutgoingCommunicationBarring;
+import com.mediatek.simservs.client.policy.Actions;
+import com.mediatek.simservs.client.policy.Conditions;
+import com.mediatek.simservs.client.policy.ForwardTo;
+import com.mediatek.simservs.client.policy.Rule;
+import com.mediatek.simservs.client.policy.RuleSet;
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+/// For OP01 UT @{
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.TimeZone;
+/// @}
+
+/**
+ * {@hide}
+ */
+class MMTelSSRequest {
+    static final String LOG_TAG = "MMTelSSReq";
+
+    //***** Class Variables
+    static int sNextSerial = 0;
+    static Object sSerialMonitor = new Object();
+    private static Object sPoolSync = new Object();
+    private static MMTelSSRequest sPool = null;
+    private static int sPoolSize = 0;
+    private static final int MAX_POOL_SIZE = 4;
+
+    //***** Instance Variables
+    int mSerial;
+    int mRequest;
+    Message mResult;
+    Parcel mp;
+    //For complex SS Operation: It can be used to carry the Rule or RuleSet object for
+    //MMTelSSTransmitter to parse & compare with remote XCAP server's data
+    //Add by mtk01411 2013-0911
+    Object requestParm;
+    MMTelSSRequest mNext;
+
+    /**
+     * Retrieves a new MMTelSSRequest instance from the pool.
+     *
+     * @param request MMTELSS_REQ_*
+     * @param result sent when operation completes
+     * @return a MMTelSSRequest instance from the pool.
+     */
+    static MMTelSSRequest obtain(int request, Message result) {
+        MMTelSSRequest rr = null;
+
+        synchronized (sPoolSync) {
+            if (sPool != null) {
+                rr = sPool;
+                sPool = rr.mNext;
+                rr.mNext = null;
+                sPoolSize--;
+            }
+        }
+
+        if (rr == null) {
+            rr = new MMTelSSRequest();
+        }
+
+        synchronized (sSerialMonitor) {
+            rr.mSerial = sNextSerial++;
+        }
+        rr.mRequest = request;
+        rr.mResult = result;
+        rr.mp = Parcel.obtain();
+
+        if (result != null && result.getTarget() == null) {
+            throw new NullPointerException("Message target must not be null");
+        }
+
+        // first elements in any MMTelSSRequest Parcel (Before returning the rr, it already
+        // fills two elements into the Parcel)
+        rr.mp.writeInt(request);
+        rr.mp.writeInt(rr.mSerial);
+
+        return rr;
+    }
+
+    /**
+     * Returns a MMTelSSRequest instance to the pool.
+     *
+     * Note: This should only be called once per use.
+     */
+    void release() {
+        synchronized (sPoolSync) {
+            if (sPoolSize < MAX_POOL_SIZE) {
+                this.mNext = sPool;
+                sPool = this;
+                sPoolSize++;
+                mResult = null;
+            }
+        }
+    }
+
+    private MMTelSSRequest() {
+    }
+
+    static void
+    resetSerial() {
+        synchronized (sSerialMonitor) {
+            sNextSerial = 0;
+        }
+    }
+
+    String
+    serialString() {
+        //Cheesy way to do %04d
+        StringBuilder sb = new StringBuilder(8);
+        String sn;
+
+        sn = Integer.toString(mSerial);
+
+        //sb.append("J[");
+        sb.append('[');
+        for (int i = 0, s = sn.length() ; i < 4 - s; i++) {
+            sb.append('0');
+        }
+
+        sb.append(sn);
+        sb.append(']');
+        return sb.toString();
+    }
+
+    void
+    onError(int error, Object ret) {
+        CommandException ex;
+
+        //[TBD] It should modify as XCAP Errno & Exception by mtk01411
+        ex = CommandException.fromRilErrno(error);
+
+        if (MMTelSSTransport.DBG) Rlog.d(LOG_TAG, serialString() + "< "
+                + MMTelSSTransport.requestToString(mRequest)
+                + " error: " + ex);
+
+        if (mResult != null) {
+            AsyncResult.forMessage(mResult, ret, ex);
+            mResult.sendToTarget();
+        }
+
+        if (mp != null) {
+            mp.recycle();
+            mp = null;
+        }
+    }
+}
+
+
+/**
+ * Implementation for MMTel SS Transport
+ *
+ * {@hide}
+ *
+ */
+public final class MMTelSSTransport {
+    private static final String LOG_TAG = "MMTelSS";
+    static final boolean DBG = true;
+
+    // Singleton instance
+    private static final MMTelSSTransport INSTANCE = new MMTelSSTransport();
+    private PowerManager pm = null;
+    HandlerThread mSenderThread;
+    MMTelSSTransmitter mSender;
+    String mMCC = "";
+    String mMNC = "";
+    String mXui = "user@chinaTel.com";
+    String mXcapRoot = "http://192.168.1.2:8080/";
+    String mXIntendedId = "user@chinaTel.com";
+    String mUserName = "sip:user@anritsu-cscf.com";
+    //[Modify mUserName as Single_TC_xxx by mtk01411 for UT - get local xml tested string instead
+    // of getting from XCAP server via http]
+    //String mUserName="Single_TC_1";
+    String mPassword = "password";
+    Context mContext = null;
+    private XcapMobileDataNetworkManager mXcapMobileDataNetworkManager = null;
+    private Network mNetwork = null;
+
+    //***** MMTelSSRequest
+    static final int MMTELSS_REQ_SET_CLIR               = 1;
+    static final int MMTELSS_REQ_GET_CLIR               = 2;
+    static final int MMTELSS_REQ_GET_CLIP               = 3;
+    static final int MMTELSS_REQ_GET_COLP               = 4;
+    static final int MMTELSS_REQ_GET_COLR               = 5;
+    static final int MMTELSS_REQ_SET_CB                 = 6;
+    static final int MMTELSS_REQ_GET_CB                 = 7;
+    static final int MMTELSS_REQ_SET_CF                 = 8;
+    static final int MMTELSS_REQ_GET_CF                 = 9;
+    static final int MMTELSS_REQ_SET_CW                 = 10;
+    static final int MMTELSS_REQ_GET_CW                 = 11;
+    //[SET OIP/SET TIP/SET TIR are not supported by 2/3G SS feature set]
+    static final int MMTELSS_REQ_SET_CLIP               = 12;
+    static final int MMTELSS_REQ_SET_COLP               = 13;
+    static final int MMTELSS_REQ_SET_COLR               = 14;
+    /// For OP01 UT @{
+    static final int MMTELSS_REQ_SET_CF_TIME_SLOT       = 15;
+    static final int MMTELSS_REQ_GET_CF_TIME_SLOT       = 16;
+    /// @}
+
+    //***** Events
+    static final int EVENT_SEND                 = 1;
+    static final int EVENT_WAKE_LOCK_TIMEOUT    = 2;
+    //static final int EVENT_RADIO_OFF_OR_NOT_AVAILABLE = 3;
+    //static final int EVENT_RADIO_AVAILABLE = 4;
+    //static final int EVENT_RADIO_ON = 5;
+
+    //[TBD] Need to sync the maximun number of bytes with SimServs's capability
+    static final int MMTELSS_MAX_COMMAND_BYTES = (8 * 1024);
+
+    private static final int DEFAULT_WAKE_LOCK_TIMEOUT = 5000;
+
+    WakeLock mWakeLock;
+    int mWakeLockTimeout;
+    // The number of requests pending to be sent out, it increases before calling
+    // EVENT_SEND and decreases while handling EVENT_SEND. It gets cleared while
+    // WAKE_LOCK_TIMEOUT occurs.
+    int mRequestMessagesPending = 0;
+    // The number of requests sent out but waiting for response. It increases while
+    // sending request and decreases while handling response. It should match
+    // mRequestList.size() unless there are requests no replied while
+    // WAKE_LOCK_TIMEOUT occurs.
+    int mRequestMessagesWaiting;
+
+    //(1) mDisableRuleMode=1:Remove the rule when the user disables it (e.g., user disables the
+    //  CFB/BAOC)
+    //(2) mDisableRuleMode=2:Add <rule-deactivated> into the child node of <conditions> for CF/CB
+    //  cases when the user disables it (e.g., user disables the CFB/BAOC)
+    static final int DISABLE_MODE_DELETE_RULE = 1;
+    static final int DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG = 2;
+    //(3) mDisableRuleMode=3:Change <allow> from false(i.e, call is barred) to true(i.e., call is
+    // allowed)
+    static final int DISABLE_MODE_CHANGE_CB_ALLOW = 3;
+    //Currently,it can decide the mDisableRuleMode from system property "ril.ss.disrulemode" - see
+    // the following APIs usage
+    //handleCreateNewRuleForExistingCF() and handleCreateNewRuleForExistingCB()
+    int mDisableRuleMode = DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG;
+
+    static final int RADIO_TEMPSTATE_AVAILABLE = 0;     /* Radio available */
+    static final int RADIO_TEMPSTATE_UNAVAILABLE = 1;   /* Radio unavailable temporarily */
+    private int radioTemporarilyUnavailable = RADIO_TEMPSTATE_AVAILABLE;
+
+    //I'd rather this be LinkedList or something
+    ArrayList<MMTelSSRequest> mRequestsList = new ArrayList<MMTelSSRequest>();
+
+    private static final SimServs mSimservs = SimServs.getInstance();
+
+    //[MMTelSS] For testing purpose (ref. to SimServsTest.java) Add by mtk01411 2013-0830
+    static final private String XCAP_ROOT = "http://192.168.1.2:8080/";
+    static final private String TEST_USER = "sip:user@anritsu-cscf.com";
+    static final private String TEST_DOC = "simservs";
+
+    //Following Constants definition must be same with EngineerMode/ims/ImsActivity.java
+    private final static String PROP_SS_MODE = "persist.radio.ss.mode";
+    private final static String MODE_SS_XCAP = "Prefer XCAP";
+    private final static String MODE_SS_CS = "Prefer CS";
+    private final static String PROP_SS_DISABLE_METHOD = "persist.radio.ss.xrdm";
+    private final static String PROP_SS_CFNUM = "persist.radio.xcap.cfn";
+    private final static String PROPERTY_CS_CURRENT_PHONE_ID = "gsm.radio.ss.phoneid";
+    private boolean mUpdateSingleRule = true;
+    private int mCsDomainPhoneId = 0;
+
+    private CommunicationDiversion mCdCache = null;
+    private int mCdCachePhoneId;
+    private long mCdCacheLastQueried = 0;
+    private OutgoingCommunicationBarring mOcbCache = null;
+    private int mOcbCachePhoneId;
+    private long mOcbCacheLastQueried = 0;
+    private IncomingCommunicationBarring mIcbCache = null;
+    private int mIcbCachePhoneId;
+    private long mIcbCacheLastQueried = 0;
+    private CommunicationWaiting mCwCache = null;
+    private int mCwCachePhoneId;
+    private long mCwCacheLastQueried = 0;
+    private OriginatingIdentityPresentationRestriction mOirCache = null;
+    private int mOirCachePhoneId;
+    private long mOirCacheLastQueried = 0;
+    private static final long MMTEL_CACHE_VALID_TIME = (2 * 60 * 1000);
+    private static final int HTTP_ERROR_CODE_412 = 412;
+
+    public MMTelSSTransport() {
+        //pm = (PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
+        //mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOG_TAG);
+        //mWakeLock.setReferenceCounted(false);
+        //mWakeLockTimeout = SystemProperties.getInt(TelephonyProperties.PROPERTY_WAKE_LOCK_TIMEOUT,
+        //        DEFAULT_WAKE_LOCK_TIMEOUT);
+
+        mSenderThread = new HandlerThread("MMTelSSTransmitter");
+        mSenderThread.start();
+        Looper looper = mSenderThread.getLooper();
+        mSender = new MMTelSSTransmitter(looper);
+    }
+
+    public static MMTelSSTransport getInstance() {
+        return INSTANCE;
+    }
+
+    public static SimServs getSimServs() {
+        return mSimservs;
+    }
+
+    public void registerUtService(Context context) {
+        mContext = context;
+        if (mWakeLock == null) {
+            pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+            mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOG_TAG);
+            mWakeLock.setReferenceCounted(false);
+            mWakeLockTimeout = SystemProperties.getInt(
+                    TelephonyProperties.PROPERTY_WAKE_LOCK_TIMEOUT, DEFAULT_WAKE_LOCK_TIMEOUT);
+        }
+
+        // Manages XCAP mobile data network connectivity related stuff
+        if (mXcapMobileDataNetworkManager == null) {
+            mXcapMobileDataNetworkManager = new XcapMobileDataNetworkManager(mContext);
+        }
+    }
+
+    private void requestXcapNetwork(int phoneId) {
+        Rlog.d(LOG_TAG, "requestXcapNetwork(): phoneId = " + phoneId
+                + ", mXcapMobileDataNetworkManager = " + mXcapMobileDataNetworkManager);
+        mNetwork = null;
+        if (mXcapMobileDataNetworkManager != null) {
+            mNetwork = mXcapMobileDataNetworkManager.acquireNetwork(phoneId);
+        }
+    }
+
+    /**
+     * Configure Simservs parameters.
+     *
+     * @param xui XUI String
+     * @param xcapRoot XCAP Root URI
+     * @param intendedId XIntended Id String
+     * @param userName username
+     * @param password password
+     * @param phoneId phone index
+     */
+    public void setSimservsInitParameters(String xui, String xcapRoot, String intendedId,
+            String userName, String password, int phoneId) {
+        mXui = xui;
+        mXcapRoot = xcapRoot;
+        mXIntendedId = intendedId;
+        mUserName = userName;
+        mPassword = password;
+
+        mSimservs.setXui(xui);
+        mSimservs.setXcapRoot(MMTelSSUtils.addXcapRootPort(xcapRoot, phoneId));
+        mSimservs.setIntendedId(intendedId);
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+
+        //[MMTelSS UT Purpose]Get userName (i.e,)
+        String tc_name = SystemProperties.get("ril.ss.tcname", "Empty");
+        Rlog.d(LOG_TAG, "setSimservsInitParameters():tc_name=" + tc_name + ", passed userName="
+                + userName);
+        if (tc_name != null && tc_name.startsWith("Single_TC_")) {
+            userName = tc_name;
+            mUserName = userName;
+        }
+
+        //[MMTelSS] In setHttpCredential():UserName will be used as the mUsername value and in
+        // SimservType.java's constructor():loadConfiguration(userName)
+        //If the userName is started with the prefix "Single_TC":It will enter the test mode & use
+        // the test cases written in SimservType.java
+        Rlog.d(LOG_TAG, "persist.mtk.simserv.username:[" +
+                SystemProperties.get("persist.mtk.simserv.username") + "]" +
+                "persist.mtk.simserv.password:[" +
+                SystemProperties.get("persist.mtk.simserv.password") + "]");
+
+        if (SystemProperties.get("persist.mtk.simserv.username") != null &&
+                !SystemProperties.get("persist.mtk.simserv.username").isEmpty() &&
+                SystemProperties.get("persist.mtk.simserv.password") != null &&
+                !SystemProperties.get("persist.mtk.simserv.password").isEmpty()) {
+            //Modify for NSN Lab IOT: Support HTTP Digest
+            //Example:username=sip:+18860000018@srnims3.srnnam.nsn-rdnet and password=ims123456
+            Authenticator.setDefault(new Authenticator() {
+                protected PasswordAuthentication getPasswordAuthentication() {
+                    return new PasswordAuthentication(
+                            SystemProperties.get("persist.mtk.simserv.username"),
+                            SystemProperties.get("persist.mtk.simserv.password").toCharArray());
+                }
+            });
+        } else {
+            GbaHttpUrlCredential gbaCredential =
+                    new GbaHttpUrlCredential(mContext, xcapRoot, subId);
+            if (mNetwork != null) {
+                gbaCredential.setNetwork(mNetwork);
+            }
+            Authenticator.setDefault(gbaCredential.getAuthenticator());
+        }
+    }
+
+    class MMTelSSTransmitter extends Handler implements Runnable {
+        public MMTelSSTransmitter(Looper looper) {
+            super(looper);
+        }
+
+        // Only allocated once
+        byte[] dataLength = new byte[4];
+
+        //***** Runnable implementation
+        public void
+        run() {
+            //setup if needed
+        }
+
+
+
+        public boolean containSpecificMedia(List<String>mediaList, int serviceClass) {
+            if (mediaList == null) return true;
+            if (mediaList.size() == 0) return true;
+            //[Note]Open Question:(1)For a voice call, it only has the "audio" media type
+            // (2)For a video call, it only has the "video" media type or have both "audio+video"
+            //Another implementation:(1)If (serviceCalss == CommandsInterface.SERVICE_CLASS_VOICE
+            // && mediaList.size()==1 && mediaType=="audio") -> return true
+            //                       (2)If (serviceCalss == CommandsInterface.SERVICE_CLASS_VIDEO
+            // && mediaList.size()==2 && one meidaType is audio the other is video") -> return true
+            for (int i = 0; i < mediaList.size(); i++) {
+                String mediaType = mediaList.get(i);
+                Rlog.d(LOG_TAG, "mediaType=" + mediaType + ",serviceClass=" + serviceClass);
+                if (mediaType.equals("audio")
+                        && (serviceClass == CommandsInterface.SERVICE_CLASS_VOICE
+                        || serviceClass == CommandsInterface.SERVICE_CLASS_NONE)) {
+                    return true;
+                } else if (mediaType.equals("video")
+                        && (serviceClass == CommandsInterface.SERVICE_CLASS_VIDEO
+                        || serviceClass == CommandsInterface.SERVICE_CLASS_NONE)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        public boolean hasExtraMedia(List<String>mediaList, int serviceClass) {
+            boolean found = false;
+            found = containSpecificMedia(mediaList, serviceClass);
+            if (found && (mediaList != null) && (mediaList.size() > 1)) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        public String getMediaType(int serviceClass) {
+            if (serviceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                return "audio";
+            } else if (serviceClass == CommandsInterface.SERVICE_CLASS_VIDEO) {
+                return "video";
+            }
+            return "";
+        }
+
+        public boolean isBAOC(Conditions cond, int serviceClass) {
+            //If the <cp:conditions></cp:conditions> is empty, the result of <cp:condition> is
+            // evaluated as true
+            if (cond == null)
+                return true;
+            if (cond.comprehendInternational() == false
+                    && cond.comprehendRoaming() == false
+                    && containSpecificMedia(cond.getMedias(), serviceClass)) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        public boolean isBAIC(Conditions cond, int serviceClass) {
+            //If the <cp:conditions></cp:conditions> is empty, the result of <cp:condition> is
+            // evaluated as true
+            if (cond == null)
+                return true;
+            if (cond.comprehendInternational() == false
+                    && cond.comprehendRoaming() == false
+                    && cond.comprehendAnonymous() == false
+                    && containSpecificMedia(cond.getMedias(), serviceClass)) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+
+        public void handleGetCLIR(MMTelSSRequest rr) {
+            //See ril_ss.c's requestClirOperation() & CLIRListPreference.java
+            //1(Permantently provisioned),3(Temporary presentation disallowed),
+            //4(Temporary presentation allowed),0(CLIR not provisioned),2(network error)
+            int presentation_mode = 1;
+            int get_clir_result = CommandsInterface.CLIR_DEFAULT;
+            int phoneId = rr.mp.readInt();
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleGetCLIR(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return;
+            }
+
+            //
+            try {
+                OriginatingIdentityPresentationRestriction oir;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleGetCLIR(): mOirCache = " + mOirCache + ", curTime = "
+                        + curTime + ", mOirCacheLastQueried = " + mOirCacheLastQueried);
+                if ((mOirCache != null) && (phoneId == mOirCachePhoneId) &&
+                        (mOirCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleGetCLIR(): using ETAG mOirCache: " + mOirCache);
+                    requestXcapNetwork(phoneId);
+                    oir = mOirCache;
+                    oir.setNetwork(mNetwork);
+                    oir.refresh();
+                    mOirCacheLastQueried = curTime;
+                } else if ((mOirCache != null) && (phoneId == mOirCachePhoneId) &&
+                        ((curTime >= mOirCacheLastQueried)
+                        && ((curTime - mOirCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleGetCLIR(): using mOirCache: " + mOirCache);
+                    oir = mOirCache;
+                } else {
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleGetCLIR(): XcapRoot = " + mXcapRoot);
+                        if (null != rr.mResult) {
+                            AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                            rr.mResult.sendToTarget();
+                        }
+                        return;
+                    }
+
+                    requestXcapNetwork(phoneId);
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+                    oir = mSimservs.getOriginatingIdentityPresentationRestriction(true, mNetwork);
+                    mOirCache = oir;
+                    mOirCachePhoneId = phoneId;
+                    mOirCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleGetCLIR(): new mOirCache = " + mOirCache
+                            + ", curTime = " + curTime);
+                }
+
+                boolean restricted = oir.isDefaultPresentationRestricted();
+                if (restricted == true) {
+                    //restrict CLI presentation
+                    presentation_mode = 3;
+                    get_clir_result = CommandsInterface.CLIR_INVOCATION;
+                } else {
+                    //allow CLI presentation
+                    presentation_mode = 4;
+                    get_clir_result = CommandsInterface.CLIR_SUPPRESSION;
+                }
+
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCLIR(): XcapException");
+                mOirCache = null;
+                mOirCachePhoneId = -1;
+                mOirCacheLastQueried = 0;
+
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCLIR(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCLIR(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                //Something is wrong:Set presentation_mode=2 for upper application
+                Rlog.d(LOG_TAG, "handleGetCLIR():Start to Print Stack Trace");
+                mOirCache = null;
+                mOirCachePhoneId = -1;
+                mOirCacheLastQueried = 0;
+
+                presentation_mode = 2;
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+
+                }
+            }
+            //
+
+            //[Example]
+            //Note that Spec 22.030 AnnexB. - only CF/CB/CW will have service class to be specified
+            //For CLIP/CLIR/COLP/COLR will not have service class to be specified
+            if (rr.mResult != null) {
+                int get_clir_response [] = new int[2];
+                get_clir_response[0] = get_clir_result;
+                get_clir_response[1] = presentation_mode; //Only 1(Permantently provisioned),
+                                                          //3(Temporary presentation disallowed),
+                                                          //4(Temporary presentation allowed)
+                                                          //are allowed
+                AsyncResult.forMessage(rr.mResult, get_clir_response, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        public void handleGetCLIP(MMTelSSRequest rr) {
+            //GsmMMiCode.java onQueryComplete():0(disabled), 1(enabled)
+            int reqNo = -1;
+            int serialNo = -1;
+            int get_clip_result = 0; //disabled
+            int phoneId = rr.mp.readInt();
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleGetCLIP(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return;
+            }
+
+            try {
+                mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                if (TextUtils.isEmpty(mXcapRoot)) {
+                    Rlog.d(LOG_TAG, "handleGetCLIP(): XcapRoot = " + mXcapRoot);
+                    if (null != rr.mResult) {
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                        rr.mResult.sendToTarget();
+                    }
+                    return;
+                }
+
+                requestXcapNetwork(phoneId);
+
+                setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                        phoneId);
+                OriginatingIdentityPresentation oip =
+                        mSimservs.getOriginatingIdentityPresentation(true, mNetwork);
+                Rlog.d(LOG_TAG, "handleGetCLIP():active=" + oip.isActive());
+                if (oip.isActive()) {
+                    get_clip_result = 1; //enabled
+                } else {
+                    get_clip_result = 0; //disabled
+                }
+
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCLIP(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCLIP(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCLIP(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "handleGetCLIP():Start to Print Stack Trace");
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+
+                }
+            }
+
+            if (rr.mResult != null) {
+                int get_clip_response [] = new int[1];
+                get_clip_response[0] = get_clip_result;
+                AsyncResult.forMessage(rr.mResult, get_clip_response, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        public void handleGetCOLP(MMTelSSRequest rr) {
+            //+COLP:n,m (n:0(disabled),1(enabled); m:0(not provision),1(provision),2(unknonw))
+            //See GsmMMiCode.java- onGetColpComplete()
+            //In IMS/XCAP, SS service should be provisioned to each user let him/her to configure
+            // this service
+            //Only the service is provisioned to the user, he/she is able to configure
+
+            int reqNo = -1;
+            int serialNo = -1;
+            int get_colp_response [] = new int[2];
+            int phoneId = rr.mp.readInt();
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleGetCOLP(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return;
+            }
+
+            try {
+                mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                if (TextUtils.isEmpty(mXcapRoot)) {
+                    Rlog.d(LOG_TAG, "handleGetCOLP(): XcapRoot = " + mXcapRoot);
+                    if (null != rr.mResult) {
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                        rr.mResult.sendToTarget();
+                    }
+                    return;
+                }
+
+                requestXcapNetwork(phoneId);
+
+                setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                        phoneId);
+                TerminatingIdentityPresentation tip =
+                        mSimservs.getTerminatingIdentityPresentation(true, mNetwork);
+                Rlog.d(LOG_TAG, "handleGetCOLP():active=" + tip.isActive());
+                if (tip.isActive()) {
+                    //According to TS24.608 Section 4.5.1:The TIP service is activated at
+                    // provisioning and deactived at withdrawal
+                    get_colp_response[0] = 1; //enabled
+                    get_colp_response[1] = 1; //provision
+                } else {
+                    get_colp_response[0] = 0; //disabled
+                    get_colp_response[1] = 0; //Not provision
+                }
+
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCOLP(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCOLP(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCOLP(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "handleGetCOLP():Start to Print Stack Trace");
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                           CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            }
+
+            if (rr.mResult != null) {
+                //get_colp_response[0] = 0; //disabled
+                //2nd parameter: Provios or not (2:un-known In this way, not expect the user will
+                // configure COLP)
+                //get_colp_response[1] = 2; //But GsmMMiCode.java- onGetColpComplete(): only cares
+                // this parameter (provison or not!)
+                AsyncResult.forMessage(rr.mResult, get_colp_response, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        public void handleGetCOLR(MMTelSSRequest rr) {
+            //See GsmMMiCode.java- onGetColrComplete(): Only check result[0] this parameter
+
+            int reqNo = -1;
+            int serialNo = -1;
+            int get_colr_response [] = new int[1];
+            int phoneId = rr.mp.readInt();
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleGetCOLR(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return;
+            }
+
+            try {
+                mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                if (TextUtils.isEmpty(mXcapRoot)) {
+                    Rlog.d(LOG_TAG, "handleGetCOLR(): XcapRoot = " + mXcapRoot);
+                    if (null != rr.mResult) {
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                        rr.mResult.sendToTarget();
+                    }
+                    return;
+                }
+
+                requestXcapNetwork(phoneId);
+
+                setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                        phoneId);
+                TerminatingIdentityPresentationRestriction tir =
+                        mSimservs.getTerminatingIdentityPresentationRestriction(true, mNetwork);
+                Rlog.d(LOG_TAG, "handleGetCOLR():active=" + tir.isActive());
+                if (tir.isActive()) {
+                    //According to TS24.608 Section 4.5.1:The TIR service is activated at
+                    // provisioning and deactived at withdrawal
+                    get_colr_response[0] = 1; //enabled/Provision
+
+                } else {
+                    get_colr_response[0] = 0; //disabled/Not Provision
+                }
+
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCOLR(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCOLR(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCOLR(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "handleGetCOLR():Start to Print Stack Trace");
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            }
+
+
+            if (rr.mResult != null) {
+                //But GsmMMiCode.java- onGetColrComplete(): only cares this parameter
+                // (provison or not!)
+                //get_colr_response[0] = 2; //unknown (In this way, not expect the user will
+                // configure COLR)
+                AsyncResult.forMessage(rr.mResult, get_colr_response, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+
+        public void handleGetCW(MMTelSSRequest rr) {
+            int reqNo = -1;
+            int serialNo = -1;
+            int cwServiceClass = -1;
+            int get_cw_response [] = new int[2];
+            int phoneId = 0;
+
+            //As per 3GPP TS 24.083, section 1.6 UE doesn't need to send service class parameter
+            // in call waiting interrogation  to network
+            //For CW Activation, it can only active for some specific service class but the query
+            // result will be returned supported status of all service classes
+            //[TODO-Question]It seems that XCAP does not support to enable CW according to
+            // different service classes!
+            try {
+                rr.mp.setDataPosition(0);
+                reqNo = rr.mp.readInt();
+                serialNo = rr.mp.readInt();
+                cwServiceClass = rr.mp.readInt();
+                phoneId = rr.mp.readInt();
+                Rlog.d(LOG_TAG, "Read GET_CW serviceClass=" + cwServiceClass);
+
+                if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                    Rlog.d(LOG_TAG, "handleGetCW(): !isPreferXcap()");
+                    throw new UnknownHostException();
+                }
+
+                //Change the serviceClass (VIDEO + DATA_SYNC) to VIDEO directly
+                if (cwServiceClass == (CommandsInterface.SERVICE_CLASS_VIDEO
+                        | CommandsInterface.SERVICE_CLASS_DATA_SYNC)) {
+                    cwServiceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                }
+
+                CommunicationWaiting cw;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleGetCW(): mCwCache = " + mCwCache + ", curTime = "
+                        + curTime + ", mCwCacheLastQueried = " + mCwCacheLastQueried);
+                if ((mCwCache != null) && (phoneId == mCwCachePhoneId) &&
+                        (mCwCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleGetCW(): using ETAG mCwCache: " + mCwCache);
+                    requestXcapNetwork(phoneId);
+                    cw = mCwCache;
+                    cw.setNetwork(mNetwork);
+                    cw.refresh();
+                    mCwCacheLastQueried = curTime;
+                } else if ((mCwCache != null) && (phoneId == mCwCachePhoneId) &&
+                        ((curTime >= mCwCacheLastQueried)
+                        && ((curTime - mCwCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleGetCW(): using mCwCache: " + mCwCache);
+                    cw = mCwCache;
+                } else {
+                    requestXcapNetwork(phoneId);
+
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleGetCW(): XcapRoot = " + mXcapRoot);
+                        throw new UnknownHostException();
+                    }
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+                    cw = mSimservs.getCommunicationWaiting(true, mNetwork);
+                    mCwCache = cw;
+                    mCwCachePhoneId = phoneId;
+                    mCwCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleGetCW(): new mCwCache = " + mCwCache
+                            + ", curTime = " + curTime);
+                }
+                //[Question] Always support CW in XCAP?
+                if (cw.isActive()) {
+                    get_cw_response[0] = 1;
+                }
+                else {
+                    get_cw_response[0] = 0;
+                }
+                Rlog.d(LOG_TAG, "handleGetCW(): isActive = " + get_cw_response[0]);
+
+            } catch (UnknownHostException unknownHostException) {
+                mCwCache = null;
+                mCwCachePhoneId = -1;
+                mCwCacheLastQueried = 0;
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, unknownHostException);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCW(): XcapException");
+                mCwCache = null;
+                mCwCachePhoneId = -1;
+                mCwCacheLastQueried = 0;
+
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCW(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCW(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "handleGetCW():Start to Print Stack Trace");
+                mCwCache = null;
+                mCwCachePhoneId = -1;
+                mCwCacheLastQueried = 0;
+
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+
+                }
+            }
+            //
+
+            //[Example]
+            if (rr.mResult != null) {
+                //get_cw_response[0] = 1; //0:Disabled, 1:Enabled
+                //serviceClass:SERVICE_CLASS_VOICE(1), SERVICE_CLASS_VIDEO(512)
+                if (get_cw_response[0] == 1) {
+                    //Service Class (If get_cw_response[0] is 1, get_cw_response[1] must set bit#1
+                    // & enable corresponding serviceClass's bit)
+                    //See ril_ss.c's requestCallWaitingOperation()
+                    //In CallWaitingCheckBoxPreference.java's handleGetCallWaitingResponse()
+                    //-> setChecked(((cwArray[0] == 1) && ((cwArray[1] & 0x01) == 0x01)));
+                    //If VIDEO call waiting is enabled, it shoud set: get_cw_response[0]=1
+                    // && get_cw_response[1]= 513 (SERVICE_CLASS_VIDEO | 1);
+                    //In GsmMmiCode.java's onQueryComplete():
+                    //-> createQueryCallWaitingResultMessage(ints[1])
+                    //-> Check each bit:
+                    // sb.append(serviceClassToCFString(classMask & serviceClass):
+                    // Check each bit then append string
+
+                    if (cwServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                        //As per 3GPP TS 24.083, section 1.6 UE doesn't need to send service
+                        // class parameter in call waiting interrogation  to network
+                        //For CW Activation, it can only active for some specific service class
+                        // but the query result will be returned supported status of all service
+                        // classes
+                        get_cw_response[1] |= CommandsInterface.SERVICE_CLASS_VOICE;
+                        get_cw_response[1] |= CommandsInterface.SERVICE_CLASS_VIDEO;
+                    } else {
+                        get_cw_response[1] |= cwServiceClass;
+                        if (cwServiceClass == CommandsInterface.SERVICE_CLASS_VIDEO) {
+                            //Need to modify:If a user presses MMI string to query CW & only vidoe
+                            // call waiting is enabled
+                            //In this way, MMI code callback handler will regard as both voice
+                            // and video call waitings are enabled
+                            get_cw_response[1] |= CommandsInterface.SERVICE_CLASS_VOICE;
+                        }
+                    }
+                    Rlog.d(LOG_TAG, "handleGetCW(): class = " + get_cw_response[1]);
+                }
+                AsyncResult.forMessage(rr.mResult, get_cw_response, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        public void handleGetCB(MMTelSSRequest rr) {
+            int reqNo = -1;
+            int serialNo = -1;
+            int cbServiceClass = -1;
+            int phoneId = 0;
+            String cBFacility = "";
+            int get_cb_response [] = new int[1];
+            //default: CB is not disabled!
+            get_cb_response[0] = 0;
+
+            try {
+                rr.mp.setDataPosition(0);
+                reqNo = rr.mp.readInt();
+                serialNo = rr.mp.readInt();
+                cBFacility = rr.mp.readString();
+                cbServiceClass = rr.mp.readInt();
+                phoneId = rr.mp.readInt();
+                Rlog.d(LOG_TAG, "Read GET_CB Facility=" + cBFacility + ",serviceClass="
+                        + cbServiceClass);
+
+                if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                    Rlog.d(LOG_TAG, "handleGetCB(): !isPreferXcap()");
+                    throw new UnknownHostException();
+                }
+
+                int num_of_comparision = 0;
+
+                //Change the serviceClass (VIDEO + DATA_SYNC) to VIDEO directly
+                if (cbServiceClass == (CommandsInterface.SERVICE_CLASS_VIDEO
+                        | CommandsInterface.SERVICE_CLASS_DATA_SYNC)) {
+                    cbServiceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                }
+
+                if (cbServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                    cbServiceClass = CommandsInterface.SERVICE_CLASS_VOICE;
+                    //one is to match audio (i.e., serviceClass = SERVICE_CLASS_VOICE),
+                    // the other is to match video (i.e., SERVICE_CLASS_VIDEO)
+                    num_of_comparision = 2;
+                    Rlog.d(LOG_TAG, "cbServiceClass==0, try to 1st match by using"
+                            + " SERVICE_CLASS_VOICE");
+                } else {
+                    //Specific serviceClass (i.e., value is not 0) is carried from the upper layer
+                    num_of_comparision = 1;
+                }
+
+
+                //According to the cBFacility to choose the XML node to check CB's ruleset
+                if (cBFacility.equals(CommandsInterface.CB_FACILITY_BAOC) ||
+                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAOIC) ||
+                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAOICxH)) {
+                    OutgoingCommunicationBarring ocb;
+                    long curTime = System.currentTimeMillis();
+                    Rlog.d(LOG_TAG, "handleGetCB(): mOcbCache = " + mOcbCache + ", curTime = "
+                            + curTime + ", mOcbCacheLastQueried = " + mOcbCacheLastQueried);
+                    if ((mOcbCache != null) && (phoneId == mOcbCachePhoneId) &&
+                            (mOcbCache.isSupportEtag())) {
+                        Rlog.d(LOG_TAG, "handleGetCB(): using ETAG mOcbCache: " + mOcbCache);
+                        requestXcapNetwork(phoneId);
+                        ocb = mOcbCache;
+                        ocb.setNetwork(mNetwork);
+                        ocb.refresh();
+                        mOcbCacheLastQueried = curTime;
+                    } else if ((mOcbCache != null) && (phoneId == mOcbCachePhoneId) &&
+                            ((curTime >= mOcbCacheLastQueried)
+                            && ((curTime - mOcbCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                        Rlog.d(LOG_TAG, "handleGetCB(): using mOcbCache: " + mOcbCache);
+                        ocb = mOcbCache;
+                    } else {
+                        requestXcapNetwork(phoneId);
+
+                        mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                        mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                        mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                        if (TextUtils.isEmpty(mXcapRoot)) {
+                            Rlog.d(LOG_TAG, "handleGetCB(): XcapRoot = " + mXcapRoot);
+                            throw new UnknownHostException();
+                        }
+
+                        setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName,
+                                mPassword, phoneId);
+
+                        ocb = mSimservs.getOutgoingCommunicationBarring(true, mNetwork);
+                        mOcbCache = ocb;
+                        mOcbCachePhoneId = phoneId;
+                        mOcbCacheLastQueried = curTime;
+                        Rlog.d(LOG_TAG, "handleGetCB(): new mOcbCache = " + mOcbCache
+                                + ", curTime = " + curTime);
+                    }
+
+                    RuleSet ruleSet = ocb.getRuleSet();
+                    List<Rule> ruleList = null;
+
+                    if (ruleSet != null) {
+                        ruleList = ruleSet.getRules();
+                        if (ruleList == null) {
+                            Rlog.d(LOG_TAG, "Dump Get MO CB XML: ruleset with empty rules");
+                        } else {
+                            Rlog.d(LOG_TAG, "Dump Get MO CB XML:" + ruleSet.toXmlString());
+                        }
+                    } else {
+                        Rlog.d(LOG_TAG, "No MO related CB rules in remote server");
+                    }
+
+                    //Note that: If no ant configuration is stored in XCAP server (e.g., empty
+                    // xml string), ruleList will be null
+                    if (ruleList != null) {
+                        for (int it = 0; it < num_of_comparision; it++) {
+                            if (it == 1
+                                    && cbServiceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                                //2nd time to match all rules by using SERVICE_CLASS_VIDEO
+                                cbServiceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                                Rlog.d(LOG_TAG, "cbServiceClass==0, try to 2nd match by using "
+                                        + "SERVICE_CLASS_VIDEO");
+                            }
+                            //Check each rule & its corresponding condition/action
+                            for (int i = 0; i < ruleList.size(); i++) {
+                                Rule r = ruleList.get(i);
+                                Conditions cond = r.getConditions();
+                                Actions action = r.getActions();
+                                List<String> mediaList = null;
+
+                                Rlog.d(LOG_TAG, "handleGetCB():MO-facility=" + cBFacility
+                                        + ",action=" + action.isAllow());
+                                if (cond != null) {
+                                    Rlog.d(LOG_TAG, "handleGetCB():MO-international="
+                                            + cond.comprehendInternational() + ",roaming="
+                                            + cond.comprehendRoaming());
+                                    mediaList = cond.getMedias();
+                                } else {
+                                    Rlog.d(LOG_TAG, "handleGetCB():Empty MO cond (cond==null)"
+                                            + " for this rule=" + r);
+                                }
+
+                                if ((cond != null && cond.comprehendInternational()) &&
+                                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAOIC) &&
+                                        containSpecificMedia(mediaList, cbServiceClass)) {
+                                    if (action.isAllow() == false && (cond != null
+                                            && cond.comprehendRuleDeactivated() == false)) {
+                                        //BAOIC is enabled
+                                        get_cb_response[0] |= cbServiceClass;
+                                    } else {
+                                        get_cb_response[0] = 0;
+                                    }
+                                    break;
+                                } else if ((cond != null && cond.comprehendInternationalExHc()) &&
+                                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAOICxH) &&
+                                        containSpecificMedia(mediaList, cbServiceClass)) {
+                                    if (action.isAllow() == false && (cond != null
+                                            && cond.comprehendRuleDeactivated() == false)) {
+                                        //BAOICxH is enabled
+                                        get_cb_response[0] |= cbServiceClass;
+                                    } else {
+                                        get_cb_response[0] = 0;
+                                    }
+                                } else if (isBAOC(cond, cbServiceClass) &&
+                                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAOC)) {
+                                    //cond == null:BAOC is enabled
+                                    //cond != null && cond.comprehendRuleDeactivated() == false =>
+                                    // E.g., <cp:conditions><media>audio</media></cp:conditions>
+                                    if (action.isAllow() == false && (cond == null ||
+                                            (cond != null
+                                            && cond.comprehendRuleDeactivated() == false))) {
+                                        //BAOC is enabled
+                                        get_cb_response[0] |= cbServiceClass;
+                                    } else {
+                                        get_cb_response[0] = 0;
+                                    }
+                                    break;
+                                }
+                            } //end of for-loop(check each rule)
+                        } //end of for-loop(check all possible service classes)
+                    } else {
+                        //MO Barring Call is disabled
+                        Rlog.d(LOG_TAG, "ruleList is null, MO CB is disabled");
+                        get_cb_response[0] = 0;
+                    }
+
+                } else if (cBFacility.equals(CommandsInterface.CB_FACILITY_BAIC) ||
+                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAICr)) {
+                    IncomingCommunicationBarring icb;
+                    long curTime = System.currentTimeMillis();
+                    Rlog.d(LOG_TAG, "handleGetCB(): mIcbCache = " + mIcbCache + ", curTime = "
+                            + curTime + ", mIcbCacheLastQueried = " + mIcbCacheLastQueried);
+                    if ((mIcbCache != null) && (phoneId == mIcbCachePhoneId) &&
+                            (mIcbCache.isSupportEtag())) {
+                        Rlog.d(LOG_TAG, "handleGetCB(): using ETAG mIcbCache: " + mIcbCache);
+                        requestXcapNetwork(phoneId);
+                        icb = mIcbCache;
+                        icb.setNetwork(mNetwork);
+                        icb.refresh();
+                        mIcbCacheLastQueried = curTime;
+                    } else if ((mIcbCache != null) && (phoneId == mIcbCachePhoneId) &&
+                            ((curTime >= mIcbCacheLastQueried)
+                            && ((curTime - mIcbCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                        Rlog.d(LOG_TAG, "handleGetCB(): using mIcbCache: " + mIcbCache);
+                        icb = mIcbCache;
+                    } else {
+                        requestXcapNetwork(phoneId);
+
+                        mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                        mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                        mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                        if (TextUtils.isEmpty(mXcapRoot)) {
+                            Rlog.d(LOG_TAG, "handleGetCB(): XcapRoot = " + mXcapRoot);
+                            throw new UnknownHostException();
+                        }
+
+                        setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName,
+                                mPassword, phoneId);
+
+                        icb = mSimservs.getIncomingCommunicationBarring(true, mNetwork);
+                        mIcbCache = icb;
+                        mIcbCachePhoneId = phoneId;
+                        mIcbCacheLastQueried = curTime;
+                        Rlog.d(LOG_TAG, "handleGetCB(): new mIcbCache = " + mIcbCache
+                                + ", curTime = " + curTime);
+                    }
+
+                    RuleSet ruleSet = icb.getRuleSet();
+                    List<Rule> ruleList = null;
+
+                    if (ruleSet != null) {
+                        ruleList = ruleSet.getRules();
+                        if (ruleList == null) {
+                            Rlog.d(LOG_TAG, "Dump Get MT CB XML: ruleset with empty rules");
+                        } else {
+                            Rlog.d(LOG_TAG, "Dump Get MT CB XML:" + ruleSet.toXmlString());
+                        }
+                    } else {
+                        Rlog.d(LOG_TAG, "No MT related CB rules in remote server");
+                    }
+
+                    //Note that: If no ant configuration is stored in XCAP server (e.g.,
+                    // empty xml string), ruleList will be null
+                    if (ruleList != null) {
+                        for (int it = 0; it < num_of_comparision; it++) {
+                            if (it == 1
+                                    && cbServiceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                                //2nd time to match all rules by using SERVICE_CLASS_VIDEO
+                                cbServiceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                                Rlog.d(LOG_TAG, "cbServiceClass==0, try to 2nd match by using"
+                                        + " SERVICE_CLASS_VIDEO");
+                            }
+                            for (int i = 0; i < ruleList.size(); i++) {
+                                Rule r = ruleList.get(i);
+                                Conditions cond = r.getConditions();
+                                Actions action = r.getActions();
+                                List<String> mediaList = null;
+
+                                Rlog.d(LOG_TAG, "handleGetCB():MT-facility=" + cBFacility
+                                        + ",action=" + action.isAllow());
+                                if (cond != null) {
+                                    Rlog.d(LOG_TAG, "handleGetCB():MT-international="
+                                            + cond.comprehendInternational() + ",roaming="
+                                            + cond.comprehendRoaming() + ",anonymous="
+                                            + cond.comprehendAnonymous());
+                                    mediaList = cond.getMedias();
+                                } else {
+                                    Rlog.d(LOG_TAG, "handleGetCB():Empty MT cond (cond==null)"
+                                            + " for this rule=" + r);
+                                }
+
+                                if ((cond != null && cond.comprehendRoaming()) &&
+                                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAICr) &&
+                                        containSpecificMedia(mediaList, cbServiceClass)) {
+                                    if (action.isAllow() == false && (cond != null
+                                            && cond.comprehendRuleDeactivated() == false)) {
+                                        //BAICr is enabled
+                                        get_cb_response[0] |= cbServiceClass;
+                                    } else {
+                                        get_cb_response[0] = 0;
+                                    }
+                                } else if (isBAIC(cond, cbServiceClass) &&
+                                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAIC)) {
+                                    //cond == null:BAIC is enabled
+                                    //cond != null && cond.comprehendRuleDeactivated() == false
+                                    // => E.g., <cp:conditions><media>audio</media></cp:conditions>
+                                    if (action.isAllow() == false && (cond == null || (cond != null
+                                            && cond.comprehendRuleDeactivated() == false))) {
+                                        //BAIC is enabled
+                                        get_cb_response[0] |= cbServiceClass;
+                                    } else {
+                                        get_cb_response[0] = 0;
+                                    }
+
+                                }
+                            } //end of for-loop(check each rule)
+                        } //end of for-loop(check each possible service class)
+                    } else {
+                        //MT Barring Call is disabled
+                        Rlog.d(LOG_TAG, "ruleList is null, MT CB is disabled");
+                        get_cb_response[0] = 0;
+                    }
+                } else {
+                    //Add handling Barring Service for 330(AB)/333(AG)/353(AC) cases - Only allow
+                    // to unlock (i.e.,disable)
+                    /***
+                     * "AO" BAOC (Barr All Outgoing Calls) (refer 3GPP TS 22.088 [6] clause 1)
+                     * "OI" BOIC (Barr Outgoing International Calls) (refer 3GPP TS 22.088 [6]
+                     * clause 1)
+                     * "OX" BOIC exHC (Barr Outgoing International Calls except to Home Country)
+                     * (refer 3GPP TS 22.088 [6] clause 1)
+                     * "AI" BAIC (Barr All Incoming Calls) (refer 3GPP TS 22.088 [6] clause 2)
+                     * "IR" BIC Roam (Barr Incoming Calls when Roaming outside the home country)
+                     * (refer 3GPP TS 22.088 [6] clause 2)
+                     * "AB" All Barring services (refer 3GPP TS 22.030 [19]) (applicable only for
+                     * <mode>=0: i.e.,unlock - ref: +CLCK & 2/3G SS Spec)
+                     * "AG" All outGoing barring services (refer 3GPP TS 22.030 [19]) (applicable
+                     * only for <mode>=0: i.e.,unlock - ref: +CLCK & 2/3G SS Spec)
+                     * "AC" All inComing barring services (refer 3GPP TS 22.030 [19]) (applicable
+                     * only for <mode>=0: i.e.,unlock - ref: +CLCK & 2/3G SS Spec)
+                     */
+                    Rlog.d(LOG_TAG, "handleGetCB(): Not support query for CB Facility="
+                            + cBFacility);
+                }
+
+            } catch (UnknownHostException unknownHostException) {
+                mOcbCache = null;
+                mOcbCachePhoneId = -1;
+                mOcbCacheLastQueried = 0;
+                mIcbCache = null;
+                mIcbCachePhoneId = -1;
+                mIcbCacheLastQueried = 0;
+
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, unknownHostException);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCB(): XcapException");
+                mOcbCache = null;
+                mOcbCachePhoneId = -1;
+                mOcbCacheLastQueried = 0;
+                mIcbCache = null;
+                mIcbCachePhoneId = -1;
+                mIcbCacheLastQueried = 0;
+
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCB(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCB(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "handleGetCB():Start to Print Stack Trace");
+                mOcbCache = null;
+                mOcbCachePhoneId = -1;
+                mOcbCacheLastQueried = 0;
+                mIcbCache = null;
+                mIcbCachePhoneId = -1;
+                mIcbCacheLastQueried = 0;
+
+                get_cb_response[0] = 0;
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+
+                }
+            }
+
+            //[Example]Fill the fake-result just for testing first by mtk01411
+            if (rr.mResult != null) {
+                //If response[0] = 0 (means that disable), otherwise response[0] will be set
+                // the corresponding serviceClass for this CallBarring
+                /*
+                if (cBFacility.equals(CommandsInterface.CB_FACILITY_BAOIC)) {
+                    get_cb_response[0] = CommandsInterface.SERVICE_CLASS_VOICE;
+                } else {
+                    //It means that: CB is disabled for this facility
+                    get_cb_response[0] = CommandsInterface.SERVICE_CLASS_NONE;
+                }
+                 */
+
+                //For Call Setting query: In CallBarringBasePreference.java's
+                // handleGetCallBarringResponse()
+                //-> int value = ints[0]; value = value & mServiceClass;
+                //It means that if the query result (e.g., both voice & video calls enable CB):
+                // Please set corresponding bit of this servicClass
+                //E.g., get_cb_response[0] = 513 (SERVICE_CLASS_VIDEO:512 + SERVICE_CLASS_VOICE:1)
+                //For GsmMmiCode query: In GsmMmiCode.java's onQueryComplete()
+                //-> createQueryCallBarringResultMessage(ints[0]):
+                //-> Check each bit then append corresponding string:
+                // sb.append(serviceClassToCFString(classMask & serviceClass));
+                AsyncResult.forMessage(rr.mResult, get_cb_response, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        public void handleGetCF(MMTelSSRequest rr) {
+            int reqNo = -1;
+            int serialNo = -1;
+            int numInfos = 1;
+            CallForwardInfo infos[] = null;
+            ArrayList<CallForwardInfo> queriedCallForwardInfoList;
+            queriedCallForwardInfoList = new ArrayList<CallForwardInfo>();
+
+            int cfAction = -1;
+            int reason = -1;
+            int serviceClass = -1;
+            int orgServiceClass = -1;
+            String cfNumber = "";
+            String CFPhoneNum = "";
+            int queryStatus = 0; //0: DISABLE, 1: ENABLE
+            int noReplyTimer = 20;
+            int phoneId = 0;
+
+            try {
+                //Solution#1: Parcel:int(request),int(mSerial),int(status),int(reason),
+                //int(serviceClass)
+                //byte data[];
+                //data = rr.mp.marshall();
+                //Note that: It must invoke Parcel's recycle() here because in obtain():
+                // It gets a Parcel object from pool then writes two int values into this object
+                //Now: It already handles this request, it's time to recycle this object back to
+                // the pool
+                //rr.mp.recycle();
+                //rr.mp = null;
+                //int reqNo = data[0];
+                //int serialNo = data[4];
+                //int status = data[8];
+                //int reason = data[12];
+                //int serviceClass = data[16];
+
+                //Solution#2: Reset Data Position back to 0 (head) to start to read the data
+                // filled previously
+                rr.mp.setDataPosition(0);
+                reqNo = rr.mp.readInt();
+                serialNo = rr.mp.readInt();
+                cfAction = rr.mp.readInt();
+                reason = rr.mp.readInt();
+                serviceClass = rr.mp.readInt();
+                orgServiceClass = serviceClass;
+                cfNumber = rr.mp.readString();
+                phoneId = rr.mp.readInt();
+
+                if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                    Rlog.d(LOG_TAG, "handleGetCF(): !isPreferXcap()");
+                    throw new UnknownHostException();
+                }
+
+                Rlog.d(LOG_TAG, "Read from CF parcel:req=" + requestToString(reqNo) + ",cfAction="
+                        + cfAction + ",reason=" + reason + ",serviceClass=" + serviceClass
+                        + ",number=" + cfNumber);
+
+                CommunicationDiversion cd;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleGetCF(): mCdCache = " + mCdCache + ", curTime = "
+                        + curTime + ", mCdCacheLastQueried = " + mCdCacheLastQueried);
+                if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        (mCdCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleGetCF(): using ETAG mCdCache: " + mCdCache);
+                    requestXcapNetwork(phoneId);
+                    cd = mCdCache;
+                    cd.setNetwork(mNetwork);
+                    cd.refresh();
+                    mCdCacheLastQueried = curTime;
+                } else if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        ((curTime >= mCdCacheLastQueried)
+                        && ((curTime - mCdCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleGetCF(): using mCdCache: " + mCdCache);
+                    cd = mCdCache;
+                } else {
+                    requestXcapNetwork(phoneId);
+
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleGetCF(): XcapRoot = " + mXcapRoot);
+                        throw new UnknownHostException();
+                    }
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+
+                    cd = mSimservs.getCommunicationDiversion(true, mNetwork);
+                    mCdCache = cd;
+                    mCdCachePhoneId = phoneId;
+                    mCdCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleGetCF(): new mCdCache = " + mCdCache
+                            + ", curTime = " + curTime);
+                }
+
+                //[M2]Reference to SimServsTest.java
+                //XcapDocumentSelector documentSelector = new XcapDocumentSelector(
+                //XcapConstants.AUID_RESOURCE_LISTS, TEST_USER, TEST_DOC);
+                //Rlog.d(LOG_TAG, "document selector is " + documentSelector.toString());
+                //XcapUri xcapUri = new XcapUri();
+                //xcapUri.setXcapRoot(XCAP_ROOT).setDocumentSelector(documentSelector);
+                //CommunicationDiversion cd =
+                //  mSimservs.getCommunicationDiversion(xcapUri, TEST_USER,"password");
+                Rlog.d(LOG_TAG, "handleGetCF():GetRuleSet from cd");
+
+                RuleSet ruleSet = cd.getRuleSet();
+                //In Communication Diversion's RuleSet, it may have several rules (e.g., rule
+                // for CFU, rule for CFB, rule for CFNoAnswer, rule for CFNotReachable)
+                List<Rule> ruleList = null;
+
+                if (ruleSet != null) {
+                    ruleList = ruleSet.getRules();
+                } else {
+                    Rlog.d(LOG_TAG, "No CF related rules in remote server");
+                }
+
+                //Note that: If no ant configuration is stored in XCAP server (e.g., empty
+                // xml string), ruleList will be null
+                if (ruleList != null) {
+
+                    int num_of_expansion = 1;
+                    if (reason == CommandsInterface.CF_REASON_ALL_CONDITIONAL) {
+                        //In this case: User inputs "*#004#"
+                        //CF Conditional (BUSY/NO_REPLY/NOT_REACHABLE/NOT_REGISTERED)x4
+                        num_of_expansion = 4;
+                    } else if (reason == CommandsInterface.CF_REASON_ALL) {
+                        //CF Conditional (BUSY/NO_REPLY/NOT_REACHABLE/NOT_REGISTERED)x4 + CFUx1
+                        //In this case: User inputs "*#002#"
+                        num_of_expansion = 5;
+                    }
+
+                    for (int n = 0; n < num_of_expansion; n++) {
+                        if (num_of_expansion != 1) {
+                            if (n == 0) reason = CommandsInterface.CF_REASON_BUSY;
+                            else if (n == 1) reason = CommandsInterface.CF_REASON_NO_REPLY;
+                            else if (n == 2) reason = CommandsInterface.CF_REASON_NOT_REACHABLE;
+                            else if (n == 3) reason = CommandsInterface.CF_REASON_NOT_REGISTERED;
+                            else if (n == 4) reason = CommandsInterface.CF_REASON_UNCONDITIONAL;
+                        }
+
+                        Rlog.d(LOG_TAG, "num_of_expansion=" + num_of_expansion + ": with round="
+                                + (n + 1) + ",with reason=" + reason);
+
+                        //Change the serviceClass (VIDEO + DATA_SYNC) to VIDEO directly
+                        if (orgServiceClass == (CommandsInterface.SERVICE_CLASS_VIDEO
+                                | CommandsInterface.SERVICE_CLASS_DATA_SYNC)) {
+                            serviceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                        }
+
+                        //E.g.,GsmMmiCode:MMI String can be :*#21#[CFU] or *#67#[CFB] or
+                        // *#61#[CF NoAnswer] or *#62#[CF Not Reachable]
+                        //=> Without serviceClass information, then serviceClass=0 is passed to
+                        // MMTelSS
+                        int num_of_comparision = 0;
+
+                        if (orgServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                            serviceClass = CommandsInterface.SERVICE_CLASS_VOICE;
+                            //one is to match audio (i.e., serviceClass = SERVICE_CLASS_VOICE), the
+                            // other is to match video (i.e., SERVICE_CLASS_VIDEO)
+                            num_of_comparision = 2;
+                            Rlog.d(LOG_TAG, "serviceClass==0, try to 1st match by using"
+                                    + " SERVICE_CLASS_VOICE");
+                        } else {
+                            //Specific serviceClass (i.e., value is not 0) is carried from the
+                            // upper layer
+                            num_of_comparision = 1;
+                        }
+
+                        for (int it = 0; it < num_of_comparision; it++) {
+
+                            if (it == 1 && serviceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                                //2nd time to match all rules by using SERVICE_CLASS_VIDEO
+                                serviceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                                Rlog.d(LOG_TAG, "serviceClass==0, try to 2nd match by using "
+                                        + "SERVICE_CLASS_VIDEO");
+                            }
+
+                            Rlog.d(LOG_TAG, "num_of_comparision=" + num_of_comparision
+                                    + ": with round=" + (it + 1) + ",with service class="
+                                    + serviceClass);
+
+                            //Check each rule & its corresponding condition/action
+                            for (int i = 0; i < ruleList.size(); i++) {
+                                Rule r = ruleList.get(i);
+                                Conditions cond = r.getConditions();
+                                Actions action = r.getActions();
+                                List<String> mediaList = null;
+
+                                if (cond != null) {
+                                    Rlog.d(LOG_TAG, "handleGetCF():busy=" + cond.comprehendBusy()
+                                            + ",NoAnswer=" + cond.comprehendNoAnswer()
+                                            + ",NoReachable=" + cond.comprehendNotReachable()
+                                            + ",NotRegistered=" + cond.comprehendNotRegistered());
+                                    mediaList = cond.getMedias();
+                                } else {
+                                    Rlog.d(LOG_TAG, "handleGetCF():Empty cond (cond==null) "
+                                            + "for this rule=" + r);
+                                }
+
+                                //See queryCallForwardStatus(): cfAction is always set to 2
+                                if (cfAction == 2
+                                        && reason == CommandsInterface.CF_REASON_UNCONDITIONAL &&
+                                        ((cond != null && cond.comprehendBusy() == false &&
+                                        cond.comprehendNoAnswer() == false &&
+                                        cond.comprehendNotRegistered() == false &&
+                                        cond.comprehendNotReachable() == false) &&
+                                        cond.comprehendRuleDeactivated() == false || cond == null)
+                                        && containSpecificMedia(mediaList, serviceClass)) {
+                                    Rlog.d(LOG_TAG, "handleGetCF():CFU is enabled on server");
+                                    //[CFU]CFU is enabled, set queryStatus as 1
+                                    queryStatus = 1;
+                                    if (action.getFowardTo() != null) {
+                                        CFPhoneNum = action.getFowardTo().getTarget();
+                                    }
+                                    //timeSeconds: This field is not required by CFU (Only required
+                                    // by CFNoAnswer)
+                                    noReplyTimer = cd.getNoReplyTimer();
+                                    break;
+
+                                } else if (cfAction == 2
+                                        && reason == CommandsInterface.CF_REASON_BUSY &&
+                                        (cond != null && cond.comprehendBusy() == true
+                                        && cond.comprehendRuleDeactivated() == false) &&
+                                        containSpecificMedia(mediaList, serviceClass)) {
+                                    Rlog.d(LOG_TAG, "handleGetCF():CFB is enabled on server");
+                                    //[CFB]CFB is ensabled, set queryStatus as 0
+                                    queryStatus = 1;
+                                    if (action.getFowardTo() != null) {
+                                        CFPhoneNum = action.getFowardTo().getTarget();
+                                    }
+                                    noReplyTimer = cd.getNoReplyTimer();
+                                    break;
+
+                                } else if (cfAction == 2
+                                        && reason == CommandsInterface.CF_REASON_NO_REPLY &&
+                                        (cond != null && cond.comprehendNoAnswer() == true &&
+                                        cond.comprehendRuleDeactivated() == false) &&
+                                        containSpecificMedia(mediaList, serviceClass)) {
+                                    Rlog.d(LOG_TAG, "handleGetCF():CFNoAnswer is enabled on "
+                                            + "server");
+                                    //[CFNoAnswer]CFNoReply is ensabled, set queryStatus as 1
+                                    queryStatus = 1;
+                                    if (action.getFowardTo() != null) {
+                                        CFPhoneNum = action.getFowardTo().getTarget();
+                                    }
+                                    noReplyTimer = cd.getNoReplyTimer();
+                                    break;
+
+                                } else if (cfAction == 2
+                                        && reason == CommandsInterface.CF_REASON_NOT_REACHABLE &&
+                                        (cond != null && cond.comprehendNotReachable() == true &&
+                                        cond.comprehendRuleDeactivated() == false) &&
+                                        containSpecificMedia(mediaList, serviceClass)) {
+                                    Rlog.d(LOG_TAG, "handleGetCF():CFNotReachable is enabled"
+                                            + " on server");
+                                    //[CFNotReachable]CFNotReachable is enabled, set queryStatus
+                                    // as 1
+                                    queryStatus = 1;
+                                    if (action.getFowardTo() != null) {
+                                        CFPhoneNum = action.getFowardTo().getTarget();
+                                    }
+                                    noReplyTimer = cd.getNoReplyTimer();
+                                    break;
+
+                                } else if (cfAction == 2
+                                        && reason == CommandsInterface.CF_REASON_NOT_REGISTERED &&
+                                        (cond != null && cond.comprehendNotRegistered() == true &&
+                                        cond.comprehendRuleDeactivated() == false) &&
+                                        containSpecificMedia(mediaList, serviceClass)) {
+                                    Rlog.d(LOG_TAG, "handleGetCF():CFNotRegistered is enabled on "
+                                            + "server");
+                                    //[CFNotRegistered]CFNotRegistered is enabled, set queryStatus
+                                    // as 1
+                                    queryStatus = 1;
+                                    if (action.getFowardTo() != null) {
+                                        CFPhoneNum = action.getFowardTo().getTarget();
+                                    }
+                                    noReplyTimer = cd.getNoReplyTimer();
+                                    break;
+
+                                } else {
+                                    //Something wrong!
+                                    Rlog.d(LOG_TAG, "handleGetCF()from xcap:Not matched "
+                                            + "this rule!");
+                                }
+
+                            } //end of for-loop(ruleList.size())
+                            //Add this queried & matched result into the matchedCallForwardInfoList
+                            CallForwardInfo item = new CallForwardInfo();
+                            item.status = queryStatus;
+                            item.reason = reason;
+                            item.serviceClass = serviceClass;
+                            item.toa = 0;
+                            item.number = CFPhoneNum;
+                            item.timeSeconds = noReplyTimer;
+                            Rlog.d(LOG_TAG, "handleGetCF():add one record with reason=" + reason
+                                    + ",serviceClass=" + serviceClass + ",queryStatus="
+                                    + queryStatus);
+                            queriedCallForwardInfoList.add(item);
+
+                            //Reset some variables for this matching result
+                            queryStatus = 0; //0: DISABLE, 1: ENABLE
+                            CFPhoneNum = "";
+                            noReplyTimer = 20;
+                        } //end of for-loop(num_of_comparision)
+
+                    } //end of for-loop(num_of_expansion)
+
+                    //After checking all rules in the ruleset, it will update the results for this
+                    // serviceClass entry
+                    //For Call Setting query, it will be handled by
+                    // CallForwardEditPreference.java's handleGetCFResponse()
+                    //For GsmMmiCode query, it will be handled by GsmMmiCode.java's
+                    // onQueryCfComplete()
+                    int queriedSize = queriedCallForwardInfoList.size();
+
+                    infos = new CallForwardInfo[queriedSize];
+                    for (int inx = 0; inx < queriedSize; inx++) {
+                        infos[inx] = (CallForwardInfo) queriedCallForwardInfoList.get(inx);
+                    }
+
+                } else {
+                    //Empty XML String:CF is disabled, set queryStatus as 0
+                    Rlog.d(LOG_TAG, "handleGetCF():get null ruleList");
+                    infos = new CallForwardInfo[0];
+                    queryStatus = 0;
+                }
+
+            } catch (UnknownHostException unknownHostException) {
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, unknownHostException);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCF(): XcapException");
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCF(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCF(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "handleGetCF():Start to Print Stack Trace");
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                e.printStackTrace();
+
+                //Add by mtk01411 (2014-0128)
+                //If not returns here, it may report infos.size!=0 but both info[0] and info[1] are
+                // null -> Cause JE happens in CallForwardEditPreference.java line#379:Null Pointer
+                // Exception
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+
+                }
+
+            }
+
+
+            //[Example - According to the reason to fill the queryStatus and CFPhoneNum -> These
+            // two fields are checked by application]
+            /*
+            if (reason == CommandsInterface.CF_REASON_UNCONDITIONAL) {
+                CFPhoneNum = "";
+                //Note that: If CFU's queryStatus=1(active/enabled), then CFB,CFNoAnswer and
+                // CFNotReachable will be disabled on UI
+                //Because CFU means that call must be forwarded unconditionally -> In this way,
+                // UI must also disabled the editable item for others CF
+                //If CFU's queryStatus=0(no active/disabled), UI must provide the editable item
+                // of CFB,CFNoAnswer and CFNotReachable for users to set phone number as their will
+                queryStatus = 0;
+            } else {
+                queryStatus = 1;
+            }
+             */
+
+            //[Example - CF Response Structure]
+            if (rr.mResult != null) {
+                /*
+                infos[0] = new CallForwardInfo();
+                infos[0].status = queryStatus;
+                infos[0].reason = reason;
+                infos[0].serviceClass = serviceClass;
+                infos[0].toa = 0;
+                infos[0].number = CFPhoneNum;
+                infos[0].timeSeconds = noReplyTimer;
+                 */
+
+                AsyncResult.forMessage(rr.mResult, infos, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        // This API is used to create new CF rule matched the serviceclass & reason specified by
+        // the user in user's configuration at this time
+        // E.g., User wants to disable CFB for voice call and XCAP server has one rule - CFB for
+        // both voice & video calls currently
+        // In this way, we can create the rule disabled CFB for voice call first by this API
+        // then copy old rule except voice type into new rule set to present that: BAOC for video
+        // call is still enabled
+        public boolean handleCreateNewRuleForExistingCF(CommunicationDiversion cd,
+                RuleSet newRuleSet, Rule r, int setCFReason, int setCFAction,
+                int setCFServiceClass, String setCFNumber, int setCFTimeSeconds, String ruleID,
+                boolean updateSingleRule, int numExpansion, int phoneId) throws XcapException {
+            Conditions cond = r.getConditions();
+            Actions action = r.getActions();
+
+            //For testing purpose, it will read XCAP Rule Disable Mode (xrdm) from system property
+            String sDisableRuleMode = SystemProperties.get(PROP_SS_DISABLE_METHOD,
+                    Integer.toString(DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG));
+            Rlog.d(LOG_TAG, "handleCreateNewRuleForExistingCF():sDisableRuleMode="
+                    + sDisableRuleMode);
+            mDisableRuleMode = Integer.parseInt(sDisableRuleMode);
+
+            //Find this rule for this time's request
+            if (setCFAction == CommandsInterface.CF_ACTION_ENABLE
+                    || setCFAction == CommandsInterface.CF_ACTION_REGISTRATION) {
+                //Create a new rule (C1:Modify existing CFB (e.g.,forwarded number)
+                Rule cfRule = newRuleSet.createNewRule(ruleID);
+                Conditions cfCond = cfRule.createConditions();
+                Actions cfAction = cfRule.createActions();
+                Rlog.d(LOG_TAG, "handleCreateNewRuleForExistingCF():Enable CF with reason="
+                        + setCFReason + ",serviceClass=" + setCFServiceClass + ",number="
+                        + setCFNumber + ",cfTime=" + setCFTimeSeconds);
+                //Add media into this new rule
+                if (!MMTelSSUtils.isOp06IccCard(phoneId)
+                    && !MMTelSSUtils.isOp07IccCard(phoneId)) {
+                    if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                        cfCond.addMedia("audio");
+                    } else if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_VIDEO) {
+                        cfCond.addMedia("video");
+                    } else if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                        cfCond.addMedia("audio");
+                        cfCond.addMedia("video");
+                    }
+                }
+
+                if (setCFReason == CommandsInterface.CF_REASON_BUSY) {
+                    cfCond.addBusy();
+                } else if (setCFReason == CommandsInterface.CF_REASON_NO_REPLY) {
+                    cfCond.addNoAnswer();
+                } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REACHABLE) {
+                    cfCond.addNotReachable();
+                } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REGISTERED) {
+                    cfCond.addNotRegistered();
+                } else if (setCFReason == CommandsInterface.CF_REASON_UNCONDITIONAL) {
+                    //Not set any conditions -> always evaluate the result as true
+                }
+
+                // + [ALPS02292552] If empty, set the value from server.
+                if (setCFNumber == null || setCFNumber.isEmpty()) {
+                    setCFNumber = action.getFowardTo().getTarget();
+                    Rlog.d(LOG_TAG, "Reason: " + setCFReason +
+                        ", setCFNumber is empty or null, so update to: " + setCFNumber);
+                }
+                // - [ALPS02292552]
+
+                if (MMTelSSUtils.isOp01IccCard(phoneId) && MMTelSSUtils.isNotifyCallerTest()) {
+                    cfAction.setFowardTo(setCFNumber, false);
+                } else {
+                    cfAction.setFowardTo(setCFNumber, true);
+                }
+                cfAction.getFowardTo().setRevealIdentityToCaller(true);
+                cfAction.getFowardTo().setRevealIdentityToTarget(true);
+                if (updateSingleRule && (1 == numExpansion)) {
+                    cd.saveRule(ruleID);
+                }
+                return true;
+            } else {
+                //Disable CFB for existing rule (Remove tihs rule -> i.e., Not copy this existing
+                // rule to newRuleSet)
+                if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                    if (mDisableRuleMode == DISABLE_MODE_DELETE_RULE) {
+                        Rlog.d(LOG_TAG, "Disable CF for serviceClass=0 (all media types):neither "
+                                + "create new rule nor copy old rule to new rule set");
+                        if (updateSingleRule) {
+                            Rlog.e(LOG_TAG, "handleCreateNewRuleForExistingCF(): ERROR: "
+                                    + "DISABLE_MODE_DELETE_RULE but updateSingleRule");
+                        }
+                        return false;
+                    } else if (mDisableRuleMode == DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG) {
+                        Rlog.d(LOG_TAG, "Disable CF for serviceClass=0 (all media types):copy old "
+                                + "rule with <rule-deactivated> into new rule set");
+                        Rule nr = copyOldRuleToNewRuleSet(r, newRuleSet, setCFAction, setCFReason);
+                        nr.getConditions().addRuleDeactivated();
+                        if (updateSingleRule && (1 == numExpansion)) {
+                            cd.saveRule(nr.mId);
+                        }
+                        return true;
+                    }
+                } else if (hasExtraMedia(cond.getMedias(), setCFServiceClass)) {
+                    if (updateSingleRule && (1 == numExpansion)) {
+                        //We just remove one media type which is marked to disable the Call
+                        // Forwarding (but the remaining media types must keep their original rule)
+                        Rule newRule = copyOldRuleToNewRuleSetExceptSpecificMedia(r, newRuleSet,
+                                    setCFServiceClass, phoneId, setCFAction, setCFReason);
+                        if (newRule != null) {
+                            cd.saveRule(newRule.mId);
+                        }
+                        return true;
+                    }
+                    if (mDisableRuleMode == DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG) {
+                        Rlog.d(LOG_TAG, "Disable" + " " + ruleID + ":copy old rule with "
+                                + "<rule-deactivated> for this media types to new rule set");
+                        Rule nr = copyOldRuleToNewRuleSet(r, newRuleSet, setCFAction, setCFReason);
+                        nr.getConditions().addRuleDeactivated();
+                    }
+
+                    Rlog.d(LOG_TAG, "Disable" + " " + ruleID
+                            + ":copy old rule for remaining media types to new rule set");
+                    //We just remove one media type which is marked to disable the Call
+                    // Forwarding (but the remaining media types must keep their original rule)
+                    copyOldRuleToNewRuleSetExceptSpecificMedia(r, newRuleSet, setCFServiceClass,
+                            phoneId, setCFAction, setCFReason);
+                    return true;
+                } else {
+                    //Exactly matched & only one serviceclass!
+                    if (mDisableRuleMode == DISABLE_MODE_DELETE_RULE) {
+                        Rlog.d(LOG_TAG, "Disable" + " " + ruleID
+                                + ":not copy old rule to new rule set");
+                        if (updateSingleRule) {
+                            Rlog.e(LOG_TAG, "handleCreateNewRuleForExistingCF(): ERROR: "
+                                    + "DISABLE_MODE_DELETE_RULE but updateSingleRule");
+                        }
+                        return false;
+                    } else if (mDisableRuleMode == DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG) {
+                        Rlog.d(LOG_TAG, "Disable" + " " + ruleID
+                                + ":copy old rule with <rule-deactivated> to new rule set");
+                        Rule nr = copyOldRuleToNewRuleSet(r, newRuleSet, setCFAction, setCFReason);
+                        nr.getConditions().addRuleDeactivated();
+                        if (updateSingleRule && (1 == numExpansion)) {
+                            cd.saveRule(nr.mId);
+                        }
+                        return true;
+                    }
+                }
+                return false;
+            }
+        }
+
+        // This API is used to create new CB rule matched the serviceclass & reason specified
+        // by the user in user's configuration at this time
+        // E.g., User wants to disable BAOC for voice call and XCAP server has one rule - BAOC
+        // for both voice & video calls currently
+        // In this way, we can create the rule disabled BAOC for voice call first by this API
+        // then copy old rule except voice type into new rule set to present that: BAOC for video
+        // call is still enabled
+        public boolean handleCreateNewRuleForExistingCB(SimservType ssType, RuleSet newRuleSet,
+                Rule r, String facility, int lockState, int setCBServiceClass, String RuleID,
+                boolean updateSingleRule, int num_of_expansion, int phoneId) throws XcapException {
+            Conditions cond = r.getConditions();
+            Actions action = r.getActions();
+            boolean cbAllow = true;
+            boolean addRuleDeactivatedNode = false;
+
+            //For testing purpose, it will read XCAP Rule Disable Mode (xrdm) from system property
+            String sDisableRuleMode = SystemProperties.get(PROP_SS_DISABLE_METHOD,
+                    Integer.toString(DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG));
+            Rlog.d(LOG_TAG, "handleCreateNewRuleForExistingCB():sDisableRuleMode="
+                    + sDisableRuleMode);
+            mDisableRuleMode = Integer.parseInt(sDisableRuleMode);
+
+            if (lockState == 1) {
+                //Enable CB (Because it always creates a new rule for this service class, it will
+                //only have <allow> and no <rule-deactivated>)
+                cbAllow = false;
+            } else {
+                //Disable CB
+                if (mDisableRuleMode == DISABLE_MODE_DELETE_RULE) {
+                    Rlog.d(LOG_TAG, "Disable CB for serviceClass=" + setCBServiceClass
+                            + " ,not create new rule for it to put in the new rule set");
+                    if (updateSingleRule) {
+                        Rlog.e(LOG_TAG, "handleCreateNewRuleForExistingCB(): ERROR:"
+                                + " DISABLE_MODE_DELETE_RULE but updateSingleRule");
+                    }
+                    return false;
+                } else if (mDisableRuleMode == DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG) {
+                    // Usage: add <rule-deactivated> to disable this CB rule, then keep <allow>
+                    // value as false
+                    addRuleDeactivatedNode = true;
+                    cbAllow = false;
+                } else if (mDisableRuleMode == DISABLE_MODE_CHANGE_CB_ALLOW) {
+                    cbAllow = true;
+                }
+            }
+
+            Rule cbRule = newRuleSet.createNewRule(RuleID);
+            Conditions cbCond = cbRule.createConditions();
+            Actions cbAction = cbRule.createActions();
+
+            //Add media into this new rule
+            if (!MMTelSSUtils.isOp06IccCard(phoneId)
+                && !MMTelSSUtils.isOp07IccCard(phoneId)) {
+                if (setCBServiceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                    cbCond.addMedia("audio");
+                } else if (setCBServiceClass == CommandsInterface.SERVICE_CLASS_VIDEO) {
+                    cbCond.addMedia("video");
+                } else if (setCBServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                    cbCond.addMedia("audio");
+                    cbCond.addMedia("video");
+                }
+            }
+
+            // Usage: add <rule-deactivated> to disable this CB rule, then keep <allow> value as
+            // false
+            if (mDisableRuleMode == DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG
+                    && addRuleDeactivatedNode == true) {
+                cbCond.addRuleDeactivated();
+            }
+
+            if (facility.equals(CommandsInterface.CB_FACILITY_BAICr)) {
+                cbCond.addRoaming();
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAIC)) {
+                //Bar All Incoming Calls (no conditions -> evaluate the result as true directly)
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOIC)) {
+                cbCond.addInternational();
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOICxH)) {
+                cbCond.addInternationalExHc();
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOC)) {
+                //Bar All Outgoing Calls (no conditions -> evaluate the result as true directly)
+                cbAction.setAllow(cbAllow);
+            }
+
+            if (updateSingleRule && (1 == num_of_expansion)) {
+                if (ssType instanceof OutgoingCommunicationBarring) {
+                    OutgoingCommunicationBarring ocb = (OutgoingCommunicationBarring) ssType;
+                    ocb.saveRule(RuleID);
+                } else if (ssType instanceof IncomingCommunicationBarring) {
+                    IncomingCommunicationBarring icb = (IncomingCommunicationBarring) ssType;
+                    icb.saveRule(RuleID);
+                }
+            }
+
+            return true;
+        }
+
+        /* This API is used to add one new rule not occurred & matched in the XCAP server */
+        /* E.g., In original XCAP server:Only BAOC, then user enables the BOIC */
+        public boolean handleCreateNewRuleForReqCB(SimservType ssType, RuleSet newRuleSet,
+                String facility, int lockState, int setCBServiceClass, String RuleID,
+                boolean updateSingleRule, int num_of_expansion, int phoneId) throws XcapException {
+            boolean cbAllow = true;
+
+            if (lockState == 1) {
+                //Enable CB
+                cbAllow = false;
+            } else {
+                //Disable CB:It means that the user disable one existed rule!
+                //Note:If the user wants to disable one rule but no any matched one stored in XCAP
+                // server,
+                //It is not allowed to add this disabled rule into the ruleset: retunr from this
+                //API directly
+                cbAllow = true;
+                Rlog.d(LOG_TAG, "Disable one non-existed rule!Return from "
+                        + "handleCreateNewRuleForReqCB() directly!");
+                return false;
+            }
+
+            Rule cbRule = newRuleSet.createNewRule(RuleID);
+            Conditions cbCond = cbRule.createConditions();
+            Actions cbAction = cbRule.createActions();
+
+            //Add media into this new rule
+            if (!MMTelSSUtils.isOp06IccCard(phoneId)
+                && !MMTelSSUtils.isOp07IccCard(phoneId)) {
+                if (setCBServiceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                    cbCond.addMedia("audio");
+                } else if (setCBServiceClass == CommandsInterface.SERVICE_CLASS_VIDEO) {
+                    cbCond.addMedia("video");
+                } else if (setCBServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                    cbCond.addMedia("audio");
+                    cbCond.addMedia("video");
+                }
+            }
+
+            if (facility.equals(CommandsInterface.CB_FACILITY_BAICr)) {
+                cbCond.addRoaming();
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAIC)) {
+                //Bar All Incoming Calls (no conditions -> evaluate the result as true directly)
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOIC)) {
+                cbCond.addInternational();
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOICxH)) {
+                cbCond.addInternationalExHc();
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOC)) {
+                //Bar All Outgoing Calls (no conditions -> evaluate the result as true directly)
+                cbAction.setAllow(cbAllow);
+            }
+
+            if (updateSingleRule && (1 == num_of_expansion)) {
+                if (ssType instanceof OutgoingCommunicationBarring) {
+                    OutgoingCommunicationBarring ocb = (OutgoingCommunicationBarring) ssType;
+                    ocb.saveRule(RuleID);
+                } else if (ssType instanceof IncomingCommunicationBarring) {
+                    IncomingCommunicationBarring icb = (IncomingCommunicationBarring) ssType;
+                    icb.saveRule(RuleID);
+                }
+            }
+
+            return true;
+        }
+
+
+        public Rule copyOldRuleToNewRuleSet(Rule oldRule, RuleSet newRuleSet,
+            int cfAction, int cfReason) {
+            Conditions oldCond = oldRule.getConditions();
+            Actions oldAction = oldRule.getActions();
+
+            Rule newRule = newRuleSet.createNewRule(oldRule.mId);
+            Conditions newCond = newRule.createConditions();
+            Actions newAction = newRule.createActions();
+
+            if (oldCond != null) {
+                if (oldCond.comprehendBusy()) {
+                    newCond.addBusy();
+                }
+                if (oldCond.comprehendCommunicationDiverted()) {
+                    newCond.addCommunicationDiverted();
+                }
+                if (oldCond.comprehendInternational()) {
+                    newCond.addInternational();
+                }
+                if (oldCond.comprehendInternationalExHc()) {
+                    newCond.addInternationalExHc();
+                }
+                if (oldCond.comprehendNoAnswer()) {
+                    newCond.addNoAnswer();
+                }
+                if (oldCond.comprehendNotReachable()) {
+                    newCond.addNotReachable();
+                }
+                if (oldCond.comprehendNotRegistered()) {
+                    newCond.addNotRegistered();
+                }
+                if (oldCond.comprehendPresenceStatus()) {
+                    newCond.addPresenceStatus();
+                }
+                if (oldCond.comprehendRoaming()) {
+                    newCond.addRoaming();
+                }
+                if (oldCond.comprehendRuleDeactivated()) {
+                    newCond.addRuleDeactivated();
+                }
+                //Copy Medias
+                List<String>oldMediaList = oldCond.getMedias();
+                if (oldMediaList != null) {
+                    for (int i = 0; i < oldMediaList.size(); i++) {
+                        newCond.addMedia(oldMediaList.get(i));
+                    }
+                }
+                // Condition for OP01 UT
+                newCond.addTime(oldCond.comprehendTime());
+            }
+
+            ForwardTo oldForward = oldAction.getFowardTo();
+            if (oldForward != null) {
+                if (cfAction == CommandsInterface.CF_ACTION_ERASURE &&
+                    cfReason == CommandsInterface.CF_REASON_UNCONDITIONAL) {
+                    Rlog.i(LOG_TAG, "No need to append the original numebr in Erasure.");
+                    newAction.setFowardTo("", oldForward.isNotifyCaller());
+                } else {
+                    newAction.setFowardTo(oldForward.getTarget(), oldForward.isNotifyCaller());
+                }
+                newAction.getFowardTo().setRevealIdentityToCaller(
+                        oldForward.isRevealIdentityToCaller());
+                newAction.getFowardTo().setRevealIdentityToTarget(
+                        oldForward.isRevealIdentityToTarget());
+            } else {
+                 Rlog.i(LOG_TAG, "No need to append the forward number, cfAction: " + cfAction +
+                    ", cfReason: " + cfReason);
+            }
+
+            newAction.setAllow(oldAction.isAllow());
+            return newRule;
+        }
+
+        public void copyOldRuleToNewRuleSetWithDisabledCB(Rule oldRule, RuleSet newRuleSet,
+                boolean allow, int cfAction, int cfReason) {
+            Actions newAction = null;
+            Conditions newCond = null;
+            Actions oldAction = oldRule.getActions();
+            Conditions oldCond = oldRule.getConditions();
+
+            if (mDisableRuleMode == DISABLE_MODE_DELETE_RULE) {
+                if (oldAction.isAllow() == false
+                        && oldCond.comprehendRuleDeactivated() == false) {
+                    //Do nothing:Not copy the old rule (enabled CB) into the new ruleset
+                } else {
+                    copyOldRuleToNewRuleSet(oldRule, newRuleSet, cfAction, cfReason);
+                }
+            } else if (mDisableRuleMode == DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG) {
+                Rule newRule = copyOldRuleToNewRuleSet(oldRule, newRuleSet, cfAction, cfReason);
+                if (newRule != null && oldAction.isAllow() == false
+                        && oldCond.comprehendRuleDeactivated() == false) {
+                    newCond = newRule.createConditions();
+                    newCond.addRuleDeactivated();
+                }
+            } else if (mDisableRuleMode == DISABLE_MODE_CHANGE_CB_ALLOW) {
+                Rule newRule = copyOldRuleToNewRuleSet(oldRule, newRuleSet, cfAction, cfReason);
+                if (newRule != null && oldAction.isAllow() == false
+                        && oldCond.comprehendRuleDeactivated() == false) {
+                    newAction = newRule.createActions();
+                    newAction.setAllow(allow);
+                }
+            }
+        }
+
+
+        public Rule copyOldRuleToNewRuleSetExceptSpecificMedia(Rule oldRule, RuleSet newRuleSet,
+                int requestedServiceClass, int phoneId, int cfAction, int cfReason) {
+            Conditions oldCond = oldRule.getConditions();
+            Actions oldAction = oldRule.getActions();
+
+            //[Example] Both voice call & video call enable CB for All Outgoing International Calls
+            // Now, a user wants to disable CB for All Outgoing International Calls of voice call
+            // <cond>
+            //     internaltional
+            //     <media>
+            //         audio
+            //         video
+            //     </media>
+            // </cond>
+            // <action>
+            //     <allow>false</allow>
+            // </action>
+
+            // One rule will be split into two rules as follows (one for voice call and the other
+            //for video call)
+
+            // Rule#1:
+            // <cond>
+            //     internaltional
+            //     <media>
+            //         audio
+            //
+            //     </media>
+            // </cond>
+            // <action>
+            //     <allow>true</allow>
+            // </action>
+            // Rule#2: (This API is used to create rule such as Rule#2 -- see the following)
+            // <cond>
+            //     internaltional
+            //     <media>
+            //
+            //         video
+            //     </media>
+            // </cond>
+            // <action>
+            //     <allow>false</allow>
+            // </action>
+
+            /*
+            int requestedServicClass = -1;
+            if (media.equals("audio")) {
+                requestedServicClass = CommandsInterface.SERVICE_CLASS_VOICE;
+            } else if (media.equals("video")) {
+                requestedServicClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+            }
+             */
+
+            //Add the check: oldCond!=null - because Barring all calls or Forwarding UnConditional
+            // => <cp:conditions> can be empty by mtk01411 2014-0122
+            if (oldCond != null &&
+                    hasExtraMedia(oldCond.getMedias(), requestedServiceClass) == false) {
+                //If the original rule has no extra media type, because we have already created a
+                // new rule for the requested media type
+                //Only for extra media type: we still must create a new rule with original
+                // configuration then add into new rule set to keep original rule such media
+                return null;
+            }
+
+            Rule newRule = newRuleSet.createNewRule(oldRule.mId);
+            Conditions newCond = newRule.createConditions();
+            Actions newAction = newRule.createActions();
+
+            if (oldCond != null) {
+                if (oldCond.comprehendBusy()) {
+                    newCond.addBusy();
+                }
+                if (oldCond.comprehendCommunicationDiverted()) {
+                    newCond.addCommunicationDiverted();
+                }
+                if (oldCond.comprehendInternational()) {
+                    newCond.addInternational();
+                }
+                if (oldCond.comprehendInternationalExHc()) {
+                    newCond.addInternationalExHc();
+                }
+                if (oldCond.comprehendNoAnswer()) {
+                    newCond.addNoAnswer();
+                }
+                if (oldCond.comprehendNotReachable()) {
+                    newCond.addNotReachable();
+                }
+                if (oldCond.comprehendNotRegistered()) {
+                    newCond.addNotRegistered();
+                }
+                if (oldCond.comprehendPresenceStatus()) {
+                    newCond.addPresenceStatus();
+                }
+                if (oldCond.comprehendRoaming()) {
+                    newCond.addRoaming();
+                }
+                if (oldCond.comprehendRuleDeactivated()) {
+                    newCond.addRuleDeactivated();
+                }
+                //Copy Medias
+                List<String>oldMediaList = oldCond.getMedias();
+                if (oldMediaList != null) {
+                    for (int i = 0; i < oldMediaList.size(); i++) {
+                        if (!getMediaType(requestedServiceClass).equals(oldMediaList.get(i))) {
+                            newCond.addMedia(oldMediaList.get(i));
+                        }
+                    }
+                }
+                // Condition for OP01 UT
+                newCond.addTime(oldCond.comprehendTime());
+            } else {
+                //Add by mtk01411: 2014-0123
+                //oldCond == null:For BAOC or CFU(Unconditional), so its oldMediaList should mean
+                // both for audio & video
+                if (!MMTelSSUtils.isOp06IccCard(phoneId)
+                    && !MMTelSSUtils.isOp07IccCard(phoneId)) {
+                    List<String>oldMediaList = new ArrayList<String>();;
+                    oldMediaList.add("audio");
+                    oldMediaList.add("video");
+                    for (int i = 0; i < oldMediaList.size(); i++) {
+                        if (getMediaType(requestedServiceClass).equals(oldMediaList.get(i))
+                                == false) {
+                            newCond.addMedia(oldMediaList.get(i));
+                        }
+                    }
+                }
+            }
+
+            ForwardTo oldForward = oldAction.getFowardTo();
+            if (oldForward != null) {
+                if (cfAction == CommandsInterface.CF_ACTION_ERASURE &&
+                    cfReason == CommandsInterface.CF_REASON_UNCONDITIONAL) {
+                    Rlog.i(LOG_TAG, "No need to append the original numebr in Erasure.");
+                    newAction.setFowardTo("", oldForward.isNotifyCaller());
+                } else {
+                    newAction.setFowardTo(oldForward.getTarget(), oldForward.isNotifyCaller());
+                }
+                newAction.getFowardTo().setRevealIdentityToCaller(
+                        oldForward.isRevealIdentityToCaller());
+                newAction.getFowardTo().setRevealIdentityToTarget(
+                        oldForward.isRevealIdentityToTarget());
+            } else {
+                 Rlog.i(LOG_TAG, "No need to append the forward number, cfAction: " + cfAction +
+                    ", cfReason: " + cfReason);
+            }
+            newAction.setAllow(oldAction.isAllow());
+
+            return newRule;
+        }
+
+
+        public int handleSetCLIR(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+
+            int clirMode = rr.mp.readInt();
+            int phoneId = rr.mp.readInt();
+            Rlog.d(LOG_TAG, "Read from CLIR parcel:clirMode=" + clirMode);
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCLIR(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return 0;
+            }
+
+            try {
+                OriginatingIdentityPresentationRestriction oir;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleSetCLIR(): mOirCache = " + mOirCache + ", curTime = "
+                        + curTime + ", mOirCacheLastQueried = " + mOirCacheLastQueried
+                        + ", phoneId = " + phoneId);
+                if ((mOirCache != null) && (phoneId == mOirCachePhoneId) &&
+                        (mOirCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleSetCLIR(): using ETAG mOirCache: " + mOirCache);
+                    requestXcapNetwork(phoneId);
+                    oir = mOirCache;
+                    oir.setNetwork(mNetwork);
+                    oir.refresh();
+                    mOirCacheLastQueried = curTime;
+                } else if ((mOirCache != null) && (phoneId == mOirCachePhoneId) &&
+                        ((curTime >= mOirCacheLastQueried)
+                        && ((curTime - mOirCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleSetCLIR(): using mOirCache: " + mOirCache);
+                    oir = mOirCache;
+                } else {
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleSetCLIR(): XcapRoot = " + mXcapRoot);
+                        if (null != rr.mResult) {
+                            AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                            rr.mResult.sendToTarget();
+                        }
+                        return 0;
+                    }
+
+                    requestXcapNetwork(phoneId);
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+                    oir = mSimservs.getOriginatingIdentityPresentationRestriction(true, mNetwork);
+
+                    mOirCache = oir;
+                    mOirCachePhoneId = phoneId;
+                    mOirCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleSetCLIR(): new mOirCache = " + mOirCache
+                            + ", curTime = " + curTime);
+                }
+
+                if (clirMode == CommandsInterface.CLIR_INVOCATION) {
+                    oir.setDefaultPresentationRestricted(true);
+                } else if (clirMode == CommandsInterface.CLIR_SUPPRESSION) {
+                    oir.setDefaultPresentationRestricted(false);
+                } else {
+                    oir.setDefaultPresentationRestricted(false);
+                }
+            } catch (XcapException xcapException) {
+                mOirCache = null;
+                mOirCachePhoneId = -1;
+                mOirCacheLastQueried = 0;
+
+                if (xcapException.getHttpErrorCode() == HTTP_ERROR_CODE_412) {
+                    Rlog.d(LOG_TAG, "handleSetCLIR(): HTTP_ERROR_CODE_412");
+                    return HTTP_ERROR_CODE_412;
+                }
+                Rlog.d(LOG_TAG, "handleSetCLIR(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCLIR(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCLIR(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            } catch (Exception e) {
+                //Get XCAP's configuration failed or set new configuration failed
+                //Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCLIR():Start to Print Stack Trace");
+                mOirCache = null;
+                mOirCachePhoneId = -1;
+                mOirCacheLastQueried = 0;
+
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            }
+
+            //[Notify upper's application about the SET_CLIR result - Success Case
+            // without exception]
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+
+            return 0;
+        }
+
+        public void handleSetCLIP(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+
+            int clipEnable = rr.mp.readInt();
+            int phoneId = rr.mp.readInt();
+            Rlog.d(LOG_TAG, "Read from CLIP parcel:clipMode=" + clipEnable);
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCLIP(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return;
+            }
+
+            try {
+                mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                if (TextUtils.isEmpty(mXcapRoot)) {
+                    Rlog.d(LOG_TAG, "handleSetCLIP(): XcapRoot = " + mXcapRoot);
+                    if (null != rr.mResult) {
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                        rr.mResult.sendToTarget();
+                    }
+                    return;
+                }
+
+                requestXcapNetwork(phoneId);
+
+                setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                        phoneId);
+                OriginatingIdentityPresentation oip =
+                        mSimservs.getOriginatingIdentityPresentation(true, mNetwork);
+                if (clipEnable == 1) {
+                    oip.setActive(true);
+                } else {
+                    oip.setActive(false);
+                }
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleSetCLIP(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCLIP(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCLIP(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                //Get XCAP's configuration failed or set new configuration failed
+                //Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCLIP():Start to Print Stack Trace");
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            }
+
+            //[Notify upper's application about the SET_CLIP result - Success Case without
+            // exception]
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+
+        public void handleSetCOLR(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+
+            int colrMode = rr.mp.readInt();
+            int phoneId = rr.mp.readInt();
+            Rlog.d(LOG_TAG, "Read from COLR parcel:clirMode=" + colrMode);
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCOLR(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return;
+            }
+
+            try {
+                mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                if (TextUtils.isEmpty(mXcapRoot)) {
+                    Rlog.d(LOG_TAG, "handleSetCOLR(): XcapRoot = " + mXcapRoot);
+                    if (null != rr.mResult) {
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                        rr.mResult.sendToTarget();
+                    }
+                    return;
+                }
+
+                requestXcapNetwork(phoneId);
+
+                setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                        phoneId);
+                TerminatingIdentityPresentationRestriction tir =
+                        mSimservs.getTerminatingIdentityPresentationRestriction(true, mNetwork);
+                if (colrMode == CommandsInterface.CLIR_INVOCATION) {
+                    tir.setDefaultPresentationRestricted(true);
+                } else if (colrMode == CommandsInterface.CLIR_SUPPRESSION) {
+                    tir.setDefaultPresentationRestricted(false);
+                } else {
+                    tir.setDefaultPresentationRestricted(false);
+                }
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleSetCOLR(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCOLR(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCOLR(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                //Get XCAP's configuration failed or set new configuration failed
+                //Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCOLR():Start to Print Stack Trace");
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            }
+
+            //[Notify upper's application about the SET_COLR result - Success Case without
+            // exception]
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        public void handleSetCOLP(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+
+            int colpEnable = rr.mp.readInt();
+            int phoneId = rr.mp.readInt();
+            Rlog.d(LOG_TAG, "Read from COLP parcel:colpEnable=" + colpEnable);
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCOLP(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return;
+            }
+
+            try {
+                mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                if (TextUtils.isEmpty(mXcapRoot)) {
+                    Rlog.d(LOG_TAG, "handleSetCOLP(): XcapRoot = " + mXcapRoot);
+                    if (null != rr.mResult) {
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                        rr.mResult.sendToTarget();
+                    }
+                    return;
+                }
+
+                requestXcapNetwork(phoneId);
+
+                setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                        phoneId);
+                TerminatingIdentityPresentation tip =
+                        mSimservs.getTerminatingIdentityPresentation(true, mNetwork);
+                if (colpEnable == 1) {
+                    tip.setActive(true);
+                } else {
+                    tip.setActive(false);
+                }
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleSetCOLP(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCOLP(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCOLP(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                //Get XCAP's configuration failed or set new configuration failed
+                //Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCOLP():Start to Print Stack Trace");
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            }
+
+            //[Notify upper's application about the SET_COLP result - Success Case without
+            // exception]
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+
+
+        public int handleSetCW(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+            int enabled = rr.mp.readInt();
+            int serviceClass = rr.mp.readInt();
+            int phoneId = rr.mp.readInt();
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCW(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return 0;
+            }
+
+            try {
+                CommunicationWaiting cw;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleSetCW(): mCwCache = " + mCwCache + ", curTime = "
+                        + curTime + ", mCwCacheLastQueried = " + mCwCacheLastQueried
+                        + ", phoneId = " + phoneId);
+                if ((mCwCache != null) && (phoneId == mCwCachePhoneId) &&
+                        (mCwCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleSetCW(): using ETAG mCwCache: " + mCwCache);
+                    requestXcapNetwork(phoneId);
+                    cw = mCwCache;
+                    cw.setNetwork(mNetwork);
+                    cw.refresh();
+                    mCwCacheLastQueried = curTime;
+                } else if ((mCwCache != null) && (phoneId == mCwCachePhoneId) &&
+                        ((curTime >= mCwCacheLastQueried)
+                        && ((curTime - mCwCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleSetCW(): using mCwCache: " + mCwCache);
+                    cw = mCwCache;
+                } else {
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleSetCW(): XcapRoot = " + mXcapRoot);
+                        if (null != rr.mResult) {
+                            AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                            rr.mResult.sendToTarget();
+                        }
+                        return 0;
+                    }
+
+                    requestXcapNetwork(phoneId);
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+                    cw = mSimservs.getCommunicationWaiting(true, mNetwork);
+
+                    mCwCache = cw;
+                    mCwCachePhoneId = phoneId;
+                    mCwCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleSetCW(): new mCwCache = " + mCwCache
+                            + ", curTime = " + curTime);
+                }
+                Rlog.d(LOG_TAG, "handleSetCW(): enabled = " + enabled);
+                if (enabled == 1) {
+                    cw.setActive(true);
+                } else {
+                    cw.setActive(false);
+                }
+            } catch (XcapException xcapException) {
+                mCwCache = null;
+                mCwCachePhoneId = -1;
+                mCwCacheLastQueried = 0;
+                if (xcapException.getHttpErrorCode() == HTTP_ERROR_CODE_412) {
+                    Rlog.d(LOG_TAG, "handleSetCW(): HTTP_ERROR_CODE_412");
+                    return HTTP_ERROR_CODE_412;
+                }
+                Rlog.d(LOG_TAG, "handleSetCW(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCW(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCW(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            } catch (Exception e) {
+                //Get XCAP's configuration failed or set new configuration failed
+                //Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCW():Start to Print Stack Trace");
+                mCwCache = null;
+                mCwCachePhoneId = -1;
+                mCwCacheLastQueried = 0;
+
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            }
+
+            //[Notify upper's application about the SET_CW result - Success Case without
+            // exception]
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+
+            return 0;
+        }
+
+        public int handleSetCF(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+
+            int setCFAction = rr.mp.readInt();
+            int setCFReason = rr.mp.readInt();
+            int setCFServiceClass = rr.mp.readInt();
+            String setCFNumber = rr.mp.readString();
+            int setCFTimeSeconds = rr.mp.readInt();
+            int phoneId = rr.mp.readInt();
+            int reportFlag = 0;
+
+            boolean AddRuleForCFUWithAllMediaType = false;
+            boolean AddRuleForCFBWithAllMediaType = false;
+            boolean AddRuleForCFNoAnswerWithAllMediaType = false;
+            boolean AddRuleForCFNotReachableWithAllMediaType = false;
+            boolean AddRuleForCFNotRegisteredWithAllMediaType = false;
+
+            String CFU_RuleID = "CFU";
+            String CFB_RuleID = "CFB";
+            String CFNoAnswer_RuleID = "CFNoAnswer";
+            String CFNotReachable_RuleID = "CFNotReachable";
+            String CFNotRegistered_RuleID = "CFNotReachable";
+
+            Rlog.d(LOG_TAG, "Read from CF parcel:req=" + requestToString(reqNo) + ",cfAction="
+                    + setCFAction + ",reason=" + setCFReason + ",serviceClass="
+                    + setCFServiceClass + ",number=" + setCFNumber + ",timeSec="
+                    + setCFTimeSeconds);
+
+            String XcapCFNum = SystemProperties.get(PROP_SS_CFNUM, "");
+            if (XcapCFNum.startsWith("sip:") || XcapCFNum.startsWith("sips:")
+                    || XcapCFNum.startsWith("tel:")) {
+                Rlog.d(LOG_TAG, "handleSetCF():get call forwarding num from EM setting:"
+                        + XcapCFNum);
+                String ss_mode = SystemProperties.get(PROP_SS_MODE, MODE_SS_XCAP);
+                Rlog.d(LOG_TAG, "handleSetCF():ss_mode=" + ss_mode);
+                if (MODE_SS_XCAP.equals(ss_mode)) {
+                    setCFNumber = XcapCFNum;
+                }
+            }
+
+            //Change the serviceClass (VIDEO + DATA_SYNC) to VIDEO directly
+            if (setCFServiceClass == (CommandsInterface.SERVICE_CLASS_VIDEO
+                    | CommandsInterface.SERVICE_CLASS_DATA_SYNC)) {
+                setCFServiceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+            }
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCF(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return 0;
+            }
+
+            try {
+
+                int num_of_expansion = 1;
+                //Need several interators to check
+                if (setCFReason == CommandsInterface.CF_REASON_ALL_CONDITIONAL) {
+                    //It means that to check 4
+                    // conditions:CFB/CFNoAnser/CFNotReachable/CFNotRegistered
+                    num_of_expansion = 4;
+                } else if (setCFReason == CommandsInterface.CF_REASON_ALL) {
+                    //It means that to check 4
+                    // conditions:CFB/CFNoAnser/CFNotReachable/CFNotRegistered
+                    // and 1 unconditional:CFU
+                    num_of_expansion = 5;
+                }
+
+                CommunicationDiversion cd;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleSetCF(): mCdCache = " + mCdCache + ", curTime = "
+                        + curTime + ", mCdCacheLastQueried = " + mCdCacheLastQueried
+                        + ", phoneId = " + phoneId);
+                if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        (mCdCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleSetCF(): using ETAG mCdCache: " + mCdCache);
+                    requestXcapNetwork(phoneId);
+                    cd = mCdCache;
+                    cd.setNetwork(mNetwork);
+                    cd.refresh();
+                    mCdCacheLastQueried = curTime;
+                } else if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        ((curTime >= mCdCacheLastQueried)
+                        && ((curTime - mCdCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleSetCF(): using mCdCache: " + mCdCache);
+                    cd = mCdCache;
+                } else {
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleSetCF(): XcapRoot = " + mXcapRoot);
+                        if (null != rr.mResult) {
+                            AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                            rr.mResult.sendToTarget();
+                        }
+                        return 0;
+                    }
+
+                    requestXcapNetwork(phoneId);
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+                    cd = mSimservs.getCommunicationDiversion(true, mNetwork);
+                    mCdCache = cd;
+                    mCdCachePhoneId = phoneId;
+                    mCdCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleSetCF(): new mCdCache = " + mCdCache
+                            + ", curTime = " + curTime);
+                }
+
+                for (int it = 0; it < num_of_expansion; it++) {
+                    if (num_of_expansion != 1) {
+                        if (it == 0) setCFReason = CommandsInterface.CF_REASON_BUSY;
+                        else if (it == 1) setCFReason = CommandsInterface.CF_REASON_NO_REPLY;
+                        else if (it == 2) setCFReason = CommandsInterface.CF_REASON_NOT_REACHABLE;
+                        else if (it == 3) setCFReason = CommandsInterface.CF_REASON_NOT_REGISTERED;
+                        else if (it == 4) setCFReason = CommandsInterface.CF_REASON_UNCONDITIONAL;
+                    }
+
+                    //Only report to upper layer application at the last execution
+                    if (it == (num_of_expansion - 1)) {
+                        reportFlag = 1;
+                    }
+
+                    Rlog.d(LOG_TAG, "handleSetCF():it=" + it + ", num_of_expansion="
+                            + num_of_expansion + ",cfReason=" + setCFReason);
+
+                    RuleSet ruleSet = cd.getRuleSet();
+                    List<Rule> ruleList = null;
+                    RuleSet newRuleSet = cd.createNewRuleSet();
+                    boolean addedNewRule = false;
+
+
+                    if (ruleSet != null) {
+                        ruleList = ruleSet.getRules();
+                    } else {
+                        Rlog.d(LOG_TAG, "No CF related rules in remote server");
+                    }
+
+                    //Note that: If no ant configuration is stored in XCAP server (e.g., empty xml
+                    // string), ruleList will be null
+                    if (ruleList != null) {
+                        //Check each rule & its corresponding condition/action
+                        for (int i = 0; i < ruleList.size(); i++) {
+                            Rule r = ruleList.get(i);
+                            Conditions cond = r.getConditions();
+                            Actions action = r.getActions();
+                            List<String> mediaList = null;
+
+                            if (cond != null) {
+                                mediaList = cond.getMedias();
+                                Rlog.d(LOG_TAG, "handleSetCF():busy=" + cond.comprehendBusy()
+                                        + ",NoAnswer=" + cond.comprehendNoAnswer()
+                                        + ",NoReachable="
+                                        + cond.comprehendNotReachable() + ",NotRegistered="
+                                        + cond.comprehendNotRegistered());
+                                if (cond.comprehendBusy()) {
+                                    CFB_RuleID = r.mId;
+                                    Rlog.d(LOG_TAG, "Update CFB_RuleID=" + CFB_RuleID);
+                                } else if (cond.comprehendNoAnswer()) {
+                                    CFNoAnswer_RuleID = r.mId;
+                                    Rlog.d(LOG_TAG, "Update CFNoAnswer_RuleID="
+                                            + CFNoAnswer_RuleID);
+                                } else if (cond.comprehendNotReachable()) {
+                                    CFNotReachable_RuleID = r.mId;
+                                    Rlog.d(LOG_TAG, "Update CFNotReachable_RuleID="
+                                            + CFNotReachable_RuleID);
+                                } else if (cond.comprehendNotRegistered()) {
+                                    CFNotRegistered_RuleID = r.mId;
+                                    Rlog.d(LOG_TAG, "Update CFNotRegistered_RuleID="
+                                            + CFNotRegistered_RuleID);
+                                } else {
+                                    CFU_RuleID = r.mId;
+                                    Rlog.d(LOG_TAG, "Update CFU_RuleID=" + CFU_RuleID);
+                                }
+                            } else {
+                                Rlog.d(LOG_TAG, "handleSetCF():Empty cond (cond==null) for"
+                                        + " this rule=" + r);
+                                if (CFU_RuleID.equals("CFU")) {
+                                    //CFU rule
+                                    CFU_RuleID = r.mId;
+                                    Rlog.d(LOG_TAG, "Update CFU_RuleID=" + CFU_RuleID);
+                                }
+                            }
+
+                            //Traverse each rule and check if this time's request is already in the
+                            // remote XCAP server
+                            if (setCFReason == CommandsInterface.CF_REASON_BUSY &&
+                                    (cond != null && cond.comprehendBusy() == true) &&
+                                    containSpecificMedia(mediaList, setCFServiceClass)) {
+
+                                if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE) ||
+                                        (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE
+                                        && AddRuleForCFBWithAllMediaType == false)) {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(cd, newRuleSet,
+                                            r, setCFReason, setCFAction, setCFServiceClass,
+                                            setCFNumber, setCFTimeSeconds, CFB_RuleID,
+                                            mUpdateSingleRule, num_of_expansion, phoneId);
+                                    Rlog.d(LOG_TAG, "handleSetCF():CFB-addedNewRule="
+                                            + addedNewRule);
+                                    if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                                        AddRuleForCFBWithAllMediaType = true;
+                                    }
+                                } else if (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE
+                                        && AddRuleForCFBWithAllMediaType == true) {
+                                    Rlog.d(LOG_TAG, "Already add rule for CFB with serviceClass=0 "
+                                            + "case previously");
+                                }
+
+                            } else if (setCFReason == CommandsInterface.CF_REASON_NO_REPLY &&
+                                    (cond != null && cond.comprehendNoAnswer() == true) &&
+                                    containSpecificMedia(mediaList, setCFServiceClass)) {
+
+                                if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                        || (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE
+                                        && AddRuleForCFNoAnswerWithAllMediaType == false)) {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(cd, newRuleSet,
+                                            r, setCFReason, setCFAction, setCFServiceClass,
+                                            setCFNumber, setCFTimeSeconds, CFNoAnswer_RuleID,
+                                            mUpdateSingleRule, num_of_expansion, phoneId);
+                                    Rlog.d(LOG_TAG, "handleSetCF():CFNoAnswer-addedNewRule="
+                                            + addedNewRule);
+
+                                    //Add the configuration for NoReplyTimer
+                                    if (addedNewRule == true &&
+                                            (setCFAction == CommandsInterface.CF_ACTION_ENABLE ||
+                                            setCFAction ==
+                                            CommandsInterface.CF_ACTION_REGISTRATION)) {
+                                        Rlog.d(LOG_TAG, "handleSetCF():[C1]Enable CFNoAnswer with "
+                                                + "new_NoReplyTimer=" + setCFTimeSeconds
+                                                + "org_NoReplyTimer=" + cd.getNoReplyTimer());
+                                        if (setCFTimeSeconds > 0 && cd.getNoReplyTimer() > -1) {
+                                            cd.setNoReplyTimer(setCFTimeSeconds);
+                                        } else {
+                                            Rlog.d(LOG_TAG, "No need to append setCFTimeSeconds: " + 
+                                                setCFTimeSeconds);
+                                        }
+                                    }
+
+                                    if (setCFServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE) {
+                                        AddRuleForCFNoAnswerWithAllMediaType = true;
+                                    }
+                                } else if (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE
+                                        && AddRuleForCFNoAnswerWithAllMediaType == true) {
+                                    Rlog.d(LOG_TAG, "Already add rule for CFNoAnswer with"
+                                            + " serviceClass=0 case previously");
+                                }
+
+                            } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REACHABLE &&
+                                    (cond != null && cond.comprehendNotReachable() == true) &&
+                                    containSpecificMedia(mediaList, setCFServiceClass)) {
+
+                                if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                        || (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE &&
+                                        AddRuleForCFNotReachableWithAllMediaType == false)) {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(cd, newRuleSet,
+                                            r, setCFReason, setCFAction, setCFServiceClass,
+                                            setCFNumber, setCFTimeSeconds, CFNotReachable_RuleID,
+                                            mUpdateSingleRule, num_of_expansion, phoneId);
+                                    Rlog.d(LOG_TAG, "handleSetCF():CFNoReachable-addedNewRule="
+                                            + addedNewRule);
+                                    if (setCFServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE) {
+                                        AddRuleForCFNotReachableWithAllMediaType = true;
+                                    }
+                                } else if (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE
+                                        && AddRuleForCFNotReachableWithAllMediaType == true) {
+                                    Rlog.d(LOG_TAG, "Already add rule for CFNoReachable with "
+                                            + "serviceClass=0 case previously");
+                                }
+
+                            } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REGISTERED &&
+                                    (cond != null && cond.comprehendNotReachable() == true) &&
+                                    containSpecificMedia(mediaList, setCFServiceClass) &&
+                                    MMTelSSUtils.isOp06IccCard(phoneId)) {
+                                // set CFNRc as CFNL for OP06
+                                Rlog.d(LOG_TAG, "handleSetCF(): Set CFNRc as CFNL for OP06");
+                                if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                        || (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE &&
+                                        AddRuleForCFNotReachableWithAllMediaType == false)) {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(cd, newRuleSet,
+                                            r, CommandsInterface.CF_REASON_NOT_REACHABLE,
+                                            setCFAction, setCFServiceClass, setCFNumber,
+                                            setCFTimeSeconds, CFNotReachable_RuleID,
+                                            mUpdateSingleRule, num_of_expansion, phoneId);
+                                    Rlog.d(LOG_TAG, "handleSetCF():CFNoReachable-addedNewRule="
+                                            + addedNewRule);
+                                    if (setCFServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE) {
+                                        AddRuleForCFNotReachableWithAllMediaType = true;
+                                    }
+                                } else if (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE
+                                        && AddRuleForCFNotReachableWithAllMediaType == true) {
+                                    Rlog.d(LOG_TAG, "Already add rule for CFNoReachable with "
+                                            + "serviceClass=0 case previously");
+                                }
+                            } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REGISTERED &&
+                                    (cond != null && cond.comprehendNotRegistered() == true) &&
+                                    containSpecificMedia(mediaList, setCFServiceClass)) {
+
+                                if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                        || (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE &&
+                                        AddRuleForCFNotRegisteredWithAllMediaType == false)) {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(cd, newRuleSet,
+                                            r, setCFReason, setCFAction, setCFServiceClass,
+                                            setCFNumber, setCFTimeSeconds, CFNotRegistered_RuleID,
+                                            mUpdateSingleRule, num_of_expansion, phoneId);
+                                    Rlog.d(LOG_TAG, "handleSetCF():CFNoRegistered-addedNewRule="
+                                            + addedNewRule);
+                                    if (setCFServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE) {
+                                        AddRuleForCFNotRegisteredWithAllMediaType = true;
+                                    }
+                                } else if (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE &&
+                                        AddRuleForCFNotRegisteredWithAllMediaType == true) {
+                                    Rlog.d(LOG_TAG, "Already add rule for CFNoRegistered with "
+                                            + "serviceClass=0 case previously");
+                                }
+                            } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REACHABLE &&
+                                    (cond != null && cond.comprehendNotRegistered() == true) &&
+                                    containSpecificMedia(mediaList, setCFServiceClass) &&
+                                    MMTelSSUtils.isOp06IccCard(phoneId)) {
+                                // set CFNL as CFNRc for OP06
+                                Rlog.d(LOG_TAG, "handleSetCF(): Set CFNL as CFNRc for OP06");
+                                if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                        || (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE &&
+                                        AddRuleForCFNotRegisteredWithAllMediaType == false)) {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(cd, newRuleSet,
+                                            r, CommandsInterface.CF_REASON_NOT_REGISTERED,
+                                            setCFAction, setCFServiceClass, setCFNumber,
+                                            setCFTimeSeconds, CFNotRegistered_RuleID,
+                                            mUpdateSingleRule, num_of_expansion, phoneId);
+                                    Rlog.d(LOG_TAG, "handleSetCF():CFNoRegistered-addedNewRule="
+                                            + addedNewRule);
+                                    if (setCFServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE) {
+                                        AddRuleForCFNotRegisteredWithAllMediaType = true;
+                                    }
+                                } else if (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE &&
+                                        AddRuleForCFNotRegisteredWithAllMediaType == true) {
+                                    Rlog.d(LOG_TAG, "Already add rule for CFNoRegistered with "
+                                            + "serviceClass=0 case previously");
+                                }
+                            } else if (setCFReason == CommandsInterface.CF_REASON_UNCONDITIONAL &&
+                                    ((cond != null && cond.comprehendBusy() == false &&
+                                    cond.comprehendNoAnswer() == false &&
+                                    cond.comprehendNotRegistered() == false &&
+                                    cond.comprehendNotReachable() == false) || cond == null) &&
+                                    containSpecificMedia(mediaList, setCFServiceClass)) {
+
+                                if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                        || (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE
+                                        && AddRuleForCFUWithAllMediaType == false)) {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(cd, newRuleSet,
+                                            r, setCFReason, setCFAction, setCFServiceClass,
+                                            setCFNumber, setCFTimeSeconds, CFU_RuleID,
+                                            mUpdateSingleRule, num_of_expansion, phoneId);
+                                    Rlog.d(LOG_TAG, "handleSetCF():CFU-addedNewRule="
+                                            + addedNewRule);
+                                    if (setCFServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE) {
+                                        AddRuleForCFUWithAllMediaType = true;
+                                    }
+                                } else if (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE &&
+                                        AddRuleForCFUWithAllMediaType == true) {
+                                    Rlog.d(LOG_TAG, "Already add rule for CFU with serviceClass=0 "
+                                            + "case previously");
+                                }
+
+                            } else {
+                                //Copy old rule into new rule set
+                                Rlog.d(LOG_TAG, "handleSetCF():Copy old rule to newRuleSet");
+                                copyOldRuleToNewRuleSet(r, newRuleSet, setCFAction, setCFReason);
+                            }
+                        } //end-of-for-loop (ruleList)
+                    }
+
+                    //Check if the new rule user wants to be modified is already added to or not
+                    //Remove the check condition "(setCFServiceClass !=
+                    //CommandsInterface.SERVICE_CLASS_NONE)" 2014-0709
+                    //Scenario:User inputs "**67#" to enable CFB (i.e.,with null phonenumber and
+                    // serviceClass is NONE) => Not match any rule, it should be added into the
+                    // rule set
+                    if (addedNewRule == false && (setCFAction == CommandsInterface.CF_ACTION_ENABLE
+                            || setCFAction == CommandsInterface.CF_ACTION_REGISTRATION)
+                            /*&& (setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE)*/
+                            ) {
+                        addedNewRule = true;
+                        Rule rule = newRuleSet.createNewRule("");
+                        Conditions cond = rule.createConditions();
+                        Actions action = rule.createActions();
+                        if (MMTelSSUtils.isOp01IccCard(phoneId)
+                                && MMTelSSUtils.isNotifyCallerTest()) {
+                            action.setFowardTo(setCFNumber, false);
+                        } else {
+                            action.setFowardTo(setCFNumber, true);
+                        }
+                        action.getFowardTo().setRevealIdentityToCaller(true);
+                        action.getFowardTo().setRevealIdentityToTarget(true);
+
+                        Rlog.d(LOG_TAG, "handleSetCF():Add rule for this time's enable reason="
+                                + setCFReason + ",serviceClass=" + setCFServiceClass);
+
+                        if (setCFReason == CommandsInterface.CF_REASON_BUSY) {
+                            rule.setId(CFB_RuleID);
+                            cond.addBusy();
+                        } else if (setCFReason == CommandsInterface.CF_REASON_NO_REPLY) {
+                            //Add the configuration for NoReplyTimer
+                            Rlog.d(LOG_TAG, "handleSetCF():[C2]Enable CFNoAnswer with "
+                                    + "new_NoReplyTimer=" + setCFTimeSeconds + ",org_NoReplyTimer="
+                                    + cd.getNoReplyTimer());
+                            if (setCFTimeSeconds > 0 && cd.getNoReplyTimer() > -1) {
+                                cd.setNoReplyTimer(setCFTimeSeconds);
+                            } else {
+                                Rlog.d(LOG_TAG, "No need to append setCFTimeSeconds: " + 
+                                    setCFTimeSeconds);
+                            }
+                            rule.setId(CFNoAnswer_RuleID);
+                            cond.addNoAnswer();
+                        } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REACHABLE) {
+                            rule.setId(CFNotReachable_RuleID);
+                            cond.addNotReachable();
+                        } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REGISTERED) {
+                            rule.setId(CFNotRegistered_RuleID);
+                            cond.addNotRegistered();
+                        } else if (setCFReason == CommandsInterface.CF_REASON_UNCONDITIONAL) {
+                            rule.setId(CFU_RuleID);
+                            //Don't add any condition (always evaluate the result as true)
+                        }
+                        if (!MMTelSSUtils.isOp06IccCard(phoneId)
+                            && !MMTelSSUtils.isOp07IccCard(phoneId)) {
+                            if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                                cond.addMedia("audio");
+                            } else if (setCFServiceClass
+                                    == CommandsInterface.SERVICE_CLASS_VIDEO) {
+                                cond.addMedia("video");
+                            }
+                        }
+
+                        if (mUpdateSingleRule && num_of_expansion == 1) {
+                            cd.saveRule(rule.mId);
+                        }
+                    }
+
+                    //Finally, update the new rule set back to remote XCAP server
+                    //Debug:
+                    if (newRuleSet.getRules() != null) {
+                        Rlog.d(LOG_TAG, "Dump SetCF XML:" + newRuleSet.toXmlString());
+                    } else {
+                        Rlog.d(LOG_TAG, "Dump SetCF XML: ruleset with empty rules");
+                    }
+
+                    if (!mUpdateSingleRule) {
+                        cd.saveRuleSet();
+                    } else {
+                        if (num_of_expansion > 1) {
+                            List<Rule> newRuleList = null;
+                            newRuleList = newRuleSet.getRules();
+                            for (int i = 0; i < newRuleList.size(); i++) {
+                                Rule newRule = newRuleList.get(i);
+                                cd.saveRule(newRule.mId);
+                            }
+                        }
+                    }
+
+                } //end-of-for-loop (num_of_expansion)
+
+            } catch (XcapException xcapException) {
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+                if (xcapException.getHttpErrorCode() == HTTP_ERROR_CODE_412) {
+                    Rlog.d(LOG_TAG, "handleSetCF(): HTTP_ERROR_CODE_412");
+                    return HTTP_ERROR_CODE_412;
+                }
+                Rlog.d(LOG_TAG, "handleSetCF(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCF(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCF(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            } catch (Exception e) {
+                //Get XCAP's configuration failed or set new configuration failed
+                //Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCF():Start to Print Stack Trace");
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                e.printStackTrace();
+                if ((rr.mResult != null) && (reportFlag == 1)) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            }
+
+            //[Notify upper's application about the SET_CF result - Success Case without exception]
+            if ((rr.mResult != null) && (reportFlag == 1)) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+
+            return 0;
+        }
+
+        public int handleSetCB(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+            String facility = rr.mp.readString();
+            String original_facility = facility;
+            int lockState = rr.mp.readInt();
+            int setCBServiceClass = rr.mp.readInt();
+            int phoneId = rr.mp.readInt();
+
+            boolean AddRuleForBAOCWithAllMediaType = false;
+            boolean AddRuleForBAOICWithAllMediaType = false;
+            boolean AddRuleForBAOICxHWithAllMediaType = false;
+            boolean AddRuleForBAICWithAllMediaType = false;
+            boolean AddRuleForBAICrWithAllMediaType = false;
+
+            String BAOC_RuleID = "AO";
+            String BAOIC_RuleID = "OI";
+            String BAOICExHC_RuleID = "OX";
+            String BAIC_RuleID = "AI";
+            String BAICR_RuleID = "IR";
+
+            Rlog.d(LOG_TAG, "Read from CB parcel:req=" + requestToString(reqNo) + ",facility="
+                   + facility + ",serviceClass=" + setCBServiceClass + ",lockState(enabled)="
+                   + lockState);
+
+            //Change the serviceClass (VIDEO + DATA_SYNC) to VIDEO directly
+            if (setCBServiceClass == (CommandsInterface.SERVICE_CLASS_VIDEO
+                    | CommandsInterface.SERVICE_CLASS_DATA_SYNC)) {
+                setCBServiceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+            }
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCB(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return 0;
+            }
+
+            try {
+
+                //Add handling Barring Service for 330(AB)/333(AG)/353(AC) cases
+                /***
+                 * "AO" BAOC (Barr All Outgoing Calls) (refer 3GPP TS 22.088 [6] clause 1)
+                 * "OI" BOIC (Barr Outgoing International Calls) (refer 3GPP TS 22.088 [6]
+                 * clause 1)
+                 * "OX" BOIC exHC (Barr Outgoing International Calls except to Home Country)
+                 *(refer 3GPP TS 22.088 [6] clause 1)
+                 * "AI" BAIC (Barr All Incoming Calls) (refer 3GPP TS 22.088 [6] clause 2)
+                 * "IR" BIC Roam (Barr Incoming Calls when Roaming outside the home country)
+                 * (refer 3GPP TS 22.088 [6] clause 2)
+                 * "AB" All Barring services (refer 3GPP TS 22.030 [19]) (applicable only for
+                 * <mode>=0: i.e.,unlock - ref: +CLCK & 2/3G SS Spec)
+                 * "AG" All outGoing barring services (refer 3GPP TS 22.030 [19]) (applicable
+                 * only for <mode>=0: i.e.,unlock - ref: +CLCK & 2/3G SS Spec)
+                 * "AC" All inComing barring services (refer 3GPP TS 22.030 [19]) (applicable
+                 * only for <mode>=0: i.e.,unlock - ref: +CLCK & 2/3G SS Spec)
+                 */
+                int num_of_expansion = 1;
+                if (original_facility.equals(CommandsInterface.CB_FACILITY_BA_ALL)
+                        && lockState == 0) {
+                    num_of_expansion = 5;
+                } else if (original_facility.equals(CommandsInterface.CB_FACILITY_BA_MO)
+                        && lockState == 0) {
+                    num_of_expansion = 3;
+                } else if (original_facility.equals(CommandsInterface.CB_FACILITY_BA_MT)
+                        && lockState == 0) {
+                    num_of_expansion = 2;
+                }
+
+                if (facility.equals(CommandsInterface.CB_FACILITY_BA_ALL)
+                        || facility.equals(CommandsInterface.CB_FACILITY_BA_MO)
+                        || facility.equals(CommandsInterface.CB_FACILITY_BA_MT)) {
+                    if (lockState != 0) {
+                        //Follow the same behavior with 2/3G CS - AB/AG/AC:Only mode=0
+                        // (i.e.,unlock state operation) is allowed
+                        Rlog.d(LOG_TAG, "Not allow lockState=1 for AB(330)/AG(333)/AC(353)");
+                        //Note that: upper layer application
+                        // (CallBarringBasePreference.java:handleSetCallBarringResponse())
+                        //Only cast the exception to CommandException is allowed (but it may
+                        //happen assertion due to cast failure)
+                        //And handle this exception in TimeConsumingPreferenceActivity.java's
+                        // onError()
+                        if (rr.mResult != null) {
+                            CommandException ce =
+                                    CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                            AsyncResult.forMessage(rr.mResult, null, ce);
+                            rr.mResult.sendToTarget();
+                            return 0;
+                        }
+                    }
+                }
+
+                OutgoingCommunicationBarring ocb = null;
+                IncomingCommunicationBarring icb = null;
+                long curTime = System.currentTimeMillis();
+                if (facility.equals(CommandsInterface.CB_FACILITY_BAOC) ||
+                        facility.equals(CommandsInterface.CB_FACILITY_BAOIC) ||
+                        facility.equals(CommandsInterface.CB_FACILITY_BAOICxH) ||
+                        facility.equals(CommandsInterface.CB_FACILITY_BA_ALL)) {
+                    Rlog.d(LOG_TAG, "handleSetCB(): mOcbCache = " + mOcbCache + ", curTime = "
+                            + curTime + ", mOcbCacheLastQueried = " + mOcbCacheLastQueried
+                            + ", facility = " + facility + ", phoneId = " + phoneId);
+                    if ((mOcbCache != null) && (phoneId == mOcbCachePhoneId) &&
+                            (mOcbCache.isSupportEtag())) {
+                        Rlog.d(LOG_TAG, "handleSetCB(): using ETAG mOcbCache: " + mOcbCache);
+                        requestXcapNetwork(phoneId);
+                        ocb = mOcbCache;
+                        ocb.setNetwork(mNetwork);
+                        ocb.refresh();
+                        mOcbCacheLastQueried = curTime;
+                    } else if ((mOcbCache != null) && (phoneId == mOcbCachePhoneId) &&
+                            ((curTime >= mOcbCacheLastQueried)
+                            && ((curTime - mOcbCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                        Rlog.d(LOG_TAG, "handleSetCB(): using mOcbCache: " + mOcbCache);
+                        ocb = mOcbCache;
+                    } else {
+                        //Outgoing Call Barring
+                        mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                        mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                        mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                        if (TextUtils.isEmpty(mXcapRoot)) {
+                            Rlog.d(LOG_TAG, "handleSetCB(): OCB XcapRoot = " + mXcapRoot);
+                            if (null != rr.mResult) {
+                                AsyncResult.forMessage(rr.mResult, null,
+                                        new UnknownHostException());
+                                rr.mResult.sendToTarget();
+                            }
+                            return 0;
+                        }
+
+                        requestXcapNetwork(phoneId);
+
+                        setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName,
+                                mPassword, phoneId);
+                        ocb = mSimservs.getOutgoingCommunicationBarring(true, mNetwork);
+                        mOcbCache = ocb;
+                        mOcbCachePhoneId = phoneId;
+                        mOcbCacheLastQueried = curTime;
+                        Rlog.d(LOG_TAG, "handleSetCB(): new mOcbCache = " + mOcbCache
+                                + ", curTime = " + curTime);
+                    }
+                }
+
+                if (facility.equals(CommandsInterface.CB_FACILITY_BAIC) ||
+                        facility.equals(CommandsInterface.CB_FACILITY_BAICr) ||
+                        facility.equals(CommandsInterface.CB_FACILITY_BA_ALL)) {
+                    Rlog.d(LOG_TAG, "handleSetCB(): mIcbCache = " + mIcbCache + ", curTime = "
+                            + curTime + ", mIcbCacheLastQueried = " + mIcbCacheLastQueried
+                            + ", facility = " + facility + ", phoneId = " + phoneId);
+                    if ((mIcbCache != null) && (phoneId == mIcbCachePhoneId) &&
+                            (mIcbCache.isSupportEtag())) {
+                        Rlog.d(LOG_TAG, "handleSetCB(): using ETAG mIcbCache: " + mIcbCache);
+                        requestXcapNetwork(phoneId);
+                        icb = mIcbCache;
+                        icb.setNetwork(mNetwork);
+                        icb.refresh();
+                        mIcbCacheLastQueried = curTime;
+                    } else if ((mIcbCache != null) && (phoneId == mIcbCachePhoneId) &&
+                            ((curTime >= mIcbCacheLastQueried)
+                            && ((curTime - mIcbCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                        Rlog.d(LOG_TAG, "handleSetCB(): using mIcbCache: " + mIcbCache);
+                        icb = mIcbCache;
+                    } else {
+                        //Incoming Call Barring
+                        mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                        mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                        mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                        if (TextUtils.isEmpty(mXcapRoot)) {
+                            Rlog.d(LOG_TAG, "handleSetCB(): ICB XcapRoot = " + mXcapRoot);
+                            if (null != rr.mResult) {
+                                AsyncResult.forMessage(rr.mResult, null,
+                                        new UnknownHostException());
+                                rr.mResult.sendToTarget();
+                            }
+                            return 0;
+                        }
+
+                        requestXcapNetwork(phoneId);
+
+                        setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName,
+                                mPassword, phoneId);
+
+                        icb = mSimservs.getIncomingCommunicationBarring(true, mNetwork);
+                        mIcbCache = icb;
+                        mIcbCachePhoneId = phoneId;
+                        mIcbCacheLastQueried = curTime;
+                        Rlog.d(LOG_TAG, "handleSetCB(): new mIcbCache = " + mIcbCache
+                                + ", curTime = " + curTime);
+                    }
+                }
+
+
+                for (int it = 0; it < num_of_expansion; it++) {
+                    if (num_of_expansion != 1) {
+                        if (original_facility.equals(CommandsInterface.CB_FACILITY_BA_MO)) {
+                            if (it == 0) facility = CommandsInterface.CB_FACILITY_BAOIC;
+                            else if (it == 1) facility = CommandsInterface.CB_FACILITY_BAOICxH;
+                            else if (it == 2) facility = CommandsInterface.CB_FACILITY_BAOC;
+
+                        } else if (original_facility.equals(CommandsInterface.CB_FACILITY_BA_MT)) {
+                            if (it == 0) facility = CommandsInterface.CB_FACILITY_BAICr;
+                            else if (it == 1) facility = CommandsInterface.CB_FACILITY_BAIC;
+
+                        } else if (original_facility.equals(CommandsInterface.CB_FACILITY_BA_ALL)) {
+                            if (it == 0) facility = CommandsInterface.CB_FACILITY_BAOIC;
+                            else if (it == 1) facility = CommandsInterface.CB_FACILITY_BAOICxH;
+                            else if (it == 2) facility = CommandsInterface.CB_FACILITY_BAOC;
+                            else if (it == 3) facility = CommandsInterface.CB_FACILITY_BAICr;
+                            else if (it == 4) facility = CommandsInterface.CB_FACILITY_BAIC;
+                        }
+                    }
+
+                    Rlog.d(LOG_TAG, "handleSetCB():num_of_expansion=" + num_of_expansion
+                            + ", round=" + it + ",for facility=" + facility + ",with lockState="
+                            + lockState);
+
+                    if (facility.equals(CommandsInterface.CB_FACILITY_BAOC) ||
+                            facility.equals(CommandsInterface.CB_FACILITY_BAOIC) ||
+                            facility.equals(CommandsInterface.CB_FACILITY_BAOICxH)) {
+                        RuleSet oRuleSet = ocb.getRuleSet();
+                        List<Rule> ruleList = null;
+                        RuleSet newRuleSet = ocb.createNewRuleSet();
+                        boolean addedNewRule = false;
+
+                        if (oRuleSet != null) {
+                            ruleList = oRuleSet.getRules();
+                        } else {
+                            Rlog.d(LOG_TAG, "No MO related CB rules in remote server");
+                        }
+
+                        //Note that: If no ant configuration is stored in XCAP server (e.g., empty
+                        // xml string), ruleList will be null
+                        if (ruleList != null) {
+                            for (int i = 0; i < ruleList.size(); i++) {
+                                Rule r = ruleList.get(i);
+                                Conditions cond = r.getConditions();
+                                Actions action = r.getActions();
+                                List<String> mediaList = null;
+
+                                if (cond != null) {
+                                    Rlog.d(LOG_TAG, "handleSetCB():MO-facility=" + facility
+                                            + ",action=" + action.isAllow() + ",international="
+                                            + cond.comprehendInternational()
+                                            + ",internationalExHC="
+                                            + cond.comprehendInternationalExHc());
+                                    mediaList = cond.getMedias();
+                                    if (cond.comprehendInternational()) {
+                                        BAOIC_RuleID = r.mId;
+                                        Rlog.d(LOG_TAG, "Update BAOIC_RuleID=" + BAOIC_RuleID);
+                                    } else if (cond.comprehendInternationalExHc()) {
+                                        BAOICExHC_RuleID = r.mId;
+                                        Rlog.d(LOG_TAG, "Update BAOICExHC_RuleID="
+                                            + BAOICExHC_RuleID);
+                                    } else {
+                                        BAOC_RuleID = r.mId;
+                                        Rlog.d(LOG_TAG, "Update BAOC_RuleID=" + BAOC_RuleID);
+                                    }
+                                } else {
+                                    //Add by mtk01411: 2014-0123
+                                    if (cond == null
+                                            && facility.equals(
+                                            CommandsInterface.CB_FACILITY_BAOC)) {
+                                        Rlog.d(LOG_TAG, "handleSetCB():cond=null"
+                                                + " but AO case!MO-facility="
+                                                + facility + ",action=" + action.isAllow());
+                                        mediaList = null;
+                                        if (BAOC_RuleID.equals("AO")) {
+                                            BAOC_RuleID = r.mId;
+                                            Rlog.d(LOG_TAG, "Update BAOC_RuleID=" + BAOC_RuleID);
+                                        }
+                                    } else {
+                                        Rlog.d(LOG_TAG, "handleSetCB():Empty MO cond "
+                                                + "(cond==null) for this rule=" + r);
+                                        if (BAOC_RuleID.equals("AO")) {
+                                            BAOC_RuleID = r.mId;
+                                            Rlog.d(LOG_TAG, "Update BAOC_RuleID=" + BAOC_RuleID);
+                                        }
+                                    }
+                                }
+
+                                if (facility.equals(CommandsInterface.CB_FACILITY_BAOIC) &&
+                                        (cond != null && cond.comprehendInternational()) &&
+                                        containSpecificMedia(mediaList, setCBServiceClass)) {
+
+                                    if ((setCBServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                             || (setCBServiceClass
+                                             == CommandsInterface.SERVICE_CLASS_NONE
+                                             && AddRuleForBAOICWithAllMediaType == false)) {
+                                        addedNewRule = handleCreateNewRuleForExistingCB(ocb,
+                                                newRuleSet, r, facility, lockState,
+                                                setCBServiceClass, BAOIC_RuleID, mUpdateSingleRule,
+                                                num_of_expansion, phoneId);
+                                        Rlog.d(LOG_TAG, "handleSetCB():OI-addedNewRule="
+                                                + addedNewRule);
+                                        //Add this check by mtk01411: If serviceClass=0, it already
+                                        // adds alllow or disallow tag for all mediatype in
+                                        // handleCreateNewRuleForExistingCB()
+                                        if (setCBServiceClass !=
+                                                CommandsInterface.SERVICE_CLASS_NONE) {
+                                            Rule newRule =
+                                                    copyOldRuleToNewRuleSetExceptSpecificMedia(r,
+                                                    newRuleSet, setCBServiceClass, phoneId, -1, -1);
+                                            if ((null != newRule) && mUpdateSingleRule
+                                                    && (1 == num_of_expansion)) {
+                                                ocb.saveRule(newRule.mId);
+                                            }
+                                        } else {
+                                            AddRuleForBAOICWithAllMediaType = true;
+                                        }
+                                    } else if (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAOICWithAllMediaType == true) {
+                                        Rlog.d(LOG_TAG, "Already add rule for BAOIC with"
+                                                + " serviceClass=0 case previously");
+                                    }
+
+                                } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOICxH)
+                                        && (cond != null && cond.comprehendInternationalExHc())
+                                        && containSpecificMedia(mediaList, setCBServiceClass)) {
+
+                                    if ((setCBServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                            || (setCBServiceClass
+                                            == CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAOICxHWithAllMediaType == false)) {
+                                        addedNewRule = handleCreateNewRuleForExistingCB(ocb,
+                                                newRuleSet, r, facility, lockState,
+                                                setCBServiceClass, BAOICExHC_RuleID,
+                                                mUpdateSingleRule, num_of_expansion, phoneId);
+                                        Rlog.d(LOG_TAG, "handleSetCB():OX-addedNewRule="
+                                                + addedNewRule);
+                                        //Add this check by mtk01411: If serviceClass=0, it already
+                                        // adds alllow or disallow tag for all mediatype in
+                                        //handleCreateNewRuleForExistingCB()
+                                        if (setCBServiceClass !=
+                                                CommandsInterface.SERVICE_CLASS_NONE) {
+                                            Rule newRule =
+                                                    copyOldRuleToNewRuleSetExceptSpecificMedia(r,
+                                                    newRuleSet, setCBServiceClass, phoneId, -1, -1);
+                                            if ((null != newRule) && mUpdateSingleRule
+                                                    && (1 == num_of_expansion)) {
+                                                ocb.saveRule(newRule.mId);
+                                            }
+                                        } else {
+                                            AddRuleForBAOICxHWithAllMediaType = true;
+                                        }
+                                    } else if (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAOICxHWithAllMediaType == true) {
+                                        Rlog.d(LOG_TAG, "Already add rule for BAOICxH with " +
+                                                "serviceClass=0 case previously");
+                                    }
+
+                                } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOC) &&
+                                        isBAOC(cond, setCBServiceClass)) {
+
+                                    if ((setCBServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                            || (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE &&
+                                            AddRuleForBAOCWithAllMediaType == false)) {
+                                        addedNewRule = handleCreateNewRuleForExistingCB(ocb,
+                                                newRuleSet, r, facility, lockState,
+                                                setCBServiceClass, BAOC_RuleID, mUpdateSingleRule,
+                                                num_of_expansion, phoneId);
+                                        Rlog.d(LOG_TAG, "handleSetCB():AO-addedNewRule="
+                                                + addedNewRule);
+                                        //Add this check by mtk01411: If serviceClass=0, it already
+                                        // adds alllow or disallow tag for all mediatype in
+                                        // handleCreateNewRuleForExistingCB()
+                                        if (setCBServiceClass !=
+                                                CommandsInterface.SERVICE_CLASS_NONE) {
+                                            Rule newRule =
+                                                     copyOldRuleToNewRuleSetExceptSpecificMedia(r,
+                                                     newRuleSet, setCBServiceClass, phoneId, -1, -1);
+                                            if ((null != newRule) && mUpdateSingleRule
+                                                    && (1 == num_of_expansion)) {
+                                                ocb.saveRule(newRule.mId);
+                                            }
+                                        } else {
+                                            AddRuleForBAOCWithAllMediaType = true;
+                                        }
+                                    } else if (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAOCWithAllMediaType == true) {
+                                        Rlog.d(LOG_TAG, "Already add rule for BAOC with"
+                                                + " serviceClass=0 case previously");
+                                    }
+
+                                } else {
+                                    //Copy old rule into new rule set
+                                    Rlog.d(LOG_TAG, "handleSetCB():MO Copy old rule inot"
+                                            + " newRuleSet");
+                                    copyOldRuleToNewRuleSet(r, newRuleSet, -1, -1);
+                                }
+                            }
+                        }
+
+                        //Add this new setting into the ruleset
+                        //[Scenario#1]For disable CB:Because the mDisableRuleMode is
+                        // DISABLE_MODE_DELETE_RULEL: Not necessary to add rule for this
+                        // serviceClass into new rule set
+                        // -> In handleCreateNewRuleForReqCB():It will return directly if lockState
+                        // is 0 (CB DISABLE)
+                        //[Scenario#2]For enable CB instead of modification one existing rule's
+                        // case: Because there is no any rule is matched in the original rule
+                        // set, it must add a new one!
+                        if (addedNewRule == false) {
+                            //XML stored in remote XCAP server is empty string
+                            //Use facility as the RuleID
+                            //E.g., XCAP server only BAIC but this time's request is BAOC with
+                            // serviceClass=0
+                            Rlog.d(LOG_TAG, "handleSetCB():MO add new rule for this time's"
+                                    + " request-facility=" + facility + ",lockState="
+                                    + lockState + ",serviceClass=" + setCBServiceClass);
+                            String newRuleID = "";
+                            //According to facility to decide the rule-id
+                            if (facility.equals(CommandsInterface.CB_FACILITY_BAOC)) {
+                                newRuleID = BAOC_RuleID;
+                            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOIC)) {
+                                newRuleID = BAOIC_RuleID;
+                            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOICxH)) {
+                                newRuleID = BAOICExHC_RuleID;
+                            }
+                            Rlog.d(LOG_TAG, "handleSetCB():MO add new rule with id=" + newRuleID);
+                            addedNewRule = handleCreateNewRuleForReqCB(ocb, newRuleSet, facility,
+                                    lockState, setCBServiceClass, newRuleID, mUpdateSingleRule,
+                                    num_of_expansion, phoneId);
+
+                        }
+
+                        //Finally, update the new rule set back to remote XCAP server
+                        if (newRuleSet.getRules() != null) {
+                            Rlog.d(LOG_TAG, "Dump MO SetCB  XML:" + newRuleSet.toXmlString());
+                        } else {
+                            Rlog.d(LOG_TAG, "Dump MO SetCB XML: ruleset with empty rules");
+                        }
+
+                        if (!mUpdateSingleRule) {
+                            ocb.saveRuleSet();
+                        } else {
+                            if (num_of_expansion > 1) {
+                                List<Rule> newRuleList = null;
+                                newRuleList = newRuleSet.getRules();
+                                for (int i = 0; i < newRuleList.size(); i++) {
+                                    Rule newRule = newRuleList.get(i);
+                                    ocb.saveRule(newRule.mId);
+                                }
+                            }
+                        }
+                    } else if (facility.equals(CommandsInterface.CB_FACILITY_BAIC) ||
+                            facility.equals(CommandsInterface.CB_FACILITY_BAICr)) {
+                        //Incoming Call Barring
+                        RuleSet iRuleSet = icb.getRuleSet();
+                        List<Rule> ruleList = null;
+                        RuleSet newRuleSet = icb.createNewRuleSet();
+                        boolean addedNewRule = false;
+
+                        if (iRuleSet != null) {
+                            ruleList = iRuleSet.getRules();
+                        } else {
+                            Rlog.d(LOG_TAG, "No MT related CB rules in remote server");
+                        }
+
+                        //Note that: If no ant configuration is stored in XCAP server (e.g., empty
+                        // xml string), ruleList will be null
+                        if (ruleList != null) {
+                            for (int i = 0; i < ruleList.size(); i++) {
+                                Rule r = ruleList.get(i);
+                                Conditions cond = r.getConditions();
+                                Actions action = r.getActions();
+                                List<String> mediaList = null;
+
+                                if (cond != null) {
+                                    Rlog.d(LOG_TAG, "handleSetCB():MT-facility=" + facility
+                                            + ",action=" + action.isAllow() + ",international="
+                                            + cond.comprehendInternational() + ",roaming="
+                                            + cond.comprehendRoaming());
+                                    mediaList = cond.getMedias();
+                                    if (cond.comprehendRoaming()) {
+                                        BAICR_RuleID = r.mId;
+                                        Rlog.d(LOG_TAG, "Update BAICR_RuleID=" + BAICR_RuleID);
+                                    } else {
+                                        BAIC_RuleID = r.mId;
+                                        Rlog.d(LOG_TAG, "Update BAIC_RuleID=" + BAIC_RuleID);
+                                    }
+                                } else {
+                                    Rlog.d(LOG_TAG, "handleSetCB():Empty MT cond (cond==null)"
+                                            + " for this rule=" + r);
+                                    if (BAIC_RuleID.equals("AI")) {
+                                        BAIC_RuleID = r.mId;
+                                        Rlog.d(LOG_TAG, "Update BAIC_RuleID=" + BAIC_RuleID);
+                                    }
+                                }
+
+                                if (facility.equals(CommandsInterface.CB_FACILITY_BAICr) &&
+                                        (cond != null && cond.comprehendRoaming() == true) &&
+                                        containSpecificMedia(mediaList, setCBServiceClass)) {
+
+                                    if ((setCBServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                            || (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAICrWithAllMediaType == false)) {
+                                        //Change enable BAICr to disable BAICr
+                                        addedNewRule = handleCreateNewRuleForExistingCB(icb,
+                                                newRuleSet, r, facility, lockState,
+                                                setCBServiceClass, BAICR_RuleID, mUpdateSingleRule,
+                                                num_of_expansion, phoneId);
+                                        Rlog.d(LOG_TAG, "handleSetCB():IR-addedNewRule="
+                                                + addedNewRule);
+                                        //Add this check by mtk01411: If serviceClass=0, it already
+                                        // adds alllow or disallow tag for all mediatype in
+                                        // handleCreateNewRuleForExistingCB()
+                                        if (setCBServiceClass !=
+                                                CommandsInterface.SERVICE_CLASS_NONE) {
+                                            Rule newRule =
+                                                    copyOldRuleToNewRuleSetExceptSpecificMedia(r,
+                                                    newRuleSet, setCBServiceClass, phoneId, -1, -1);
+                                            if ((null != newRule) && mUpdateSingleRule
+                                                    && (1 == num_of_expansion)) {
+                                                icb.saveRule(newRule.mId);
+                                            }
+                                        } else {
+                                            AddRuleForBAICrWithAllMediaType = true;
+                                        }
+                                    } else if (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAICrWithAllMediaType == true) {
+                                        Rlog.d(LOG_TAG, "Already add rule for BAICr with "
+                                                + "serviceClass=0 case previously");
+                                    }
+
+                                } else if (facility.equals(CommandsInterface.CB_FACILITY_BAIC) &&
+                                        isBAIC(cond, setCBServiceClass) &&
+                                        containSpecificMedia(mediaList, setCBServiceClass)) {
+
+                                    if ((setCBServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                            || (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAICWithAllMediaType == false)) {
+                                        addedNewRule = handleCreateNewRuleForExistingCB(icb,
+                                                newRuleSet, r, facility, lockState,
+                                                setCBServiceClass, BAIC_RuleID, mUpdateSingleRule,
+                                                num_of_expansion, phoneId);
+                                        Rlog.d(LOG_TAG, "handleSetCB():AI-addedNewRule="
+                                                + addedNewRule);
+                                        //Add this check by mtk01411: If serviceClass=0, it already
+                                        // adds alllow or disallow tag for all mediatype in
+                                        // handleCreateNewRuleForExistingCB()
+                                        if (setCBServiceClass !=
+                                                CommandsInterface.SERVICE_CLASS_NONE) {
+                                            Rule newRule =
+                                                    copyOldRuleToNewRuleSetExceptSpecificMedia(r,
+                                                    newRuleSet,
+                                                    setCBServiceClass, phoneId, -1, -1);
+                                            if ((null != newRule) && mUpdateSingleRule
+                                                    && (1 == num_of_expansion)) {
+                                                icb.saveRule(newRule.mId);
+                                            }
+                                        } else {
+                                            AddRuleForBAICWithAllMediaType = true;
+                                        }
+                                    } else if (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAICWithAllMediaType == true) {
+                                        Rlog.d(LOG_TAG, "Already add rule for BAIC with"
+                                                + " serviceClass=0 case previously");
+                                    }
+
+                                } else {
+                                    //Copy old rule into new rule set
+                                    Rlog.d(LOG_TAG, "handleSetCB():MT Copy old rule inot "
+                                            + "newRuleSet");
+                                    copyOldRuleToNewRuleSet(r, newRuleSet, -1, -1);
+
+                                }
+                            }
+                        }
+
+                        //Add this new setting into the ruleset
+                        if (addedNewRule == false) {
+                            //XML stored in remote XCAP server is empty string
+                            //Use facility as the RuleID
+                            //E.g., XCAP server only BAICr but this time's request is BAIC with
+                            // serviceClass=0
+                            Rlog.d(LOG_TAG, "handleSetCB():MT add new rule for this time's "
+                                    + "request-facility=" + facility + ",lockState=" + lockState
+                                    + ",serviceClass=" + setCBServiceClass);
+                            String newRuleID = "";
+                            //According to facility to decide the rule-id
+                            if (facility.equals(CommandsInterface.CB_FACILITY_BAIC)) {
+                                newRuleID = BAIC_RuleID;
+                            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAICr)) {
+                                newRuleID = BAICR_RuleID;
+                            }
+                            Rlog.d(LOG_TAG, "handleSetCB():MT add new rule with id=" + newRuleID);
+                            addedNewRule = handleCreateNewRuleForReqCB(icb, newRuleSet, facility,
+                                    lockState, setCBServiceClass, newRuleID, mUpdateSingleRule,
+                                    num_of_expansion, phoneId);
+
+                        }
+
+                        //Finally, update the new rule set back to remote XCAP server
+                        if (newRuleSet.getRules() != null) {
+                            Rlog.d(LOG_TAG, "Dump MT SetCB XML:" + newRuleSet.toXmlString());
+                        } else {
+                            Rlog.d(LOG_TAG, "Dump MT SetCB XML: ruleset with empty rules");
+                        }
+
+                        if (!mUpdateSingleRule) {
+                            icb.saveRuleSet();
+                        } else {
+                            if (num_of_expansion > 1) {
+                                List<Rule> newRuleList = null;
+                                newRuleList = newRuleSet.getRules();
+                                for (int i = 0; i < newRuleList.size(); i++) {
+                                    Rule newRule = newRuleList.get(i);
+                                    icb.saveRule(newRule.mId);
+                                }
+                            }
+                        }
+                    } else if (facility.equals(CommandsInterface.CB_FACILITY_BA_ALL)
+                            && lockState == 0) {
+                        //Disable All Call Barring Cases (Triggered by
+                        // CallBarringResetPreference.java)
+
+                        RuleSet iNewRuleSet = null;
+                        RuleSet oNewRuleSet = null;
+                        RuleSet oldRuleSet = null;
+                        List<Rule> ruleList = null;
+
+                        //Note that:If no rule in RuleSet: In RuleSet.java's toXmlString(): get
+                        // null rule -> Null Pointer Exception
+                        //Read original rule first then copy each rule to new rule set but with
+                        // allow as true!
+                        oldRuleSet = ocb.getRuleSet();
+                        if (oldRuleSet != null) {
+                            ruleList = oldRuleSet.getRules();
+                        } else {
+                            Rlog.d(LOG_TAG, "No MO related CB rules in remote server");
+                        }
+
+                        if (ruleList != null) {
+                            oNewRuleSet = ocb.createNewRuleSet();
+                            for (int i = 0; i < ruleList.size(); i++) {
+                                Rule r = ruleList.get(i);
+                                copyOldRuleToNewRuleSetWithDisabledCB(r, oNewRuleSet, true, -1, -1);
+                            }
+
+                            if (oNewRuleSet.getRules() != null) {
+                                Rlog.d(LOG_TAG, "Dump MO Disable All CB XML:"
+                                        + oNewRuleSet.toXmlString());
+                            } else {
+                                Rlog.d(LOG_TAG, "Dump MO Disable All CB XML: ruleset with empty "
+                                        + "rules");
+                            }
+                            if (!mUpdateSingleRule) {
+                                ocb.saveRuleSet();
+                            } else {
+                                List<Rule> newRuleList = null;
+                                newRuleList = oNewRuleSet.getRules();
+                                for (int i = 0; i < newRuleList.size(); i++) {
+                                    Rule newRule = newRuleList.get(i);
+                                    ocb.saveRule(newRule.mId);
+                                }
+                            }
+                        } else {
+                            Rlog.d(LOG_TAG, "No MO related CB rules in remote server");
+                        }
+
+                        oldRuleSet = icb.getRuleSet();
+                        if (oldRuleSet != null) {
+                            ruleList = oldRuleSet.getRules();
+                        } else {
+                            Rlog.d(LOG_TAG, "No MT related CB rules in remote server");
+                        }
+
+                        if (ruleList != null) {
+                            iNewRuleSet = icb.createNewRuleSet();
+                            for (int i = 0; i < ruleList.size(); i++) {
+                                Rule r = ruleList.get(i);
+                                copyOldRuleToNewRuleSetWithDisabledCB(r, iNewRuleSet, true, -1, -1);
+                            }
+
+                            if (iNewRuleSet.getRules() != null) {
+                                Rlog.d(LOG_TAG, "Dump MT Disable All CB XML:"
+                                        + iNewRuleSet.toXmlString());
+                            } else {
+                                Rlog.d(LOG_TAG, "Dump MT Disable All CB XML: ruleset with empty"
+                                        + " rules");
+                            }
+                            if (!mUpdateSingleRule) {
+                                icb.saveRuleSet();
+                            } else {
+                                List<Rule> newRuleList = null;
+                                newRuleList = iNewRuleSet.getRules();
+                                for (int i = 0; i < newRuleList.size(); i++) {
+                                    Rule newRule = newRuleList.get(i);
+                                    icb.saveRule(newRule.mId);
+                                }
+                            }
+                        } else {
+                            Rlog.d(LOG_TAG, "No MT related CB rules in remote server");
+                        }
+
+                    } else {
+                        //Not supported request & parameters
+                        throw new RuntimeException("Unrecognized SET_CB facility= "
+                               + facility + " and its parameters");
+                    }
+                } //end-of-for-loop (num_of_expansion)
+
+            } catch (XcapException xcapException) {
+                mOcbCache = null;
+                mOcbCachePhoneId = -1;
+                mOcbCacheLastQueried = 0;
+                mIcbCache = null;
+                mIcbCachePhoneId = -1;
+                mIcbCacheLastQueried = 0;
+
+                if (xcapException.getHttpErrorCode() == HTTP_ERROR_CODE_412) {
+                    Rlog.d(LOG_TAG, "handleSetCB(): HTTP_ERROR_CODE_412");
+                    return HTTP_ERROR_CODE_412;
+                }
+                Rlog.d(LOG_TAG, "handleSetCB(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCB(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCB(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            } catch (Exception e) {
+
+                //Get XCAP's configuration failed or set new configuration failed
+                //Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCB():Start to Print Stack Trace");
+                mOcbCache = null;
+                mOcbCachePhoneId = -1;
+                mOcbCacheLastQueried = 0;
+                mIcbCache = null;
+                mIcbCachePhoneId = -1;
+                mIcbCacheLastQueried = 0;
+
+                e.printStackTrace();
+
+                //Note that: upper layer application
+                // (CallBarringBasePreference.java:handleSetCallBarringResponse())
+                //Only cast the exception to CommandException is allowed (but it may happen
+                // assertion due to cast failure)
+                //And handle this exception in TimeConsumingPreferenceActivity.java's onError()
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+
+            }
+
+            //[Notify upper's application about the SET_CB result - Success Case without exception]
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+
+            return 0;
+        }
+
+        /// For OP01 UT @{
+        public void handleGetCFInTimeSlot(MMTelSSRequest rr) {
+            int reqNo = -1;
+            int serialNo = -1;
+            CallForwardInfoEx infos[] = null;
+            ArrayList<CallForwardInfoEx> queriedCallForwardInfoList =
+                    new ArrayList<CallForwardInfoEx>();
+
+            int reason = -1;
+            int serviceClass = -1;
+            int orgServiceClass = -1;
+            String cfPhoneNum = "";
+            int queryStatus = 0; // 0: DISABLE, 1: ENABLE
+            int noReplyTimer = 20;
+            long[] timeSlot = null;
+            int phoneId = 0;
+
+            try {
+                rr.mp.setDataPosition(0);
+                reqNo = rr.mp.readInt();
+                serialNo = rr.mp.readInt();
+                reason = rr.mp.readInt();
+                serviceClass = rr.mp.readInt();
+                phoneId = rr.mp.readInt();
+                orgServiceClass = serviceClass;
+
+                Rlog.d(LOG_TAG, "Read from CF parcel: req = " + requestToString(reqNo) +
+                        ", reason = " + reason + ", serviceClass = " + serviceClass);
+
+                if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                    Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): !isPreferXcap()");
+                    throw new UnknownHostException();
+                }
+
+                CommunicationDiversion cd;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): mCdCache = " + mCdCache + ", curTime = "
+                        + curTime + ", mCdCacheLastQueried = " + mCdCacheLastQueried);
+                if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        (mCdCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): using ETAG mCdCache: " + mCdCache);
+                    requestXcapNetwork(phoneId);
+                    cd = mCdCache;
+                    cd.setNetwork(mNetwork);
+                    cd.refresh();
+                    mCdCacheLastQueried = curTime;
+                } else if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        ((curTime >= mCdCacheLastQueried)
+                        && ((curTime - mCdCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): using mCdCache: " + mCdCache);
+                    cd = mCdCache;
+                } else {
+                    requestXcapNetwork(phoneId);
+
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): XcapRoot = " + mXcapRoot);
+                        throw new UnknownHostException();
+                    }
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+
+                    cd = mSimservs.getCommunicationDiversion(true, mNetwork);
+                    mCdCache = cd;
+                    mCdCachePhoneId = phoneId;
+                    mCdCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): new mCdCache = " + mCdCache
+                            + ", curTime = " + curTime);
+                }
+
+                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): GetRuleSet from cd");
+
+                RuleSet ruleSet = cd.getRuleSet();
+                // In Communication Diversion's RuleSet, it may have several rules
+                // (e.g., rule for CFU, rule for CFB, rule for CFNoAnswer, rule for CFNotReachable)
+                List<Rule> ruleList = null;
+
+                if (ruleSet != null) {
+                    ruleList = ruleSet.getRules();
+                } else {
+                    Rlog.d(LOG_TAG, "No CF related rules in remote server");
+                }
+
+                // Note that: If no ant configuration is stored in XCAP server
+                // (e.g., empty xml string), ruleList will be null
+                if (ruleList != null) {
+                    // Change the serviceClass (VIDEO + DATA_SYNC) to VIDEO directly
+                    if (orgServiceClass == (CommandsInterface.SERVICE_CLASS_VIDEO |
+                            CommandsInterface.SERVICE_CLASS_DATA_SYNC)) {
+                        serviceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                    }
+
+                    int numOfComparision = 0;
+
+                    if (orgServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                        serviceClass = CommandsInterface.SERVICE_CLASS_VOICE;
+                        // one is to match audio (i.e., serviceClass = SERVICE_CLASS_VOICE),
+                        // the other is to match video (i.e., SERVICE_CLASS_VIDEO)
+                        numOfComparision = 2;
+                        Rlog.d(LOG_TAG, "serviceClass == 0, " +
+                                "try to 1st match by using SERVICE_CLASS_VOICE");
+                    } else {
+                        // Specific serviceClass (i.e., value is not 0)
+                        // is carried from the upper layer
+                        numOfComparision = 1;
+                    }
+
+                    for (int it = 0; it < numOfComparision; it++) {
+                        if (it == 1 && serviceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                            // 2nd time to match all rules by using SERVICE_CLASS_VIDEO
+                            serviceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                            Rlog.d(LOG_TAG, "serviceClass == 0, " +
+                                    "try to 2nd match by using SERVICE_CLASS_VIDEO");
+                        }
+
+                        Rlog.d(LOG_TAG, "numOfComparision = " + numOfComparision +
+                                ": with round = " + (it + 1) +
+                                ", with service class = " + serviceClass);
+
+                        // Check each rule & its corresponding condition/action
+                        for (int i = 0; i < ruleList.size(); i++) {
+                            Rule r = ruleList.get(i);
+                            Conditions cond = r.getConditions();
+                            Actions action = r.getActions();
+                            List<String> mediaList = null;
+
+                            if (cond != null) {
+                                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): " +
+                                        "busy = " + cond.comprehendBusy() +
+                                        ", NoAnswer = " + cond.comprehendNoAnswer() +
+                                        ", NoReachable = " + cond.comprehendNotReachable() +
+                                        ", NotRegistered = " + cond.comprehendNotRegistered());
+                                mediaList = cond.getMedias();
+                            } else {
+                                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): " +
+                                        "Empty cond (cond==null) for this rule=" + r);
+                            }
+
+                            if (reason == CommandsInterface.CF_REASON_UNCONDITIONAL &&
+                                    ((cond != null && cond.comprehendBusy() == false &&
+                                    cond.comprehendNoAnswer() == false &&
+                                    cond.comprehendNotRegistered() == false &&
+                                    cond.comprehendNotReachable() == false) &&
+                                    cond.comprehendRuleDeactivated() == false || cond == null) &&
+                                    containSpecificMedia(mediaList, serviceClass)) {
+                                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): " +
+                                        "CFU is enabled on server");
+                                // [CFU]CFU is enabled, set queryStatus as 1
+                                queryStatus = 1;
+                                if (action.getFowardTo() != null) {
+                                    cfPhoneNum = action.getFowardTo().getTarget();
+                                }
+                                // timeSeconds: This field is not required by CFU
+                                // (Only required by CFNoAnswer)
+                                noReplyTimer = cd.getNoReplyTimer();
+                                if (cond != null) {
+                                    timeSlot = convertToLocalTime(cond.comprehendTime());
+                                }
+                                break;
+                            } else {
+                                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot()from xcap: " +
+                                        "Not matched this rule!");
+                            }
+                        }
+                        CallForwardInfoEx item = new CallForwardInfoEx();
+                        item.status = queryStatus;
+                        item.reason = reason;
+                        item.serviceClass = serviceClass;
+                        item.toa = 0;
+                        item.number = cfPhoneNum;
+                        item.timeSeconds = noReplyTimer;
+                        item.timeSlot = timeSlot;
+                        Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): " +
+                                "add one record with reason = " + reason +
+                                ", serviceClass = " + serviceClass +
+                                ", queryStatus = " + queryStatus +
+                                ", timeSlot = " + Arrays.toString(timeSlot));
+                        queriedCallForwardInfoList.add(item);
+
+                        // Reset some variables for this matching result
+                        queryStatus = 0; // 0: DISABLE, 1: ENABLE
+                        cfPhoneNum = "";
+                        noReplyTimer = 20;
+                        timeSlot = null;
+                    }
+                    // end of for-loop(numOfComparision)
+
+                    int queriedSize = queriedCallForwardInfoList.size();
+
+                    infos = new CallForwardInfoEx[queriedSize];
+                    for (int inx = 0; inx < queriedSize; inx++) {
+                        infos[inx] = (CallForwardInfoEx) queriedCallForwardInfoList.get(inx);
+                    }
+                } else {
+                    // Empty XML String:CF is disabled, set queryStatus as 0
+                    Rlog.d(LOG_TAG, "handleGetCFInTimeSlot():get null ruleList");
+                    infos = new CallForwardInfoEx[0];
+                    queryStatus = 0;
+                }
+            } catch (UnknownHostException unknownHostException) {
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, unknownHostException);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): XcapException");
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): Start to Print Stack Trace");
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            }
+
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, infos, null);
+                rr.mResult.sendToTarget();
+            }
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        public int handleSetCFInTimeSlot(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+
+            int setCFAction = rr.mp.readInt();
+            int setCFReason = rr.mp.readInt();
+            int setCFServiceClass = rr.mp.readInt();
+            String setCFNumber = rr.mp.readString();
+            int setCFTimeSeconds = rr.mp.readInt();
+            long[] timeSlot = new long[2];
+            try {
+                rr.mp.readLongArray(timeSlot);
+            } catch (Exception e) {
+                timeSlot = null;
+            }
+            String timeSlotString = convertToSeverTime(timeSlot);
+            int phoneId = rr.mp.readInt();
+
+            boolean addRuleForCFUWithAllMediaType = false;
+            String cfuRuleID = "CFU";
+
+            Rlog.d(LOG_TAG, "Read from CF parcel: req = " + requestToString(reqNo) +
+                    ", cfAction = " + setCFAction + ", reason = " + setCFReason +
+                    ", serviceClass = " + setCFServiceClass + ", number = " + setCFNumber +
+                    ", timeSec = " + setCFTimeSeconds +
+                    ", timsSlot = " + timeSlotString);
+
+            String xcapCFNum = SystemProperties.get(PROP_SS_CFNUM, "");
+            if (xcapCFNum.startsWith("sip:") ||
+                    xcapCFNum.startsWith("sips:") ||
+                    xcapCFNum.startsWith("tel:")) {
+                Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): " +
+                        "get call forwarding num from EM setting: " + xcapCFNum);
+                String ssMode = SystemProperties.get(PROP_SS_MODE, MODE_SS_XCAP);
+                Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): ssMode = " + ssMode);
+                if (MODE_SS_XCAP.equals(ssMode)) {
+                    setCFNumber = xcapCFNum;
+                }
+            }
+
+            // Change the serviceClass (VIDEO + DATA_SYNC) to VIDEO directly
+            if (setCFServiceClass == (CommandsInterface.SERVICE_CLASS_VIDEO |
+                    CommandsInterface.SERVICE_CLASS_DATA_SYNC)) {
+                setCFServiceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+            }
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return 0;
+            }
+
+            try {
+                CommunicationDiversion cd;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): mCdCache = " + mCdCache + ", curTime = "
+                        + curTime + ", mCdCacheLastQueried = " + mCdCacheLastQueried
+                        + ", phoneId = " + phoneId);
+                if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        (mCdCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): using ETAG mCdCache: " + mCdCache);
+                    requestXcapNetwork(phoneId);
+                    cd = mCdCache;
+                    cd.setNetwork(mNetwork);
+                    cd.refresh();
+                    mCdCacheLastQueried = curTime;
+                } else if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        ((curTime >= mCdCacheLastQueried)
+                        && ((curTime - mCdCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): using mCdCache: " + mCdCache);
+                    cd = mCdCache;
+                } else {
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): XcapRoot = " + mXcapRoot);
+                        if (null != rr.mResult) {
+                            AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                            rr.mResult.sendToTarget();
+                        }
+                        return 0;
+                    }
+
+                    requestXcapNetwork(phoneId);
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+                    cd = mSimservs.getCommunicationDiversion(true, mNetwork);
+                    mCdCache = cd;
+                    mCdCachePhoneId = phoneId;
+                    mCdCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): new mCdCache = " + mCdCache
+                            + ", curTime = " + curTime);
+                }
+
+                RuleSet ruleSet = cd.getRuleSet();
+                List<Rule> ruleList = null;
+                RuleSet newRuleSet = cd.createNewRuleSet();
+                boolean addedNewRule = false;
+
+                if (ruleSet != null) {
+                    ruleList = ruleSet.getRules();
+                } else {
+                    Rlog.d(LOG_TAG, "No CF related rules in remote server");
+                }
+
+                // Note that: If no ant configuration is stored in XCAP server
+                // (e.g., empty xml string), ruleList will be null
+                if (ruleList != null) {
+                    // Check each rule & its corresponding condition/action
+                    for (int i = 0; i < ruleList.size(); i++) {
+                        Rule r = ruleList.get(i);
+                        Conditions cond = r.getConditions();
+                        Actions action = r.getActions();
+                        List<String> mediaList = null;
+
+                        if (cond != null) {
+                            mediaList = cond.getMedias();
+                            Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): " +
+                                    "busy = " + cond.comprehendBusy() +
+                                    ", NoAnswer = " + cond.comprehendNoAnswer() +
+                                    ", NoReachable = " + cond.comprehendNotReachable() +
+                                    ", NotRegistered = " + cond.comprehendNotRegistered());
+                            if (cond.comprehendBusy()) {
+                                Rlog.d(LOG_TAG, "The rule is CFB");
+                            } else if (cond.comprehendNoAnswer()) {
+                                Rlog.d(LOG_TAG, "The rule is CFNoAnswer");
+                            } else if (cond.comprehendNotReachable()) {
+                                Rlog.d(LOG_TAG, "The rule is CFNotReachable");
+                            } else if (cond.comprehendNotRegistered()) {
+                                Rlog.d(LOG_TAG, "The rule is CFNotRegistered");
+                            } else {
+                                cfuRuleID = r.mId;
+                                Rlog.d(LOG_TAG, "Update cfuRuleID = " + cfuRuleID);
+                            }
+                        } else {
+                            Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): " +
+                                    "Empty cond (cond==null) for this rule = " + r);
+                            if (cfuRuleID.equals("CFU")) {
+                                //CFU rule
+                                cfuRuleID = r.mId;
+                                Rlog.d(LOG_TAG, "Update cfuRuleID = " + cfuRuleID);
+                            }
+                        }
+
+                        if (setCFReason == CommandsInterface.CF_REASON_UNCONDITIONAL &&
+                                ((cond != null && cond.comprehendBusy() == false &&
+                                cond.comprehendNoAnswer() == false &&
+                                cond.comprehendNotRegistered() == false &&
+                                cond.comprehendNotReachable() == false) || cond == null) &&
+                                containSpecificMedia(mediaList, setCFServiceClass)) {
+
+                            if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE) ||
+                                    (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE &&
+                                    addRuleForCFUWithAllMediaType == false)) {
+                                if (setCFAction == CommandsInterface.CF_ACTION_ENABLE ||
+                                        setCFAction == CommandsInterface.CF_ACTION_REGISTRATION) {
+                                    addedNewRule = handleCreateNewRuleForCFInTimeSlot(
+                                            cd, newRuleSet, setCFReason, setCFAction,
+                                            setCFServiceClass, setCFNumber, setCFTimeSeconds,
+                                            timeSlotString, cfuRuleID, mUpdateSingleRule);
+                                } else {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(
+                                            cd, newRuleSet, r, setCFReason, setCFAction,
+                                            setCFServiceClass, setCFNumber, setCFTimeSeconds,
+                                            cfuRuleID, mUpdateSingleRule, 1, phoneId);
+                                }
+                                Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): CFU-addedNewRule = " +
+                                        addedNewRule);
+                                if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                                    addRuleForCFUWithAllMediaType = true;
+                                }
+                            } else if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE &&
+                                    addRuleForCFUWithAllMediaType == true) {
+                                Rlog.d(LOG_TAG, "Already add rule for CFU previously");
+                            }
+                        } else {
+                            // Copy old rule into new rule set
+                            Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): " +
+                                    "Copy old rule to newRuleSet");
+                            copyOldRuleToNewRuleSet(r, newRuleSet, setCFAction, setCFReason);
+                        }
+                    }
+                    // end-of-for-loop (ruleList)
+                }
+
+                // Check if the new rule user wants to be modified is already added to or not
+                if (addedNewRule == false &&
+                        (setCFAction == CommandsInterface.CF_ACTION_ENABLE ||
+                        setCFAction == CommandsInterface.CF_ACTION_REGISTRATION)) {
+                    addedNewRule = true;
+                    handleCreateNewRuleForCFInTimeSlot(
+                            cd, newRuleSet, setCFReason, setCFAction,
+                            setCFServiceClass, setCFNumber, setCFTimeSeconds,
+                            timeSlotString, cfuRuleID, mUpdateSingleRule);
+                }
+
+                // Finally, update the new rule set back to remote XCAP server
+                // Debug:
+                if (newRuleSet.getRules() != null) {
+                    Rlog.d(LOG_TAG, "Dump SetCF XML: " + newRuleSet.toXmlString());
+                } else {
+                    Rlog.d(LOG_TAG, "Dump SetCF XML: ruleset with empty rules");
+                }
+
+                if (!mUpdateSingleRule) {
+                    cd.saveRuleSet();
+                }
+            } catch (XcapException xcapException) {
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+                if (xcapException.getHttpErrorCode() == HTTP_ERROR_CODE_412) {
+                    
+                    Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): HTTP_ERROR_CODE_412");
+                    return HTTP_ERROR_CODE_412;
+                }
+                Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): XcapException");
+                xcapException.printStackTrace();
+                if (rr.mResult != null) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            } catch (Exception e) {
+                // Get XCAP's configuration failed or set new configuration failed
+                // Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): Start to Print Stack Trace");
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            }
+
+            // [Notify upper's application about the SET_CF result - Success Case]
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+
+            return 0;
+        }
+
+        public boolean handleCreateNewRuleForCFInTimeSlot(CommunicationDiversion cd,
+                RuleSet newRuleSet, int setCFReason, int setCFAction,
+                int setCFServiceClass, String setCFNumber, int setCFTimeSeconds,
+                String timeSlot, String ruleID, boolean updateSingleRule) throws XcapException {
+            // Create a new rule
+            Rule cfRule = newRuleSet.createNewRule(ruleID);
+            Conditions cfCond = cfRule.createConditions();
+            Actions cfAction = cfRule.createActions();
+            Rlog.d(LOG_TAG, "handleCreateNewRuleForCFInTimeSlot(): reason = " + setCFReason +
+                    ", serviceClass = " + setCFServiceClass + ", number = " + setCFNumber +
+                    ", cfTime = " + setCFTimeSeconds +
+                    ", timeSlot = " + timeSlot);
+            // Add media into this new rule
+            if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                cfCond.addMedia("audio");
+            } else if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_VIDEO) {
+                cfCond.addMedia("video");
+            } else if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                cfCond.addMedia("audio");
+                cfCond.addMedia("video");
+            }
+
+            if (setCFReason == CommandsInterface.CF_REASON_BUSY) {
+                cfCond.addBusy();
+            } else if (setCFReason == CommandsInterface.CF_REASON_NO_REPLY) {
+                cfCond.addNoAnswer();
+            } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REACHABLE) {
+                cfCond.addNotReachable();
+            } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REGISTERED) {
+                cfCond.addNotRegistered();
+            } else if (setCFReason == CommandsInterface.CF_REASON_UNCONDITIONAL) {
+                // Not set any conditions -> always evaluate the result as true
+            }
+            cfCond.addTime(timeSlot);
+            if (MMTelSSUtils.isNotifyCallerTest()) {
+                cfAction.setFowardTo(setCFNumber, false);
+            } else {
+                cfAction.setFowardTo(setCFNumber, true);
+            }
+            cfAction.getFowardTo().setRevealIdentityToCaller(true);
+            cfAction.getFowardTo().setRevealIdentityToTarget(true);
+
+            if (updateSingleRule) {
+                cd.saveRule(ruleID);
+            }
+            return true;
+        }
+
+        public long[] convertToLocalTime(String timeSlotString) {
+            long[] timeSlot = null;
+            if (timeSlotString != null) {
+                String[] timeArray = timeSlotString.split(",", 2);
+                if (timeArray.length == 2) {
+                    timeSlot = new long[2];
+                    for (int i = 0; i < 2; i++) {
+                        SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm");
+                        dateFormat.setTimeZone(TimeZone.getTimeZone("GMT+8"));
+                        try {
+                            Date date = dateFormat.parse(timeArray[i]);
+                            timeSlot[i] = date.getTime();
+                        } catch (ParseException e) {
+                            e.printStackTrace();
+                            return null;
+                        }
+                    }
+                }
+            }
+            return timeSlot;
+        }
+
+        public String convertToSeverTime(long[] timeSlot) {
+            String timeSlotString = null;
+            if (timeSlot == null || timeSlot.length != 2) {
+                return null;
+            }
+            for (int i = 0; i < timeSlot.length; i++) {
+                Date date = new Date(timeSlot[i]);
+                SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm");
+                dateFormat.setTimeZone(TimeZone.getTimeZone("GMT+8"));
+                if (i == 0) {
+                    timeSlotString = dateFormat.format(date);
+                } else {
+                    timeSlotString += "," + dateFormat.format(date);
+                }
+            }
+            return timeSlotString;
+        }
+        /// @}
+
+        //***** Handler implementation
+        @Override public void
+        handleMessage(Message msg) {
+            MMTelSSRequest rr = (MMTelSSRequest) (msg.obj);
+            MMTelSSRequest req = null;
+
+            switch (msg.what) {
+                case EVENT_SEND:
+                    /**
+                     * mRequestMessagePending++ already happened for every
+                     * EVENT_SEND, thus we must make sure
+                     * mRequestMessagePending-- happens once and only once
+                     */
+                    boolean alreadySubtracted = false;
+                    int reqNo = -1;
+                    int serialNo = -1;
+
+                    Rlog.d(LOG_TAG, "handleMessage(): EVENT_SEND:"
+                            + "mRequestMessagesPending = " + mRequestMessagesPending
+                            + ", mRequestsList.size() = " + mRequestsList.size());
+                    try {
+                        synchronized (mRequestsList) {
+                            mRequestsList.add(rr);
+                        }
+
+                        mRequestMessagesPending--;
+                        alreadySubtracted = true;
+                        //MTK-END [mtk04070][111121][ALPS00093395]MTK modified
+
+
+                        //[MMTelSS] Because it always gets response from simServs immediately,
+                        // it must invoke findAndRemoveRequestFromList() here instead of RIL's
+                        // invoking at proceeResponse()
+                        findAndRemoveRequestFromList(rr.mSerial);
+
+                        //Rlog.d(LOG_TAG, "Receive MMTelSS Request:" + requestToString(rr.mRequest)
+                        // + ", parcel dataLen=" + data.length);
+                        Rlog.d(LOG_TAG, "Receive MMTelSS Request:" + requestToString(rr.mRequest));
+
+                        switch (rr.mRequest) {
+                            case MMTELSS_REQ_SET_CLIR:
+                                if (HTTP_ERROR_CODE_412 == handleSetCLIR(rr)) {
+                                    Rlog.d(LOG_TAG, "Cache out of date, handleSetCLIR() again");
+                                    handleSetCLIR(rr);
+                                }
+                                break;
+                            case MMTELSS_REQ_GET_CLIR:
+                                handleGetCLIR(rr);
+                                break;
+                            case MMTELSS_REQ_GET_CLIP:
+                                handleGetCLIP(rr);
+                                break;
+                            case MMTELSS_REQ_GET_COLP:
+                                handleGetCOLP(rr);
+                                break;
+                            case MMTELSS_REQ_GET_COLR:
+                                handleGetCOLR(rr);
+                                break;
+                            case MMTELSS_REQ_SET_CW:
+                                if (HTTP_ERROR_CODE_412 == handleSetCW(rr)) {
+                                    Rlog.d(LOG_TAG, "Cache out of date, handleSetCW() again");
+                                    handleSetCW(rr);
+                                }
+                                break;
+                            case MMTELSS_REQ_GET_CW:
+                                handleGetCW(rr);
+                                break;
+                            case MMTELSS_REQ_SET_CB:
+                                if (HTTP_ERROR_CODE_412 == handleSetCB(rr)) {
+                                    Rlog.d(LOG_TAG, "Cache out of date, handleSetCB() again");
+                                    handleSetCB(rr);
+                                }
+                                break;
+                            case MMTELSS_REQ_GET_CB:
+                                handleGetCB(rr);
+                                break;
+                            case MMTELSS_REQ_SET_CF:
+                                if (HTTP_ERROR_CODE_412 == handleSetCF(rr)) {
+                                    Rlog.d(LOG_TAG, "Cache out of date, handleSetCF() again");
+                                    handleSetCF(rr);
+                                }
+                                break;
+                            case MMTELSS_REQ_GET_CF:
+                                handleGetCF(rr);
+                                break;
+                            case MMTELSS_REQ_SET_CLIP:
+                                handleSetCLIP(rr);
+                                break;
+                            case MMTELSS_REQ_SET_COLP:
+                                handleSetCOLP(rr);
+                                break;
+                            case MMTELSS_REQ_SET_COLR:
+                                handleSetCOLR(rr);
+                                break;
+                            /// For OP01 UT @{
+                            case MMTELSS_REQ_SET_CF_TIME_SLOT:
+                                if (HTTP_ERROR_CODE_412 == handleSetCFInTimeSlot(rr)) {
+                                    Rlog.d(LOG_TAG, "Cache out of date, handleSetCFInTimeSlot()"
+                                            + " again");
+                                    handleSetCFInTimeSlot(rr);
+                                }
+                                break;
+                            case MMTELSS_REQ_GET_CF_TIME_SLOT:
+                                handleGetCFInTimeSlot(rr);
+                                break;
+                            /// @}
+                            default:
+                                Rlog.d(LOG_TAG, "Invalid MMTelSS Request:" + rr.mRequest);
+                                throw new RuntimeException("Unrecognized MMTelSS Request: "
+                                        + rr.mRequest);
+                        }
+
+                        //Rlog.v(LOG_TAG, "writing packet: " + data.length + " bytes");
+
+                    } catch (RuntimeException exc) {
+                        Rlog.e(LOG_TAG, "Uncaught exception ", exc);
+                        req = findAndRemoveRequestFromList(rr.mSerial);
+                        // make sure this request has not already been handled,
+                        // eg, if RILReceiver cleared the list.
+                        Rlog.d(LOG_TAG, "handleMessage(): RuntimeException:"
+                                + "mRequestMessagesPending = " + mRequestMessagesPending
+                                + ", mRequestsList.size() = " + mRequestsList.size());
+                        if (req != null || !alreadySubtracted) {
+                            rr.onError(RILConstants.GENERIC_FAILURE, null);
+                            rr.release();
+                        }
+                    } finally {
+                        // Note: We are "Done" only if there are no outstanding
+                        // requests or replies. Thus this code path will only release
+                        // the wake lock on errors.
+                        releaseWakeLockIfDone();
+                    }
+
+                    //MTK-START [mtk04070][111121][ALPS00093395]MTK modified
+                    if (!alreadySubtracted) {
+                        Rlog.d(LOG_TAG, "handleMessage(): !alreadySubtracted:"
+                                + "mRequestMessagesPending = " + mRequestMessagesPending
+                                + ", mRequestsList.size() = " + mRequestsList.size());
+                        mRequestMessagesPending--;
+                    }
+                    //MTK-END [mtk04070][111121][ALPS00093395]MTK modified
+
+                    //Recycle the Parcel object back to the pool by mtk01411
+                    if (rr.mp != null) {
+                        rr.mp.recycle();
+                        rr.mp = null;
+                    }
+
+                    if ((mRequestMessagesPending != 0) || (mRequestsList.size() != 0)) {
+                        Rlog.d(LOG_TAG, "handleMessage(): ERROR wakeLock:"
+                                + "mRequestMessagesPending = " + mRequestMessagesPending
+                                + ", mRequestsList.size() = " + mRequestsList.size());
+                    }
+                    break;
+
+                case EVENT_WAKE_LOCK_TIMEOUT:
+                    // Haven't heard back from the last request.  Assume we're
+                    // not getting a response and  release the wake lock.
+                    // TODO should we clean up mRequestList and mRequestPending
+                    synchronized (mWakeLock) {
+                        if (mWakeLock.isHeld()) {
+                            if (DBG) {
+                                synchronized (mRequestsList) {
+                                    int count = mRequestsList.size();
+                                    Rlog.d(LOG_TAG, "WAKE_LOCK_TIMEOUT " +
+                                            " mReqPending=" + mRequestMessagesPending +
+                                            " mRequestList=" + count);
+
+                                    for (int i = 0; i < count; i++) {
+                                        rr = mRequestsList.get(i);
+                                        Rlog.d(LOG_TAG, i + ": [" + rr.mSerial + "] " +
+                                                requestToString(rr.mRequest));
+
+                                    }
+                                }
+                            }
+                            mWakeLock.release();
+                        }
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+    };
+
+
+    /**
+     * Get the Phone ID for Ut/XCAP request. If IMS is registered, use IMS Phone ID.
+     * Ohterwise, use the CS domain Phone ID.
+     */
+    private int getUtXcapPhoneId() {
+        int imsPhoneId = MMTelSSUtils.getDefaultImsPhoneId(mContext);
+
+        if (imsPhoneId < 0) {
+            int csDomainPhoneId = SystemProperties.getInt(PROPERTY_CS_CURRENT_PHONE_ID, 0);
+            Rlog.d(LOG_TAG, "getUtXcapPhoneId(): use CS domain phoneId by SystemProperties = " + 
+                csDomainPhoneId);
+            return csDomainPhoneId;
+        } else {
+            Rlog.d(LOG_TAG, "getUtXcapPhoneId(): use IMS phoneId = " + imsPhoneId);
+            return imsPhoneId;
+        }
+    }
+
+    // Only Support 2/3G SS Feature Sets
+    public void
+    setCLIR(int clirMode, Message result) {
+        setCLIR(clirMode, result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set CLIR for the specific phoneId.
+     * @param clirMode enable/disable CLIR
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setCLIR(int clirMode, Message result, int phoneId) {
+        //OriginatingIdentityPresentation oip =
+        // SimServs.getOriginatingIdentityPresentation(xcapUri, TEST_USER, "password");
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_CLIR, result);
+        //clirMode: 0-CommandsInterface.CLIR_DEFAULT , 1-CommandsInterface.CLIR_INVOCATION
+        // (restrict CLI presentation), 2-CommandsInterface.CLIR_SUPPRESSION
+        // (allow CLI presentation)
+        rr.mp.writeInt(clirMode);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    getCLIR(Message result) {
+        getCLIR(result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get CLIR mode for the specific phoneId.
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    getCLIR(Message result, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_GET_CLIR, result);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    setCLIP(int clipEnable, Message result) {
+        setCLIP(clipEnable, result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set CLIP for the specific phoneId.
+     * @param clipEnable enable/disable CLIP
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setCLIP(int clipEnable, Message result, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_CLIP, result);
+        rr.mp.writeInt(clipEnable);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    queryCLIP(Message result) {
+        queryCLIP(result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get CLIP for the specific phoneId.
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    queryCLIP(Message result, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_GET_CLIP, result);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    setCOLP(int colpEnable, Message result) {
+        setCOLP(colpEnable, result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set COLP for the specific phoneId.
+     * @param colpEnable enable/disable COLP
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setCOLP(int colpEnable, Message result, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_COLP, result);
+        rr.mp.writeInt(colpEnable);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    getCOLP(Message result) {
+        getCOLP(result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get COLP for the specific phoneId.
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    getCOLP(Message result, int phoneId) {
+        MMTelSSRequest rr
+        = MMTelSSRequest.obtain(MMTELSS_REQ_GET_COLP, result);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+
+    public void
+    setCOLR(int colrMode, Message result) {
+        setCOLR(colrMode, result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set COLR for the specific phoneId.
+     * @param colrMode enable/disable COLR
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setCOLR(int colrMode, Message result, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_COLR, result);
+        rr.mp.writeInt(colrMode);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    getCOLR(Message result) {
+        getCOLR(result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get COLR for the specific phoneId.
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    getCOLR(Message result, int phoneId) {
+        MMTelSSRequest rr
+        = MMTelSSRequest.obtain(MMTELSS_REQ_GET_COLR, result);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+
+    public void
+    setCallWaiting(boolean enable, int serviceClass, Message response) {
+        setCallWaiting(enable, serviceClass, response, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set Call Waiting for the specific phoneId.
+     * @param enable enable/disable Call Waiting
+     * @param serviceClass service class for Call Waiting
+     * @param response Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setCallWaiting(boolean enable, int serviceClass, Message response, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_CW, response);
+        rr.mp.writeInt((enable == true) ? 1 : 0);
+        rr.mp.writeInt(serviceClass);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    queryCallWaiting(int serviceClass, Message response) {
+        queryCallWaiting(serviceClass, response, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get Call Waiting mode for the specific phoneId.
+     * @param serviceClass service class for Call Waiting
+     * @param response Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    queryCallWaiting(int serviceClass, Message response, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_GET_CW, response);
+        rr.mp.writeInt(serviceClass);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+
+    public void
+    setFacilityLock(String facility, boolean lockState, String password,
+            int serviceClass, Message response) {
+        setFacilityLock(facility, lockState, password,
+                serviceClass, response, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set Call Barring for the specific phoneId.
+     * @param facility Call Barring type
+     * @param lockState enable/disable Call Barring
+     * @param password password
+     * @param serviceClass service class for Call Barring
+     * @param response Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setFacilityLock(String facility, boolean lockState, String password,
+            int serviceClass, Message response, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_CB, response);
+        rr.mp.writeString(facility);
+        rr.mp.writeInt((lockState == true) ? 1 : 0);
+        rr.mp.writeInt(serviceClass);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+
+    public void
+    queryFacilityLock(String facility, String password, int serviceClass,
+            Message response) {
+        queryFacilityLock(facility, password, serviceClass,
+                response, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get Call Barring mode for the specific phoneId.
+     * @param facility Call Barring type
+     * @param password password
+     * @param serviceClass service class for Call Barring
+     * @param response Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    queryFacilityLock(String facility, String password, int serviceClass,
+            Message response, int phoneId) {
+
+        //[Example]Testing fake-result by mtk01411 2013-0904
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_GET_CB, response);
+        rr.mp.writeString(facility);
+        rr.mp.writeInt(serviceClass);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    setCallForward(int action, int cfReason, int serviceClass,
+            String number, int timeSeconds, Message response) {
+        setCallForward(action, cfReason, serviceClass,
+                number, timeSeconds, response, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set Call Forwarding for the specific phoneId.
+     * @param action CommandsInterface Call Forwarding action
+     * @param cfReason CommandsInterface Call Forwarding reason
+     * @param serviceClass service class for Call Barring
+     * @param number forwarded-to number
+     * @param timeSeconds no-reply time
+     * @param response Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setCallForward(int action, int cfReason, int serviceClass,
+            String number, int timeSeconds, Message response, int phoneId) {
+        // target should be a SIP URI (IETF RFC 3261 [6]) or TEL URL (IETF RFC 3966 [7])
+        if (number != null && !number.startsWith("sip:") && !number.startsWith("sips:")
+                && !number.startsWith("tel:")) {
+            number = "tel:" + number;
+        }
+
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_CF, response);
+        rr.mp.writeInt(action);
+        rr.mp.writeInt(cfReason);
+        rr.mp.writeInt(serviceClass);
+        rr.mp.writeString(number);
+        rr.mp.writeInt(timeSeconds);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+
+    public void
+    queryCallForwardStatus(int cfReason, int serviceClass,
+            String number, Message response) {
+        queryCallForwardStatus(cfReason, serviceClass,
+                number, response, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get Call Forwarding status for the specific phoneId.
+     * @param cfReason CommandsInterface Call Forwarding reason
+     * @param serviceClass service class for Call Barring
+     * @param number forwarded-to number
+     * @param response Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    queryCallForwardStatus(int cfReason, int serviceClass,
+            String number, Message response, int phoneId) {
+        //[Example]Testing fake-result by mtk01411 2013-0904
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_GET_CF, response);
+
+        rr.mp.writeInt(2); // cfAction filed: 2 is for query action, not in used any