From 2c761466614230bd68e15ed954ac604c175663ff Mon Sep 17 00:00:00 2001
From: Lok Jian Ming <jianminglok@hotmail.com>
Date: Fri, 28 Oct 2016 09:23:01 +0800
Subject: [PATCH] Update for Mediatek

---
 .../android/internal/telephony/BaseCommands.java   | 1386 +++++
 .../internal/telephony/CallForwardInfoEx.java      |   65 +
 .../internal/telephony/CommandException.java       |   51 +
 .../internal/telephony/CommandsInterface.java      | 1511 +++++-
 .../com/android/internal/telephony/DriverCall.java |   21 +
 .../com/android/internal/telephony/IccCard.java    |   99 +
 .../android/internal/telephony/MediaTekRIL.java    | 5328 ++++++++++++++++++++
 .../com/android/internal/telephony/PhbEntry.java   |   71 +
 .../android/internal/telephony/PhoneFactory.java   |  261 +
 src/java/com/android/internal/telephony/RIL.java   |  549 +-
 .../internal/telephony/ServiceStateTracker.java    |    7 +
 .../internal/telephony/SubscriptionController.java |   52 +
 .../android/internal/telephony/SuppSrvRequest.java |  101 +
 .../internal/telephony/cat/AppInterface.java       |    6 +
 .../internal/telephony/cat/CatCmdMessage.java      |   10 +
 .../android/internal/telephony/cat/CatService.java |   43 +-
 .../internal/telephony/cat/CommandParams.java      |   19 +
 .../telephony/dataconnection/DcTracker.java        |  130 +-
 .../telephony/dataconnection/DcTrackerBase.java    |  110 +-
 .../internal/telephony/gsm/CallFailCause.java      |   29 +
 .../android/internal/telephony/gsm/GSMPhone.java   |    7 +-
 .../telephony/gsm/GsmServiceStateTracker.java      |   35 +
 .../imsphone/ImsPhoneCommandInterface.java         |  109 +
 .../telephony/sip/SipCommandInterface.java         |  109 +
 .../internal/telephony/test/SimulatedCommands.java |  135 +
 .../internal/telephony/uicc/IccCardProxy.java      |  380 +-
 .../internal/telephony/uicc/IccFileHandler.java    |    2 +-
 .../internal/telephony/uicc/IccRecords.java        |    7 +
 .../telephony/uicc/IccRefreshResponse.java         |    9 +-
 .../internal/telephony/uicc/SpnOverride.java       |  466 ++
 .../android/internal/telephony/uicc/UiccCard.java  |  466 +-
 .../telephony/uicc/UiccCardApplication.java        |   41 +-
 32 files changed, 11550 insertions(+), 65 deletions(-)
 create mode 100644 src/java/com/android/internal/telephony/CallForwardInfoEx.java
 create mode 100644 src/java/com/android/internal/telephony/MediaTekRIL.java
 create mode 100644 src/java/com/android/internal/telephony/PhbEntry.java
 create mode 100644 src/java/com/android/internal/telephony/SuppSrvRequest.java

diff --git a/src/java/com/android/internal/telephony/BaseCommands.java b/src/java/com/android/internal/telephony/BaseCommands.java
index 32f9d86..eb11193 100644
--- a/src/java/com/android/internal/telephony/BaseCommands.java
+++ b/src/java/com/android/internal/telephony/BaseCommands.java
@@ -18,14 +18,19 @@
 package com.android.internal.telephony;
 
 import android.content.Context;
+import android.os.AsyncResult;
 import android.os.Message;
 import android.os.RegistrantList;
 import android.os.Registrant;
 import android.os.Handler;
 import android.os.AsyncResult;
 import android.telephony.RadioAccessFamily;
+import android.telephony.Rlog;
 import android.telephony.TelephonyManager;
 
+import com.mediatek.internal.telephony.FemtoCellInfo;
+import com.mediatek.internal.telephony.SrvccCallContext;
+
 import com.android.internal.telephony.RadioCapability;
 
 /**
@@ -462,6 +467,15 @@ public void unSetOnCatSendSmsResult(Handler h) {
     @Override
     public void setOnIccSmsFull(Handler h, int what, Object obj) {
         mIccSmsFullRegistrant = new Registrant (h, what, obj);
+
+        // MTK-START, SMS part
+        if (mIsSmsSimFull == true) {
+            mIccSmsFullRegistrant.notifyRegistrant();
+            // Already notify, set as false. Because there is no URC to notify avaliable and
+            // only one module will register. Looks like a workaround solution and make it easy
+            mIsSmsSimFull = false;
+        }
+        // MTK-END, SMS part
     }
 
     @Override
@@ -930,4 +944,1376 @@ public void iccTransmitApduBasicChannel(int cla, int instruction, int p1, int p2
 
     @Override
     public void getAtr(Message response) {}
+
+    /**
+     * @hide
+     */
+    @Override
+    public int getLteOnGsmMode() {
+        return TelephonyManager.getLteOnGsmModeStatic();
+    }
+
+    // MTK
+
+    //MTK-START Support Multi-Application
+    protected RegistrantList mSessionChangedRegistrants = new RegistrantList();
+    //MTK-END Support Multi-Application
+
+    protected Registrant mStkEvdlCallRegistrant;
+    protected Registrant mStkSetupMenuResetRegistrant;
+    protected Registrant mStkCallCtrlRegistrant;
+
+    /// M: CC010: Add RIL interface @{
+    protected RegistrantList mCallForwardingInfoRegistrants = new RegistrantList();
+    protected Registrant mCallRelatedSuppSvcRegistrant;
+    protected Registrant mIncomingCallIndicationRegistrant;
+    //protected Registrant mCnapNotifyRegistrant; //obsolete
+    protected RegistrantList mCipherIndicationRegistrant = new RegistrantList();
+    /// @}
+    /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+    protected Registrant mSpeechCodecInfoRegistrant;
+    /// @}
+
+    //Remote SIM ME lock related APIs [Start]
+    protected RegistrantList mMelockRegistrants = new RegistrantList();
+    //Remote SIM ME lock related APIs [End]
+
+    protected RegistrantList mPhbReadyRegistrants = new RegistrantList();
+
+    /// M: IMS feature. @{
+    /* Register for updating call ids for conference call after SRVCC is done. */
+    protected RegistrantList mEconfSrvccRegistrants = new RegistrantList();
+    /* Register for updating conference call merged/added result. */
+    protected RegistrantList mEconfResultRegistrants = new RegistrantList();
+    /* Register for updating call mode and pau. */
+    protected RegistrantList mCallInfoRegistrants = new RegistrantList();
+    /// @}
+
+    // M: fast dormancy.
+    protected Registrant mScriResultRegistrant;
+    // M: CC33 LTE.
+    protected RegistrantList mRacUpdateRegistrants = new RegistrantList();
+    protected RegistrantList mRemoveRestrictEutranRegistrants = new RegistrantList();
+
+    protected RegistrantList mResetAttachApnRegistrants = new RegistrantList();
+
+    /// M: [C2K] for eng mode
+    protected RegistrantList mEngModeNetworkInfoRegistrant = new RegistrantList();
+
+    /// M: [C2K] for call fade
+    protected Registrant mCdmaSignalFadeRegistrant;
+    /// M: [C2K] for tone signal
+    protected Registrant mCdmaToneSignalsRegistrant;
+    /// M: BIP {
+    protected Registrant mBipProCmdRegistrant;
+    /// M: BIP }
+
+    // Mode of Xtk, Stk or Utk. Set by SvlteRatController
+    protected int mStkSwitchMode;
+    // xTK BIP PS Type. Set by SvltePhoneProxy
+    protected int mBipPsType;
+    // for capability switch to early get modem capability
+    RadioCapability mRadioCapability;
+
+    /* M: network part start */
+    protected RegistrantList mFemtoCellInfoRegistrants = new RegistrantList();
+    protected RegistrantList mNeighboringInfoRegistrants = new RegistrantList();
+    protected RegistrantList mNetworkInfoRegistrants = new RegistrantList();
+    protected RegistrantList mNetworkExistRegistrants = new RegistrantList();
+
+    protected RegistrantList mPlmnChangeNotificationRegistrant = new RegistrantList();
+    protected Registrant mRegistrationSuspendedRegistrant;
+    protected Object mEmsrReturnValue = null;
+    protected Object mEcopsReturnValue = null;
+    protected Object mWPMonitor = new Object();
+
+    //VoLTE
+    protected RegistrantList mImsEnableRegistrants = new RegistrantList();
+    protected RegistrantList mImsDisableRegistrants = new RegistrantList();
+    protected RegistrantList mImsRegistrationInfoRegistrants = new RegistrantList();
+    protected RegistrantList mDedicateBearerActivatedRegistrant = new RegistrantList();
+    protected RegistrantList mDedicateBearerModifiedRegistrant = new RegistrantList();
+    protected RegistrantList mDedicateBearerDeactivatedRegistrant = new RegistrantList();
+
+    protected RegistrantList mPsNetworkStateRegistrants = new RegistrantList();
+    protected RegistrantList mImeiLockRegistrant = new RegistrantList();
+    protected RegistrantList mInvalidSimInfoRegistrant = new RegistrantList();
+    protected RegistrantList mGetAvailableNetworkDoneRegistrant = new RegistrantList();
+    /* M: network part end */
+
+    /// M: CC010: Add RIL interface @{
+    protected Object mCfuReturnValue = null; ///* M: SS part */
+    /// @}
+
+    // MTK-START, SMS part
+    // In order to cache the event from modem at boot-up sequence
+    protected boolean mIsSmsSimFull = false;
+    protected boolean mIsSmsReady = false;
+    protected RegistrantList mSmsReadyRegistrants = new RegistrantList();
+    protected Registrant mMeSmsFullRegistrant;
+    protected Registrant mEtwsNotificationRegistrant;
+    // MTK-END
+
+    // IMS VoLTE
+    protected RegistrantList mEpsNetworkFeatureSupportRegistrants = new RegistrantList();
+    protected RegistrantList mEpsNetworkFeatureInfoRegistrants = new RegistrantList();
+    protected RegistrantList mSrvccHandoverInfoIndicationRegistrants = new RegistrantList();
+    protected RegistrantList mMoDataBarringInfoRegistrants = new RegistrantList();
+    protected RegistrantList mSsacBarringInfoRegistrants = new RegistrantList();
+    /// M: CC071: Add Customer proprietary-IMS RIL interface. @{
+    protected RegistrantList mEmergencyBearerSupportInfoRegistrants = new RegistrantList();
+    /// @}
+
+    /* C2K part start */
+    protected RegistrantList mViaGpsEvent = new RegistrantList();
+    protected RegistrantList mAcceptedRegistrant = new RegistrantList();
+    protected RegistrantList mNetworkTypeChangedRegistrant = new RegistrantList();
+    protected Registrant mUtkSessionEndRegistrant;
+    protected Registrant mUtkProCmdRegistrant;
+    protected Registrant mUtkEventRegistrant;
+    protected RegistrantList mInvalidSimDetectedRegistrant = new RegistrantList();
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @{
+    protected RegistrantList mMccMncChangeRegistrants = new RegistrantList();
+    /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @{
+    protected RegistrantList mGmssRatChangedRegistrant = new RegistrantList();
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @}
+
+    /// M: [C2K] for ps type changed.
+    protected RegistrantList mDataNetworkTypeChangedRegistrant = new RegistrantList();
+
+    /// M: [C2K][MD IRAT] add IRat state change registrant.
+    protected RegistrantList mIratStateChangeRegistrant = new RegistrantList();
+
+    /* C2K part end */
+
+    protected RegistrantList mAbnormalEventRegistrant = new RegistrantList();
+
+    /// M: For 3G VT only @{
+    protected RegistrantList mVtStatusInfoRegistrants = new RegistrantList();
+    protected RegistrantList mVtRingRegistrants = new RegistrantList();
+    /// @}
+
+    protected RegistrantList mCdmaImsiReadyRegistrant = new RegistrantList();
+    protected RegistrantList mImsiRefreshDoneRegistrant = new RegistrantList();
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    protected RegistrantList mLteAccessStratumStateRegistrants = new RegistrantList();
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    /// M: BIP {
+    @Override
+    public void setOnBipProactiveCmd(Handler h, int what, Object obj) {
+        mBipProCmdRegistrant = new Registrant (h, what, obj);
+    }
+
+    @Override
+    public void unSetOnBipProactiveCmd(Handler h) {
+        if (mBipProCmdRegistrant != null && mBipProCmdRegistrant.getHandler() == h) {
+            mBipProCmdRegistrant.clear();
+            mBipProCmdRegistrant = null;
+        }
+    }
+    /// M: BIP }
+
+    @Override
+    public void setStkEvdlCallByAP(int enabled, Message response) {
+    }
+
+
+    @Override
+    public void setOnStkEvdlCall(Handler h, int what, Object obj) {
+        mStkEvdlCallRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnStkEvdlCall(Handler h) {
+        mStkEvdlCallRegistrant.clear();
+    }
+
+    @Override
+    public void setOnStkSetupMenuReset(Handler h, int what, Object obj) {
+        mStkSetupMenuResetRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnStkSetupMenuReset(Handler h) {
+        mStkSetupMenuResetRegistrant.clear();
+    }
+
+    @Override
+    public void setOnStkCallCtrl(Handler h, int what, Object obj) {
+        mStkCallCtrlRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnStkCallCtrl(Handler h) {
+        mStkCallCtrlRegistrant.clear();
+    }
+
+    //MTK-START [mtk06800] modem power on/off
+    @Override
+    public void setModemPower(boolean power, Message response) {
+    }
+    //MTK-END [mtk06800] modem power on/off
+
+    public void setUiccSubscription(int slotId, int appIndex, int subId, int subStatus,
+            Message response) {
+    }
+
+    /// M: CC010: Add RIL interface @{
+    public void registerForCipherIndication(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCipherIndicationRegistrant.add(r);
+    }
+
+    public void unregisterForCipherIndication(Handler h) {
+        mCipherIndicationRegistrant.remove(h);
+    }
+
+    public void registerForCallForwardingInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCallForwardingInfoRegistrants.add(r);
+        /* M: SS part */
+        if (mCfuReturnValue != null) {
+           r.notifyRegistrant(new AsyncResult(null, mCfuReturnValue, null));
+        }
+        /* M: SS part end */
+    }
+
+    public void unregisterForCallForwardingInfo(Handler h) {
+        mCallForwardingInfoRegistrants.remove(h);
+    }
+
+    public void setOnCallRelatedSuppSvc(Handler h, int what, Object obj) {
+        mCallRelatedSuppSvcRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnCallRelatedSuppSvc(Handler h) {
+        mCallRelatedSuppSvcRegistrant.clear();
+    }
+
+    public void setOnIncomingCallIndication(Handler h, int what, Object obj) {
+        mIncomingCallIndicationRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unsetOnIncomingCallIndication(Handler h) {
+        mIncomingCallIndicationRegistrant.clear();
+    }
+
+    //obsolete
+    /*
+    public void setCnapNotify(Handler h, int what, Object obj) {
+        mCnapNotifyRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetCnapNotify(Handler h) {
+        mCnapNotifyRegistrant.clear();
+    }
+    */
+    /// @}
+
+    /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+    @Override
+    public void setOnSpeechCodecInfo(Handler h, int what, Object obj) {
+        mSpeechCodecInfoRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnSpeechCodecInfo(Handler h) {
+        if (mSpeechCodecInfoRegistrant != null && mSpeechCodecInfoRegistrant.getHandler() == h) {
+            mSpeechCodecInfoRegistrant.clear();
+            mSpeechCodecInfoRegistrant = null;
+        }
+    }
+    /// @}
+
+    public void hangupAll(Message result) {}
+    public void forceReleaseCall(int index, Message response) {}
+    public void setCallIndication(int mode, int callId, int seqNumber, Message response) {}
+    public void emergencyDial(String address, int clirMode, UUSInfo uusInfo, Message result) {}
+    public void setEccServiceCategory(int serviceCategory) {}
+    /// @}
+    /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+    public void setSpeechCodecInfo(boolean enable, Message response) {}
+    /// @}
+
+    /// M: For 3G VT only @{
+    public void registerForVtStatusInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mVtStatusInfoRegistrants.add(r);
+    }
+
+    public void unregisterForVtStatusInfo(Handler h) {
+        mVtStatusInfoRegistrants.remove(h);
+    }
+
+    public void registerForVtRingInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mVtRingRegistrants.add(r);
+    }
+
+    public void unregisterForVtRingInfo(Handler h) {
+        mVtRingRegistrants.remove(h);
+    }
+    /// @}
+
+    /// M: For 3G VT only @{
+    public void vtDial(String address, int clirMode, UUSInfo uusInfo, Message result) {}
+    public void acceptVtCallWithVoiceOnly(int callId, Message result) {}
+    public void replaceVtCall(int index, Message result) {}
+    /// @}
+    /* M: SS part  */
+    ///M: For query CNAP
+    public void sendCNAPSS(String cnapssString, Message response){}
+    public void setCLIP(boolean enable, Message response) {}
+    /* M: SS part end */
+
+    //MTK-START Support Multi-Application
+    @Override
+    public void openIccApplication(int application, Message response){}
+    @Override
+    public void getIccApplicationStatus(int sessionId, Message result){}
+
+    @Override
+    public void registerForSessionChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSessionChangedRegistrants.add(r);
+    }
+
+    @Override
+    public void unregisterForSessionChanged(Handler h) {
+        mSessionChangedRegistrants.remove(h);
+    }
+    //MTK-END Support Multi-Application
+
+    //MTK-START Support SIM ME lock
+    @Override
+    public void queryNetworkLock(int categrory, Message response){};
+
+    @Override
+    public void setNetworkLock(int catagory, int lockop, String password,
+            String data_imsi, String gid1, String gid2, Message response){};
+    //MTK-END Support SIM ME lock
+
+    @Override
+    public void doGeneralSimAuthentication(int sessionId, int mode , int tag, String param1,
+                                          String param2, Message response) {
+    }
+    // Added by M begin
+
+    protected RegistrantList mSimMissing = new RegistrantList();
+    protected RegistrantList mSimRecovery = new RegistrantList();
+    protected RegistrantList mVirtualSimOn = new RegistrantList();
+    protected RegistrantList mVirtualSimOff = new RegistrantList();
+    protected RegistrantList mSimPlugOutRegistrants = new RegistrantList();
+    protected RegistrantList mSimPlugInRegistrants = new RegistrantList();
+    protected RegistrantList mTrayPlugInRegistrants = new RegistrantList();
+    protected RegistrantList mCdmaCardTypeRegistrants = new RegistrantList();
+    protected RegistrantList mCommonSlotNoChangedRegistrants = new RegistrantList();
+    protected RegistrantList mDataAllowedRegistrants = new RegistrantList();
+    protected RegistrantList mEusimReady = new RegistrantList();
+    protected boolean mIsEusimReady = false;
+    protected Object mCdmaCardTypeValue = null;
+
+    public void registerForSimMissing(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSimMissing.add(r);
+    }
+    public void unregisterForSimMissing(Handler h) {
+        mSimMissing.remove(h);
+    }
+
+    public void registerForSimRecovery(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSimRecovery.add(r);
+    }
+
+    public void unregisterForSimRecovery(Handler h) {
+        mSimRecovery.remove(h);
+    }
+
+    public void registerForVirtualSimOn(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mVirtualSimOn.add(r);
+    }
+
+    public void unregisterForVirtualSimOn(Handler h) {
+        mVirtualSimOn.remove(h);
+    }
+
+    public void registerForVirtualSimOff(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mVirtualSimOff.add(r);
+    }
+
+    public void unregisterForVirtualSimOff(Handler h) {
+        mVirtualSimOff.remove(h);
+    }
+
+    public void registerForSimPlugOut(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSimPlugOutRegistrants.add(r);
+    }
+
+    public void unregisterForSimPlugOut(Handler h) {
+        mSimPlugOutRegistrants.remove(h);
+    }
+
+    public void registerForSimPlugIn(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSimPlugInRegistrants.add(r);
+    }
+
+    public void unregisterForSimPlugIn(Handler h) {
+        mSimPlugInRegistrants.remove(h);
+    }
+
+    public void registerForTrayPlugIn(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mTrayPlugInRegistrants.add(r);
+    }
+
+    public void unregisterForTrayPlugIn(Handler h) {
+        mTrayPlugInRegistrants.remove(h);
+    }
+    /**
+      * Rregister for cdma card type.
+      * @param h Handler for network information messages.
+      * @param what User-defined message code.
+      * @param obj User object.
+      */
+    public void registerForCdmaCardType(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCdmaCardTypeRegistrants.add(r);
+
+        if (mCdmaCardTypeValue != null) {
+            r.notifyRegistrant(new AsyncResult(null, mCdmaCardTypeValue, null));
+        }
+    }
+
+    /**
+      * Rregister for cdma card type.
+      * @param h Handler for network information messages.
+      */
+    public void unregisterForCdmaCardType(Handler h) {
+        mCdmaCardTypeRegistrants.remove(h);
+    }
+
+    public void registerForCommonSlotNoChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCommonSlotNoChangedRegistrants.add(r);
+    }
+
+    public void unregisterForCommonSlotNoChanged(Handler h) {
+        mCommonSlotNoChangedRegistrants.remove(h);
+    }
+
+    public void registerForEusimReady(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEusimReady.add(r);
+    }
+
+    public void unregisterForEusimReady(Handler h) {
+        mEusimReady.remove(h);
+    }
+
+    /* M: CC33 LTE. */
+    public void setDataOnToMD(boolean enable, Message result){}
+    public void setRemoveRestrictEutranMode(boolean enable, Message result){}
+    public void registerForRemoveRestrictEutran(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mRemoveRestrictEutranRegistrants.add(r);
+    }
+    public void unregisterForRemoveRestrictEutran(Handler h) {
+        mRemoveRestrictEutranRegistrants.remove(h);
+    }
+    public void registerForRacUpdate(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mRacUpdateRegistrants.add(r);
+    }
+    public void unregisterForRacUpdate(Handler h) {
+        mRacUpdateRegistrants.remove(h);
+    }
+
+    public void registerForResetAttachApn(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mResetAttachApnRegistrants.add(r);
+    }
+
+    public void unregisterForResetAttachApn(Handler h) {
+        mResetAttachApnRegistrants.remove(h);
+    }
+
+    public void registerSetDataAllowed(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDataAllowedRegistrants.add(r);
+    }
+
+    public void unregisterSetDataAllowed(Handler h) {
+        mDataAllowedRegistrants.remove(h);
+    }
+
+    public void sendBTSIMProfile(int nAction, int nType, String strData, Message response){
+    }
+
+    protected Registrant mEfCspPlmnModeBitRegistrant;
+
+    public void registerForEfCspPlmnModeBitChanged(Handler h, int what, Object obj) {
+        mEfCspPlmnModeBitRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unregisterForEfCspPlmnModeBitChanged(Handler h) {
+        mEfCspPlmnModeBitRegistrant.clear();
+    }
+
+    public void queryPhbStorageInfo(int type, Message response) {
+    }
+
+    public void writePhbEntry(PhbEntry entry, Message result) {
+    }
+
+    public void ReadPhbEntry(int type, int bIndex, int eIndex, Message response) {
+    }
+
+    public void registerForPhbReady(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mPhbReadyRegistrants.add(r);
+    }
+
+    public void unregisterForPhbReady(Handler h) {
+        mPhbReadyRegistrants.remove(h);
+    }
+
+    public void queryUPBCapability(Message response){
+    }
+
+    public void editUPBEntry(int entryType, int adnIndex, int entryIndex, String strVal, String tonForNum, Message response) {
+    }
+
+    public void deleteUPBEntry(int entryType, int adnIndex, int entryIndex, Message response) {
+    }
+
+    public void readUPBGasList(int startIndex, int endIndex, Message response) {
+    }
+
+    public void readUPBGrpEntry(int adnIndex, Message response) {
+    }
+
+    public void writeUPBGrpEntry(int adnIndex, int[] grpIds, Message response) {
+    }
+
+    public void getPhoneBookStringsLength(Message result) {
+
+    }
+    public void getPhoneBookMemStorage(Message result) {
+
+    }
+    public void setPhoneBookMemStorage(String storage, String password, Message result) {
+    }
+
+    // xen0n: MTK TODO
+    /*
+    public void readPhoneBookEntryExt(int index1, int index2, Message result) {
+    }
+
+    public void writePhoneBookEntryExt(PBEntry entry, Message result) {
+    }
+    */
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    public void setLteAccessStratumReport(boolean enable, Message result) {
+    }
+
+    public void setLteUplinkDataTransfer(int state, int interfaceId, Message result) {
+    }
+
+    public void registerForLteAccessStratumState(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mLteAccessStratumStateRegistrants.add(r);
+    }
+
+    public void unregisterForLteAccessStratumState(Handler h) {
+        mLteAccessStratumStateRegistrants.remove(h);
+    }
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    // Added by M end
+
+    // MTK-START, SMS part
+    public void registerForSmsReady(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSmsReadyRegistrants.add(r);
+
+        if (mIsSmsReady == true) {
+            // Only notify the new registrant
+            r.notifyRegistrant();
+        }
+    }
+
+    public void unregisterForSmsReady(Handler h) {
+        mSmsReadyRegistrants.remove(h);
+    }
+
+    public void setOnMeSmsFull(Handler h, int what, Object obj) {
+        mMeSmsFullRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnMeSmsFull(Handler h) {
+        mMeSmsFullRegistrant.clear();
+    }
+
+    // xen0n: MTK TODO
+    /*
+    public void getSmsParameters(Message response) {
+    }
+
+    public void setSmsParameters(SmsParameters params, Message response) {
+    }
+    */
+
+    public void setEtws(int mode, Message result) {
+    }
+
+    public void setOnEtwsNotification(Handler h, int what, Object obj) {
+        mEtwsNotificationRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnEtwsNotification(Handler h) {
+        mEtwsNotificationRegistrant.clear();
+    }
+
+    public void setCellBroadcastChannelConfigInfo(String config, int cb_set_type,
+            Message response) {
+    }
+
+    public void setCellBroadcastLanguageConfigInfo(String config, Message response) {
+    }
+
+    public void queryCellBroadcastConfigInfo(Message response) {
+    }
+
+    public void removeCellBroadcastMsg(int channelId, int serialId, Message response) {
+    }
+
+    public void getSmsSimMemoryStatus(Message result) {
+    }
+    // MTK-END, SMS part
+
+    public void registerForNeighboringInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mNeighboringInfoRegistrants.add(r);
+    }
+
+    public void unregisterForNeighboringInfo(Handler h) {
+        mNeighboringInfoRegistrants.remove(h);
+    }
+
+    public void registerForNetworkInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mNetworkInfoRegistrants.add(r);
+    }
+
+    public void unregisterForNetworkInfo(Handler h) {
+        mNetworkInfoRegistrants.remove(h);
+    }
+
+    public void setInvalidSimInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mInvalidSimInfoRegistrant.add(r);
+    }
+
+    public void unSetInvalidSimInfo(Handler h) {
+        mInvalidSimInfoRegistrant.remove(h);
+    }
+
+    public void registerForIMEILock(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImeiLockRegistrant.add(r);
+    }
+
+    public void unregisterForIMEILock(Handler h) {
+        mImeiLockRegistrant.remove(h);
+    }
+
+    public void setNetworkSelectionModeManualWithAct(String operatorNumeric,
+                                                                  String act, Message result) {
+    }
+
+    public void setNetworkSelectionModeSemiAutomatic(String operatorNumeric, String act, Message response) {
+
+    }
+
+    public void cancelAvailableNetworks(Message response) {}
+
+    public void registerForGetAvailableNetworksDone(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mGetAvailableNetworkDoneRegistrant.add(r);
+    }
+
+    public void unregisterForGetAvailableNetworksDone(Handler h) {
+        mGetAvailableNetworkDoneRegistrant.remove(h);
+    }
+
+    public void getPOLCapabilty(Message response) {
+    }
+    public void getCurrentPOLList(Message response) {
+    }
+    public void setPOLEntry(int index, String numeric, int nAct, Message response) {
+    }
+
+    // Femtocell (CSG) feature START
+    public void getFemtoCellList(String operatorNumeric, int rat, Message response){}
+    public void abortFemtoCellList(Message response){}
+    public void selectFemtoCell(FemtoCellInfo femtocell, Message response){}
+    public void registerForFemtoCellInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mFemtoCellInfoRegistrants.add(r);
+    }
+
+    public void registerForPsNetworkStateChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mPsNetworkStateRegistrants.add(r);
+    }
+
+    public void unregisterForPsNetworkStateChanged(Handler h) {
+        mPsNetworkStateRegistrants.remove(h);
+    }
+
+    public boolean isGettingAvailableNetworks() { return false; }
+
+    public void unregisterForFemtoCellInfo(Handler h) {
+        mFemtoCellInfoRegistrants.remove(h);
+    }
+
+    // IMS
+    public void registerForImsEnable(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsEnableRegistrants.add(r);
+    }
+
+    public void unregisterForImsEnable(Handler h) {
+        mImsEnableRegistrants.remove(h);
+    }
+
+    public void registerForImsDisable(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsDisableRegistrants.add(r);
+    }
+
+    public void unregisterForImsDisable(Handler h) {
+        mImsDisableRegistrants.remove(h);
+    }
+
+    public void registerForImsRegistrationInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsRegistrationInfoRegistrants.add(r);
+    }
+
+    public void unregisterForImsRegistrationInfo(Handler h) {
+        mImsRegistrationInfoRegistrants.remove(h);
+    }
+
+    public void setIMSEnabled(boolean enable, Message response){}
+    public void registerForImsDisableDone(Handler h, int what, Object obj){}
+    public void unregisterForImsDisableDone(Handler h){}
+
+    public void setTrm(int mode, Message result) {}
+
+    public void setOnPlmnChangeNotification(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+         synchronized (mWPMonitor) {
+            mPlmnChangeNotificationRegistrant.add(r);
+
+            if (mEcopsReturnValue != null) {
+               // Only notify the new registrant
+               r.notifyRegistrant(new AsyncResult(null, mEcopsReturnValue, null));
+               mEcopsReturnValue = null;
+            }
+        }
+    }
+
+    public void unSetOnPlmnChangeNotification(Handler h) {
+        synchronized (mWPMonitor) {
+            mPlmnChangeNotificationRegistrant.remove(h);
+        }
+    }
+
+    public void setOnRegistrationSuspended(Handler h, int what, Object obj) {
+        synchronized (mWPMonitor) {
+            mRegistrationSuspendedRegistrant = new Registrant(h, what, obj);
+
+            if (mEmsrReturnValue != null) {
+                // Only notify the new registrant
+                mRegistrationSuspendedRegistrant.notifyRegistrant(
+                    new AsyncResult(null, mEmsrReturnValue, null));
+                mEmsrReturnValue = null;
+            }
+        }
+    }
+
+    public void unSetOnRegistrationSuspended(Handler h) {
+        synchronized (mWPMonitor) {
+            mRegistrationSuspendedRegistrant.clear();
+        }
+    }
+
+    //Remote SIM ME lock related APIs [Start]
+    public void registerForMelockChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mMelockRegistrants.add(r);
+    }
+
+    public void unregisterForMelockChanged(Handler h) {
+        mMelockRegistrants.remove(h);
+    }
+    //Remote SIM ME lock related APIs [End]
+
+    /** M: start */
+    public void setupDataCall(String radioTechnology, String profile,
+            String apn, String user, String password, String authType,
+            String protocol, Message result) {
+    }
+
+    public void setupDataCall(String radioTechnology, String profile,
+            String apn, String user, String password, String authType,
+            String protocol, String interfaceId, Message result) {
+    }
+
+    // M: fast dormancy
+    public void setScriResult(Handler h, int what, Object obj) {
+        mScriResultRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetScriResult(Handler h) {
+        mScriResultRegistrant.clear();
+    }
+
+    public void setScri(boolean forceRelease, Message response){
+    }
+
+    public void setFDMode(int mode, int parameter1, int parameter2, Message response){
+    }
+
+
+    public void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, Object obj, Message result) {
+    }
+    /** M: end */
+
+    // For IMS VoLTE, EPS network feature support
+    public void registerForEpsNetworkFeatureSupport(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEpsNetworkFeatureSupportRegistrants.add(r);
+    }
+
+    public void unregisterForEpsNetworkFeatureSupport(Handler h) {
+        mEpsNetworkFeatureSupportRegistrants.remove(h);
+    }
+
+    /// M: IMS feature. @{
+    /* Register for updating call ids for conference call after SRVCC is done. */
+    public void registerForEconfSrvcc(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEconfSrvccRegistrants.add(r);
+    }
+
+    public void unregisterForEconfSrvcc(Handler h) {
+        mEconfSrvccRegistrants.remove(h);
+    }
+
+    /* Register for updating conference call merged/added result. */
+    public void registerForEconfResult(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEconfResultRegistrants.add(r);
+    }
+
+    public void unregisterForEconfResult(Handler h) {
+        mEconfResultRegistrants.remove(h);
+    }
+
+    public void registerForCallInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCallInfoRegistrants.add(r);
+    }
+
+    public void unregisterForCallInfo(Handler h) {
+        mCallInfoRegistrants.remove(h);
+    }
+
+
+    /* Add/Remove VoLTE(IMS) conference call member. */
+    public void addConferenceMember(int confCallId, String address, int callIdToAdd, Message response) {}
+    public void removeConferenceMember(int confCallId, String address, int callIdToRemove, Message response) {}
+
+    /**
+     * To resume the call.
+     * @param callIdToResume toIndicate which call session to resume.
+     * @param response command response.
+     */
+    public void resumeCall(int callIdToResume, Message response) {}
+
+    /**
+     * To hold the call.
+     * @param callIdToHold toIndicate which call session to hold.
+     * @param response command response.
+     */
+    public void holdCall(int callIdToHold, Message response) {}
+    /// @}
+
+    public void registerForEpsNetworkFeatureInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEpsNetworkFeatureInfoRegistrants.add(r);
+    }
+
+    public void unregisterForEpsNetworkFeatureInfo(Handler h) {
+        mEpsNetworkFeatureInfoRegistrants.remove(h);
+    }
+
+    public void registerForMoDataBarringInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mMoDataBarringInfoRegistrants.add(r);
+    }
+
+    public void unregisterForMoDataBarringInfo(Handler h) {
+        mMoDataBarringInfoRegistrants.remove(h);
+    }
+
+    public void registerForSsacBarringInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSsacBarringInfoRegistrants.add(r);
+    }
+
+    public void unregisterForSsacBarringInfo(Handler h) {
+        mSsacBarringInfoRegistrants.remove(h);
+    }
+
+    public void registerForSrvccHandoverInfoIndication(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSrvccHandoverInfoIndicationRegistrants.add(r);
+    }
+    public void unregisterForSrvccHandoverInfoIndication(Handler h) {
+        mSrvccHandoverInfoIndicationRegistrants.remove(h);
+    }
+
+    /// M: CC071: Add Customer proprietary-IMS RIL interface. @{
+    public void registerForEmergencyBearerSupportInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEmergencyBearerSupportInfoRegistrants.add(r);
+    }
+
+    public void unregisterForEmergencyBearerSupportInfo(Handler h) {
+        mEmergencyBearerSupportInfoRegistrants.remove(h);
+    }
+    /// @}
+
+    public void sendScreenState(boolean on){}
+
+    @Override
+    public void setDataCentric(boolean enable, Message response) {}
+
+    /// M: CC010: Add RIL interface @{
+    @Override
+    public void setImsCallStatus(boolean existed, Message response) {}
+    /// @}
+
+    /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+    /**
+     * Transfer IMS call to modem.
+     *
+     * @param numberOfCall The number of call
+     * @param callList IMS call context
+     */
+     public void setSrvccCallContextTransfer(int numberOfCall, SrvccCallContext[] callList) {}
+
+    /**
+     * Update IMS registration status to modem.
+     *
+     * @param regState IMS registration state
+     *                 0: IMS unregistered
+     *                 1: IMS registered
+     * @param regType  IMS registration type
+     *                 0: Normal IMS registration
+     *                 1: Emergency IMS registration
+     * @param reason   The reason of state transition from registered to unregistered
+     *                 0: Unspecified
+     *                 1: Power off
+     *                 2: RF off
+     */
+     public void updateImsRegistrationStatus(int regState, int regType, int reason) {}
+     /// @}
+
+    /* C2K part start */
+    @Override
+    public void setViaTRM(int mode, Message result) {}
+
+    @Override
+    public void getNitzTime(Message result) {}
+
+    @Override
+    public void requestSwitchHPF(boolean enableHPF, Message response) {}
+
+    @Override
+    public void setAvoidSYS(boolean avoidSYS, Message response) {}
+
+    @Override
+    public void getAvoidSYSList(Message response) {}
+
+    @Override
+    public void queryCDMANetworkInfo(Message response) {}
+
+    @Override
+    public void setOplmn(String oplmnInfo, Message response) {
+    }
+
+    @Override
+    public void getOplmnVersion(Message response) {
+    }
+
+    @Override
+    public void registerForCallAccepted(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mAcceptedRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForCallAccepted(Handler h) {
+        mAcceptedRegistrant.remove(h);
+    }
+
+    @Override
+    public void registerForViaGpsEvent(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mViaGpsEvent.add(r);
+    }
+
+    @Override
+    public void unregisterForViaGpsEvent(Handler h) {
+        mViaGpsEvent.remove(h);
+    }
+
+    @Override
+    public void setMeid(String meid, Message response) {}
+
+    @Override
+    public void setArsiReportThreshold(int threshold, Message response) {}
+
+    @Override
+    public void registerForNetworkTypeChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mNetworkTypeChangedRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForNetworkTypeChanged(Handler h) {
+        mNetworkTypeChangedRegistrant.remove(h);
+    }
+
+    @Override
+    public void queryCDMASmsAndPBStatus(Message response) {}
+
+    @Override
+    public void queryCDMANetWorkRegistrationState(Message response) {}
+
+    @Override
+    public void requestSetEtsDev(int dev, Message result) {}
+
+    @Override
+    public void requestAGPSGetMpcIpPort(Message result) {}
+
+    @Override
+    public void requestAGPSSetMpcIpPort(String ip, String port, Message result) {}
+
+    @Override
+    public void requestAGPSTcpConnected(int connected, Message result) {}
+
+    @Override
+    public void setMdnNumber(String mdn, Message response) {}
+
+    // UTK start
+    @Override
+    public void setOnUtkSessionEnd(Handler h, int what, Object obj) {
+        mUtkSessionEndRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnUtkSessionEnd(Handler h) {
+        mUtkSessionEndRegistrant.clear();
+    }
+
+    @Override
+    public void setOnUtkProactiveCmd(Handler h, int what, Object obj) {
+        mUtkProCmdRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnUtkProactiveCmd(Handler h) {
+        mUtkProCmdRegistrant.clear();
+    }
+
+    @Override
+    public void setOnUtkEvent(Handler h, int what, Object obj) {
+        mUtkEventRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnUtkEvent(Handler h) {
+        mUtkEventRegistrant.clear();
+    }
+    //UTK end
+
+    //C2K SVLTE remote SIM access
+    @Override
+    public void configModemStatus(int modemStatus, int remoteSimProtocol, Message result) {}
+
+    @Override
+    public void disconnectRilSocket() {}
+
+    @Override
+    public void connectRilSocket() {}
+
+    @Override
+    public void configEvdoMode(int evdoMode, Message result) {}
+    /* C2k part end */
+
+    public void registerForAbnormalEvent(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mAbnormalEventRegistrant.add(r);
+    }
+
+    public void unregisterForAbnormalEvent(Handler h) {
+        mAbnormalEventRegistrant.remove(h);
+    }
+
+    /// M: [C2K] for eng mode start
+    @Override
+    public void registerForEngModeNetworkInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEngModeNetworkInfoRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForEngModeNetworkInfo(Handler h) {
+        mEngModeNetworkInfoRegistrant.remove(h);
+    }
+    /// M: [C2K] for eng mode end
+
+    public int getDisplayState() {
+        //return Display type: Unknown display type.
+        return 0;
+    }
+
+    public String lookupOperatorNameFromNetwork(long subId, String numeric, boolean desireLongName) {
+        // return operator name from network: null string
+        return null;
+    }
+
+    /* M: IMS VoLTE conference dial feature start*/
+    /**
+     * Dial conference call.
+     * @param participants participants' dailing number.
+     * @param clirMode indication to present the dialing number or not.
+     * @param isVideoCall indicate this call is belong to video call or voice call.
+     * @param result the command result.
+     */
+    public void conferenceDial(String[] participants, int clirMode,
+            boolean isVideoCall, Message result) {}
+    /* IMS VoLTE conference dial feature end*/
+
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @{
+    @Override
+    public void registerForGmssRatChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mGmssRatChangedRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForGmssRatChanged(Handler h) {
+        mGmssRatChangedRegistrant.remove(h);
+    }
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @}
+
+    /// M: [C2K] for ps type changed. @{
+    @Override
+    public void registerForDataNetworkTypeChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDataNetworkTypeChangedRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForDataNetworkTypeChanged(Handler h) {
+        mDataNetworkTypeChangedRegistrant.remove(h);
+    }
+    /// @}
+
+    /// [C2K][IRAT] @{
+    @Override
+    public void registerForIratStateChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mIratStateChangeRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForIratStateChanged(Handler h) {
+        mIratStateChangeRegistrant.remove(h);
+    }
+
+    @Override
+    public void confirmIratChange(int apDecision, Message result) {
+
+    }
+
+    @Override
+    public void requestSetPsActiveSlot(int psSlot, Message response) {
+    }
+
+    @Override
+    public void syncNotifyDataCallList(AsyncResult dcList) {
+
+    }
+
+    @Override
+    public void requestDeactivateLinkDownPdn(Message response) {
+
+    }
+    /// @}
+
+    @Override
+    public void registerForImsiRefreshDone(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsiRefreshDoneRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForImsiRefreshDone(Handler h) {
+        mImsiRefreshDoneRegistrant.remove(h);
+    }
+
+    @Override
+    public RadioCapability getBootupRadioCapability() {
+        Rlog.d("RILJ", "getBootupRadioCapability: " + mRadioCapability);
+        return mRadioCapability;
+    }
+
+    @Override
+    public void registerForCdmaImsiReady(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCdmaImsiReadyRegistrant.add(r);
+    }
+
+    @Override
+    public void unregisterForCdmaImsiReady(Handler h) {
+        mCdmaImsiReadyRegistrant.remove(h);
+    }
+
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @{
+    @Override
+    public void setSvlteRatMode(int radioTechMode, int preSvlteMode, int svlteMode,
+            int preRoamingMode, int roamingMode, boolean is3GDualModeCard, Message response) {
+    }
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @}
+
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @{
+    public void setStkUtkMode(int stkUtkMode, Message response) {
+    }
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @}
+
+    /// M: [C2K][SVLTE] Update RIL instance id for SVLTE switch ActivePhone. @{
+    @Override
+    public void setInstanceId(int instanceId) {
+    }
+    /// @}
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @{
+
+    @Override
+    public void setRegistrationSuspendEnabled(int enabled, Message response) {
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+    }
+
+    @Override
+    public void setCdmaRegistrationSuspendEnabled(boolean enabled, Message response) {
+    }
+
+    @Override
+    public void setResumeCdmaRegistration(Message response) {
+    }
+
+    @Override
+    public void registerForMccMncChange(Handler h, int what, Object obj) {
+        Rlog.d(RIL.RILJ_LOG_TAG, "registerForMccMncChange h=" + h + " w=" + what);
+        Registrant r = new Registrant(h, what, obj);
+        mMccMncChangeRegistrants.add(r);
+    }
+
+    @Override
+    public void unregisterForMccMncChange(Handler h) {
+        Rlog.d(RIL.RILJ_LOG_TAG, "unregisterForMccMncChange");
+        mMccMncChangeRegistrants.remove(h);
+    }
+
+    @Override
+    public void queryStkSetUpMenuFromMD(String contents, Message response) {}
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+    /// M: [C2K] Support Signal Fade. @{
+    @Override
+    public void setOnCdmaSignalFade(Handler h, int what, Object obj) {
+        mCdmaSignalFadeRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnCdmaSignalFade(Handler h) {
+        if (mCdmaSignalFadeRegistrant != null && mCdmaSignalFadeRegistrant.getHandler() == h) {
+            mCdmaSignalFadeRegistrant.clear();
+            mCdmaSignalFadeRegistrant = null;
+        }
+    }
+    /// @}
+
+    /// M: [C2K] Support Tone Signal. @{
+    @Override
+    public void setOnCdmaToneSignal(Handler h, int what, Object obj) {
+        mCdmaToneSignalsRegistrant = new Registrant(h, what, obj);
+    }
+
+    @Override
+    public void unSetOnCdmaToneSignal(Handler h) {
+        if (mCdmaToneSignalsRegistrant != null && mCdmaToneSignalsRegistrant.getHandler() == h) {
+            mCdmaToneSignalsRegistrant.clear();
+            mCdmaToneSignalsRegistrant = null;
+        }
+    }
+    /// @}
+
+    @Override
+    public void switchAntenna(int callState, int ratMode) {}
+    @Override
+    public void switchCardType(int cardtype) {}
+
+    @Override
+    public void enableMd3Sleep(int enable) {
+    }
+
+    @Override
+    public void registerForNetworkExsit(Handler h, int what, Object obj) {
+        Rlog.d(RIL.RILJ_LOG_TAG, "registerForNetworkExsit h=" + h + " w=" + what);
+        Registrant r = new Registrant(h, what, obj);
+        mNetworkExistRegistrants.add(r);
+    }
+
+    @Override
+    public void unregisterForNetworkExsit(Handler h) {
+        Rlog.d(RIL.RILJ_LOG_TAG, "registerForNetworkExsit");
+        mNetworkExistRegistrants.remove(h);
+    }
 }
diff --git a/src/java/com/android/internal/telephony/CallForwardInfoEx.java b/src/java/com/android/internal/telephony/CallForwardInfoEx.java
new file mode 100644
index 0000000..b39f34f
--- /dev/null
+++ b/src/java/com/android/internal/telephony/CallForwardInfoEx.java
@@ -0,0 +1,65 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package com.android.internal.telephony;
+
+import android.telephony.PhoneNumberUtils;
+
+import java.util.Arrays;
+
+/**
+ * {@hide}
+ */
+public class CallForwardInfoEx {
+    public int             status;      /*1 = active, 0 = not active */
+    public int             reason;      /* from TS 27.007 7.11 "reason" */
+    public int             serviceClass; /* Sum of CommandsInterface.SERVICE_CLASS */
+    public int             toa;         /* "type" from TS 27.007 7.11 */
+    public String          number;      /* "number" from TS 27.007 7.11 */
+    public int             timeSeconds; /* for CF no reply only */
+    public long[]          timeSlot;    /* Time slot of CF */
+
+    @Override
+    public String toString() {
+        return super.toString() + (status == 0 ? " not active " : " active ")
+            + " reason: " + reason
+            + " serviceClass: " + serviceClass
+            + " \"" + PhoneNumberUtils.stringFromStringAndTOA(number, toa) + "\" "
+            + timeSeconds + " seconds"
+            + " timeSlot: " + Arrays.toString(timeSlot);
+    }
+}
diff --git a/src/java/com/android/internal/telephony/CommandException.java b/src/java/com/android/internal/telephony/CommandException.java
index f8f7c33..c4b8c0a 100644
--- a/src/java/com/android/internal/telephony/CommandException.java
+++ b/src/java/com/android/internal/telephony/CommandException.java
@@ -55,6 +55,31 @@
         SS_MODIFIED_TO_DIAL,
         SS_MODIFIED_TO_USSD,
         SS_MODIFIED_TO_SS,
+        // MTK
+        DIAL_STRING_TOO_LONG,
+        TEXT_STRING_TOO_LONG,
+        SIM_MEM_FULL,
+        /* M: SS part */
+        CALL_BARRED,
+        UT_XCAP_403_FORBIDDEN,
+        UT_UNKNOWN_HOST,
+        /* M: SS part end */
+
+        BT_SAP_UNDEFINED,
+        BT_SAP_NOT_ACCESSIBLE,
+        BT_SAP_CARD_REMOVED,
+
+        ADDITIONAL_NUMBER_STRING_TOO_LONG,
+        ADDITIONAL_NUMBER_SAVE_FAILURE,
+        ADN_LIST_NOT_EXIST,
+        EMAIL_SIZE_LIMIT,
+        EMAIL_NAME_TOOLONG,
+        NOT_READY,
+        /// M: SS Ut part
+        SPECAIL_UT_COMMAND_NOT_SUPPORTED,
+
+        /// M: ALPS02147333 call control part
+        CC_CALL_HOLD_FAILED_CAUSED_BY_TERMINATED,
     }
 
     public CommandException(Error e) {
@@ -127,6 +152,32 @@ public CommandException(Error e, String errString) {
                 return new CommandException(Error.SS_MODIFIED_TO_USSD);
             case RILConstants.SS_MODIFIED_TO_SS:
                 return new CommandException(Error.SS_MODIFIED_TO_SS);
+            // MTK
+            case RILConstants.DIAL_STRING_TOO_LONG:
+                return new CommandException(Error.DIAL_STRING_TOO_LONG);
+            case RILConstants.TEXT_STRING_TOO_LONG:
+                return new CommandException(Error.TEXT_STRING_TOO_LONG);
+            case RILConstants.SIM_MEM_FULL:
+                return new CommandException(Error.SIM_MEM_FULL);
+            case RILConstants.ADDITIONAL_NUMBER_STRING_TOO_LONG:
+                return new CommandException(Error.ADDITIONAL_NUMBER_STRING_TOO_LONG);
+            case RILConstants.ADDITIONAL_NUMBER_SAVE_FAILURE:
+                return new CommandException(Error.ADDITIONAL_NUMBER_SAVE_FAILURE);
+            case RILConstants.ADN_LIST_NOT_EXIST:
+                return new CommandException(Error.ADN_LIST_NOT_EXIST);
+            case RILConstants.EMAIL_SIZE_LIMIT:
+                return new CommandException(Error.EMAIL_SIZE_LIMIT);
+            case RILConstants.EMAIL_NAME_TOOLONG:
+                return new CommandException(Error.EMAIL_NAME_TOOLONG);
+            case RILConstants.BT_SAP_UNDEFINED:
+                return new CommandException(Error.BT_SAP_UNDEFINED);
+            case RILConstants.BT_SAP_NOT_ACCESSIBLE:
+                return new CommandException(Error.BT_SAP_NOT_ACCESSIBLE);
+            case RILConstants.BT_SAP_CARD_REMOVED:
+                return new CommandException(Error.BT_SAP_CARD_REMOVED);
+            /// M: ALPS02147333 Hold call failed caused by call terminated
+            case RILConstants.CC_CALL_HOLD_FAILED_CAUSED_BY_TERMINATED:
+                return new CommandException(Error.CC_CALL_HOLD_FAILED_CAUSED_BY_TERMINATED);
             default:
                 Rlog.e("GSM", "Unrecognized RIL errno " + ril_errno);
                 return new CommandException(Error.INVALID_RESPONSE);
diff --git a/src/java/com/android/internal/telephony/CommandsInterface.java b/src/java/com/android/internal/telephony/CommandsInterface.java
index 2717682..06d2466 100644
--- a/src/java/com/android/internal/telephony/CommandsInterface.java
+++ b/src/java/com/android/internal/telephony/CommandsInterface.java
@@ -22,6 +22,10 @@
 import com.android.internal.telephony.RadioCapability;
 import com.android.internal.telephony.uicc.IccCardStatus;
 
+import com.mediatek.internal.telephony.FemtoCellInfo;
+import com.mediatek.internal.telephony.SrvccCallContext;
+
+import android.os.AsyncResult;
 import android.os.Message;
 import android.os.Handler;
 
@@ -65,6 +69,9 @@ public boolean isAvailable() {
     static final int CF_REASON_NOT_REACHABLE    = 3;
     static final int CF_REASON_ALL              = 4;
     static final int CF_REASON_ALL_CONDITIONAL  = 5;
+    //MTK-START [MMTelSS]
+    static final int CF_REASON_NOT_REGISTERED   = 6;
+    //MTK-END [MMTelSS]
 
     // Used for call barring methods below
     static final String CB_FACILITY_BAOC         = "AO";
@@ -90,7 +97,17 @@ public boolean isAvailable() {
     static final int SERVICE_CLASS_DATA_ASYNC = (1 << 5);
     static final int SERVICE_CLASS_PACKET   = (1 << 6);
     static final int SERVICE_CLASS_PAD      = (1 << 7);
-    static final int SERVICE_CLASS_MAX      = (1 << 7); // Max SERVICE_CLASS value
+    // MTK
+    static final int SERVICE_CLASS_MAX      = (1 << 9); // Max SERVICE_CLASS value
+    /* M: SS part */
+    //MTK-START [mtk04070][111118][ALPS00093395]MTK added
+    static final int SERVICE_CLASS_LINE2    = (1 << 8); // Add for Line2
+    /**
+     * SERVICE_CLASS_VIDEO Service Supplementary Information codes for Video Telephony support.
+     */
+    static final int SERVICE_CLASS_VIDEO    = (1 << 9);
+    //MTK-END [mtk04070][111118][ALPS00093395]MTK added
+    /* M: SS part end */
 
     // Numeric representation of string values returned
     // by messages sent to setOnUSSD handler
@@ -100,6 +117,14 @@ public boolean isAvailable() {
     static final int USSD_MODE_LOCAL_CLIENT  = 3;
     static final int USSD_MODE_NOT_SUPPORTED = 4;
     static final int USSD_MODE_NW_TIMEOUT    = 5;
+    /* M: SS part */
+    //MTK-START [mtk04070][111118][ALPS00093395]MTK added
+    static final int USSD_SESSION_END               = 2;
+    static final int USSD_HANDLED_BY_STK            = 3;
+    static final int USSD_OPERATION_NOT_SUPPORTED   = 4;
+    static final int USSD_NETWORK_TIMEOUT           = 5;
+    //MTK-END [mtk04070][111118][ALPS00093395]MTK added
+    /* M: SS part end */
 
     // GSM SMS fail cause for acknowledgeLastIncomingSMS. From TS 23.040, 9.2.3.22.
     static final int GSM_SMS_FAIL_CAUSE_MEMORY_CAPACITY_EXCEEDED    = 0xD3;
@@ -113,6 +138,36 @@ public boolean isAvailable() {
     static final int CDMA_SMS_FAIL_CAUSE_OTHER_TERMINAL_PROBLEM     = 39;
     static final int CDMA_SMS_FAIL_CAUSE_ENCODING_PROBLEM           = 96;
 
+    // MTK
+    //MTK-START [mtk04070][111118][ALPS00093395]MTK added
+    //MTK AT CMD +ESMLCK
+    static final int CAT_NETWOEK                = 0;
+    static final int CAT_NETOWRK_SUBSET         = 1;
+    static final int CAT_SERVICE_PROVIDER       = 2;
+    static final int CAT_CORPORATE              = 3;
+    static final int CAT_SIM                    = 4;
+
+    static final int OP_UNLOCK                  = 0;
+    static final int OP_LOCK                    = 1;
+    static final int OP_ADD                     = 2;
+    static final int OP_REMOVE                  = 3;
+    static final int OP_PERMANENT_UNLOCK        = 4;
+    //MTK-END [mtk04070][111118][ALPS00093395]MTK added
+
+    // UTK start
+    // Command Qualifier values for refresh command
+    static final int REFRESH_NAA_INIT_AND_FULL_FILE_CHANGE  = 0x00;
+    static final int REFRESH_NAA_FILE_CHANGE                = 0x01;
+    static final int REFRESH_NAA_INIT_AND_FILE_CHANGE       = 0x02;
+    static final int REFRESH_NAA_INIT                       = 0x03;
+    static final int REFRESH_UICC_RESET                     = 0x04;
+
+    // Qualifier values for UTK Refresh command
+    static final int UTK_REFRESH_SMS = 0;
+    static final int UTK_REFRESH_PHB = 1;
+    static final int UTK_REFRESH_SYS = 2;
+    //UTKE end
+
     //***** Methods
     RadioState getRadioState();
 
@@ -773,6 +828,7 @@ public boolean isAvailable() {
 
     void changeBarringPassword(String facility, String oldPwd, String newPwd, Message result);
 
+    // MTK
     void supplyNetworkDepersonalization(String netpin, Message result);
 
     /**
@@ -1983,6 +2039,1459 @@ public void iccTransmitApduBasicChannel(int cla, int instruction, int p1, int p2
     void setOnCatSendSmsResult(Handler h, int what, Object obj);
     void unSetOnCatSendSmsResult(Handler h);
 
+    // MTK
+    // wow so content very media amuse
+
+    void registerForEusimReady(Handler h, int what, Object obj);
+    void unregisterForEusimReady(Handler h);
+
+    /**
+     * Sets the handler for event download of call notifications.
+     * Unlike the register* methods, there's only one notification handler
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnStkEvdlCall(Handler h, int what, Object obj);
+    void unSetOnStkEvdlCall(Handler h);
+
+    /**
+     * Sets the handler for event download of call notifications.
+     * Unlike the register* methods, there's only one notification handler
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnStkSetupMenuReset(Handler h, int what, Object obj);
+    void unSetOnStkSetupMenuReset(Handler h);
+
+    /**
+     * Sets the handler for call ccontrol response message.
+     * Unlike the register* methods, there's only one notification handler
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnStkCallCtrl(Handler h, int what, Object obj);
+    /**
+     * Unsets the handler for call ccontrol response message.
+     * Unlike the register* methods, there's only one notification handler
+     *
+     * @param h Handler for notification message.
+     */
+    void unSetOnStkCallCtrl(Handler h);
+
+    /// M: BIP {
+    /**
+     * Sets the handler for Proactive Commands for CAT.
+     * Unlike the register* methods, there's only one notification handler
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnBipProactiveCmd(Handler h, int what, Object obj);
+    void unSetOnBipProactiveCmd(Handler h);
+    /// M: BIP }
+
+    //MTK-START [mtk06800] modem power on/off
+    void setModemPower(boolean power, Message response);
+    //MTK-END [mtk06800] modem power on/off
+
+    void setNetworkSelectionModeManualWithAct(String operatorNumeric, String act, Message response);
+
+    void setNetworkSelectionModeSemiAutomatic(String operatorNumeric, String act, Message response);
+
+    /**
+     * Cancel querie the currently available networks
+     *
+     * ((AsyncResult)response.obj).result  is a List of NetworkInfo objects
+     */
+    void cancelAvailableNetworks(Message response);
+
+    /* M: SS part */
+    ///M: For query CNAP
+    void sendCNAPSS(String cnapssString, Message response);
+    /* M: SS part end */
+
+    /**
+     * Indicates to the vendor ril that call connected and disconnected
+     * event download will be handled by AP.
+     * @param enabled '0' handles event download by AP; '1' handles event download by MODEM
+     * @param response callback message
+     */
+    void setStkEvdlCallByAP(int enabled, Message response);
+
+    /**
+     * Query UTK menu from modem
+     *
+     *
+     * @param contents  String containing SAT/USAT response in hexadecimal
+     *                  format starting with command tag. See TS 102 223 for
+     *                  details.
+     * @param response  Callback message
+     */
+    public void queryUtkSetupMenuFromMD(String contents, Message response);
+
+    /**
+     * Query STK menu from modem.
+     *
+     *
+     * @param contents  String containing SAT/USAT response in hexadecimal
+     *                  format starting with command tag. See TS 102 223 for
+     *                  details.
+     * @param response  Callback message
+     */
+    public void queryStkSetUpMenuFromMD(String contents, Message response);
+
+    /**
+     * Accept or reject the call setup request from SIM.
+     *
+     * @param accept   true if the call is to be accepted, false otherwise.
+     * @param response Callback message
+     */
+    public void handleCallSetupRequestFromSim(boolean accept, int resCode, Message response);
+
+    /**
+     * Sets user selected subscription at Modem.
+     *
+     * @param slotId
+     *          Slot.
+     * @param appIndex
+     *          Application index in the card.
+     * @param subId
+     *          Indicates subscription 0 or subscription 1.
+     * @param subStatus
+     *          Activation status, 1 = activate and 0 = deactivate.
+     * @param result
+     *          Callback message contains the information of SUCCESS/FAILURE.
+     */
+    // FIXME Update the doc and consider modifying the request to make more generic.
+    public void setUiccSubscription(int slotId, int appIndex, int subId, int subStatus,
+            Message result);
+
+    /// M: CC010: Add RIL interface @{
+    public void registerForCipherIndication(Handler h, int what, Object obj);
+    public void unregisterForCipherIndication(Handler h);
+    public void registerForCallForwardingInfo(Handler h, int what, Object obj);
+    public void unregisterForCallForwardingInfo(Handler h);
+    public void setOnCallRelatedSuppSvc(Handler h, int what, Object obj);
+    public void unSetOnCallRelatedSuppSvc(Handler h);
+
+    /**
+     * used to register to EAIC URC for call state change.
+     *
+     * msg.obj is an AsyncResult
+     * ar.result is a String[]
+     */
+    public void setOnIncomingCallIndication(Handler h, int what, Object obj);
+    public void unsetOnIncomingCallIndication(Handler h);
+
+    //obsolete
+    /*
+    public void setCnapNotify(Handler h, int what, Object obj);
+    public void unSetCnapNotify(Handler h);
+    */
+    /// @}
+
+    /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+    void setOnSpeechCodecInfo(Handler h, int what, Object obj);
+    void unSetOnSpeechCodecInfo(Handler h);
+    /// @}
+
+    /// M: CC010: Add RIL interface @{
+    /**
+     *  ar.exception carries exception on failure
+     *  ar.userObject contains the orignal value of result.obj
+     *  ar.result is null on success and failure
+     */
+    public void hangupAll(Message result);
+
+    /**
+     *
+     *  ar.exception carries exception on failure
+     *  ar.userObject contains the orignal value of result.obj
+     *  ar.result is null on success and failure
+     */
+    public void forceReleaseCall(int index, Message result);
+
+    /**
+     *
+     *  ar.exception carries exception on failure
+     *  ar.userObject contains the orignal value of result.obj
+     *  ar.result is null on success and failure
+     */
+    public void setCallIndication(int mode, int callId, int seqNumber, Message result);
+
+    /**
+     *  returned message
+     *  retMsg.obj = AsyncResult ar
+     *  ar.exception carries exception on failure
+     *  ar.userObject contains the orignal value of result.obj
+     *  ar.result is null on success and failure
+     *
+     * CLIR_DEFAULT     == on "use subscription default value"
+     * CLIR_SUPPRESSION == on "CLIR suppression" (allow CLI presentation)
+     * CLIR_INVOCATION  == on "CLIR invocation" (restrict CLI presentation)
+     */
+    public void emergencyDial(String address, int clirMode, UUSInfo uusInfo, Message result);
+
+    public void setEccServiceCategory(int serviceCategory);
+    /// @}
+
+    /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+    public void setSpeechCodecInfo(boolean enable, Message response);
+    /// @}
+
+    /// M: For 3G VT only @{
+    /**
+     * used to register to EVTSTATUS URC for VT status.
+     *
+     * msg.obj is an AsyncResult
+     * ar.result is a int[]
+     * String[0] is on_off
+     */
+    void registerForVtStatusInfo(Handler h, int what, Object obj);
+    void unregisterForVtStatusInfo(Handler h);
+
+    /**
+     * used to register to CRING: VIDEO URC for MT VT call.
+     *
+     * msg.obj is an AsyncResult
+     */
+    void registerForVtRingInfo(Handler h, int what, Object obj);
+    void unregisterForVtRingInfo(Handler h);
+    /// @}
+
+    /// M: For 3G VT only @{
+    /**
+     *  returned message
+     *  retMsg.obj = AsyncResult ar
+     *  ar.exception carries exception on failure
+     *  ar.userObject contains the orignal value of result.obj
+     *  ar.result is null on success and failure
+     *
+     * CLIR_DEFAULT     == on "use subscription default value"
+     * CLIR_SUPPRESSION == on "CLIR suppression" (allow CLI presentation)
+     * CLIR_INVOCATION  == on "CLIR invocation" (restrict CLI presentation)
+     */
+    public void vtDial(String address, int clirMode, UUSInfo uusInfo, Message result);
+
+    /**
+     *  ar.exception carries exception on failure
+     *  ar.userObject contains the orignal value of result.obj
+     *  ar.result is null on success and failure
+     */
+    public void acceptVtCallWithVoiceOnly(int callId, Message result);
+
+    /**
+     *
+     *  ar.exception carries exception on failure
+     *  ar.userObject contains the orignal value of result.obj
+     *  ar.result is null on success and failure
+     */
+    public void replaceVtCall(int index, Message result);
+    /// @}
+
+    /* M: SS part */
+    void changeBarringPassword(String facility, String oldPwd, String newPwd, String newCfm,
+         Message result);
+
+    /**
+     * response.obj will be a an int[2]
+     *
+     * response.obj[0] will be TS 27.007 COLP parameter 'n'
+     *  0 COLP disabled
+     *  1 COLP enabled
+     *
+     * response.obj[1] will be TS 27.007 COLP parameter 'm'
+     *  0 COLP not provisioned
+     *  1 COLP provisioned
+     *  2 unknown (e.g. no network, etc.)
+     */
+    void getCOLP(Message response);
+
+    /**
+     * enable is true for enable / false for disable COLP (ONLY affect TE not NW)
+     *
+     * response.obj is null
+     */
+    void setCOLP(boolean enable, Message response);
+
+    /**
+     * response.obj will be a an int[1]
+     *
+     * response.obj[0] will be proprietary COLR parameter 'n'
+     *  0 COLR not provisioned
+     *  1 COLR provisioned
+     *  2 unknown (e.g. no network, etc.)
+     */
+    void getCOLR(Message response);
+
+    /**
+     * enable is true for enable / false for disable CLIP (ONLY affect TE not NW)
+     *
+     * response.obj is null
+     */
+    void setCLIP(boolean enable, Message response);
+    /* M: SS part end */
+
+    //MTK-START multiple application support
+    /**
+     * M: Open application in the UICC
+     *
+     * @param application: application ID
+     * @param response The message to send.
+     */
+    public void openIccApplication(int application, Message response);
+
+    /**
+     * Query application status
+     *
+     * @param sessionId: The channel ID
+     * @param response The message to send.
+     */
+    public void getIccApplicationStatus(int sessionId, Message result);
+
+
+    /**
+     * Register the handler for event notifications for sessionid of an application changed event.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForSessionChanged(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for event notifications for sessionid of an application changed event.
+     *
+     * @param h Handler for notification message.
+     */
+    void unregisterForSessionChanged(Handler h);
+    //MTK-END multiple application support
+
+    /**
+     * Query network lock status according to indicated category.
+     *
+     * @param categrory network lock category
+     *                  0 for Network personalisation category
+     *                  1 for Network subset personalisation category
+     *                  2 for Service provider personalisation category
+     *                  3 for Corporate(GID) personalisation category
+     *                  4 for SIM/USIM(IMSI) personalisation category
+     * @param response Callback message containing response structure.
+     */
+    void queryNetworkLock(int categrory, Message response);
+
+    /**
+     * Query network lock status according to indicated category.
+     *
+     * @param categrory network lock category
+     *                  "0" for Network personalisation category
+     *                  "1" for Network subset personalisation category
+     *                  "2" for Service provider personalisation category
+     *                  "3" for Corporate(GID) personalisation category
+     *                  "4" for SIM/USIM(IMSI) personalisation category
+     * @param lockop lock operation
+     *               "0" for unlock opreation
+     *               "1" for lock opreation
+     *               "2" for add lock opreation
+     *               "3" for remove lock opreation
+     *               "4" for disable lock category opreation
+     * @param password password of indicated network lock
+     * @param data_imsi IMSI value used to setup lock
+     * @param gid1 GID1 value used to setup lock
+     * @param gid2 GID2 value used to setup lock
+     * @param response Callback message containing response structure.
+     */
+    void setNetworkLock(int catagory, int lockop, String password,
+            String data_imsi, String gid1, String gid2, Message response);
+
+
+    /**
+     * Request security context authentication for SIM/USIM/ISIM
+     */
+    public void doGeneralSimAuthentication(int sessionId, int mode , int tag, String param1,
+                                                    String param2, Message response);
+
+    // Added by M begin
+    void iccGetATR(Message result);
+    void iccOpenChannelWithSw(String AID, Message result);
+
+    void registerForSimMissing(Handler h, int what, Object obj);
+    void unregisterForSimMissing(Handler h);
+
+    void registerForSimRecovery(Handler h, int what, Object obj);
+    void unregisterForSimRecovery(Handler h);
+
+    public void registerForVirtualSimOn(Handler h, int what, Object obj);
+    public void unregisterForVirtualSimOn(Handler h);
+
+    public void registerForVirtualSimOff(Handler h, int what, Object obj);
+    public void unregisterForVirtualSimOff(Handler h);
+
+    /**
+     * Sets the handler for event notifications for SIM plug-out event.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForSimPlugOut(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for event notifications for SIM plug-out event.
+     *
+     * @param h Handler for notification message.
+     */
+    void unregisterForSimPlugOut(Handler h);
+
+    /**
+     * Sets the handler for event notifications for SIM plug-in event.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForSimPlugIn(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for event notifications for SIM plug-in event.
+     *
+     * @param h Handler for notification message.
+     */
+    void unregisterForSimPlugIn(Handler h);
+
+    /**
+     * Sets the handler for event notifications for Tray plug-in event in common slot project.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForTrayPlugIn(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for event notifications for Tray plug-in event in common slot project.
+     *
+     * @param h Handler for notification message.
+     */
+    void unregisterForTrayPlugIn(Handler h);
+
+    /**
+     * Sets the handler for event notifications for SIM common slot no changed.
+     *
+     */
+    void registerForCommonSlotNoChanged(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for event notifications for SIM common slot no changed.
+     *
+     */
+    void unregisterForCommonSlotNoChanged(Handler h);
+
+    void registerSetDataAllowed(Handler h, int what, Object obj);
+    void unregisterSetDataAllowed(Handler h);
+
+
+    /**
+     * Send BT SIM profile
+     * @param nAction
+     *          the type of the action
+     *          0: Connect
+     *          1: Disconnect
+     *          2: Power On
+     *          3: Power Off
+     *          4: Reset
+     *          5: APDU
+     * @param nType
+     *          Indicate which transport protocol is the preferred one
+     *          0x00 : T=0
+     *          0x01 : T=1
+     * @param strData
+     *          Only be used when action is APDU transfer
+     * @param response
+     *          Callback message containing response structure.
+     */
+    public void sendBTSIMProfile(int nAction, int nType, String strData, Message response);
+
+    void registerForEfCspPlmnModeBitChanged(Handler h, int what, Object obj);
+    void unregisterForEfCspPlmnModeBitChanged(Handler h);
+
+    /**
+     * Request the information of the given storage type
+     *
+     * @param type
+     *          the type of the storage, refer to PHB_XDN defined in the RilConstants
+     * @param response
+     *          Callback message
+     *          response.obj.result is an int[4]
+     *          response.obj.result[0] is number of current used entries
+     *          response.obj.result[1] is number of total entries in the storage
+     *          response.obj.result[2] is maximum supported length of the number
+     *          response.obj.result[3] is maximum supported length of the alphaId
+     */
+    public void queryPhbStorageInfo(int type, Message response);
+
+    /**
+     * Request update a PHB entry using the given {@link PhbEntry}
+     *
+     * @param entry a PHB entry strucutre {@link PhbEntry}
+     *          when one of the following occurs, it means delete the entry.
+     *          1. entry.number is NULL
+     *          2. entry.number is empty and entry.ton = 0x91
+     *          3. entry.alphaId is NULL
+     *          4. both entry.number and entry.alphaId are empty.
+     * @param result
+     *          Callback message containing if the action is success or not.
+     */
+    public void writePhbEntry(PhbEntry entry, Message result);
+
+    /**
+     * Request read PHB entries from the given storage
+     * @param type
+     *          the type of the storage, refer to PHB_* defined in the RilConstants
+     * @param bIndex
+     *          the begin index of the entries to be read
+     * @param eIndex
+     *          the end index of the entries to be read, note that the (eIndex - bIndex 1)
+     *          should not exceed the value RilConstants.PHB_MAX_ENTRY
+     *
+     * @param response
+     *          Callback message containing an array of {@link PhbEntry} structure.
+     */
+    public void ReadPhbEntry(int type, int bIndex, int eIndex, Message response);
+
+    /**
+     * Sets the handler for PHB ready notification
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForPhbReady(Handler h, int what, Object obj);
+    void unregisterForPhbReady(Handler h);
+
+    void queryUPBCapability(Message response);
+    void editUPBEntry(int entryType, int adnIndex, int entryIndex, String strVal,
+         String tonForNum, Message response);
+    void deleteUPBEntry(int entryType, int adnIndex, int entryIndex, Message response);
+    void readUPBGasList(int startIndex, int endIndex, Message response);
+    void readUPBGrpEntry(int adnIndex, Message response);
+    void writeUPBGrpEntry(int adnIndex, int[] grpIds, Message response);
+
+    void getPhoneBookStringsLength(Message result);
+    void getPhoneBookMemStorage(Message result);
+    void setPhoneBookMemStorage(String storage, String password, Message result);
+    // xen0n: MTK TODO
+    // void readPhoneBookEntryExt(int index1, int index2, Message result);
+    // void writePhoneBookEntryExt(PBEntry entry, Message result);
+
+    // Added by M end
+
+    // xen0n: MTK TODO
+    // MTK-START, SMS part
+    /*
+     * Get sms parameters from EFsmsp
+     */
+    // void getSmsParameters(Message response);
+
+    /*
+     * Set sms parameters into EFsmsp
+     */
+    // void setSmsParameters(SmsParameters params, Message response);
+
+    /**
+     * Get SMS SIM Card memory's total and used number
+     *
+     * @param result callback message
+     */
+    void getSmsSimMemoryStatus(Message result);
+
+    void setEtws(int mode, Message result);
+    void setOnEtwsNotification(Handler h, int what, Object obj);
+    void unSetOnEtwsNotification(Handler h);
+
+    /**
+     * Sets the handler for ME SMS storage full unsolicited message.
+     * Unlike the register methods, there's only one notification handler
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnMeSmsFull(Handler h, int what, Object obj);
+    void unSetOnMeSmsFull(Handler h);
+
+    /**
+     * Register the handler for SMS ready notification.
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForSmsReady(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for SMS ready notification.
+     *
+     * @param h Handler for notification message.
+     */
+    void unregisterForSmsReady(Handler h);
+
+    void setCellBroadcastChannelConfigInfo(String config, int cb_set_type, Message response);
+    void setCellBroadcastLanguageConfigInfo(String config, Message response);
+    void queryCellBroadcastConfigInfo(Message response);
+    void removeCellBroadcastMsg(int channelId, int serialId, Message response);
+    // MTK-END, SMS part
+
+    void getPOLCapabilty(Message response);
+    void getCurrentPOLList(Message response);
+    void setPOLEntry(int index, String numeric, int nAct, Message response);
+
+    void registerForPsNetworkStateChanged(Handler h, int what, Object obj);
+    void unregisterForPsNetworkStateChanged(Handler h);
+
+    void registerForIMEILock(Handler h, int what, Object obj);
+    void unregisterForIMEILock(Handler h);
+
+   /**
+     * Sets the handler for Invalid SIM unsolicited message.
+     * Unlike the register* methods, there's only one notification handler
+     *
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setInvalidSimInfo(Handler h, int what, Object obj);
+    void unSetInvalidSimInfo(Handler h);
+
+    // get Available network informaitons API
+    void registerForGetAvailableNetworksDone(Handler h, int what, Object obj);
+    void unregisterForGetAvailableNetworksDone(Handler h);
+    boolean isGettingAvailableNetworks();
+
+  // Femtocell (CSG) feature START
+  /**
+     * Queries the currently available femtocells
+     *
+     * ((AsyncResult)response.obj).result  is a List of FemtoCellInfo objects
+     */
+    void getFemtoCellList(String operatorNumeric, int rat, Message response);
+
+  /**
+     * Abort quering available femtocells
+     *
+     * ((AsyncResult)response.obj).result  is a List of FemtoCellInfo objects
+     */
+    void abortFemtoCellList(Message response);
+
+  /**
+     * select femtocell
+     *
+     * @param femtocell info
+     */
+    void selectFemtoCell(FemtoCellInfo femtocell, Message response);
+
+    public void registerForFemtoCellInfo(Handler h, int what, Object obj);
+    public void unregisterForFemtoCellInfo(Handler h);
+    // Femtocell (CSG) feature END
+
+    /**
+     * unlike the register* methods, there's only one Neighboring cell info handler
+     *
+     * AsyncResult.result is an Object[]
+     * ((Object[])AsyncResult.result)[0] is a String containing the RAT
+     * ((Object[])AsyncResult.result)[1] is a String containing the neighboring cell info raw data
+     *
+     * Please note that the delivery of this message may be delayed several
+     * seconds on system startup
+     */
+    void registerForNeighboringInfo(Handler h, int what, Object obj);
+    void unregisterForNeighboringInfo(Handler h);
+
+    /**
+     * unlike the register* methods, there's only one Network info handler
+     *
+     * AsyncResult.result is an Object[]
+     * ((Object[])AsyncResult.result)[0] is a String containing the type
+     * ((Object[])AsyncResult.result)[1] is a String contain the network info raw data
+     *
+     * Please note that the delivery of this message may be delayed several
+     * seconds on system startup
+     */
+    void registerForNetworkInfo(Handler h, int what, Object obj);
+    void unregisterForNetworkInfo(Handler h);
+
+    // IMS
+    public void registerForImsEnable(Handler h, int what, Object obj);
+    public void unregisterForImsEnable(Handler h);
+    public void registerForImsDisable(Handler h, int what, Object obj);
+    public void unregisterForImsDisable(Handler h);
+    public void setIMSEnabled(boolean enable, Message response);
+    public void registerForImsDisableDone(Handler h, int what, Object obj);
+    public void unregisterForImsDisableDone(Handler h);
+    public void registerForImsRegistrationInfo(Handler h, int what, Object obj);
+    public void unregisterForImsRegistrationInfo(Handler h);
+
+    void setTrm(int mode, Message result);
+
+    void setOnPlmnChangeNotification(Handler h, int what, Object obj);
+    void unSetOnPlmnChangeNotification(Handler h);
+    void setOnRegistrationSuspended(Handler h, int what, Object obj);
+    void unSetOnRegistrationSuspended(Handler h);
+    void storeModemType(int modemType, Message response);
+    void reloadModemType(int modemType, Message response);
+    void queryModemType(Message response);
+
+    //Remote SIM ME lock related APIs [Start]
+    void registerForMelockChanged(Handler h, int what, Object obj);
+    void unregisterForMelockChanged(Handler h);
+    //Remote SIM ME lock related APIs [End]
+
+    /** M: start */
+    void setupDataCall(String radioTechnology, String profile, String apn, String user,
+            String password, String authType, String protocol, String interfaceId, Message result);
+
+     /**
+     * @param apn for apn name
+     * @param protocol for IP type
+     * @param authType for Auth type
+     * @param username for username
+     * @param password for password
+     * @param obj for ia extend parameter
+     * @param result for result
+     */
+    void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, Object obj, Message result);
+
+    // Fast Dormancy
+    void setScri(boolean forceRelease, Message response);
+    void setFDMode(int mode, int parameter1, int parameter2, Message response);
+    public void setScriResult(Handler h, int what, Object obj);
+    public void unSetScriResult(Handler h);
+    /** M: end */
+
+    /// M: IMS feature. @{
+    /* Register for updating call ids for conference call after SRVCC is done. */
+    public void registerForEconfSrvcc(Handler h, int what, Object obj);
+    public void unregisterForEconfSrvcc(Handler h);
+
+    /* Register for updating conference call merged/added result. */
+    public void registerForEconfResult(Handler h, int what, Object obj);
+    public void unregisterForEconfResult(Handler h);
+
+    /* Register for updating call mode and pau */
+    public void registerForCallInfo(Handler h, int what, Object obj);
+    public void unregisterForCallInfo(Handler h);
+
+    /* Add/Remove VoLTE(IMS) conference call member. */
+    public void addConferenceMember(int confCallId, String address, int callIdToAdd, Message response);
+    public void removeConferenceMember(int confCallId, String address, int callIdToRemove,
+           Message response);
+
+    /**
+     * To resume the call.
+     * @param callIdToResume toIndicate which call session to resume.
+     * @param response command response.
+     */
+    public void resumeCall(int callIdToResume, Message response);
+
+    /**
+     * To hold the call.
+     * @param callIdToHold toIndicate which call session to hold.
+     * @param response command response.
+     */
+    public void holdCall(int callIdToHold, Message response);
+
+    /**
+     * M: notify screen state to RILD
+     *
+     * @param on The screen state
+     */
+    public void sendScreenState(boolean on);
+
+    /// @}
+
+    /**
+     * M: CC33 LTE.
+     */
+    public void registerForRacUpdate(Handler h, int what, Object obj);
+    public void unregisterForRacUpdate(Handler h);
+    public void setDataOnToMD(boolean enable, Message result);
+    public void setRemoveRestrictEutranMode(boolean enable, Message result);
+    public void registerForRemoveRestrictEutran(Handler h, int what, Object obj);
+    public void unregisterForRemoveRestrictEutran(Handler h);
+
+    /**
+     * M: Reset Attach Apn
+     */
+    public void registerForResetAttachApn(Handler h, int what, Object obj);
+    public void unregisterForResetAttachApn(Handler h);
+
+   /**
+    * M: [LTE][Low Power][UL traffic shaping]
+    */
+    public void setLteAccessStratumReport(boolean enable, Message result);
+    public void setLteUplinkDataTransfer(int state, int interfaceId, Message result);
+    public void registerForLteAccessStratumState(Handler h, int what, Object obj);
+    public void unregisterForLteAccessStratumState(Handler h);
+
+    /**
+     * IMS.
+     * @param enable if true.
+     * @param response User-defined message code.
+     */
+
+    public void setDataCentric(boolean enable, Message response);
+
+
+    /// M: CC010: Add RIL interface @{
+    /**
+     * Notify modem about IMS call status.
+     * @param existed True if there is at least one IMS call existed, else return false.
+     * @param response User-defined message code.
+     */
+    public void setImsCallStatus(boolean existed, Message response);
+    /// @}
+
+    /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+    /**
+     * Transfer IMS call to CS modem.
+     *
+     * @param numberOfCall The number of call
+     * @param callList IMS call context
+     */
+     public void setSrvccCallContextTransfer(int numberOfCall, SrvccCallContext[] callList);
+
+    /**
+     * Update IMS registration status to modem.
+     *
+     * @param regState IMS registration state
+     *                 0: IMS unregistered
+     *                 1: IMS registered
+     * @param regType  IMS registration type
+     *                 0: Normal IMS registration
+     *                 1: Emergency IMS registration
+     * @param reason   The reason of state transition from registered to unregistered
+     *                 0: Unspecified
+     *                 1: Power off
+     *                 2: RF off
+     */
+     public void updateImsRegistrationStatus(int regState, int regType, int reason);
+     /// @}
+
+    /* C2K part start */
+    /**
+     * Request to recovery telephony.
+     *
+     * @param mode The recovery mode
+     * @param result callback message
+     */
+    void setViaTRM(int mode, Message result);
+
+    /**
+     * Request to get NITZ time.
+     *
+     * @param result callback message
+     */
+    void getNitzTime(Message result);
+
+    /**
+     * Request to switch HPF.
+     * @param enableHPF true if
+     * @param response callback message
+     */
+    void requestSwitchHPF(boolean enableHPF, Message response);
+
+    /**
+     * Request to set avoid SYS.
+     * @param avoidSYS true if
+     * @param response callback message
+     */
+    void setAvoidSYS(boolean avoidSYS, Message response);
+
+    /**
+     * Request to get avoid SYS List.
+     * @param response callback message
+     */
+    void getAvoidSYSList(Message response);
+
+    /**
+     * M: oplmn is the oplmn list download from the specific url.
+     * @param oplmnInfo The info send to the modem
+     * @param response The message to send.
+     */
+    void setOplmn(String oplmnInfo, Message response);
+
+    /**
+     * M: Get the oplmn updated version.
+     * @param response the responding message.
+     */
+    void getOplmnVersion(Message response);
+
+    /**
+     * query CDMA Network Info.
+     * @param response callback message
+     */
+    void queryCDMANetworkInfo(Message response);
+
+    /**
+     * Register the handler for call accepted.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForCallAccepted(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for call accepted.
+     * @param h Handler for notification message.
+     */
+    void unregisterForCallAccepted(Handler h);
+
+    /**
+     * Sets the handler for meid.
+     * @param meid meid string.
+     * @param response callback message.
+     */
+    void setMeid(String meid, Message response);
+
+    /**
+     * Register for via gps event.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForViaGpsEvent(Handler h, int what, Object obj);
+
+    /**
+     * Unregister the handler for via gps event.
+     * @param h Handler for notification message.
+     */
+    void unregisterForViaGpsEvent(Handler h);
+
+    /**
+     * Request to AGPScp connected.
+     * @param connected connected number
+     * @param result callback message
+     */
+    void requestAGPSTcpConnected(int connected, Message result);
+
+    /**
+     * request AGPS set mpc ip & port address.
+     *
+     * @param ip ip address
+     * @param port port to use
+     * @param result callback message
+     */
+    void requestAGPSSetMpcIpPort(String ip, String port, Message result);
+
+    /**
+     * request AGPS get mpc ip & port address.
+     *
+     * @param result callback message
+     */
+    void requestAGPSGetMpcIpPort(Message result);
+
+    /**
+     * request set ets device.
+     *
+     * @param dev 0-uart,1-usb,2-sdio
+     * @param result callback message
+     */
+     void requestSetEtsDev(int dev, Message result);
+
+     /**
+      * For China Telecom auto-register sms.
+      *
+      * @param response The request's response
+      */
+     void queryCDMASmsAndPBStatus(Message response);
+
+     /**
+      * For China Telecom auto-register sms.
+      *
+      * @param response The request's response
+      */
+     void queryCDMANetWorkRegistrationState(Message response);
+
+     /**
+      * Register for network change callback.
+      *
+      * @param h Handler for notification message.
+      * @param what User-defined message code.
+      * @param obj User object.
+      */
+     void registerForNetworkTypeChanged(Handler h, int what, Object obj);
+
+     /**
+      * Unregister for network change callback.
+      *
+      * @param h Handler for notification message.
+      */
+     void unregisterForNetworkTypeChanged(Handler h);
+
+     /**
+      * Set ARSI report threshold.
+      *
+      * @param threshold The threshold to set
+      * @param response The request's response
+      */
+     void setArsiReportThreshold(int threshold, Message response);
+
+     /**
+      * Set MDN number.
+      * @param mdn The mdn numer to set
+      * @param response The request's response
+      */
+     void setMdnNumber(String mdn, Message response);
+
+    // UTK start
+    /**
+     * set on utk session end.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnUtkSessionEnd(Handler h, int what, Object obj);
+
+    /**
+     * unset on utk session end.
+     * @param h Handler for notification message.
+     */
+    void unSetOnUtkSessionEnd(Handler h);
+
+    /**
+     * set on utk proactive cmd.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnUtkProactiveCmd(Handler h, int what, Object obj);
+
+    /**
+     * unset on utk proactive cmd.
+     * @param h Handler for notification message.
+     */
+    void unSetOnUtkProactiveCmd(Handler h);
+
+    /**
+     * set on utk event.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnUtkEvent(Handler h, int what, Object obj);
+
+    /**
+     * unset on utk event.
+     * @param h Handler for notification message.
+     */
+    void unSetOnUtkEvent(Handler h);
+
+    /**
+     * handle call setup request from uim.
+     * @param accept true if.
+     * @param response callback message.
+     */
+    public void handleCallSetupRequestFromUim(boolean accept, Message response);
+
+    /**
+     * report utk service is running.
+     * @param result callback message.
+     */
+    void reportUtkServiceIsRunning(Message result);
+    /**
+     * Query Local Info.
+     *
+     * @param result callback message
+     */
+    void getUtkLocalInfo(Message result);
+
+    /**
+     * Send a UTK refresh command.
+     *
+     * @param refreshType refresh type
+     * @param result callback message
+     */
+    void requestUtkRefresh(int refreshType, Message result);
+
+    /**
+     * When Vendor UtkService is running, download profile to tell Ruim what capability phone has.
+     *
+     * @param response callback message
+     *
+     * @param profile  profile downloaded into Ruim
+     */
+    void profileDownload(String profile, Message response);
+    //UTK end
+
+    /**
+     * C2K SVLTE remote SIM access.
+     * @param modemStatus The Modem status: 0: Only MD1 active
+     *                                      1: MD1's RF is closed, but MD1's SIM task is still
+     *                                         working onlyfor MD3 SIM remove access and MD3 active
+     *                                      2: Both MD1 and MD3 active
+     * @param remoteSimProtocol MD3 decide to access SIM from which protocl of MD1
+     *                          0: MD3 access local card
+     *                          1: MD1 access MD1's SIM task1
+     *                          2: MD1 access MD1's SIM task2
+     * @param result callback message
+     */
+    void configModemStatus(int modemStatus, int remoteSimProtocol, Message result);
+
+    /**
+     * Disconnect RIL socket. For SVLTE C2K only mode to disable LTE functions.
+     */
+    void disconnectRilSocket();
+
+    /**
+     * Reconnect RIL socket.
+     */
+    void connectRilSocket();
+
+    /* C2k part end */
+    /**
+     * C2K SVLTE CDMA eHPRD control.
+     * Used to turn on/off eHPRD.
+     * @param evdoMode The mode set to MD3: 0: turn off eHPRD.
+     *                                      1: turn on eHPRD.
+     * @param result callback message
+     */
+    void configEvdoMode(int evdoMode, Message result);
+    /* C2k part end */
+
+    void setBandMode(int[] bandMode, Message response);
+
+    public void registerForAbnormalEvent(Handler h, int what, Object obj);
+
+    public void unregisterForAbnormalEvent(Handler h);
+
+    /**
+      * Rregister for cdma card type.
+      * @param h Handler for network information messages.
+      * @param what User-defined message code.
+      * @param obj User object.
+      */
+    void registerForCdmaCardType(Handler h, int what, Object obj);
+
+    /**
+      * Rregister for cdma card type.
+      * @param h Handler for network information messages.
+      */
+    void unregisterForCdmaCardType(Handler h);
+
+    /// M: [C2K] for eng mode start
+    /**
+     * M: Rregister on network information for eng mode.
+     * @param h Handler for network information messages.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForEngModeNetworkInfo(Handler h, int what, Object obj);
+
+    /**
+     * M: Unrregister on network information for eng mode.
+     * @param h Handler for network information messages.
+     */
+    void unregisterForEngModeNetworkInfo(Handler h);
+    /// M: [C2K] for eng mode end
+
+    /**
+     * M: return display state to RILD
+     *
+     */
+    public int getDisplayState();
+
+    /**
+     *  Query operator name from network
+     * @param subId
+     *          Indicates subscription 0 or subscription 1.
+     * @param numeric for operator numeric
+     * @param desireLongName
+     *          Indicates longname or shortname
+     */
+    public String lookupOperatorNameFromNetwork(long subId, String numeric, boolean desireLongName);
+
+    /* M: IMS VoLTE conference dial feature start*/
+    /**
+     * Dial conference call.
+     * @param participants participants' dailing number.
+     * @param clirMode indication to present the dialing number or not.
+     * @param isVideoCall indicate the call is belong to video call or voice call.
+     * @param result the command result.
+     */
+    void conferenceDial(String[] participants, int clirMode, boolean isVideoCall, Message result);
+    /* IMS VoLTE conference dial feature end*/
+
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @{
+    /**
+     * Register for GMSS RAT.
+     * When boot the phone,AP can use this informaiton decide PS' type(LTE or C2K).
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForGmssRatChanged(Handler h, int what, Object obj);
+
+    /**
+     * Unregister GMSS RAT get GMSS RAT.
+     * When boot the phone,AP can use this informaiton decide PS' type(LTE or C2K).
+     * @param h Handler for notification message.
+     */
+    void unregisterForGmssRatChanged(Handler h);
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @}
+
+    /// M: [C2K] for ps type changed. @{
+    /**
+     * Register for ps type changed.
+     * @param h Handler for ps type change messages.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForDataNetworkTypeChanged(Handler h, int what, Object obj);
+
+    /**
+     * Unregister for ps type changed.
+     * @param h Handler for ps type change messages.
+     */
+    void unregisterForDataNetworkTypeChanged(Handler h);
+    /// @}
+
+    /// [C2K][IRAT] start @{
+    /**
+     * M: Fires on any change in inter-3GPP IRAT status change.
+     * @param h Handler for IRAT status change messages.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForIratStateChanged(Handler h, int what, Object obj);
+
+    /**
+     * M: Unregister for inter-3GPP IRAT status change event.
+     * @param h Handler for IRAT status change messages
+     */
+    void unregisterForIratStateChanged(Handler h);
+
+    /**
+     * M: Confirm inter-3GPP IRAT change, MD will perform IRAT process after
+     * receive this command, AP need to make sure to suspend all PS requests
+     * before call this function.
+     * @param apDecision The decision of AP, need to be 1(accept) currently.
+     * @param response A callback message with the String response in the obj field
+     */
+    void confirmIratChange(int apDecision, Message response);
+
+    /**
+     * M: Set PS active slot for Gemini LTE dual connection project, send
+     * ATEACTS=slotId to MD, the request can only send by main protocol.
+     * @param psSlot Slot to be used for data connection.
+     * @param response A callback message with the String response in the obj field
+     */
+    void requestSetPsActiveSlot(int psSlot, Message response);
+
+    /**
+     * Sync notify data call list after IRAT finished.
+     * @param dcList Data call list.
+     */
+    void syncNotifyDataCallList(AsyncResult dcList);
+    /// }@
+
+    /**
+     * Request to deactivate link down PDN to release IP address.
+     * @param response callback message.
+     */
+    void requestDeactivateLinkDownPdn(Message response);
+
+    /**
+     * Register for CDMA imsi ready.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    public void registerForCdmaImsiReady(Handler h, int what, Object obj);
+
+    /**
+     * Unregister for CDMA imsi ready.
+     * @param h Handler for notification message.
+     */
+    public void unregisterForCdmaImsiReady(Handler h);
+
+    /**
+      * Register for imsi refresh done.
+      * @param h Handler for notification message.
+      * @param what User-defined message code.
+      * @param obj User object.
+      */
+    public void registerForImsiRefreshDone(Handler h, int what, Object obj);
+    /**
+      * Unregister for imsi refresh done.
+      * @param h Handler for notification message.
+      */
+    public void unregisterForImsiRefreshDone(Handler h) ;
+
+    /**
+      * To get RadioCapability stored in RILJ when phone object is not created
+      */
+    public RadioCapability getBootupRadioCapability();
+
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @{
+    /**
+     * M: Request to set the SVLTE Mode (SVLTE_4G or SVLTE_3G or LTE_TDD_DATA_ONLY).
+     *
+     * @param radioTechMode The radio teck mode.
+     * @param preSvlteMode The previous rat mode.
+     * @param svlteMode The rat mode.
+     * @param preRoamingMode The previous roaming mode.
+     * @param roamingMode The roaming mode.
+     * @param is3GDualModeCard Whether the SIM card is 3g dual mode card or not.
+     * @param response A callback message with the String response in the obj field.
+     */
+    void setSvlteRatMode(int radioTechMode, int preSvlteMode, int svlteMode,
+            int preRoamingMode, int roamingMode, boolean is3GDualModeCard, Message response);
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @}
+
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @{
+    /**
+     * M: Request to set the STK/UTK Mode
+     *
+     * @param stkUtkMode the target STK/UTK mode
+     * @param response A callback message with the String response in the obj field.
+     */
+    void setStkUtkMode(int stkUtkMode, Message response);
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @}
+
+    /// M: [C2K][SVLTE] Update RIL instance id for SVLTE switch ActivePhone. @{
+    /**
+     * M: For SVLTE to update RIL instance id.
+     * @param instanceId The new instance Id.
+     */
+    void setInstanceId(int instanceId);
+    /// @}
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @{
+
+    /**
+     * Set GSM modem to suspend network registration.
+     * @param enabled True to pause and false to resume.
+     * @param response the responding message.
+     */
+    void setRegistrationSuspendEnabled(int enabled, Message response);
+
+    /**
+     * Request GSM modem to resume network registration.
+     * @param sessionId the session index.
+     * @param response the responding message.
+     */
+    void setResumeRegistration(int sessionId, Message response);
+
+    /**
+     * Set GSM modem to suspend network registration.
+     * @param enabled True to pause and false to resume.
+     * @param response the responding message.
+     */
+    void setCdmaRegistrationSuspendEnabled(boolean enabled, Message response);
+
+    /**
+     * Request C2K modem to resume network registration.
+     * @param response the responding message.
+     */
+    void setResumeCdmaRegistration(Message response);
+
+    /**
+     * Register for mcc and mnc change.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForMccMncChange(Handler h, int what, Object obj);
+
+    /**
+     * Unregister for mcc and mnc change.
+     * @param h Handler for notification message.
+     */
+    void unregisterForMccMncChange(Handler h);
+
+    /**
+     * Set the xTK mode.
+     * @param mode The xTK mode.
+     */
+    void setStkSwitchMode(int mode);
+
+    /**
+     * Set the UTK Bip Ps type .
+     * @param mBipPsType The Bip type.
+     */
+    void setBipPsType(int type);
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+    /**
+     * Register for Signal Fade notification.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnCdmaSignalFade(Handler h, int what, Object obj);
+
+    /**
+     * Unregister for Signal Fade notification.
+     * @param h Handler for notification message.
+     */
+    void unSetOnCdmaSignalFade(Handler h);
+
+    /**
+     * Register for Tone Signal message.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void setOnCdmaToneSignal(Handler h, int what, Object obj);
+
+    /**
+     * Unregister for Tone Signal message.
+     * @param h Handler for notification message.
+     */
+    void unSetOnCdmaToneSignal(Handler h);
+
+    /**
+     * Switch antenna.
+     * @param callState call state, 0 means call disconnected and 1 means call established.
+     * @param ratMode RAT mode, 0 means GSM and 7 means C2K.
+     */
+    void switchAntenna(int callState, int ratMode);
+
+    /**
+     * Switch RUIM card to SIM or switch SIM to RUIM.
+     * @param cardtype that to be switched.
+     */
+    void switchCardType(int cardtype);
+
+    /**
+     * Enable or disable MD3 Sleep.
+     * @param enable MD3 sleep.
+     */
+    void enableMd3Sleep(int enable);
+
+    /**
+     * Register for network exsit or not for ECC only.
+     * @param h Handler for notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    void registerForNetworkExsit(Handler h, int what, Object obj);
+
+    /**
+     * Unregister for network exsit.
+     * @param h Handler for notification message.
+     */
+    void unregisterForNetworkExsit(Handler h);
+
     /**
      * Start LCE (Link Capacity Estimation) service with a desired reporting interval.
      *
diff --git a/src/java/com/android/internal/telephony/DriverCall.java b/src/java/com/android/internal/telephony/DriverCall.java
index a923d8f..3006460 100644
--- a/src/java/com/android/internal/telephony/DriverCall.java
+++ b/src/java/com/android/internal/telephony/DriverCall.java
@@ -51,6 +51,15 @@
     public int namePresentation;
     public UUSInfo uusInfo;
 
+    /// M: Add for IMS conference call. @{
+    public int     callMode;
+    public String  pau;
+    /// @}
+
+    /// M: For 3G VT only @{
+    public boolean isVideo;
+    /// @}
+
     /** returns null on error */
     static DriverCall
     fromCLCCLine(String line) {
@@ -66,6 +75,10 @@
             ret.state = stateFromCLCC(p.nextInt());
 
             ret.isVoice = (0 == p.nextInt());
+            /// M: For 3G VT only @{
+            // callmode: 0(voice), 10(video)
+            ret.isVideo = (10 == p.nextInt());
+            /// @}
             ret.isMpty = p.nextBoolean();
 
             // use ALLOWED as default presentation while parsing CLCC
@@ -111,6 +124,14 @@
                 + (isMT ? "mt" : "mo") + ","
                 + als + ","
                 + (isVoice ? "voc" : "nonvoc") + ","
+                /// M: For 3G VT only @{
+                + (isVideo ? "vid" : "nonvid") + ","
+                /// @}
+                + (isVoicePrivacy ? "evp" : "noevp") + ","
+                /*+ "number=" + number */ + ",cli=" + numberPresentation + ","
+                /*+ "name="+ name */ + "," + namePresentation;
+                /*+ "name="+ name */ + "," + namePresentation + ","
+                + callMode;
                 + (isVoicePrivacy ? "evp" : "noevp") + ","
                 /*+ "number=" + number */ + ",cli=" + numberPresentation + ","
                 /*+ "name="+ name */ + "," + namePresentation;
diff --git a/src/java/com/android/internal/telephony/IccCard.java b/src/java/com/android/internal/telephony/IccCard.java
index e5b34e2..640adf6 100644
--- a/src/java/com/android/internal/telephony/IccCard.java
+++ b/src/java/com/android/internal/telephony/IccCard.java
@@ -21,6 +21,7 @@
 
 import com.android.internal.telephony.IccCardConstants.State;
 import com.android.internal.telephony.uicc.IccCardApplicationStatus;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.PersoSubState;
 import com.android.internal.telephony.uicc.IccFileHandler;
 import com.android.internal.telephony.uicc.IccRecords;
 
@@ -231,4 +232,102 @@ public void changeIccFdnPassword(String oldPassword, String newPassword,
      * @return true if ICC card is PUK2 blocked
      */
     public boolean getIccPuk2Blocked();
+
+    // MTK
+
+    /**
+     * Supply Network depersonalization code to the RIL
+     */
+    public void supplyNetworkDepersonalization (String pin, Message onComplete);
+
+    /**
+     * Use to query the network lock type.
+     *
+     * @return the network lock type define in IccCardApplicationStatus.PersoSubState
+     *
+     * @internal
+     */
+    public PersoSubState getNetworkPersoType();
+
+    /**
+     * Use to query indicated category's ME lock status
+     *
+     * @param category 0:Network, 1:Network subset, 2:Service Provider, 3: Corporate, 4:SIM
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     *
+     * @return the network lock type define in IccCardApplicationStatus.PersoSubState
+     *
+     * @internal
+     */
+    public void queryIccNetworkLock(int category, Message onComplete);
+
+    /**
+     * Use to set indicated category's ME lock status
+     *
+     * @param category 0:Network, 1:Network subset, 2:Service Provider, 3: Corporate, 4:SIM
+     * @param lockop 0: Unlock, 1: Lock, 2:Add, 3:Remove, 4:Permanently unlock
+     * @param password password of indicated category lock
+     * @param data_imsi IMSI
+     * @param gid1 GID1 value
+     * @param gid2 GID2 value
+     * @param onComplete
+     *        onComplete.obj will be an AsyncResult
+     *        ((AsyncResult)onComplete.obj).exception == null on success
+     *        ((AsyncResult)onComplete.obj).exception != null on fail
+     *
+     * @return the network lock type define in IccCardApplicationStatus.PersoSubState
+     *
+     * @internal
+     */
+    public void setIccNetworkLockEnabled(int category,
+            int lockop, String password, String data_imsi, String gid1, String gid2, Message onComplete);
+
+    /**
+     * Use to repolling icc card status (Used by SIM ME lock related enhancement feature)
+     *
+     * @param needIntent indicated need an Intent to notify needed to unlock another SIM or not.
+     *                   if yes, will broadcast TelephonyIntents.ACTION_UNLOCK_SIM_LOCK to notify.
+     *                   if no, will notify by original TelephonyIntents.ACTION_SIM_STATE_CHANGED.
+     */
+    public void repollIccStateForModemSmlChangeFeatrue(boolean needIntent);
+
+    /**
+     * NFC API, use to exchange SIM IO.
+     *
+     * @internal
+     */
+    public void exchangeSimIo(int fileID, int command,
+                                           int p1, int p2, int p3, String pathID, String data, String pin2, Message onComplete);
+
+    /**
+     * NFC API, use to get ATR.
+     *
+     * @internal
+     */
+    public void iccGetAtr(Message onComplete);
+
+    public String getIccCardType();
+    // MTK-START
+    /**
+     * Request to get UICC card type.
+     *
+     * @return index for UICC card type
+     *
+     */
+    public int getSvlteCardType();
+    // MTK-END
+     /**
+     * NFC API, use to open logical channel with sw.
+     *
+     * @internal
+     */
+    public void openLogicalChannelWithSw(String AID, Message onComplete);
+    /**
+     * Notifies handler in case of FDN changed
+     */
+    public void registerForFdnChanged(Handler h, int what, Object obj);
+    public void unregisterForFdnChanged(Handler h);
 }
diff --git a/src/java/com/android/internal/telephony/MediaTekRIL.java b/src/java/com/android/internal/telephony/MediaTekRIL.java
new file mode 100644
index 0000000..6c70bd3
--- /dev/null
+++ b/src/java/com/android/internal/telephony/MediaTekRIL.java
@@ -0,0 +1,5328 @@
+/*
+ * Copyright (C) 2014 The OmniROM Project <http://www.omnirom.org>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_UNKNOWN;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_EDGE;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_GPRS;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_UMTS;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSDPA;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSUPA;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSPA;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.LocalSocket;
+import android.net.LocalSocketAddress;
+import android.os.AsyncResult;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.PowerManager;
+import android.os.SystemProperties;
+import android.text.TextUtils;
+import android.telephony.ModemActivityInfo;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.RadioAccessFamily;
+import android.telephony.Rlog;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.view.Display;
+
+import java.io.UnsupportedEncodingException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Vector;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import com.android.internal.telephony.uicc.IccRecords;
+import com.android.internal.telephony.uicc.IccRefreshResponse;
+import com.android.internal.telephony.uicc.SIMRecords;
+import com.android.internal.telephony.uicc.SpnOverride;
+import com.android.internal.telephony.uicc.UiccController;
+
+import com.mediatek.internal.telephony.FemtoCellInfo;
+import com.mediatek.internal.telephony.IccSmsStorageStatus;
+import com.mediatek.internal.telephony.NetworkInfoWithAcT;
+import com.mediatek.internal.telephony.SrvccCallContext;
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+import com.mediatek.internal.telephony.dataconnection.IaExtendParam;
+import com.mediatek.internal.telephony.ltedc.svlte.SvlteUtils;
+import com.mediatek.internal.telephony.worldphone.WorldMode;
+
+
+public class MediaTekRIL extends RIL implements CommandsInterface {
+
+    private static final String  PROPERTY_RIL_CARD_TYPE_SET = "gsm.ril.cardtypeset";
+    private static final String  PROPERTY_RIL_CARD_TYPE_SET_2 = "gsm.ril.cardtypeset.2";
+    private static final String  PROPERTY_NET_CDMA_MDMSTAT = "net.cdma.mdmstat";
+    private static final int INITIAL_RETRY_INTERVAL_MSEC = 200;
+    private static final String  PROPERTY_CONFIG_EMDSTATUS_SEND = "ril.cdma.emdstatus.send";
+
+    /* ALPS00799783: for restore previous preferred network type when set type fail */
+    private int mPreviousPreferredType = -1;
+
+    /// M: C2K RILD socket name definition
+    static final String C2K_SOCKET_NAME_RIL = "rild-via";
+
+    private static final String[]  PROPERTY_RIL_FULL_UICC_TYPE = {
+        "gsm.ril.fulluicctype",
+        "gsm.ril.fulluicctype.2",
+        "gsm.ril.fulluicctype.3",
+        "gsm.ril.fulluicctype.4",
+    };
+    private static final int CARD_TYPE_SIM  = 1;
+    private static final int CARD_TYPE_USIM = 2;
+    private static final int CARD_TYPE_CSIM = 4;
+    private static final int CARD_TYPE_RUIM = 8;
+
+    /// M: CC009: DTMF request special handling @{
+    /* DTMF request will be ignored when duplicated sending */
+    private class dtmfQueueHandler {
+
+        public dtmfQueueHandler() {
+            mDtmfStatus = DTMF_STATUS_STOP;
+        }
+
+        public void start() {
+            mDtmfStatus = DTMF_STATUS_START;
+        }
+
+        public void stop() {
+            mDtmfStatus = DTMF_STATUS_STOP;
+        }
+
+        public boolean isStart() {
+            return (mDtmfStatus == DTMF_STATUS_START);
+        }
+
+        public void add(RILRequest o) {
+            mDtmfQueue.addElement(o);
+        }
+
+        public void remove(RILRequest o) {
+            mDtmfQueue.remove(o);
+        }
+
+        public void remove(int idx) {
+            mDtmfQueue.removeElementAt(idx);
+        }
+
+        public RILRequest get() {
+            return (RILRequest) mDtmfQueue.get(0);
+        }
+
+        public int size() {
+            return mDtmfQueue.size();
+        }
+
+        public void setPendingRequest(RILRequest r) {
+            mPendingCHLDRequest = r;
+        }
+
+        public RILRequest getPendingRequest() {
+            return mPendingCHLDRequest;
+        }
+
+        public void setSendChldRequest() {
+            mIsSendChldRequest = true;
+        }
+
+        public void resetSendChldRequest() {
+            mIsSendChldRequest = false;
+        }
+
+        public boolean hasSendChldRequest() {
+            riljLog("mIsSendChldRequest = " + mIsSendChldRequest);
+            return mIsSendChldRequest;
+        }
+
+        public final int MAXIMUM_DTMF_REQUEST = 32;
+        private final boolean DTMF_STATUS_START = true;
+        private final boolean DTMF_STATUS_STOP = false;
+
+        private boolean mDtmfStatus = DTMF_STATUS_STOP;
+        private Vector mDtmfQueue = new Vector(MAXIMUM_DTMF_REQUEST);
+
+        private RILRequest mPendingCHLDRequest = null;
+        private boolean mIsSendChldRequest = false;
+    }
+
+    private dtmfQueueHandler mDtmfReqQueue = new dtmfQueueHandler();
+    /// @}
+
+    public MediaTekRIL(Context context, int networkMode, int cdmaSubscription) {
+            super(context, networkMode, cdmaSubscription, null);
+    }
+
+    public MediaTekRIL(Context context, int networkMode, int cdmaSubscription, Integer instanceId) {
+            super(context, networkMode, cdmaSubscription, instanceId);
+    }
+
+    // all that C&P just for responseOperator overriding?
+    @Override
+    protected RILRequest
+    processSolicited (Parcel p) {
+        int serial, error;
+        boolean found = false;
+
+        serial = p.readInt();
+        error = p.readInt();
+
+        RILRequest rr;
+
+        rr = findAndRemoveRequestFromList(serial);
+
+        if (rr == null) {
+            Rlog.w(RILJ_LOG_TAG, "Unexpected solicited response! sn: "
+                            + serial + " error: " + error);
+            return null;
+        }
+
+        /// M: CC012: DTMF request special handling @{
+        /* DTMF request will be ignored when the count of requests reaches 32 */
+        if ((rr.mRequest == RIL_REQUEST_DTMF_START) ||
+            (rr.mRequest == RIL_REQUEST_DTMF_STOP)) {
+            synchronized (mDtmfReqQueue) {
+                mDtmfReqQueue.remove(rr);
+                riljLog("remove first item in dtmf queue done, size = " + mDtmfReqQueue.size());
+                if (mDtmfReqQueue.size() > 0) {
+                    RILRequest rr2 = mDtmfReqQueue.get();
+                    if (RILJ_LOGD) riljLog(rr2.serialString() + "> " + requestToString(rr2.mRequest));
+                    send(rr2);
+                } else {
+                    if (mDtmfReqQueue.getPendingRequest() != null) {
+                        riljLog("send pending switch request");
+                        send(mDtmfReqQueue.getPendingRequest());
+                        mDtmfReqQueue.setSendChldRequest();
+                        mDtmfReqQueue.setPendingRequest(null);
+                    }
+                }
+            }
+        }
+        /// @}
+        Object ret = null;
+
+        if ((rr.mRequest == RIL_REQUEST_QUERY_AVAILABLE_NETWORKS) ||
+            (rr.mRequest == RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT)) {
+            mGetAvailableNetworkDoneRegistrant.notifyRegistrants();
+        }
+
+        /* ALPS00799783 START */
+        if (rr.mRequest == RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE) {
+            if ((error != 0) && (mPreviousPreferredType != -1)) {
+                riljLog("restore mPreferredNetworkType from " + mPreferredNetworkType + " to " + mPreviousPreferredType);
+                mPreferredNetworkType = mPreviousPreferredType;
+            }
+            mPreviousPreferredType = -1; //reset
+        }
+        /* ALPS00799783 END */
+
+        /// M: CC012: DTMF request special handling @{
+        if (rr.mRequest == RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE ||
+            rr.mRequest == RIL_REQUEST_CONFERENCE ||
+            rr.mRequest == RIL_REQUEST_SEPARATE_CONNECTION ||
+            rr.mRequest == RIL_REQUEST_EXPLICIT_CALL_TRANSFER) {
+            riljLog("clear mIsSendChldRequest");
+            mDtmfReqQueue.resetSendChldRequest();
+        }
+        /// @}
+
+        if (error == 0 || p.dataAvail() > 0) {
+
+            /* Convert RIL_REQUEST_GET_MODEM_VERSION back */
+            if (SystemProperties.get("ro.cm.device").indexOf("e73") == 0 &&
+                  rr.mRequest == 220) {
+                rr.mRequest = RIL_REQUEST_BASEBAND_VERSION;
+            }
+
+            // either command succeeds or command fails but with data payload
+            try {switch (rr.mRequest) {
+            /*
+ cat libs/telephony/ril_commands.h \
+ | egrep "^ *{RIL_" \
+ | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
+             */
+            case RIL_REQUEST_GET_SIM_STATUS: ret =  responseIccCardStatus(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK2: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_CURRENT_CALLS: ret =  responseCallList(p); break;
+            case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMSI: ret =  responseString(p); break;
+            case RIL_REQUEST_HANGUP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: {
+                if (mTestingEmergencyCall.getAndSet(false)) {
+                    if (mEmergencyCallbackModeRegistrant != null) {
+                        riljLog("testing emergency call, notify ECM Registrants");
+                        mEmergencyCallbackModeRegistrant.notifyRegistrant();
+                    }
+                }
+                ret =  responseVoid(p);
+                break;
+            }
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CONFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_UDUB: ret =  responseVoid(p); break;
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: ret =  responseFailCause(p); break;
+            case RIL_REQUEST_SIGNAL_STRENGTH: ret =  responseSignalStrength(p); break;
+            case RIL_REQUEST_VOICE_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_DATA_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_OPERATOR: ret =  responseOperator(p); break;
+            case RIL_REQUEST_RADIO_POWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SETUP_DATA_CALL: ret =  responseSetupDataCall(p); break;
+            case RIL_REQUEST_SIM_IO: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CLIR: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: ret =  responseCallForward(p); break;
+            case RIL_REQUEST_SET_CALL_FORWARD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_WAITING: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CALL_WAITING: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMEI: ret =  responseString(p); break;
+            case RIL_REQUEST_GET_IMEISV: ret =  responseString(p); break;
+            case RIL_REQUEST_ANSWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: ret = responseVoid(p); break; //VoLTE
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : ret =  responseOperatorInfos(p); break;
+            case RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_START: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_STOP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_BASEBAND_VERSION: ret =  responseString(p); break;
+            case RIL_REQUEST_SEPARATE_CONNECTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_MUTE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_MUTE: ret =  responseInts(p); break;
+            case RIL_REQUEST_QUERY_CLIP: ret =  responseInts(p); break;
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_DATA_CALL_LIST: ret =  responseDataCallList(p); break;
+            case RIL_REQUEST_RESET_RADIO: ret =  responseVoid(p); break;
+            case RIL_REQUEST_OEM_HOOK_RAW: ret =  responseRaw(p); break;
+            case RIL_REQUEST_OEM_HOOK_STRINGS: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SCREEN_STATE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_BAND_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_STK_GET_PROFILE: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SET_PROFILE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: ret = responseSetPreferredNetworkType(p); break;
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: ret = responseGetPreferredNetworkType(p); break;
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: ret = responseCellList(p); break;
+            case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_TTY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_TTY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_FLASH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BURST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: ret =  responseGmsBroadcastConfig(p); break;
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: ret =  responseCdmaBroadcastConfig(p); break;
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: ret =  responseStrings(p); break;
+            /*ret = responseInts(p);RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM modify for UIM sms cache*/
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: ret =  responseStrings(p); break;
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEVICE_IDENTITY: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GET_SMSC_ADDRESS: ret = responseString(p); break;
+            case RIL_REQUEST_SET_SMSC_ADDRESS: ret = responseVoid(p); break;
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: ret = responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_ISIM_AUTHENTICATION:
+                if (SystemProperties.get("ro.mtk_tc1_feature").equals("1"))
+                    ret =  responseStringEncodeBase64(p);
+                else
+                    ret =  responseString(p);
+                break;
+            case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU: ret = responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS: ret = responseICC_IO(p); break;
+            case RIL_REQUEST_VOICE_RADIO_TECH: ret = responseInts(p); break;
+            case RIL_REQUEST_GET_CELL_INFO_LIST: ret = responseCellInfoList(p); break;
+            case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_INITIAL_ATTACH_APN: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_DATA_PROFILE: ret = responseVoid(p); break;
+            case RIL_REQUEST_IMS_REGISTRATION_STATE: ret = responseInts(p); break;
+            case RIL_REQUEST_IMS_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SIM_OPEN_CHANNEL: ret  = responseInts(p); break;
+            case RIL_REQUEST_SIM_CLOSE_CHANNEL: ret  = responseVoid(p); break;
+            case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL: ret = responseICC_IO(p); break;
+            case RIL_REQUEST_NV_READ_ITEM: ret = responseString(p); break;
+            case RIL_REQUEST_NV_WRITE_ITEM: ret = responseVoid(p); break;
+            case RIL_REQUEST_NV_WRITE_CDMA_PRL: ret = responseVoid(p); break;
+            case RIL_REQUEST_NV_RESET_CONFIG: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_UICC_SUBSCRIPTION: ret = responseVoid(p); break;
+            case RIL_REQUEST_ALLOW_DATA: ret = responseVoid(p); break;
+            case RIL_REQUEST_GET_HARDWARE_CONFIG: ret = responseHardwareConfig(p); break;
+            case RIL_REQUEST_SIM_AUTHENTICATION: ret =  responseICC_IOBase64(p); break;
+            case RIL_REQUEST_SHUTDOWN: ret = responseVoid(p); break;
+            case RIL_REQUEST_GET_RADIO_CAPABILITY: ret =  responseRadioCapability(p); break;
+            case RIL_REQUEST_SET_RADIO_CAPABILITY: ret =  responseRadioCapability(p); break;
+            /// M: CC010: Add RIL interface @{
+            case RIL_REQUEST_HANGUP_ALL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_FORCE_RELEASE_CALL: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_CALL_INDICATION: ret = responseVoid(p); break;
+            case RIL_REQUEST_EMERGENCY_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_ECC_SERVICE_CATEGORY: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_ECC_LIST: ret = responseVoid(p); break;
+            /// @}
+            /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+            case RIL_REQUEST_SET_SPEECH_CODEC_INFO: ret = responseVoid(p); break;
+            /// @}
+            /// M: For 3G VT only @{
+            case RIL_REQUEST_VT_DIAL: ret = responseVoid(p); break;
+            case RIL_REQUEST_VOICE_ACCEPT: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPLACE_VT_CALL: ret = responseVoid(p); break;
+            /// @}
+            /// M: IMS feature. @{
+            case RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER: responseString(p); break;
+            case RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER: responseString(p); break;
+            case RIL_REQUEST_DIAL_WITH_SIP_URI: ret = responseVoid(p); break;
+            case RIL_REQUEST_RESUME_CALL: ret = responseVoid(p); break;
+            case RIL_REQUEST_HOLD_CALL: ret = responseVoid(p); break;
+            /// @}
+
+            //MTK-START SS
+            case RIL_REQUEST_GET_COLP: ret = responseInts(p); break;
+            case RIL_REQUEST_SET_COLP: ret = responseVoid(p); break;
+            case RIL_REQUEST_GET_COLR: ret = responseInts(p); break;
+            //MTK-END SS
+
+            //MTK-START SIM ME lock
+            case RIL_REQUEST_QUERY_SIM_NETWORK_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_SIM_NETWORK_LOCK: ret =  responseInts(p); break;
+            //MTK-END SIM ME lock
+            //MTK-START multiple application support
+            case RIL_REQUEST_GENERAL_SIM_AUTH: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_OPEN_ICC_APPLICATION: ret = responseInts(p); break;
+            case RIL_REQUEST_GET_ICC_APPLICATION_STATUS: ret = responseIccCardStatus(p); break;
+            //MTK-END multiple application support
+            case RIL_REQUEST_SIM_IO_EX: ret =  responseICC_IO(p); break;
+            // PHB Start
+            case RIL_REQUEST_QUERY_PHB_STORAGE_INFO: ret = responseInts(p); break;
+            case RIL_REQUEST_WRITE_PHB_ENTRY: ret = responseVoid(p); break;
+            case RIL_REQUEST_READ_PHB_ENTRY: ret = responsePhbEntries(p); break;
+            case RIL_REQUEST_QUERY_UPB_CAPABILITY: ret = responseInts(p); break;
+            case RIL_REQUEST_READ_UPB_GRP: ret = responseInts(p); break;
+            case RIL_REQUEST_WRITE_UPB_GRP: ret = responseVoid(p); break;
+            case RIL_REQUEST_EDIT_UPB_ENTRY: ret = responseVoid(p); break;
+            case RIL_REQUEST_DELETE_UPB_ENTRY: ret = responseVoid(p); break;
+            case RIL_REQUEST_READ_UPB_GAS_LIST: ret = responseStrings(p); break;
+            case RIL_REQUEST_GET_PHB_STRING_LENGTH: ret = responseInts(p); break;
+            case RIL_REQUEST_GET_PHB_MEM_STORAGE : ret = responseGetPhbMemStorage(p); break;
+            case RIL_REQUEST_SET_PHB_MEM_STORAGE : responseVoid(p); break;
+            case RIL_REQUEST_READ_PHB_ENTRY_EXT: ret = responseReadPhbEntryExt(p); break;
+            case RIL_REQUEST_WRITE_PHB_ENTRY_EXT: ret = responseVoid(p); break;
+            // PHB End
+
+
+            /* M: network part start */
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_POL_CAPABILITY: ret = responseInts(p); break;
+            case RIL_REQUEST_GET_POL_LIST: ret = responseNetworkInfoWithActs(p); break;
+            case RIL_REQUEST_SET_POL_ENTRY: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_TRM: ret = responseInts(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT : ret =  responseOperatorInfosWithAct(p); break;
+            case RIL_REQUEST_STK_EVDL_CALL_BY_AP: ret = responseVoid(p); break;
+
+            //Femtocell (CSG) feature START
+            case RIL_REQUEST_GET_FEMTOCELL_LIST: ret = responseFemtoCellInfos(p); break;
+            case RIL_REQUEST_ABORT_FEMTOCELL_LIST: ret = responseVoid(p); break;
+            case RIL_REQUEST_SELECT_FEMTOCELL: ret = responseVoid(p); break;
+            //Femtocell (CSG) feature END
+            /* M: network part end */
+
+            case RIL_REQUEST_QUERY_MODEM_TYPE: ret = responseInts(p); break;
+            case RIL_REQUEST_STORE_MODEM_TYPE: ret = responseVoid(p); break;
+
+            // IMS
+            case RIL_REQUEST_SET_IMS_ENABLE: ret = responseVoid(p); break;
+            case RIL_REQUEST_SIM_GET_ATR: ret = responseString(p); break;
+            // M: Fast Dormancy
+            case RIL_REQUEST_SET_SCRI: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_FD_MODE: ret = responseInts(p); break;
+
+            // MTK-START, SMS part
+            case RIL_REQUEST_GET_SMS_PARAMS: ret = responseSmsParams(p); break;
+            case RIL_REQUEST_SET_SMS_PARAMS: ret = responseVoid(p); break;
+            case RIL_REQUEST_GET_SMS_SIM_MEM_STATUS: ret = responseSimSmsMemoryStatus(p); break;
+            case RIL_REQUEST_SET_ETWS: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO: ret = responseVoid(p); break;
+            case RIL_REQUEST_GET_CB_CONFIG_INFO: ret = responseCbConfig(p); break;
+            case RIL_REQUEST_REMOVE_CB_MESSAGE: ret = responseVoid(p); break;
+            // MTK-END, SMS part
+            case RIL_REQUEST_SET_DATA_CENTRIC: ret = responseVoid(p); break;
+
+            /// M: SVLTE Remove access feature
+            case RIL_REQUEST_CONFIG_MODEM_STATUS: ret = responseVoid(p); break;
+
+            // M: CC33 LTE.
+            case RIL_REQUEST_SET_DATA_ON_TO_MD: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE: ret = responseVoid(p); break;
+
+            case RIL_REQUEST_BTSIM_CONNECT: ret = responseString(p); break;
+            case RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF: ret = responseVoid(p); break;
+            case RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM: ret = responseString(p); break;
+            case RIL_REQUEST_BTSIM_TRANSFERAPDU: ret = responseString(p); break;
+
+            /// M: IMS VoLTE conference dial feature. @{
+            case RIL_REQUEST_CONFERENCE_DIAL: ret =  responseVoid(p); break;
+            /// @}
+            case RIL_REQUEST_RELOAD_MODEM_TYPE: ret =  responseVoid(p); break;
+            /// M: CC010: Add RIL interface @{
+            case RIL_REQUEST_SET_IMS_CALL_STATUS: ret = responseVoid(p); break;
+            /// @}
+
+            /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+            case RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER: ret = responseVoid(p); break;
+            case RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS: ret = responseVoid(p); break;
+            /// @}
+
+            /* M: C2K part start */
+            case RIL_REQUEST_GET_NITZ_TIME: ret = responseGetNitzTime(p); break;
+            case RIL_REQUEST_QUERY_UIM_INSERTED: ret = responseInts(p); break;
+            case RIL_REQUEST_SWITCH_HPF: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_AVOID_SYS: ret = responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVOID_SYS: ret = responseInts(p); break;
+            case RIL_REQUEST_QUERY_CDMA_NETWORK_INFO: ret = responseStrings(p); break;
+            case RIL_REQUEST_GET_LOCAL_INFO: ret =  responseInts(p); break;
+            case RIL_REQUEST_UTK_REFRESH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS: ret = responseInts(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_REGISTRATION: ret = responseInts(p); break;
+            case RIL_REQUEST_AGPS_TCP_CONNIND: ret = responseVoid(p); break;
+            case RIL_REQUEST_AGPS_SET_MPC_IPPORT: ret = responseVoid(p); break;
+            case RIL_REQUEST_AGPS_GET_MPC_IPPORT: ret = responseStrings(p); break;
+            case RIL_REQUEST_SET_MEID: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_ETS_DEV: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_MDN: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_VIA_TRM: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_ARSI_THRESHOLD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_ACTIVE_PS_SLOT: ret = responseVoid(p); break;
+            case RIL_REQUEST_CONFIRM_INTER_3GPP_IRAT_CHANGE: ret = responseVoid(p); break;
+            case RIL_REQUEST_CONFIG_EVDO_MODE: ret = responseVoid(p); break;
+            case RIL_REQUEST_QUERY_UTK_MENU_FROM_MD: ret =  responseString(p); break;
+            case RIL_REQUEST_QUERY_STK_MENU_FROM_MD: ret =  responseString(p); break;
+            case RIL_REQUEST_DEACTIVATE_LINK_DOWN_PDN: ret = responseVoid(p); break;
+            /* M: C2K part end */
+
+            case RIL_REQUEST_MODEM_POWERON: ret =  responseVoid(p); break;
+            case RIL_REQUEST_MODEM_POWEROFF: ret =  responseVoid(p); break;
+
+            /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @{
+            case RIL_REQUEST_SET_SVLTE_RAT_MODE: ret =  responseVoid(p); break;
+            /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @}
+
+            /// M: [C2K][IR] Support SVLTE IR feature. @{
+            case RIL_REQUEST_SET_REG_SUSPEND_ENABLED: ret = responseVoid(p); break;
+            case RIL_REQUEST_RESUME_REGISTRATION: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_REG_SUSPEND_ENABLED_CDMA: ret =  responseVoid(p); break;
+            case RIL_REQUEST_RESUME_REGISTRATION_CDMA: ret =  responseVoid(p); break;
+            /// M: [C2K][IR] Support SVLTE IR feature. @}
+            case RIL_REQUEST_SET_STK_UTK_MODE: ret = responseVoid(p); break;
+
+            case RIL_REQUEST_SWITCH_ANTENNA: ret = responseVoid(p); break;
+            case RIL_REQUEST_START_LCE: ret = responseLceStatus(p); break;
+            case RIL_REQUEST_STOP_LCE: ret = responseLceStatus(p); break;
+            case RIL_REQUEST_PULL_LCEDATA: ret = responseLceData(p); break;
+            case RIL_REQUEST_GET_ACTIVITY_INFO: ret = responseActivityData(p); break;
+            case RIL_REQUEST_SWITCH_CARD_TYPE: ret = responseVoid(p); break;
+            case RIL_REQUEST_ENABLE_MD3_SLEEP: ret = responseVoid(p); break;
+
+            // M: [LTE][Low Power][UL traffic shaping] Start
+            case RIL_REQUEST_SET_LTE_ACCESS_STRATUM_REPORT: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_LTE_UPLINK_DATA_TRANSFER: ret = responseVoid(p); break;
+            // M: [LTE][Low Power][UL traffic shaping] End
+            default:
+                throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
+            //break;
+            }} catch (Throwable tr) {
+                // Exceptions here usually mean invalid RIL responses
+
+                Rlog.w(RILJ_LOG_TAG, rr.serialString() + "< "
+                        + requestToString(rr.mRequest)
+                        + " exception, possible invalid RIL response", tr);
+
+                if (rr.mResult != null) {
+                    AsyncResult.forMessage(rr.mResult, null, tr);
+                    rr.mResult.sendToTarget();
+                }
+                return rr;
+            }
+        }
+
+        if (rr.mRequest == RIL_REQUEST_SHUTDOWN) {
+            // Set RADIO_STATE to RADIO_UNAVAILABLE to continue shutdown process
+            // regardless of error code to continue shutdown procedure.
+            riljLog("Response to RIL_REQUEST_SHUTDOWN received. Error is " +
+                    error + " Setting Radio State to Unavailable regardless of error.");
+            setRadioState(RadioState.RADIO_UNAVAILABLE);
+        }
+
+        // Here and below fake RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, see b/7255789.
+        // This is needed otherwise we don't automatically transition to the main lock
+        // screen when the pin or puk is entered incorrectly.
+        switch (rr.mRequest) {
+            case RIL_REQUEST_ENTER_SIM_PUK:
+            case RIL_REQUEST_ENTER_SIM_PUK2:
+                if (mIccStatusChangedRegistrants != null) {
+                    if (RILJ_LOGD) {
+                        riljLog("ON enter sim puk fakeSimStatusChanged: reg count="
+                                + mIccStatusChangedRegistrants.size());
+                    }
+                    mIccStatusChangedRegistrants.notifyRegistrants();
+                }
+                break;
+        }
+
+        if (error != 0) {
+            switch (rr.mRequest) {
+                case RIL_REQUEST_ENTER_SIM_PIN:
+                case RIL_REQUEST_ENTER_SIM_PIN2:
+                case RIL_REQUEST_CHANGE_SIM_PIN:
+                case RIL_REQUEST_CHANGE_SIM_PIN2:
+                case RIL_REQUEST_SET_FACILITY_LOCK:
+                    if (mIccStatusChangedRegistrants != null) {
+                        if (RILJ_LOGD) {
+                            riljLog("ON some errors fakeSimStatusChanged: reg count="
+                                    + mIccStatusChangedRegistrants.size());
+                        }
+                        mIccStatusChangedRegistrants.notifyRegistrants();
+                    }
+                    break;
+                case RIL_REQUEST_GET_RADIO_CAPABILITY: {
+                    // Ideally RIL's would support this or at least give NOT_SUPPORTED
+                    // but the hammerhead RIL reports GENERIC :(
+                    // TODO - remove GENERIC_FAILURE catching: b/21079604
+                    if (REQUEST_NOT_SUPPORTED == error ||
+                            GENERIC_FAILURE == error) {
+                        // we should construct the RAF bitmask the radio
+                        // supports based on preferred network bitmasks
+                        ret = makeStaticRadioCapability();
+                        error = 0;
+                    }
+                    break;
+                }
+                case RIL_REQUEST_GET_ACTIVITY_INFO:
+                    ret = new ModemActivityInfo(0, 0, 0,
+                            new int [ModemActivityInfo.TX_POWER_LEVELS], 0, 0);
+                    error = 0;
+                    break;
+            }
+
+            rr.onError(error, ret);
+            return rr;
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "< " + requestToString(rr.mRequest)
+            + " " + retToString(rr.mRequest, ret));
+
+        if (rr.mResult != null) {
+            AsyncResult.forMessage(rr.mResult, ret, null);
+            rr.mResult.sendToTarget();
+        }
+
+        return rr;
+    }
+
+    @Override
+    protected void
+    processUnsolicited (Parcel p) {
+        Object ret;
+        int dataPosition = p.dataPosition(); // save off position within the Parcel
+        int response = p.readInt();
+
+        switch(response) {
+            // select AOSP unsols to process differently
+            /*
+            case RIL_UNSOL_STK_SESSION_END: ret = responseVoid(p); break;
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND: ret = responseString(p); break;
+            */
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RIL_CONNECTED: ret = responseInts(p); break;
+            // MTK unsols
+            case RIL_UNSOL_NEIGHBORING_CELL_INFO: ret = responseStrings(p); break;
+            case RIL_UNSOL_NETWORK_INFO: ret = responseStrings(p); break;
+            case RIL_UNSOL_NETWORK_EXIST: ret = responseInts(p); break;
+            case RIL_UNSOL_FEMTOCELL_INFO: ret = responseStrings(p); break;
+            case RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED: ret =  responseInts(p); break;
+            case RIL_UNSOL_INVALID_SIM:  ret = responseStrings(p); break;
+            case RIL_UNSOL_RESPONSE_ACMT: ret = responseInts(p); break;
+            case RIL_UNSOL_IMEI_LOCK: ret = responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_MMRR_STATUS_CHANGED: ret = responseInts(p); break;
+            case RIL_UNSOL_STK_EVDL_CALL: ret = responseInts(p); break;
+            case RIL_UNSOL_STK_CALL_CTRL: ret = responseStrings(p); break;
+
+            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED: ret =  responseInts(p); break;
+            case RIL_UNSOL_SRVCC_STATE_NOTIFY: ret = responseInts(p); break;
+            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED: ret = responseHardwareConfig(p); break;
+            case RIL_UNSOL_RADIO_CAPABILITY:
+                    ret = responseRadioCapability(p); break;
+            case RIL_UNSOL_ON_SS: ret =  responseSsData(p); break;
+            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY: ret =  responseStrings(p); break;
+            case RIL_UNSOL_LCEDATA_RECV: ret = responseLceData(p); break;
+            /// M: CC010: Add RIL interface @{
+            case RIL_UNSOL_CALL_FORWARDING: ret = responseInts(p); break;
+            case RIL_UNSOL_CRSS_NOTIFICATION: ret = responseCrssNotification(p); break;
+            case RIL_UNSOL_INCOMING_CALL_INDICATION: ret = responseStrings(p); break;
+            case RIL_UNSOL_CIPHER_INDICATION: ret = responseStrings(p); break;
+            //case RIL_UNSOL_CNAP: ret = responseStrings(p); break; //obsolete
+            /// @}
+            /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+            case RIL_UNSOL_SPEECH_CODEC_INFO: ret =  responseInts(p); break;
+            /// @}
+            //MTK-START multiple application support
+            case RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED: ret = responseInts(p); break;
+            //MTK-END multiple application support
+            case RIL_UNSOL_SIM_MISSING: ret = responseInts(p); break;
+            case RIL_UNSOL_SIM_RECOVERY: ret = responseInts(p); break;
+            case RIL_UNSOL_VIRTUAL_SIM_ON: ret = responseInts(p); break;
+            case RIL_UNSOL_VIRTUAL_SIM_OFF: ret = responseInts(p); break;
+            case RIL_UNSOL_SIM_PLUG_OUT: ret = responseVoid(p); break;
+            case RIL_UNSOL_SIM_PLUG_IN: ret = responseVoid(p); break;
+            case RIL_UNSOL_TRAY_PLUG_IN: ret = responseVoid(p); break;
+            case RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED: ret = responseVoid(p); break;
+            case RIL_UNSOL_DATA_ALLOWED: ret = responseVoid(p); break;
+            case RIL_UNSOL_PHB_READY_NOTIFICATION: ret = responseInts(p); break;
+            case RIL_UNSOL_STK_SETUP_MENU_RESET: ret = responseVoid(p); break;
+            // IMS
+            case RIL_UNSOL_IMS_ENABLE_DONE: ret = responseVoid(p); break;
+            case RIL_UNSOL_IMS_DISABLE_DONE: ret = responseVoid(p); break;
+            case RIL_UNSOL_IMS_REGISTRATION_INFO: ret = responseInts(p); break;
+            // M: Fast Dormancy
+            case RIL_UNSOL_SCRI_RESULT: ret = responseInts(p); break;
+
+            case RIL_UNSOL_RESPONSE_PLMN_CHANGED: ret = responseStrings(p); break;
+            case RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED: ret = responseInts(p); break;
+            //Remote SIM ME lock related APIs [Start]
+            case RIL_UNSOL_MELOCK_NOTIFICATION: ret = responseInts(p); break;
+            //Remote SIM ME lock related APIs [End]
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_SUPPORT: ret = responseInts(p); break;
+
+            /// M: IMS feature. @{
+            //For updating call ids for conference call after SRVCC is done.
+            case RIL_UNSOL_ECONF_SRVCC_INDICATION: ret = responseInts(p); break;
+            //For updating conference call merged/added result.
+            case RIL_UNSOL_ECONF_RESULT_INDICATION: ret = responseStrings(p); break;
+            //For updating call mode and pau information.
+            case RIL_UNSOL_CALL_INFO_INDICATION : ret = responseStrings(p); break;
+            /// @}
+
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO: ret = responseInts(p); break;
+            case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION:ret = responseInts(p); break;
+            // M: CC33 LTE.
+            case RIL_UNSOL_RAC_UPDATE: ret = responseVoid(p); break;
+            case RIL_UNSOL_REMOVE_RESTRICT_EUTRAN: ret = responseVoid(p); break;
+
+            //MTK-START for MD state change
+            case RIL_UNSOL_MD_STATE_CHANGE: ret = responseInts(p); break;
+            //MTK-END for MD state change
+
+            case RIL_UNSOL_MO_DATA_BARRING_INFO: ret = responseInts(p); break;
+            case RIL_UNSOL_SSAC_BARRING_INFO: ret = responseInts(p); break;
+
+            /// M: CC071: Add Customer proprietary-IMS RIL interface. @{
+            case RIL_UNSOL_EMERGENCY_BEARER_SUPPORT_NOTIFY: ret = responseInts(p); break;
+            /// @}
+
+            /* M: C2K part start*/
+            case RIL_UNSOL_CDMA_CALL_ACCEPTED: ret = responseVoid(p); break;
+            case RIL_UNSOL_UTK_SESSION_END: ret = responseVoid(p); break;
+            case RIL_UNSOL_UTK_PROACTIVE_COMMAND: ret = responseString(p); break;
+            case RIL_UNSOL_UTK_EVENT_NOTIFY: ret = responseString(p); break;
+            case RIL_UNSOL_VIA_GPS_EVENT: ret = responseInts(p); break;
+            case RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE: ret = responseInts(p); break;
+            case RIL_UNSOL_VIA_INVALID_SIM_DETECTED: ret = responseVoid(p); break;
+            /* M: C2K part end*/
+            case RIL_UNSOL_ABNORMAL_EVENT: ret = responseStrings(p); break;
+            case RIL_UNSOL_CDMA_CARD_TYPE: ret = responseInts(p); break;
+            /// M: [C2K] for eng mode start
+            case RIL_UNSOL_ENG_MODE_NETWORK_INFO:
+                ret = responseStrings(p);
+                unsljLog(response);
+                break;
+            /// M: [C2K] for eng mode end
+
+            /// M: [C2K][IR] Support SVLTE IR feature. @{
+            case RIL_UNSOL_CDMA_PLMN_CHANGED: ret = responseStrings(p); break;
+            /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+            /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @{
+            case RIL_UNSOL_GMSS_RAT_CHANGED: ret = responseInts(p); break;
+            /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @}
+
+            case RIL_UNSOL_SET_ATTACH_APN: ret = responseVoid(p); break;
+
+            // MTK-START, SMS part
+            // SMS ready
+            case RIL_UNSOL_SMS_READY_NOTIFICATION: ret = responseVoid(p); break;
+            // New SMS but phone storage is full
+            case RIL_UNSOL_ME_SMS_STORAGE_FULL: ret = responseVoid(p); break;
+            // ETWS primary notification
+            case RIL_UNSOL_RESPONSE_ETWS_NOTIFICATION: ret = responseEtwsNotification(p); break;
+            // MTK-END, SMS part
+
+            /// M: [C2K] For ps type changed.
+            case RIL_UNSOL_RESPONSE_DATA_NETWORK_TYPE_CHANGED: ret = responseInts(p); break;
+
+            ///M: [C2K][MD IRAT] start @{
+            case RIL_UNSOL_INTER_3GPP_IRAT_STATE_CHANGE:
+                riljLog(" RIL_UNSOL_INTER_3GPP_IRAT_STATE_CHANGE...");
+                ret = responseIratStateChange(p);
+                break;
+            /// }@ [C2K][MD IRAT] end
+            case RIL_UNSOL_IMSI_REFRESH_DONE: ret = responseVoid(p); break;
+            case RIL_UNSOL_CDMA_IMSI_READY: ret = responseVoid(p); break;
+            // M: Notify RILJ that the AT+EUSIM was received
+            case RIL_UNSOL_EUSIM_READY: ret = responseVoid(p); break;
+            // M: Notify RILJ that call fade happened
+            case RIL_UNSOL_CDMA_SIGNAL_FADE: ret = responseInts(p); break;
+            // M: Notify RILJ that the AT+EFNM was received
+            case RIL_UNSOL_CDMA_TONE_SIGNALS: ret = responseInts(p); break;
+            /// M: BIP {
+            case RIL_UNSOL_STK_BIP_PROACTIVE_COMMAND: ret = responseString(p); break;
+            /// M: BIP }
+            //WorldMode
+            case RIL_UNSOL_WORLD_MODE_CHANGED: ret = responseInts(p); break;
+            /// M: For 3G VT only @{
+            case RIL_UNSOL_VT_STATUS_INFO: ret = responseInts(p); break;
+            case RIL_UNSOL_VT_RING_INFO: ret = responseVoid(p); break;
+            /// @}
+
+            // M: [LTE][Low Power][UL traffic shaping] Start
+            case RIL_UNSOL_LTE_ACCESS_STRATUM_STATE_CHANGE: ret = responseInts(p); break;
+            // M: [LTE][Low Power][UL traffic shaping] End
+            default:
+                // Rewind the Parcel
+                p.setDataPosition(dataPosition);
+
+                // Forward responses that we are not overriding to the super class
+                super.processUnsolicited(p);
+                return;
+        }
+
+        // To avoid duplicating code from RIL.java, we rewrite some response codes to fit
+        // AOSP's one (when they do the same effect)
+        boolean rewindAndReplace = false;
+        int newResponseCode = 0;
+
+        switch (response) {
+            // xen0n: MTK TODO
+            /*
+            case RIL_UNSOL_STK_SESSION_END:
+                if (RILJ_LOGD) unsljLog(response);
+
+                /// M: SVLTE UTK feature @{
+                if ((CdmaFeatureOptionUtils.isCdmaLteDcSupport())
+                        && (mUtkSessionEndRegistrant != null)
+                        && (mUtkSessionEndRegistrant.getHandler() != null)
+                        && (mStkSwitchMode == IUtkService.SVLTE_UTK_MODE)) {
+                    riljLog("SVLTE UTK received PS session end from MD1");
+                    mUtkSessionEndRegistrant.notifyRegistrant(
+                            new AsyncResult(null, ret, null));
+                } else {
+                    if (mCatSessionEndRegistrant != null) {
+                        mCatSessionEndRegistrant.notifyRegistrant(
+                                new AsyncResult(null, ret, null));
+                    }
+                }
+                /// @}
+                break;
+
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
+                if (RILJ_LOGD) unsljLog(response);
+
+                /// M: SVLTE UTK feature @{
+                if ((CdmaFeatureOptionUtils.isCdmaLteDcSupport())
+                        && (mUtkProCmdRegistrant != null)
+                        && (mUtkProCmdRegistrant.getHandler() != null)
+                        && (mStkSwitchMode == IUtkService.SVLTE_UTK_MODE)
+                        && (mBipPsType != IUtkService.SVLTE_BIP_TYPE_ON_LTE)) {
+                    riljLog("SVLTE UTK received PS proactive command from MD1");
+                    mUtkProCmdRegistrant.notifyRegistrant(
+                            new AsyncResult(null, ret, null));
+                } else {
+                    if (mCatProCmdRegistrant != null) {
+                        mCatProCmdRegistrant.notifyRegistrant(
+                                new AsyncResult(null, ret, null));
+                    }
+                }
+                /// @}
+                break;
+
+            // case RIL_UNSOL_STK_EVENT_NOTIFY:
+            // identical to upstream, not ported
+            */
+
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
+                if (RILJ_LOGD) unsljLog(response);
+
+                // MTK-START, SMS part
+                if (mIccSmsFullRegistrant != null) {
+                    mIccSmsFullRegistrant.notifyRegistrant();
+                } else {
+                    // Phone process is not ready and cache it then wait register to notify
+                    if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "Cache sim sms full event");
+                    mIsSmsSimFull = true;
+                }
+                // MTK-END, SMS part
+                break;
+
+            case RIL_UNSOL_RIL_CONNECTED: {
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                // Set ecc list before MO call
+                if  (TelephonyManager.getDefault().getMultiSimConfiguration() == TelephonyManager.MultiSimVariants.DSDA
+                        || mInstanceId == 0) {
+                    setEccList();
+                }
+
+                // Initial conditions
+                //setRadioPower(false, null);
+
+                setCdmaSubscriptionSource(mCdmaSubscription, null);
+                setCellInfoListRate(Integer.MAX_VALUE, null);
+                notifyRegistrantsRilConnectionChanged(((int[])ret)[0]);
+                //[ALPS01810775,ALPS01868743]-Start
+                //"isScreenOn" removed and replaced by mDefaultDisplayState
+                //sendScreenState(isScreenOn);
+                if (mDefaultDisplayState == Display.STATE_ON) {
+                    sendScreenState(true);
+                } else if (mDefaultDisplayState == Display.STATE_OFF) {
+                    sendScreenState(false);
+                } else {
+                    riljLog("not setScreenState mDefaultDisplayState="
+                            + mDefaultDisplayState);
+                }
+                //[ALPS01810775,ALPS01868743]-End
+                break;
+            }
+
+            case RIL_UNSOL_NEIGHBORING_CELL_INFO:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mNeighboringInfoRegistrants != null) {
+                    mNeighboringInfoRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_NETWORK_INFO:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                 /* M: Start - abnormal event logging for logger */
+                if (ret != null) {
+                    String[] networkinfo = (String[]) ret;
+                    int type = Integer.parseInt(networkinfo[0]);
+                    //type 400 for abnormal testing event.
+                    //type 401 for no service event.
+                    //type 402 for C2K voice call drop.
+                    //type 403 for C2K SMS failure.
+                    if (type == 401 || type == 402 || type == 403) {
+                        Intent intent = new Intent(
+                                TelephonyIntents.ACTION_EXCEPTION_HAPPENED);
+                        intent.putExtra("Reason", "SmartLogging");
+                        intent.putExtra("from_where", "RIL");
+                        mContext.sendBroadcast(intent);
+                        riljLog("Broadcast for SmartLogging " + type);
+                        break;
+                    }
+                }
+                /* M: End - abnormal event logging for logger */
+                if (mNetworkInfoRegistrants != null) {
+                    mNetworkInfoRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_NETWORK_EXIST:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                if (mNetworkExistRegistrants != null) {
+                    mNetworkExistRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mHardwareConfigChangeRegistrants != null) {
+                    mHardwareConfigChangeRegistrants.notifyRegistrants(
+                                             new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RADIO_CAPABILITY:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                mRadioCapability = (RadioCapability)ret;
+                if (mPhoneRadioCapabilityChangedRegistrants != null) {
+                    mPhoneRadioCapabilityChangedRegistrants.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                 }
+                 break;
+            case RIL_UNSOL_ON_SS:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mSsRegistrant != null) {
+                    mSsRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCatCcAlphaRegistrant != null) {
+                    mCatCcAlphaRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_LCEDATA_RECV:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mLceInfoRegistrant != null) {
+                    mLceInfoRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+            /// M: CC010: Add RIL interface @{
+            case RIL_UNSOL_CALL_FORWARDING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mCallForwardingInfoRegistrants != null) {
+                    boolean bCfuEnabled = (((int[]) ret)[0] == 1);
+                    boolean bIsLine1 = (((int[]) ret)[1] == 1);
+                    /* ONLY notify for Line1 */
+                    if (bIsLine1) {
+                        mCfuReturnValue = ret;
+                        mCallForwardingInfoRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                    }
+                }
+                break;
+
+            case RIL_UNSOL_CRSS_NOTIFICATION:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCallRelatedSuppSvcRegistrant != null) {
+                    mCallRelatedSuppSvcRegistrant.notifyRegistrant(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_INCOMING_CALL_INDICATION:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                // example of how mindless copying can adversely affect functionality
+                // if (mIncomingCallIndicationRegistrant != null) {
+                //     mIncomingCallIndicationRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                // }
+                setCallIndication((String[])ret);
+                rewindAndReplace = true;
+                newResponseCode = RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED;
+                break;
+
+            case RIL_UNSOL_CIPHER_INDICATION:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+
+                int simCipherStatus = Integer.parseInt(((String[]) ret)[0]);
+                int sessionStatus = Integer.parseInt(((String[]) ret)[1]);
+                int csStatus = Integer.parseInt(((String[]) ret)[2]);
+                int psStatus = Integer.parseInt(((String[]) ret)[3]);
+
+                riljLog("RIL_UNSOL_CIPHER_INDICATION :" + simCipherStatus + " " + sessionStatus + " " + csStatus + " " + psStatus);
+
+                int[] cipherResult = new int[3];
+
+                cipherResult[0] = simCipherStatus;
+                cipherResult[1] = csStatus;
+                cipherResult[2] = psStatus;
+
+                if (mCipherIndicationRegistrant != null) {
+                    mCipherIndicationRegistrant.notifyRegistrants(
+                        new AsyncResult(null, cipherResult, null));
+                }
+
+                break;
+            //obsolete
+            /*
+            case RIL_UNSOL_CNAP:
+                    String[] respCnap = (String[]) ret;
+                    int validity = Integer.parseInt(((String[]) ret)[1]);
+
+                    riljLog("RIL_UNSOL_CNAP :" + respCnap[0] + " " + respCnap[1]);
+                    if (validity == 0) {
+                        if (mCnapNotifyRegistrant != null) {
+                            mCnapNotifyRegistrant.notifyRegistrant(
+                                            new AsyncResult(null, respCnap, null));
+                        }
+                    }
+
+                break;
+                */
+            /// @}
+
+            /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+            case RIL_UNSOL_SPEECH_CODEC_INFO:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+
+                if (mSpeechCodecInfoRegistrant != null) {
+                    mSpeechCodecInfoRegistrant.notifyRegistrant(
+                        new AsyncResult(null, ret, null));
+                }
+            break;
+            /// @}
+
+            case RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+                int[] stat = null;
+                if (ret != null) {
+                    stat = (int[]) ret;
+                }
+                mPsNetworkStateRegistrants
+                        .notifyRegistrants(new AsyncResult(null, stat, null));
+            break;
+
+            /* M: network part start */
+            case RIL_UNSOL_IMEI_LOCK:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mImeiLockRegistrant != null) {
+                    mImeiLockRegistrant.notifyRegistrants(new AsyncResult(null, null, null));
+                }
+                break;
+
+            //ALPS00248788 START
+            case RIL_UNSOL_INVALID_SIM:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mInvalidSimInfoRegistrant != null) {
+                   mInvalidSimInfoRegistrant.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            //ALPS00248788 END
+            //MTK-START [MTK80515] [ALPS00368272]
+            case RIL_UNSOL_RESPONSE_MMRR_STATUS_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+                if (ret != null) {
+                    int[] emmrrs = (int[]) ret;
+                    int ps_status = Integer.valueOf(emmrrs[0]);
+
+                    /*
+                    if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                        try {
+                            if (mServiceStateExt.isBroadcastEmmrrsPsResume(ps_status)) {
+                                riljLog("Broadcast for EMMRRS: android.intent.action.EMMRRS_PS_RESUME ");
+                            }
+                        } catch (RuntimeException e) {
+                            e.printStackTrace();
+                        }
+                    }
+                    */
+                }
+                break;
+            //MTK-END [MTK80515] [ALPS00368272]
+
+            case RIL_UNSOL_FEMTOCELL_INFO:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                mFemtoCellInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                break;
+
+            // ALPS00297719 START
+            case RIL_UNSOL_RESPONSE_ACMT:
+                if (RILJ_LOGD) unsljLog(response);
+                if (ret != null) {
+                    int[] acmt = (int[]) ret;
+                    if (acmt.length == 2) {
+                        int error_type = Integer.valueOf(acmt[0]);
+                        int error_cause = acmt[1];
+
+                        /*
+                        if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                            try {
+                                if (mServiceStateExt.needBrodcastAcmt(error_type, error_cause)
+                                        == true) {
+                                    Intent intent = new Intent(
+                                            TelephonyIntents.ACTION_ACMT_NETWORK_SERVICE_STATUS_INDICATOR);
+                                    intent.putExtra("CauseCode", acmt[1]);
+                                    intent.putExtra("CauseType", acmt[0]);
+                                    mContext.sendBroadcast(intent);
+                                    riljLog("Broadcast for ACMT: com.VendorName.CauseCode "
+                                            + acmt[1] + "," + acmt[0]);
+                                }
+                            } catch (RuntimeException e) {
+                                e.printStackTrace();
+                            }
+                        }
+                        */
+                    }
+                }
+                break;
+            // ALPS00297719 END
+            /* M: network part end */
+            case RIL_UNSOL_STK_EVDL_CALL:
+                // if (false == SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+                    if (RILJ_LOGD) unsljLogvRet(response, ret);
+                    if (mStkEvdlCallRegistrant != null) {
+                        mStkEvdlCallRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                    }
+                // }
+                break;
+
+            case RIL_UNSOL_STK_CALL_CTRL:
+                if (RILJ_LOGD) {
+                    unsljLogvRet(response, ret);
+                }
+                if (mStkCallCtrlRegistrant != null) {
+                    mStkCallCtrlRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_STK_SETUP_MENU_RESET:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mStkSetupMenuResetRegistrant != null) {
+                    mStkSetupMenuResetRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            //MTK-START multiple application support
+            case RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED: {
+                if (RILJ_LOGD) unsljLog(response);
+                if (mSessionChangedRegistrants != null) {
+                    mSessionChangedRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            }
+            //MTK-END multiple application support
+            case RIL_UNSOL_SIM_MISSING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mSimMissing != null) {
+                    mSimMissing.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_SIM_RECOVERY:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mSimRecovery != null) {
+                    mSimRecovery.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_VIRTUAL_SIM_ON:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mVirtualSimOn != null) {
+                    mVirtualSimOn.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_VIRTUAL_SIM_OFF:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mVirtualSimOff != null) {
+                    mVirtualSimOff.notifyRegistrants(
+                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_SIM_PLUG_OUT:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mSimPlugOutRegistrants != null) {
+                    mSimPlugOutRegistrants.notifyRegistrants(
+                        new AsyncResult(null, ret, null));
+                }
+                mCfuReturnValue = null;
+                break;
+            case RIL_UNSOL_SIM_PLUG_IN:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mSimPlugInRegistrants != null) {
+                    mSimPlugInRegistrants.notifyRegistrants(
+                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_TRAY_PLUG_IN:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mTrayPlugInRegistrants != null) {
+                    mTrayPlugInRegistrants.notifyRegistrants(
+                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            // MTK-START, SMS part
+            // SMS ready notification
+            case RIL_UNSOL_SMS_READY_NOTIFICATION:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mSmsReadyRegistrants.size() != 0) {
+                    mSmsReadyRegistrants.notifyRegistrants();
+                } else {
+                    // Phone process is not ready and cache it then wait register to notify
+                    if (RILJ_LOGD) Rlog.d(RILJ_LOG_TAG, "Cache sms ready event");
+                    mIsSmsReady = true;
+                }
+                break;
+
+            // New SMS but phone storage is full
+            case RIL_UNSOL_ME_SMS_STORAGE_FULL:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mMeSmsFullRegistrant != null) {
+                    mMeSmsFullRegistrant.notifyRegistrant();
+                }
+                break;
+
+            // ETWS primary notification
+            case RIL_UNSOL_RESPONSE_ETWS_NOTIFICATION:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mEtwsNotificationRegistrant != null) {
+                    mEtwsNotificationRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+            // MTK-END, SMS part
+
+            case RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mCommonSlotNoChangedRegistrants != null) {
+                    mCommonSlotNoChangedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
+                }
+                break;
+            case RIL_UNSOL_DATA_ALLOWED:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mDataAllowedRegistrants != null) {
+                    mDataAllowedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
+                }
+                break;
+
+            case RIL_UNSOL_PHB_READY_NOTIFICATION:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mPhbReadyRegistrants != null) {
+                    mPhbReadyRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_IMS_REGISTRATION_INFO:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mImsRegistrationInfoRegistrants != null) {
+                    mImsRegistrationInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_RESPONSE_PLMN_CHANGED:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                synchronized (mWPMonitor) {
+                    mEcopsReturnValue = ret;
+                    if (mPlmnChangeNotificationRegistrant.size() > 0) {
+                        if (RILJ_LOGD) riljLog("ECOPS,notify mPlmnChangeNotificationRegistrant");
+                        mPlmnChangeNotificationRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                    }
+                }
+                break;
+            case RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                synchronized (mWPMonitor) {
+                    mEmsrReturnValue = ret;
+                    if (mRegistrationSuspendedRegistrant != null) {
+                        if (RILJ_LOGD) riljLog("EMSR, notify mRegistrationSuspendedRegistrant");
+                        mRegistrationSuspendedRegistrant.notifyRegistrant(
+                            new AsyncResult(null, ret, null));
+                    }
+                }
+                break;
+            //Remote SIM ME lock related APIs [Start]
+            case RIL_UNSOL_MELOCK_NOTIFICATION:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mMelockRegistrants != null) {
+                    mMelockRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+            //Remote SIM ME lock related APIs [End]
+            case RIL_UNSOL_IMS_ENABLE_DONE:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mImsEnableRegistrants != null) {
+                    mImsEnableRegistrants.notifyRegistrants();
+                }
+                break;
+            case RIL_UNSOL_IMS_DISABLE_DONE:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mImsDisableRegistrants != null) {
+                    mImsDisableRegistrants.notifyRegistrants();
+                }
+                break;
+            // M: Fast Dormancy
+            case RIL_UNSOL_SCRI_RESULT:
+                Integer scriResult = (((int[]) ret)[0]);
+                riljLog("s:" + scriResult + ":" + (((int[]) ret)[0]));
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mScriResultRegistrant != null) {
+                   mScriResultRegistrant.notifyRegistrant(new AsyncResult(null, scriResult, null));
+                }
+                break;
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_SUPPORT:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mEpsNetworkFeatureSupportRegistrants != null) {
+                    mEpsNetworkFeatureSupportRegistrants.notifyRegistrants(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+
+            /// M: IMS feature. @{
+            //For updating call ids for conference call after SRVCC is done.
+            case RIL_UNSOL_ECONF_SRVCC_INDICATION:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mEconfSrvccRegistrants != null) {
+                    mEconfSrvccRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            //For updating conference call merged/added result.
+            case RIL_UNSOL_ECONF_RESULT_INDICATION:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mEconfResultRegistrants != null) {
+                     riljLog("Notify ECONF result");
+                     String[] econfResult = (String[]) ret;
+                     riljLog("ECONF result = " + econfResult[3]);
+                     mEconfResultRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            //For updating call mode and pau information.
+            case RIL_UNSOL_CALL_INFO_INDICATION :
+                if (RILJ_LOGD) unsljLog(response);
+                if (mCallInfoRegistrants != null) {
+                   mCallInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            /// @}
+
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mEpsNetworkFeatureInfoRegistrants != null) {
+                   mEpsNetworkFeatureInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mSrvccHandoverInfoIndicationRegistrants != null) {
+                    mSrvccHandoverInfoIndicationRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            //MTK-START for MD state change
+            case RIL_UNSOL_MD_STATE_CHANGE:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                break;
+            //MTK-END for MD state change
+
+            case RIL_UNSOL_MO_DATA_BARRING_INFO:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mMoDataBarringInfoRegistrants != null) {
+                    mMoDataBarringInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_SSAC_BARRING_INFO:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mSsacBarringInfoRegistrants != null) {
+                    mSsacBarringInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            /// M: CC071: Add Customer proprietary-IMS RIL interface. @[
+            case RIL_UNSOL_EMERGENCY_BEARER_SUPPORT_NOTIFY:
+                if (RILJ_LOGD) unsljLog(response);
+                if (mEmergencyBearerSupportInfoRegistrants != null) {
+                    mEmergencyBearerSupportInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            /// @}
+
+            // M: CC33 LTE.
+            case RIL_UNSOL_RAC_UPDATE:
+                if (RILJ_LOGD) unsljLog(response);
+                mRacUpdateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+                break;
+            case RIL_UNSOL_REMOVE_RESTRICT_EUTRAN:
+                if (RILJ_LOGD) unsljLog(response);
+                mRemoveRestrictEutranRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+                break;
+
+            case RIL_UNSOL_SET_ATTACH_APN:
+                if (RILJ_LOGD) unsljLog(response);
+                mResetAttachApnRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+                break;
+
+            /* M: C2K part start */
+            case RIL_UNSOL_CDMA_CALL_ACCEPTED:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+
+                if (mAcceptedRegistrant != null) {
+                    mAcceptedRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_UTK_SESSION_END:
+                if (RILJ_LOGD) {
+                    unsljLog(response);
+                }
+
+                if (mUtkSessionEndRegistrant != null) {
+                    mUtkSessionEndRegistrant.notifyRegistrant(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_UTK_PROACTIVE_COMMAND:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+
+                if (mUtkProCmdRegistrant != null) {
+                    mUtkProCmdRegistrant.notifyRegistrant(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_UTK_EVENT_NOTIFY:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                if (mUtkEventRegistrant != null) {
+                    mUtkEventRegistrant.notifyRegistrant(
+                                        new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_VIA_GPS_EVENT:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                if (mViaGpsEvent != null) {
+                    mViaGpsEvent.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                if (mNetworkTypeChangedRegistrant != null) {
+                    mNetworkTypeChangedRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_VIA_INVALID_SIM_DETECTED:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                if (mInvalidSimDetectedRegistrant != null) {
+                    mInvalidSimDetectedRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            /* M: C2K part end*/
+            case RIL_UNSOL_ABNORMAL_EVENT:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mAbnormalEventRegistrant != null) {
+                    mAbnormalEventRegistrant.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_CDMA_CARD_TYPE:
+                if (RILJ_LOGD) {
+                    unsljLogvRet(response, ret);
+                }
+                if (mCdmaCardTypeRegistrants != null) {
+                    mCdmaCardTypeValue = ret;
+                    mCdmaCardTypeRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                }
+                break;
+            /// M:[C2K] for eng mode start
+            case RIL_UNSOL_ENG_MODE_NETWORK_INFO:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                if (mEngModeNetworkInfoRegistrant != null) {
+                    mEngModeNetworkInfoRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            /// M:[C2K] for eng mode end
+
+            /// M: [C2K][IR] Support SVLTE IR feature. @{
+            case RIL_UNSOL_CDMA_PLMN_CHANGED:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                String mccmnc = "";
+                if (ret != null && ret instanceof String[]) {
+                    String s[] = (String[]) ret;
+                    if (s.length >= 2) {
+                        mccmnc = s[0] + s[1];
+                    }
+                }
+                riljLog("mccmnc changed mccmnc=" + mccmnc);
+                mMccMncChangeRegistrants.notifyRegistrants(new AsyncResult(null, mccmnc, null));
+                break;
+            /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+            /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @{
+            case RIL_UNSOL_GMSS_RAT_CHANGED:
+                if (RILJ_LOGD) {
+                    unsljLogvRet(response, ret);
+                }
+                int[] rat = (int[]) ret;
+                riljLog("Notify RIL_UNSOL_GMSS_RAT_CHANGED result rat = " + rat);
+                if (mGmssRatChangedRegistrant != null) {
+                    mGmssRatChangedRegistrant.notifyRegistrants(
+                            new AsyncResult(null, rat, null));
+                }
+                break;
+            /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @}
+
+            /// M: [C2K] for ps type changed. @{
+            case RIL_UNSOL_RESPONSE_DATA_NETWORK_TYPE_CHANGED:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+
+                if (mDataNetworkTypeChangedRegistrant != null) {
+                    mDataNetworkTypeChangedRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            /// @}
+            ///M: [C2K][MD IRAT] start @{
+            case RIL_UNSOL_INTER_3GPP_IRAT_STATE_CHANGE:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                mIratStateChangeRegistrant.notifyRegistrants(new AsyncResult(null, ret, null));
+                break;
+            /// @} [C2K][MD IRAT] end
+            case RIL_UNSOL_IMSI_REFRESH_DONE:
+                if (RILJ_LOGD) {
+                    unsljLog(response);
+                }
+                if (mImsiRefreshDoneRegistrant != null) {
+                    mImsiRefreshDoneRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_CDMA_IMSI_READY:
+                if (RILJ_LOGD) {
+                    unsljLog(response);
+                }
+                if (mCdmaImsiReadyRegistrant != null) {
+                    mCdmaImsiReadyRegistrant.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_EUSIM_READY:
+                if (RILJ_LOGD) {
+                    unsljLogRet(response, ret);
+                }
+                mIsEusimReady = true;
+                if (mEusimReady != null) {
+                    mEusimReady.notifyRegistrants(new AsyncResult(null, null, null));
+                    if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                        if ((mInstanceId == 0) || (mInstanceId == 10)) {
+                            SystemProperties.set(PROPERTY_RIL_CARD_TYPE_SET, "1");
+                            riljLog("set gsm.ril.cardtypeset to 1");
+                        } else if ((mInstanceId == 1) || (mInstanceId == 11)) {
+                            SystemProperties.set(PROPERTY_RIL_CARD_TYPE_SET_2, "1");
+                            riljLog("set gsm.ril.cardtypeset.2 to 1");
+                        } else {
+                            riljLog("not set cardtypeset mInstanceId=" + mInstanceId);
+                        }
+                    }
+                }
+                break;
+            // M: Notify RILJ that call fade happened
+            case RIL_UNSOL_CDMA_SIGNAL_FADE:
+                if (RILJ_LOGD) {
+                    unsljLogvRet(response, ret);
+                }
+                if (mCdmaSignalFadeRegistrant != null) {
+                    mCdmaSignalFadeRegistrant.notifyRegistrant(
+                        new AsyncResult(null, ret, null));
+                }
+                break;
+            // M: Notify RILJ that the AT+EFNM was received
+            case RIL_UNSOL_CDMA_TONE_SIGNALS:
+                if (RILJ_LOGD) {
+                    unsljLogvRet(response, ret);
+                }
+                if (mCdmaToneSignalsRegistrant != null) {
+                    mCdmaToneSignalsRegistrant.notifyRegistrant(
+                        new AsyncResult(null, ret, null));
+                }
+                break;
+            // xen0n: MTK TODO
+            /// M: BIP {
+            case RIL_UNSOL_STK_BIP_PROACTIVE_COMMAND:
+                if (RILJ_LOGD) unsljLog(response);
+                /*
+                if ((CdmaFeatureOptionUtils.isCdmaLteDcSupport())
+                        && (mUtkProCmdRegistrant != null)
+                        && (mUtkProCmdRegistrant.getHandler() != null)
+                        && (mStkSwitchMode == IUtkService.SVLTE_UTK_MODE)
+                        && (mBipPsType != IUtkService.SVLTE_BIP_TYPE_ON_LTE)) {
+                    riljLog("SVLTE UTK received BIP proactive command from MD1");
+                    mUtkProCmdRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                } else {
+                */
+                    if (mBipProCmdRegistrant != null) {
+                        mBipProCmdRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                    }
+                // }
+                break;
+            /// M: BIP }
+            //WorldMode
+            case RIL_UNSOL_WORLD_MODE_CHANGED:
+                int[] state = null;
+                if (RILJ_LOGD) {
+                    unsljLog(response);
+                }
+                if (ret != null) {
+                    state = (int[]) ret;
+
+                    //update switching state
+                    if (state[0] == 0){
+                        WorldMode.updateSwitchingState(true);
+                    }else{
+                        WorldMode.updateSwitchingState(false);
+                    }
+
+                    //sendBroadcast with state
+                    Intent intent = new Intent(
+                            TelephonyIntents.ACTION_WORLD_MODE_CHANGED);
+                    intent.putExtra(TelephonyIntents.EXTRA_WORLD_MODE_CHANGE_STATE,
+                            (Integer)state[0]);
+                    mContext.sendBroadcast(intent);
+                    if (RILJ_LOGD) {
+                        riljLog("Broadcast for WorldModeChanged: state=" + state[0]);
+                    }
+                }
+                break;
+            /// M: For 3G VT only @{
+            case RIL_UNSOL_VT_STATUS_INFO:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mVtStatusInfoRegistrants != null) {
+                    mVtStatusInfoRegistrants.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_VT_RING_INFO:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mVtRingRegistrants != null) {
+                    mVtRingRegistrants.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            /// @}
+
+            // M: [LTE][Low Power][UL traffic shaping] Start
+            case RIL_UNSOL_LTE_ACCESS_STRATUM_STATE_CHANGE:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+                if (mLteAccessStratumStateRegistrants != null) {
+                    mLteAccessStratumStateRegistrants.notifyRegistrants(
+                            new AsyncResult(null, ret, null));
+                }
+                break;
+            // M: [LTE][Low Power][UL traffic shaping] End
+            default:
+                Rlog.i(RILJ_LOG_TAG, "Unprocessed unsolicited known MTK response: " + response);
+        }
+
+        if (rewindAndReplace) {
+            Rlog.w(RILJ_LOG_TAG, "Rewriting MTK unsolicited response " + response + " to " + newResponseCode);
+
+            // Rewrite
+            p.setDataPosition(dataPosition);
+            p.writeInt(newResponseCode);
+
+            // And rewind again in front
+            p.setDataPosition(dataPosition);
+
+            super.processUnsolicited(p);
+        }
+    }
+
+    /*
+     * to protect modem status we need to avoid two case :
+     * 1. DTMF start -> CHLD request -> DTMF stop
+     * 2. CHLD request -> DTMF request
+     */
+    private void handleChldRelatedRequest(RILRequest rr) {
+        synchronized (mDtmfReqQueue) {
+            int queueSize = mDtmfReqQueue.size();
+            int i, j;
+            if (queueSize > 0) {
+                RILRequest rr2 = mDtmfReqQueue.get();
+                if (rr2.mRequest == RIL_REQUEST_DTMF_START) {
+                    // need to send the STOP command
+                    if (RILJ_LOGD) riljLog("DTMF queue isn't 0, first request is START, send stop dtmf and pending switch");
+                    if (queueSize > 1) {
+                        j = 2;
+                    } else {
+                        // need to create a new STOP command
+                        j = 1;
+                    }
+                    if (RILJ_LOGD) riljLog("queue size  " + mDtmfReqQueue.size());
+
+                    for (i = queueSize - 1; i >= j; i--) {
+                        mDtmfReqQueue.remove(i);
+                    }
+                    if (RILJ_LOGD) riljLog("queue size  after " + mDtmfReqQueue.size());
+                    if (mDtmfReqQueue.size() == 1) { // only start command, we need to add stop command
+                        RILRequest rr3 = RILRequest.obtain(RIL_REQUEST_DTMF_STOP, null);
+                        if (RILJ_LOGD) riljLog("add dummy stop dtmf request");
+                        mDtmfReqQueue.stop();
+                        mDtmfReqQueue.add(rr3);
+                    }
+                }
+                else {
+                    // first request is STOP, just remove it and send switch
+                    if (RILJ_LOGD) riljLog("DTMF queue isn't 0, first request is STOP, penging switch");
+                    j = 1;
+                    for (i = queueSize - 1; i >= j; i--) {
+                        mDtmfReqQueue.remove(i);
+                    }
+                }
+                mDtmfReqQueue.setPendingRequest(rr);
+            } else {
+                if (RILJ_LOGD) riljLog("DTMF queue is 0, send switch Immediately");
+                mDtmfReqQueue.setSendChldRequest();
+                send(rr);
+            }
+        }
+    }
+
+    private static int readRilMessage(InputStream is, byte[] buffer)
+            throws IOException {
+        int countRead;
+        int offset;
+        int remaining;
+        int messageLength;
+
+        // First, read in the length of the message
+        offset = 0;
+        remaining = 4;
+        do {
+            countRead = is.read(buffer, offset, remaining);
+
+            if (countRead < 0 ) {
+                Rlog.e(RILJ_LOG_TAG, "Hit EOS reading message length");
+                return -1;
+            }
+
+            offset += countRead;
+            remaining -= countRead;
+        } while (remaining > 0);
+
+        messageLength = ((buffer[0] & 0xff) << 24)
+                | ((buffer[1] & 0xff) << 16)
+                | ((buffer[2] & 0xff) << 8)
+                | (buffer[3] & 0xff);
+
+        // Then, re-use the buffer and read in the message itself
+        offset = 0;
+        remaining = messageLength;
+        do {
+            countRead = is.read(buffer, offset, remaining);
+
+            if (countRead < 0 ) {
+                Rlog.e(RILJ_LOG_TAG, "Hit EOS reading message.  messageLength=" + messageLength
+                        + " remaining=" + remaining);
+                return -1;
+            }
+
+            offset += countRead;
+            remaining -= countRead;
+        } while (remaining > 0);
+
+        return messageLength;
+    }
+
+        protected RILReceiver createRILReceiver() {
+        return new MTKRILReceiver();
+    }
+
+        protected class MTKRILReceiver extends RILReceiver {
+        byte[] buffer;
+
+        protected MTKRILReceiver() {
+            buffer = new byte[RIL_MAX_COMMAND_BYTES];
+        }
+
+        /// M: For SVLTE to disconnect socket in C2K only mode.
+        boolean mStoped = false;
+
+        @Override
+        public void
+        run() {
+            int retryCount = 0;
+            String rilSocket = "rild";
+
+            try {for (;;) {
+                /// M: For SVLTE to disconnect socket in C2K only mode.
+                if (mStoped) {
+                    riljLog("[RIL SWITCH] stoped now!");
+                    return;
+                }
+
+                LocalSocket s = null;
+                LocalSocketAddress l;
+
+                /// M: If SVLTE support, LTE RIL ID is a special value, force connect to rild socket
+                if (mInstanceId == null || SvlteUtils.isValidPhoneId(mInstanceId)) {
+                    rilSocket = SOCKET_NAME_RIL[SvlteUtils.getSlotId(mInstanceId)];
+                } else {
+                    if (SystemProperties.getInt("ro.mtk_dt_support", 0) != 1) {
+                        // dsds
+                        rilSocket = SOCKET_NAME_RIL[mInstanceId];
+                    } else {
+                        // dsda
+                        if (SystemProperties.getInt("ro.evdo_dt_support", 0) == 1) {
+                            // c2k dsda
+                            rilSocket = SOCKET_NAME_RIL[mInstanceId];
+                        } else if (SystemProperties.getInt("ro.telephony.cl.config", 0) == 1) {
+                            // for C+L
+                            rilSocket = SOCKET_NAME_RIL[mInstanceId];
+                        } else {
+                            // gsm dsda
+                            rilSocket = "rild-md2";
+                        }
+                    }
+                }
+
+                /* M: C2K start */
+                int phoneType = TelephonyManager.getPhoneType(mPreferredNetworkType);
+                if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
+                    rilSocket = C2K_SOCKET_NAME_RIL;
+                }
+                /* M: C2K end */
+
+                riljLog("rilSocket[" + mInstanceId + "] = " + rilSocket);
+
+                try {
+                    s = new LocalSocket();
+                    l = new LocalSocketAddress(rilSocket,
+                            LocalSocketAddress.Namespace.RESERVED);
+                    s.connect(l);
+                } catch (IOException ex){
+                    try {
+                        if (s != null) {
+                            s.close();
+                        }
+                    } catch (IOException ex2) {
+                        //ignore failure to close after failure to connect
+                    }
+
+                    // don't print an error message after the the first time
+                    // or after the 8th time
+
+                    if (retryCount == 8) {
+                        Rlog.e (RILJ_LOG_TAG,
+                            "Couldn't find '" + rilSocket
+                            + "' socket after " + retryCount
+                            + " times, continuing to retry silently");
+                    } else if (retryCount >= 0 && retryCount < 8) {
+                        Rlog.i (RILJ_LOG_TAG,
+                            "Couldn't find '" + rilSocket
+                            + "' socket; retrying after timeout");
+                    }
+
+                    try {
+                        Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
+                    } catch (InterruptedException er) {
+                    }
+
+                    retryCount++;
+                    continue;
+                }
+
+                retryCount = 0;
+
+                mSocket = s;
+                Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Connected to '"
+                        + rilSocket + "' socket");
+
+                int length = 0;
+                try {
+                    InputStream is = mSocket.getInputStream();
+                    for (;;) {
+                        Parcel p;
+                        length = readRilMessage(is, buffer);
+                        if (length < 0) {
+                            // End-of-stream reached
+                            break;
+                        }
+                        p = Parcel.obtain();
+                        p.unmarshall(buffer, 0, length);
+                        p.setDataPosition(0);
+
+                        //Rlog.v(RILJ_LOG_TAG, "Read packet: " + length + " bytes");
+
+                        processResponse(p);
+                        p.recycle();
+                    }
+                } catch (java.io.IOException ex) {
+                    Rlog.i(RILJ_LOG_TAG, "'" + rilSocket + "' socket closed",
+                          ex);
+                } catch (Throwable tr) {
+                    Rlog.e(RILJ_LOG_TAG, "Uncaught exception read length=" + length +
+                        "Exception:" + tr.toString());
+                }
+
+                Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Disconnected from '" + rilSocket
+                      + "' socket");
+
+                setRadioState (RadioState.RADIO_UNAVAILABLE);
+
+                try {
+                    mSocket.close();
+                } catch (IOException ex) {
+                }
+
+                mSocket = null;
+                RILRequest.resetSerial();
+
+                // Clear request list on close
+                clearRequestList(RADIO_NOT_AVAILABLE, false);
+            }} catch (Throwable tr) {
+                Rlog.e(RILJ_LOG_TAG,"Uncaught exception", tr);
+            }
+
+            /* We're disconnected so we don't know the ril version */
+            notifyRegistrantsRilConnectionChanged(-1);
+        }
+    }
+
+    /* broken by new version of MTK RIL, disable for now */
+    /*
+    public void handle3GSwitch() {
+        int simId = mInstanceId == null ? 0 : mInstanceId;
+        int newsim = SystemProperties.getInt("gsm.3gswitch", 0);
+        newsim = newsim - 1;
+        if(!(simId==newsim)) {
+            int prop = SystemProperties.getInt("gsm.3gswitch", 0);
+            if (RILJ_LOGD) riljLog("Setting data subscription on SIM" + (simId + 1) + " mInstanceid=" + mInstanceId + " gsm.3gswitch=" + prop);
+            RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_3G_CAPABILITY, null);
+            rr.mParcel.writeInt(1);
+            int realsim = simId + 1;
+            rr.mParcel.writeInt(realsim);
+            if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+            send(rr);
+            try {
+                Thread.sleep(1000);
+            } catch (InterruptedException er) {
+            }
+            resetRadio(null);
+            try {
+                Thread.sleep(4*1000);
+            } catch (InterruptedException er) {
+            }
+        }
+        else {
+            if (RILJ_LOGD) riljLog("Not setting data subscription on same SIM");
+        }
+    }
+
+    public void setDataAllowed(boolean allowed, Message result) {
+        handle3GSwitch();
+
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ALLOW_DATA, result);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " " + allowed);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(allowed ? 1 : 0);
+        send(rr);
+    }
+    */
+
+    @Override
+    public void connectRilSocket() {
+        if (RILJ_LOGD) {
+            riljLog("[RIL SWITCH]reconnectRilSocket()");
+        }
+        if (mReceiverThread == null && mReceiver == null) {
+            connectRild();
+        } else {
+            if (RILJ_LOGD) {
+                riljLog("[RIL SWITCH] Already connected, abort connect request.");
+            }
+        }
+    }
+
+    @Override
+    public void disconnectRilSocket() {
+        if (RILJ_LOGD) {
+            riljLog("[RIL SWITCH]disconnectRilSocket()");
+        }
+        if (mSenderThread != null) {
+            mSenderThread.getLooper().quit();
+            mSenderThread = null;
+        }
+        if (mReceiver != null) {
+            if (mReceiver instanceof MTKRILReceiver) {
+                ((MTKRILReceiver) mReceiver).mStoped = true;
+            }
+        }
+
+        try {
+            if (mSocket != null) {
+                mSocket.shutdownInput();
+            }
+            if (mReceiverThread != null) {
+                while (mReceiverThread.isAlive()) {
+                    riljLog("[RIL SWITCH]mReceiverThread.isAlive() = true;");
+                    Thread.sleep(500);
+                }
+            }
+            mReceiverThread = null;
+            mReceiver = null;
+            // Set mRilVersion to -1, it will not notifyRegistrant in registerForRilConnected.
+            mRilVersion = -1;
+        } catch (IOException ex) {
+            if (RILJ_LOGD) {
+                riljLog("[RIL SWITCH]IOException ex = " + ex);
+            }
+        } catch (InterruptedException er) {
+            if (RILJ_LOGD) {
+                riljLog("[RIL SWITCH]InterruptedException er = " + er);
+            }
+        }
+    }
+
+    // ported from sprout RIL
+    protected Object
+    responseFailCause(Parcel p) {
+        int numInts;
+        int response[];
+
+        numInts = p.readInt();
+        response = new int[numInts];
+        for (int i = 0 ; i < numInts ; i++) {
+            response[i] = p.readInt();
+        }
+        LastCallFailCause failCause = new LastCallFailCause();
+        failCause.causeCode = response[0];
+        if (p.dataAvail() > 0) {
+          failCause.vendorCause = p.readString();
+        }
+        return failCause;
+    }
+
+    // CommandsInterface impl
+
+    public void setUiccSubscription(int slotId, int appIndex, int subId,
+            int subStatus, Message result) {
+        //Note: This RIL request is also valid for SIM and RUIM (ICC card)
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_UICC_SUBSCRIPTION, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " slot: " + slotId + " appIndex: " + appIndex
+                + " subId: " + subId + " subStatus: " + subStatus);
+
+        rr.mParcel.writeInt(slotId);
+        rr.mParcel.writeInt(appIndex);
+        rr.mParcel.writeInt(subId);
+        rr.mParcel.writeInt(subStatus);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    supplyNetworkDepersonalization(String netpin, String type, Message result) {
+        riljLog("supplyNetworkDepersonalization: type is ignored on MTK!");
+        supplyNetworkDepersonalization(netpin, result);
+    }
+
+    @Override
+    public void
+    supplyNetworkDepersonalization(String netpin, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeString(netpin);
+
+        send(rr);
+    }
+
+    // xen0n refactored
+    @Override
+    public void
+    dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        if (PhoneNumberUtils.isUriNumber(address)) {
+           RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL_WITH_SIP_URI, result);
+
+           rr.mParcel.writeString(address);
+           if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+           send(rr);
+           return;
+        }
+
+        super.dial(address, clirMode, uusInfo, result);
+    }
+
+    @Override
+    public void
+    switchWaitingOrHoldingAndActive (Message result) {
+        RILRequest rr
+                = RILRequest.obtain(
+                        RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE,
+                                        result);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        /// M: CC012: DTMF request special handling @{
+        handleChldRelatedRequest(rr);
+        /// @}
+    }
+
+    @Override
+    public void
+    conference (Message result) {
+
+        /// M: CC053: MoMS [Mobile Managerment] @{
+        // 3. Permission Control for Conference call
+        /*
+        if (MobileManagerUtils.isSupported()) {
+            if (!checkMoMSSubPermission(SubPermissions.MAKE_CONFERENCE_CALL)) {
+                return;
+            }
+        }
+        */
+        /// @}
+
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_CONFERENCE, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        /// M: CC012: DTMF request special handling @{
+        handleChldRelatedRequest(rr);
+        ///@}
+    }
+
+    @Override
+    public void
+    separateConnection (int gsmIndex, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SEPARATE_CONNECTION, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                            + " " + gsmIndex);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(gsmIndex);
+
+        /// M: CC012: DTMF request special handling @{
+        handleChldRelatedRequest(rr);
+        /// @}
+    }
+
+    @Override
+    public void
+    explicitCallTransfer (Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_EXPLICIT_CALL_TRANSFER, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        /// M: CC012: DTMF request special handling @{
+        handleChldRelatedRequest(rr);
+        /// @}
+    }
+
+    @Override
+    public void
+    startDtmf(char c, Message result) {
+        /// M: CC012: DTMF request special handling @{
+        /* DTMF request will be ignored when the count of requests reaches 32 */
+        synchronized (mDtmfReqQueue) {
+            if (!mDtmfReqQueue.hasSendChldRequest() && mDtmfReqQueue.size() < mDtmfReqQueue.MAXIMUM_DTMF_REQUEST) {
+                if (!mDtmfReqQueue.isStart()) {
+                    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DTMF_START, result);
+
+                    rr.mParcel.writeString(Character.toString(c));
+                    mDtmfReqQueue.start();
+                    mDtmfReqQueue.add(rr);
+                    if (mDtmfReqQueue.size() == 1) {
+                        riljLog("send start dtmf");
+                        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+                        send(rr);
+                    }
+                } else {
+                    riljLog("DTMF status conflict, want to start DTMF when status is " + mDtmfReqQueue.isStart());
+                }
+            }
+        }
+        /// @}
+    }
+
+    @Override
+    public void
+    stopDtmf(Message result) {
+        /// M: CC012: DTMF request special handling @{
+        /* DTMF request will be ignored when the count of requests reaches 32 */
+        synchronized (mDtmfReqQueue) {
+            if (!mDtmfReqQueue.hasSendChldRequest() && mDtmfReqQueue.size() < mDtmfReqQueue.MAXIMUM_DTMF_REQUEST) {
+                if (mDtmfReqQueue.isStart()) {
+                    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DTMF_STOP, result);
+
+                    mDtmfReqQueue.stop();
+                    mDtmfReqQueue.add(rr);
+                    if (mDtmfReqQueue.size() == 1) {
+                        riljLog("send stop dtmf");
+                        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+                        send(rr);
+                    }
+                } else {
+                    riljLog("DTMF status conflict, want to start DTMF when status is " + mDtmfReqQueue.isStart());
+                }
+            }
+        }
+        /// @}
+    }
+
+    @Override
+    public void
+    setupDataCall(String radioTechnology, String profile, String apn,
+            String user, String password, String authType, String protocol,
+            Message result) {
+        /* [Note by mtk01411] In original Android2.1 release: MAX PDP Connection is 1
+        * request_cid is only allowed to set as "1" manually
+        */
+        setupDataCall(radioTechnology, profile, apn, user, password, authType, protocol, "1", result);
+    }
+
+    @Override
+    public void
+    setupDataCall(String radioTechnology, String profile, String apn,
+            String user, String password, String authType, String protocol,
+            String interfaceId, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result);
+
+        rr.mParcel.writeInt(8); //the number should be changed according to number of parameters
+
+        rr.mParcel.writeString(radioTechnology);
+        rr.mParcel.writeString(profile);
+        rr.mParcel.writeString(apn);
+        rr.mParcel.writeString(user);
+        rr.mParcel.writeString(password);
+        rr.mParcel.writeString(authType);
+        rr.mParcel.writeString(protocol);
+
+        /** M: specify interface Id */
+        rr.mParcel.writeString(interfaceId);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                + requestToString(rr.mRequest) + " " + radioTechnology + " "
+                + profile + " " + apn + " " + user + " "
+                + password + " " + authType + " " + protocol + " " + interfaceId);
+
+        send(rr);
+    }
+
+    @Override
+    public void setModemPower(boolean power, Message result) {
+
+        if (RILJ_LOGD) riljLog("Set Modem power as: " + power);
+        RILRequest rr;
+
+        if (power) {
+            rr = RILRequest.obtain(RIL_REQUEST_MODEM_POWERON, result);
+        }
+        else {
+            rr = RILRequest.obtain(RIL_REQUEST_MODEM_POWEROFF, result);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+            + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /* M: SS part */
+    // mtk00732 add for getCOLP
+    public void
+    getCOLP(Message result) {
+        RILRequest rr
+                //= RILRequest.obtain(RIL_REQUEST_GET_COLP, result, mySimId);
+                = RILRequest.obtain(RIL_REQUEST_GET_COLP, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    // mtk00732 add for setCOLP
+    public void
+    setCOLP(boolean enable, Message result) {
+        RILRequest rr
+                //= RILRequest.obtain(RIL_REQUEST_SET_COLP, result, mySimId);
+                = RILRequest.obtain(RIL_REQUEST_SET_COLP, result);
+
+        // count ints
+        rr.mParcel.writeInt(1);
+
+        if (enable) {
+            rr.mParcel.writeInt(1);
+        } else {
+            rr.mParcel.writeInt(0);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + enable);
+
+        send(rr);
+    }
+
+    // mtk00732 add for getCOLR
+    public void
+    getCOLR(Message result) {
+        RILRequest rr
+                //= RILRequest.obtain(RIL_REQUEST_GET_COLR, result, mySimId);
+                = RILRequest.obtain(RIL_REQUEST_GET_COLR, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+    /* M: SS part end */
+
+    @Override
+    public void
+    getAvailableNetworks(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void
+    cancelAvailableNetworks(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    /* M: SS part */
+    ///M: For query CNAP
+    public void sendCNAPSS(String cnapssString, Message response) {
+        RILRequest rr
+                //= RILRequest.obtain(RIL_REQUEST_SEND_CNAP, response, mySimId);
+                = RILRequest.obtain(RIL_REQUEST_SEND_CNAP, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " " + cnapssString);
+
+        rr.mParcel.writeString(cnapssString);
+
+        send(rr);
+    }
+    /* M: SS part end */
+
+    public void setBandMode(int[] bandMode, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_BAND_MODE, response);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeInt(bandMode[0]);
+        rr.mParcel.writeInt(bandMode[1]);
+        rr.mParcel.writeInt(bandMode[2]);
+
+        Rlog.d(RILJ_LOG_TAG, "Set band modes: " + bandMode[1] + ", " + bandMode[2]);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                 + " " + bandMode);
+
+        send(rr);
+     }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void handleCallSetupRequestFromSim(
+            boolean accept, int resCode, Message response) {
+
+        RILRequest rr = RILRequest.obtain(
+            RILConstants.RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM,
+            response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        int[] param = new int[1];
+        if (resCode == 0x21 || resCode == 0x20) {
+            param[0] = resCode;
+        } else {
+            param[0] = accept ? 1 : 0;
+        }
+        rr.mParcel.writeIntArray(param);
+        send(rr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void queryUtkSetupMenuFromMD(String contents, Message response) {
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_QUERY_UTK_MENU_FROM_MD, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void queryStkSetUpMenuFromMD(String contents, Message response) {
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_QUERY_STK_MENU_FROM_MD, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setPreferredNetworkType(int networkType , Message response) {
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(networkType);
+
+        mPreviousPreferredType = mPreferredNetworkType; //ALPS00799783
+        mPreferredNetworkType = networkType;
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " : " + networkType);
+        }
+
+        send(rr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setLocationUpdates(boolean enable, Message response) {
+        //MTK-START [ALPS00093395]Consider screen on/off state
+        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+        if ((pm.isScreenOn()) && (false == enable)) return;
+        //MTK-END [ALPS00093395]Consider screen on/off state
+
+        super.setLocationUpdates(enable, response);
+    }
+
+    @Override
+    protected Object
+    responseInts(Parcel p) {
+        int numInts;
+        int response[];
+
+        numInts = p.readInt();
+
+        response = new int[numInts];
+        // MTK
+        riljLog("responseInts numInts=" + numInts);
+
+        for (int i = 0 ; i < numInts ; i++) {
+            response[i] = p.readInt();
+            // MTK
+            riljLog("responseInts response[" + i + "]=" + response[i]);
+        }
+
+        return response;
+    }
+
+    protected Object
+    responseStringEncodeBase64(Parcel p) {
+        String response;
+
+        response = p.readString();
+
+        if (RILJ_LOGD) {
+            riljLog("responseStringEncodeBase64 - Response = " + response);
+        }
+
+        byte[] auth_output = new byte[response.length() / 2];
+        for (int i = 0; i < auth_output.length; i++) {
+            auth_output[i] |= Character.digit(response.charAt(i * 2), 16) * 16;
+            auth_output[i] |= Character.digit(response.charAt(i * 2 + 1), 16);
+        }
+        response = android.util.Base64.encodeToString(auth_output, android.util.Base64.NO_WRAP);
+
+        if (RILJ_LOGD) {
+            riljLog("responseStringEncodeBase64 - Encoded Response = " + response);
+        }
+
+        return response;
+    }
+
+    @Override
+    protected Object
+    responseSimRefresh(Parcel p) {
+        IccRefreshResponse response = new IccRefreshResponse();
+
+        int i = 0;
+        int files_num = 0;
+        String efId_String;
+
+        if (SystemProperties.get("ro.mtk_wifi_calling_ril_support").equals("1")) {
+            response.sessionId = p.readInt();
+            //files_num = numInts - 2; //sessionid + refresh type
+        } else {
+            //files_num = numInts - 1; //refresh type
+        }
+        //refresh type
+        response.refreshResult = p.readInt();
+        //efIds hex string
+        efId_String = p.readString();
+        if (null != efId_String && 4 <= efId_String.length()) {
+            files_num = efId_String.length() / 4;
+        }
+        response.efId = new int[files_num];
+        riljLog("efId_String: " + efId_String + ", files_num: " + files_num);
+
+        int startIdx = 0;
+        int endIdx = 0;
+        if (null != efId_String && 4 <= efId_String.length()) {
+            for (i = 0; i < files_num; i++) {
+                String efidStr = efId_String.substring(startIdx, startIdx + 4);
+                response.efId[i] = (Integer.valueOf(efidStr, 16)).intValue();
+                startIdx += 4;
+                riljLog("EFId " + i + ":" + response.efId[i]);
+            }
+        }
+        /*
+        for (i = 0; i < files_num; i++) {
+            response.efId[i] = p.readInt();
+            riljLog("EFId " + i + ":" + response.efId[i]);
+        }
+        */
+        response.aid = p.readString();
+
+        if (SystemProperties.get("ro.mtk_wifi_calling_ril_support").equals("1")) {
+            riljLog("responseSimRefresh, sessionId=" + response.sessionId + ", result=" + response.refreshResult
+                + ", efId=" + response.efId + ", aid=" + response.aid);
+        }
+
+        return response;
+    }
+
+    @Override
+    protected Object
+    responseCallList(Parcel p) {
+        int num;
+        int voiceSettings;
+        ArrayList<DriverCall> response;
+        DriverCall dc;
+
+        num = p.readInt();
+        response = new ArrayList<DriverCall>(num);
+
+        if (RILJ_LOGV) {
+            riljLog("responseCallList: num=" + num +
+                    " mEmergencyCallbackModeRegistrant=" + mEmergencyCallbackModeRegistrant +
+                    " mTestingEmergencyCall=" + mTestingEmergencyCall.get());
+        }
+        for (int i = 0 ; i < num ; i++) {
+            dc = new DriverCall();
+
+            dc.state = DriverCall.stateFromCLCC(p.readInt());
+            dc.index = p.readInt();
+            dc.TOA = p.readInt();
+            dc.isMpty = (0 != p.readInt());
+            dc.isMT = (0 != p.readInt());
+            dc.als = p.readInt();
+            voiceSettings = p.readInt();
+            dc.isVoice = (0 == voiceSettings) ? false : true;
+            /// M: For 3G VT only @{
+            // Assume that call can be either Voice or Video (no Fax, data type is supported)
+            dc.isVideo = !(dc.isVoice);
+            riljLog("isVoice = " + dc.isVoice + ", isVideo = " + dc.isVideo);
+            /// @}
+            dc.isVoicePrivacy = (0 != p.readInt());
+            dc.number = p.readString();
+            int np = p.readInt();
+            dc.numberPresentation = DriverCall.presentationFromCLIP(np);
+            dc.name = p.readString();
+            // according to ril.h, namePresentation should be handled as numberPresentation;
+            dc.namePresentation = DriverCall.presentationFromCLIP(p.readInt());
+            int uusInfoPresent = p.readInt();
+            if (uusInfoPresent == 1) {
+                dc.uusInfo = new UUSInfo();
+                dc.uusInfo.setType(p.readInt());
+                dc.uusInfo.setDcs(p.readInt());
+                byte[] userData = p.createByteArray();
+                dc.uusInfo.setUserData(userData);
+                riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d",
+                                dc.uusInfo.getType(), dc.uusInfo.getDcs(),
+                                dc.uusInfo.getUserData().length));
+                riljLogv("Incoming UUS : data (string)="
+                        + new String(dc.uusInfo.getUserData()));
+                riljLogv("Incoming UUS : data (hex): "
+                        + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
+            } else {
+                riljLogv("Incoming UUS : NOT present!");
+            }
+
+            // Make sure there's a leading + on addresses with a TOA of 145
+            dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
+
+            response.add(dc);
+
+            if (dc.isVoicePrivacy) {
+                mVoicePrivacyOnRegistrants.notifyRegistrants();
+                riljLog("InCall VoicePrivacy is enabled");
+            } else {
+                mVoicePrivacyOffRegistrants.notifyRegistrants();
+                riljLog("InCall VoicePrivacy is disabled");
+            }
+        }
+
+        Collections.sort(response);
+
+        if ((num == 0) && mTestingEmergencyCall.getAndSet(false)) {
+            if (mEmergencyCallbackModeRegistrant != null) {
+                riljLog("responseCallList: call ended, testing emergency call," +
+                            " notify ECM Registrants");
+                mEmergencyCallbackModeRegistrant.notifyRegistrant();
+            }
+        }
+
+        return response;
+    }
+
+    // slightly modified from the original MediaTekRIL
+    private Object
+    responseOperator(Parcel p) {
+        int num;
+        String response[] = null;
+
+        response = p.readStringArray();
+
+        for (int i = 0; i < response.length; i++) {
+            if((response[i] != null) && (response[i].startsWith("uCs2") == true))
+            {
+                riljLog("responseOperator handling UCS2 format name: response[" + i + "]");
+                try{
+                    response[i] = new String(IccUtils.hexStringToBytes(response[i].substring(4)),"UTF-16");
+                }catch(UnsupportedEncodingException ex){
+                    riljLog("responseOperatorInfos UnsupportedEncodingException");
+                }
+            }
+        }
+
+        // NOTE: the original code seemingly has some nontrivial SpnOverride
+        // modifications, so I'm not going to port that.
+        if (response.length > 2 && response[2] != null) {
+            if (response[0] != null && (response[0].equals("") || response[0].equals(response[2]))) {
+                // xen0n: seems the Operators class is now gone
+                // Operators init = new Operators ();
+                // String temp = init.unOptimizedOperatorReplace(response[2]);
+
+                // NOTE: using MTK methods here! (all the used methods are not visible from this class)
+                SpnOverride spnOverride = SpnOverride.getInstance();
+                final String mccmnc = response[2];
+                final String temp = spnOverride.containsCarrierEx(mccmnc) ? spnOverride.getSpnEx(mccmnc) : mccmnc;
+                riljLog("lookup RIL responseOperator() " + response[2] + " gave " + temp + " was " + response[0] + "/" + response[1] + " before.");
+                response[0] = temp;
+                response[1] = temp;
+            }
+        }
+
+        return response;
+    }
+
+    // MTK TODO
+    /*
+    @Override
+    protected Object
+    responseOperatorInfos(Parcel p) {
+        String strings[] = (String [])responseStrings(p);
+        ArrayList<OperatorInfo> ret;
+
+        SpnOverride spnOverride = SpnOverride.getInstance();
+
+        if (strings.length % 4 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got "
+                + strings.length + " strings, expected multible of 4");
+        }
+
+        ret = new ArrayList<OperatorInfo>(strings.length / 4);
+
+        for (int i = 0 ; i < strings.length ; i += 4) {
+            String strOperatorLong = null;
+            if (spnOverride.containsCarrierEx(strings[i + 2])) {
+                strOperatorLong = spnOverride.getSpnEx(strings[i + 2]);
+            } else {
+                strOperatorLong = strings[i + 0]; // use operator name from RIL
+            }
+            ret.add (
+                new OperatorInfo(
+                    strOperatorLong,
+                    strings[i+1],
+                    strings[i+2],
+                    strings[i+3]));
+        }
+
+        return ret;
+    }
+    */
+
+    protected Object
+    responseOperatorInfosWithAct(Parcel p) {
+        String strings[] = (String []) responseStrings(p);
+        ArrayList<OperatorInfo> ret;
+
+        if (strings.length % 5 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT: invalid response. Got "
+                + strings.length + " strings, expected multible of 5");
+        }
+
+        String lacStr = SystemProperties.get("gsm.cops.lac");
+        boolean lacValid = false;
+        int lacIndex = 0;
+
+        Rlog.d(RILJ_LOG_TAG, "lacStr = " + lacStr + " lacStr.length=" + lacStr.length() + " strings.length=" + strings.length);
+        if ((lacStr.length() > 0) && (lacStr.length() % 4 == 0) && ((lacStr.length() / 4) == (strings.length / 5))) {
+            Rlog.d(RILJ_LOG_TAG, "lacValid set to true");
+            lacValid = true;
+        }
+
+        SystemProperties.set("gsm.cops.lac", ""); //reset property
+
+        ret = new ArrayList<OperatorInfo>(strings.length / 5);
+
+        for (int i = 0 ; i < strings.length ; i += 5) {
+            /* Default display manufacturer maintained operator name table */
+            if (strings[i + 2] != null) {
+                strings[i + 0] = SpnOverride.getInstance().lookupOperatorName(SubscriptionManager.getSubIdUsingPhoneId(mInstanceId), strings[i + 2], true, mContext);
+                strings[i + 1] = SpnOverride.getInstance().lookupOperatorName(SubscriptionManager.getSubIdUsingPhoneId(mInstanceId), strings[i + 2], false, mContext);
+                riljLog("lookup RIL responseOperator(), longAlpha= " + strings[i + 0] + ",shortAlpha= " + strings[i + 1] + ",numeric=" + strings[i + 2]);
+            }
+
+            String longName = null;
+            String shortName = null;
+            /* Operator name from network MM information has higher priority to display */
+            longName = lookupOperatorNameFromNetwork(SubscriptionManager.getSubIdUsingPhoneId(mInstanceId), strings[i + 2], true);
+            shortName = lookupOperatorNameFromNetwork(SubscriptionManager.getSubIdUsingPhoneId(mInstanceId), strings[i + 2], false);
+            if (longName != null) {
+                strings[i + 0] = longName;
+            }
+            if (shortName != null) {
+                strings[i + 1] = shortName;
+            }
+            riljLog("lookupOperatorNameFromNetwork in responseOperatorInfosWithAct(),updated longAlpha= " + strings[i + 0] + ",shortAlpha= " + strings[i + 1] + ",numeric=" + strings[i + 2]);
+
+            // Not to show MVNO name for registered operator name display for certain SIM @{
+            // MTK TODO
+            /*
+            if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                int phoneNum = TelephonyManager.getDefault().getPhoneCount();
+                int[] cardType = new int[phoneNum];
+                int targetCardType;
+                String strOperatorOverride = "";
+                boolean isCdma3GDualModeOr4GSim = false;
+                SpnOverride spnOverride = SpnOverride.getInstance();
+
+                if ((strings[i + 2].equals("45403")) || (strings[i + 2].equals("45404"))) {
+                    cardType = UiccController.getInstance().getC2KWPCardType();
+                    //FIX ME in svlte solution 2
+                    if (mInstanceId == PhoneConstants.SIM_ID_1) {
+                        targetCardType = cardType[PhoneConstants.SIM_ID_1];
+
+                        if (((targetCardType & UiccController.CARD_TYPE_RUIM) > 0 || (targetCardType & UiccController.CARD_TYPE_CSIM) > 0)
+                            && ((targetCardType & UiccController.CARD_TYPE_USIM) > 0)
+                            || SvlteUiccUtils.getInstance().isCt3gDualMode(
+                                    PhoneConstants.SIM_ID_1)) {
+                                isCdma3GDualModeOr4GSim = true;
+                        }
+
+                        if ((spnOverride != null) && (spnOverride.containsCarrierEx(strings[i + 2]))) {
+                            strOperatorOverride = spnOverride.getSpnEx(strings[i + 2]);
+                        }
+
+                        riljLog("targetCardType= " + targetCardType + " strOperatorOverride= " + strOperatorOverride
+                                + " isCdma3GDualModeOr4GSim=" + isCdma3GDualModeOr4GSim
+                                + " opNumeric= " + strings[i + 2]);
+
+                        if (isCdma3GDualModeOr4GSim == true) {
+                            riljLog("longAlpha: " + strings[i + 0] + " is overwritten to " + strOperatorOverride);
+                            strings[i + 0] = strOperatorOverride;
+                        }
+                    }
+                }
+            }
+            */
+            ///Not to show MVNO name for registered operator name display for certain SIM.@}
+
+
+            /* Operator name from SIM (EONS/CPHS) has highest priority to display. This will be handled in GsmSST updateSpnDisplay() */
+            /* ALPS00353868: To get operator name from OPL/PNN/CPHS, which need lac info */
+            // MTK TODO
+            /*
+            if ((lacValid == true) && (strings[i + 0] != null)) {
+                int phoneId = mInstanceId;
+                if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                       phoneId = SvlteUtils.getSlotId(phoneId);
+                }
+                UiccController uiccController = UiccController.getInstance();
+                SIMRecords simRecord = (SIMRecords) uiccController.getIccRecords(mInstanceId, UiccController.APP_FAM_3GPP);
+                int lacValue = -1;
+                String sEons = null;
+                String lac = lacStr.substring(lacIndex, lacIndex + 4);
+                Rlog.d(RILJ_LOG_TAG, "lacIndex=" + lacIndex + " lacValue=" + lacValue + " lac=" + lac + " plmn numeric=" + strings[i + 2] + " plmn name" + strings[i + 0]);
+
+                if (lac != "") {
+                    lacValue = Integer.parseInt(lac, 16);
+                    lacIndex += 4;
+                    if (lacValue != 0xfffe) {
+                        sEons = simRecord.getEonsIfExist(strings[i + 2], lacValue, true);
+                        if (sEons != null) {
+                            strings[i + 0] = sEons;
+                            Rlog.d(RILJ_LOG_TAG, "plmn name update to Eons: " + strings[i + 0]);
+                        } else {
+                            //[ALPS01858353]-Start: The CPHS operator name shall only be used for HPLMN name dispaly
+                            String mSimOperatorNumeric = simRecord.getOperatorNumeric();
+                            if ((mSimOperatorNumeric != null) &&
+                                    (mSimOperatorNumeric.equals(strings[i + 2]))) {
+                                String sCphsOns = null;
+                                sCphsOns = simRecord.getSIMCPHSOns();
+                                if (sCphsOns != null) {
+                                    strings[i + 0] = sCphsOns;
+                                    Rlog.d(RILJ_LOG_TAG, "plmn name update to CPHS Ons: "
+                                            + strings[i + 0]);
+                                }
+                            }
+                            //[ALPS01858353]-End
+                        }
+                    } else {
+                        Rlog.d(RILJ_LOG_TAG, "invalid lac ignored");
+                    }
+                }
+            }
+            */
+            // ALPS00353868 END
+
+            /* ALPS01597054 Always show Act info(ex: "2G","3G","4G") for PLMN list result */
+            strings[i + 0] = strings[i + 0].concat(" " + strings[i + 4]);
+            strings[i + 1] = strings[i + 1].concat(" " + strings[i + 4]);
+
+            ret.add(
+                new OperatorInfo(
+                    strings[i + 0],
+                    strings[i + 1],
+                    strings[i + 2],
+                    strings[i + 3]));
+        }
+        return ret;
+    }
+
+    @Override
+    protected Object
+    responseCellList(Parcel p) {
+       int num, rssi;
+       String location;
+       ArrayList<NeighboringCellInfo> response;
+       NeighboringCellInfo cell;
+
+       num = p.readInt();
+       response = new ArrayList<NeighboringCellInfo>();
+
+       // ALPS00269882 START
+       // Get the radio access type
+       /*
+       int[] subId = SubscriptionManager.getSubId(mInstanceId);
+       int radioType =
+               ((TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE)).
+               getDataNetworkType(subId[0]);
+       */
+       int radioType = SystemProperties.getInt("gsm.enbr.rat", NETWORK_TYPE_GPRS);
+       riljLog("gsm.enbr.rat=" + radioType);
+       // ALPS00269882 END
+
+       // Interpret the location based on radio access type
+       if (radioType != NETWORK_TYPE_UNKNOWN) {
+           for (int i = 0 ; i < num ; i++) {
+               rssi = p.readInt();
+               location = p.readString();
+               cell = new NeighboringCellInfo(rssi, location, radioType);
+               response.add(cell);
+           }
+       }
+       return response;
+    }
+
+    protected Object responseSetPreferredNetworkType(Parcel p) {
+        int count = getRequestCount(RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE);
+        if (count == 0) {
+            Intent intent = new Intent(
+                    TelephonyIntents.ACTION_RAT_CHANGED);
+            intent.putExtra(PhoneConstants.PHONE_KEY, mInstanceId);
+            intent.putExtra(TelephonyIntents.EXTRA_RAT, mPreferredNetworkType);
+            mContext.sendBroadcast(intent);
+        }
+        riljLog("SetRatRequestCount: " + count);
+
+        return null;
+    }
+
+    private int getRequestCount(int reuestId) {
+        int count = 0;
+        synchronized (mRequestList) {
+            for (int i = 0, s = mRequestList.size() ; i < s ; i++) {
+                RILRequest rr = mRequestList.valueAt(i);
+                if (rr != null && rr.mRequest == reuestId) {
+                    count++;
+                }
+            }
+        }
+        return count;
+    }
+
+    //MTK-START Femtocell (CSG)
+    protected Object
+    responseFemtoCellInfos(Parcel p) {
+        String strings[] = (String []) responseStrings(p);
+        ArrayList<FemtoCellInfo> ret;
+
+        if (strings.length % 6 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_GET_FEMTOCELL_LIST: invalid response. Got "
+                + strings.length + " strings, expected multible of 6");
+        }
+
+        ret = new ArrayList<FemtoCellInfo>(strings.length / 6);
+
+        /* <plmn numeric>,<act>,<plmn long alpha name>,<csgId>,,csgIconType>,<hnbName> */
+        for (int i = 0 ; i < strings.length ; i += 6) {
+            String actStr;
+            String hnbName;
+            int rat;
+
+            /* ALPS00273663 handle UCS2 format name : prefix + hex string ex: "uCs2806F767C79D1" */
+            if ((strings[i + 1] != null) && (strings[i + 1].startsWith("uCs2") == true))
+            {
+                Rlog.d(RILJ_LOG_TAG, "responseOperatorInfos handling UCS2 format name");
+
+                try {
+                    strings[i + 0] = new String(IccUtils.hexStringToBytes(strings[i + 1].substring(4)), "UTF-16");
+                } catch (UnsupportedEncodingException ex) {
+                    Rlog.d(RILJ_LOG_TAG, "responseOperatorInfos UnsupportedEncodingException");
+                }
+            }
+
+            if (strings[i + 1] != null && (strings[i + 1].equals("") || strings[i + 1].equals(strings[i + 0]))) {
+                Rlog.d(RILJ_LOG_TAG, "lookup RIL responseFemtoCellInfos() for plmn id= " + strings[i + 0]);
+                strings[i + 1] = SpnOverride.getInstance().lookupOperatorName(SubscriptionManager.getSubIdUsingPhoneId(mInstanceId), strings[i + 0], true, mContext);
+            }
+
+            if (strings[i + 2].equals("7")) {
+                actStr = "4G";
+                rat = ServiceState.RIL_RADIO_TECHNOLOGY_LTE;
+            } else if (strings[i + 2].equals("2")) {
+                actStr = "3G";
+                rat = ServiceState.RIL_RADIO_TECHNOLOGY_UMTS;
+            } else {
+                actStr = "2G";
+                rat = ServiceState.RIL_RADIO_TECHNOLOGY_GPRS;
+            }
+
+            //1 and 2 is 2g. above 2 is 3g
+            String property_name = "gsm.baseband.capability";
+            if (mInstanceId > PhoneConstants.SIM_ID_1) {
+                property_name = property_name + (mInstanceId + 1) ;
+            }
+
+            int basebandCapability = SystemProperties.getInt(property_name, 3);
+            Rlog.d(RILJ_LOG_TAG, "property_name=" + property_name + ",basebandCapability=" + basebandCapability);
+            if (3 < basebandCapability) {
+                strings[i + 1] = strings[i + 1].concat(" " + actStr);
+            }
+
+            hnbName = new String(IccUtils.hexStringToBytes(strings[i + 5]));
+
+            Rlog.d(RILJ_LOG_TAG, "FemtoCellInfo(" + strings[i + 3] + "," + strings[i + 4] + "," + strings[i + 5] + "," + strings[i + 0] + "," + strings[i + 1] + "," + rat + ")" + "hnbName=" + hnbName);
+
+            ret.add(
+                new FemtoCellInfo(
+                    Integer.parseInt(strings[i + 3]),
+                    Integer.parseInt(strings[i + 4]),
+                    hnbName,
+                    strings[i + 0],
+                    strings[i + 1],
+                    rat));
+        }
+
+        return ret;
+    }
+    //MTK-END Femtocell (CSG)
+
+    // xen0n refactored
+    @Override
+    public void requestIsimAuthentication(String nonce, Message response) {
+        if (SystemProperties.get("ro.mtk_tc1_feature").equals("1")) {
+            byte[] result = android.util.Base64.decode(nonce, android.util.Base64.DEFAULT);
+            StringBuilder mStringBuilder = new StringBuilder(result.length * 2);
+            for (byte mByte: result)
+               mStringBuilder.append(String.format("%02x", mByte & 0xff));
+            nonce = mStringBuilder.toString();
+            if (RILJ_LOGD) riljLog("requestIsimAuthentication - nonce = " + nonce);
+        }
+
+        super.requestIsimAuthentication(nonce, response);
+    }
+
+    /** M: add extra parameter */
+    public void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, Message result) {
+        IaExtendParam param = new IaExtendParam();
+        setInitialAttachApn(apn, protocol, authType, username, password, (Object) param, result);
+    }
+
+    public void setInitialAttachApn(String apn, String protocol, int authType, String username,
+            String password, Object obj, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_INITIAL_ATTACH_APN, null);
+
+        if (RILJ_LOGD) { riljLog("Set RIL_REQUEST_SET_INITIAL_ATTACH_APN"); }
+
+        rr.mParcel.writeString(apn);
+        rr.mParcel.writeString(protocol);
+        rr.mParcel.writeInt(authType);
+        rr.mParcel.writeString(username);
+        rr.mParcel.writeString(password);
+
+        /** M: start */
+        IaExtendParam param = (IaExtendParam) obj;
+        rr.mParcel.writeString(param.mOperatorNumeric);
+        rr.mParcel.writeInt(param.mCanHandleIms ? 1 : 0);
+        rr.mParcel.writeStringArray(param.mDualApnPlmnList);
+        /* M: end */
+
+        if (RILJ_LOGD) { riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + ", apn:" + apn + ", protocol:" + protocol + ", authType:" + authType
+                + ", username:" + username + ", password:" + password + " ," + param);
+        }
+
+        send(rr);
+    }
+
+    // xen0n: MTK REQUEST_SIM_GET_ATR has a different format, thus the AOSP
+    // impl has to be overriden.
+    @Override
+    public void getAtr(Message response) {
+        riljLog("getAtr: using MTK impl");
+        iccGetATR(response);
+    }
+
+    //MTK-START Support Multi-Application
+    @Override
+    public void openIccApplication(int application, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_OPEN_ICC_APPLICATION, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(application);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + ", application = " + application);
+        send(rr);
+    }
+
+    @Override
+    public void getIccApplicationStatus(int sessionId, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_ICC_APPLICATION_STATUS, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(sessionId);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + ", session = " + sessionId);
+        send(rr);
+    }
+
+    //MTK-END Support Multi-Application
+
+    @Override public void
+    queryNetworkLock(int category, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_SIM_NETWORK_LOCK, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        riljLog("queryNetworkLock:" + category);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(category);
+
+        send(rr);
+    }
+
+    @Override public void
+    setNetworkLock(int catagory, int lockop, String password,
+                        String data_imsi, String gid1, String gid2, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_SIM_NETWORK_LOCK, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        riljLog("setNetworkLock:" + catagory + ", " + lockop + ", " + password + ", " + data_imsi
+                + ", " + gid1 + ", " + gid2);
+
+        rr.mParcel.writeInt(6);
+        rr.mParcel.writeString(Integer.toString(catagory));
+        rr.mParcel.writeString(Integer.toString(lockop));
+        if (null != password) {
+            rr.mParcel.writeString(password);
+        } else {
+            rr.mParcel.writeString("");
+        }
+        rr.mParcel.writeString(data_imsi);
+        rr.mParcel.writeString(gid1);
+        rr.mParcel.writeString(gid2);
+
+        send(rr);
+    }
+
+    @Override public void
+    doGeneralSimAuthentication(int sessionId, int mode , int tag, String param1,
+                                         String param2, Message response) {
+
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GENERAL_SIM_AUTH, response);
+
+        rr.mParcel.writeInt(sessionId);
+        rr.mParcel.writeInt(mode);
+
+        // Calcuate param1 length in byte length
+        if (param1 != null && param1.length() > 0) {
+            String length = Integer.toHexString(param1.length() / 2);
+            length = (((length.length() % 2 == 1) ? "0" : "") + length);
+            // Session id is equal to 0, for backward compability, we use old AT command
+            // old AT command no need to include param's length
+            rr.mParcel.writeString(((sessionId == 0) ? param1 : (length + param1)));
+        } else {
+            rr.mParcel.writeString(param1);
+        }
+
+        // Calcuate param2 length in byte length
+        if (param2 != null && param2.length() > 0) {
+            String length = Integer.toHexString(param2.length() / 2);
+            length = (((length.length() % 2 == 1) ? "0" : "") + length);
+            // Session id is equal to 0, for backward compability, we use old AT command
+            // old AT command no need to include param's length
+            rr.mParcel.writeString(((sessionId == 0) ? param2 : (length + param2)));
+        } else {
+            rr.mParcel.writeString(param2);
+        }
+
+        if (mode == 1) {
+            rr.mParcel.writeInt(tag);
+        }
+
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " +
+            "session = " + sessionId + ",mode = " + mode + ",tag = " + tag + ", "  + param1 + ", " + param2);
+
+        send(rr);
+    }
+    // Added by M begin
+    @Override
+    public void
+    iccGetATR(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_GET_ATR, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void
+    iccOpenChannelWithSw(String AID, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_OPEN_CHANNEL_WITH_SW, result);
+
+        rr.mParcel.writeString(AID);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> iccOpenChannelWithSw: " + requestToString(rr.mRequest)
+                + " " + AID);
+
+        send(rr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void sendBTSIMProfile(int nAction, int nType, String strData, Message response) {
+        if (RILJ_LOGD) riljLog(" sendBTSIMProfile nAction is " + nAction);
+        switch (nAction) {
+            case 0:
+                requestConnectSIM(response);
+                break;
+            case 1:
+                requestDisconnectOrPowerOffSIM(nAction, response);
+                break;
+            case 2:
+                requestPowerOnOrResetSIM(nAction, nType, response);
+                break;
+            case 3:
+                requestDisconnectOrPowerOffSIM(nAction, response);
+                break;
+            case 4:
+                requestPowerOnOrResetSIM(nAction, nType, response);
+                break;
+            case 5:
+                requestTransferApdu(nAction, nType, strData, response);
+                break;
+        }
+    }
+
+    //***** Private Methods
+    /**
+    * used only by sendBTSIMProfile
+    */
+    private void requestConnectSIM(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_BTSIM_CONNECT, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+    * used only by sendBTSIMProfile
+    */
+    private void requestDisconnectOrPowerOffSIM(int nAction, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF, response);
+
+         rr.mParcel.writeString(Integer.toString(nAction));
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + nAction);
+
+        send(rr);
+    }
+
+    /**
+    * used only by sendBTSIMProfile
+    */
+    private void requestPowerOnOrResetSIM(int nAction, int nType, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM, response);
+
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeString(Integer.toString(nAction));
+        rr.mParcel.writeString(Integer.toString(nType));
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": "
+                + nAction + " nType: " + nType);
+
+        send(rr);
+    }
+
+    /**
+    * used only by sendBTSIMProfile
+    */
+    private void requestTransferApdu(int nAction, int nType, String strData, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_BTSIM_TRANSFERAPDU, response);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(Integer.toString(nAction));
+        rr.mParcel.writeString(Integer.toString(nType));
+        rr.mParcel.writeString(strData);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": "
+                + nAction + " nType: " + nType + " data: " + strData);
+
+        send(rr);
+    }
+    // Added by M end
+
+    /**
+     * {@inheritDoc}
+     */
+    public void queryPhbStorageInfo(int type, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_PHB_STORAGE_INFO, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(type);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + type);
+
+        send(rr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void writePhbEntry(PhbEntry entry, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_WRITE_PHB_ENTRY, result);
+
+        rr.mParcel.writeInt(entry.type);
+        rr.mParcel.writeInt(entry.index);
+        rr.mParcel.writeString(entry.number);
+        rr.mParcel.writeInt(entry.ton);
+        rr.mParcel.writeString(entry.alphaId);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + entry);
+
+        send(rr);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void ReadPhbEntry(int type, int bIndex, int eIndex, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_READ_PHB_ENTRY, response);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeInt(type);
+        rr.mParcel.writeInt(bIndex);
+        rr.mParcel.writeInt(eIndex);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": "
+                + type + " begin: " + bIndex + " end: " + eIndex);
+
+        send(rr);
+    }
+
+    private Object
+    responsePhbEntries(Parcel p) {
+        int numerOfEntries;
+        PhbEntry[] response;
+
+        numerOfEntries = p.readInt();
+        response = new PhbEntry[numerOfEntries];
+
+        Rlog.d(RILJ_LOG_TAG, "Number: " + numerOfEntries);
+
+        for (int i = 0; i < numerOfEntries; i++) {
+            response[i] = new PhbEntry();
+            response[i].type = p.readInt();
+            response[i].index = p.readInt();
+            response[i].number = p.readString();
+            response[i].ton = p.readInt();
+            response[i].alphaId = p.readString();
+        }
+
+        return response;
+    }
+
+    public void queryUPBCapability(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_UPB_CAPABILITY, response);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void editUPBEntry(int entryType, int adnIndex, int entryIndex, String strVal, String tonForNum, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_EDIT_UPB_ENTRY, response);
+        if (entryType == 0) {
+            rr.mParcel.writeInt(5);
+        } else {
+            rr.mParcel.writeInt(4);
+        }
+        rr.mParcel.writeString(Integer.toString(entryType));
+        rr.mParcel.writeString(Integer.toString(adnIndex));
+        rr.mParcel.writeString(Integer.toString(entryIndex));
+        rr.mParcel.writeString(strVal);
+
+        if (entryType == 0) {
+            rr.mParcel.writeString(tonForNum);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+
+    }
+
+    public void deleteUPBEntry(int entryType, int adnIndex, int entryIndex, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_DELETE_UPB_ENTRY, response);
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeInt(entryType);
+        rr.mParcel.writeInt(adnIndex);
+        rr.mParcel.writeInt(entryIndex);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void readUPBGasList(int startIndex, int endIndex, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_READ_UPB_GAS_LIST, response);
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeInt(startIndex);
+        rr.mParcel.writeInt(endIndex);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void readUPBGrpEntry(int adnIndex, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_READ_UPB_GRP, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(adnIndex);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void writeUPBGrpEntry(int adnIndex, int[] grpIds, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_WRITE_UPB_GRP, response);
+        int nLen = grpIds.length;
+        rr.mParcel.writeInt(nLen + 1);
+        rr.mParcel.writeInt(adnIndex);
+        for (int i = 0; i < nLen; i++) {
+            rr.mParcel.writeInt(grpIds[i]);
+        }
+        if (RILJ_LOGD) riljLog("writeUPBGrpEntry nLen is " + nLen);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+
+    }
+
+    private Object responseGetPhbMemStorage(Parcel p) {
+        /*
+        PBMemStorage response = PBMemStorage.createFromParcel(p);
+        riljLog("responseGetPhbMemStorage:" +  response);
+        return response;
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseGetPhbMemStorage: stub!");
+        return null;
+    }
+
+    // ALPS01977595 - KOR MVNO Operator Support
+    private Object responseReadPhbEntryExt(Parcel p) {
+        /*
+        int numerOfEntries;
+        PBEntry[] response;
+
+        numerOfEntries = p.readInt();
+        response = new PBEntry[numerOfEntries];
+
+        Rlog.d(RILJ_LOG_TAG, "responseReadPhbEntryExt Number: " + numerOfEntries);
+
+        for (int i = 0; i < numerOfEntries; i++) {
+            response[i] = new PBEntry();
+            response[i].setIndex1(p.readInt());
+            response[i].setNumber(p.readString());
+            response[i].setType(p.readInt());
+            response[i].setText(getAdnRecordFromPBEntry(p.readString()));
+            response[i].setHidden(p.readInt());
+            response[i].setGroup(p.readString());
+            response[i].setAdnumber(p.readString());
+            response[i].setAdtype(p.readInt());
+            response[i].setSecondtext(p.readString());
+            response[i].setEmail(getEmailRecordFromPBEntry(p.readString()));
+
+            Rlog.d(RILJ_LOG_TAG, "responseReadPhbEntryExt[" + i + "] " + response[i].toString());
+        }
+
+        return response;
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseReadPhbEntryExt: stub!");
+        return null;
+    }
+
+    public static String convertKSC5601(String input) {
+        Rlog.d(RILJ_LOG_TAG, "convertKSC5601");
+
+        String output = "";
+        try {
+            int    ucslen = 0;
+            byte[] inData = IccUtils.hexStringToBytes(input.substring(4));
+            if (inData != null)
+            {
+                String strKSC = new String(inData , "KSC5601");
+
+                if (strKSC != null) {
+                    ucslen = strKSC.length();
+                    while (ucslen > 0 && strKSC.charAt(ucslen - 1) == '\uF8F7')
+                        ucslen--;
+
+                    output = strKSC.substring(0, ucslen);
+                }
+            }
+        } catch (UnsupportedEncodingException ex) {
+            Rlog.d(RILJ_LOG_TAG, "Implausible UnsupportedEncodingException : " + ex);
+        }
+
+        return output;
+    }
+
+    public static String getEmailRecordFromPBEntry(String text) {
+        if (text == null)
+            return null;
+
+        String email = "";
+
+        if (text.trim().length() > 2 && text.startsWith("FEFE"))
+            email = convertKSC5601(text);
+        else
+            email = text;
+
+        Rlog.d(RILJ_LOG_TAG, "getEmailRecordFromPBEntry - email = " + email);
+
+        return email;
+    }
+
+    public static String getAdnRecordFromPBEntry(String text) {
+        if (text == null)
+            return null;
+
+        String alphaId = "";
+
+        if (text.trim().length() > 2 && text.startsWith("FEFE"))
+            alphaId = convertKSC5601(text);
+        else
+        {
+            Rlog.d(RILJ_LOG_TAG, "getRecordFromPBEntry - Not KSC5601 Data");
+            try {
+                byte[] ba = IccUtils.hexStringToBytes(text);
+                if (ba == null)
+                    return null;
+
+                alphaId = new String(ba, 0, text.length() / 2, "utf-16be");
+            } catch (UnsupportedEncodingException ex) {
+                Rlog.d(RILJ_LOG_TAG, "Implausible UnsupportedEncodingException : " + ex);
+            }
+        }
+
+        Rlog.d(RILJ_LOG_TAG, "getRecordFromPBEntry - alphaId = " + alphaId);
+
+        return alphaId;
+    }
+    // ALPS01977595 - KOR MVNO Operator Support
+
+    /**
+     * at+cpbr=?
+     * @return  <nlength><tlength><glength><slength><elength>
+     */
+    public void getPhoneBookStringsLength(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_PHB_STRING_LENGTH, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> :::" + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+     * at+cpbs?
+     * @return  PBMemStorage :: +cpbs:<storage>,<used>,<total>
+     */
+    public void getPhoneBookMemStorage(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_PHB_MEM_STORAGE, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> :::" + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+     * at+epin2=<p2>; at+cpbs=<storage>
+     * @return
+     */
+    public void setPhoneBookMemStorage(String storage, String password, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_PHB_MEM_STORAGE, result);
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeString(storage);
+        rr.mParcel.writeString(password);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> :::" + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+     * M at+cpbr=<index1>,<index2>
+     * +CPBR:<indexn>,<number>,<type>,<text>,<hidden>,<group>,<adnumber>,<adtype>,<secondtext>,<email>
+     */
+    public void readPhoneBookEntryExt(int index1, int index2, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_READ_PHB_ENTRY_EXT, result);
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeInt(index1);
+        rr.mParcel.writeInt(index2);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> :::" + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    // MTK TODO
+    /**
+     * M AT+CPBW=<index>,<number>,<type>,<text>,<hidden>,<group>,<adnumber>,<adtype>,<secondtext>,<email>
+     */
+    /*
+    public void writePhoneBookEntryExt(PBEntry entry, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_WRITE_PHB_ENTRY_EXT, result);
+
+        rr.mParcel.writeInt(entry.getIndex1());
+        rr.mParcel.writeString(entry.getNumber());
+        rr.mParcel.writeInt(entry.getType());
+        rr.mParcel.writeString(entry.getText());
+        rr.mParcel.writeInt(entry.getHidden());
+
+        rr.mParcel.writeString(entry.getGroup());
+        rr.mParcel.writeString(entry.getAdnumber());
+        rr.mParcel.writeInt(entry.getAdtype());
+        rr.mParcel.writeString(entry.getSecondtext());
+        rr.mParcel.writeString(entry.getEmail());
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + entry);
+
+        send(rr);
+    }
+    */
+
+    // MTK-START, SMS part
+    /**
+     * {@inheritDoc}
+     */
+    public void getSmsParameters(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_SMS_PARAMS, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    private Object
+    responseSmsParams(Parcel p) {
+        /*
+        int format = p.readInt();
+        int vp = p.readInt();
+        int pid = p.readInt();
+        int dcs = p.readInt();
+
+        return new SmsParameters(format, vp, pid, dcs);
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseSmsParams: stub!");
+        return null;
+    }
+
+    // MTK TODO
+    /**
+     * {@inheritDoc}
+     */
+    /*
+    public void setSmsParameters(SmsParameters params, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_SMS_PARAMS, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mParcel.writeInt(4);
+        rr.mParcel.writeInt(params.format);
+        rr.mParcel.writeInt(params.vp);
+        rr.mParcel.writeInt(params.pid);
+        rr.mParcel.writeInt(params.dcs);
+
+        send(rr);
+    }
+    */
+
+    /**
+     * {@inheritDoc}
+     */
+    public void getSmsSimMemoryStatus(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_SMS_SIM_MEM_STATUS, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    private Object responseSimSmsMemoryStatus(Parcel p) {
+        IccSmsStorageStatus response;
+
+        response = new IccSmsStorageStatus();
+        response.mUsed = p.readInt();
+        response.mTotal = p.readInt();
+        return response;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void setEtws(int mode, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_ETWS, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(mode);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " +
+                mode);
+
+        send(rr);
+    }
+
+    public void setCellBroadcastChannelConfigInfo(String config, int cb_set_type,
+            Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO, response);
+
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeString(config);
+        rr.mParcel.writeString(Integer.toString(cb_set_type));
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void setCellBroadcastLanguageConfigInfo(String config, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO, response);
+
+        rr.mParcel.writeString(config);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void queryCellBroadcastConfigInfo(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_CB_CONFIG_INFO, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    private Object responseCbConfig(Parcel p) {
+        /*
+        int mode            = p.readInt();
+        String channels     = p.readString();
+        String languages    = p.readString();
+        boolean allOn       = (p.readInt() == 1) ? true : false;
+
+        return new CellBroadcastConfigInfo(mode, channels, languages, allOn);
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseCbConfig: stub!");
+        return null;
+    }
+
+    public void removeCellBroadcastMsg(int channelId, int serialId, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_REMOVE_CB_MESSAGE, response);
+
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeInt(channelId);
+        rr.mParcel.writeInt(serialId);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " +
+            channelId + ", " + serialId);
+
+        send(rr);
+    }
+
+    private Object responseEtwsNotification(Parcel p) {
+        // MTK TODO
+        /*
+        EtwsNotification response = new EtwsNotification();
+
+        response.warningType = p.readInt();
+        response.messageId = p.readInt();
+        response.serialNumber = p.readInt();
+        response.plmnId = p.readString();
+        response.securityInfo = p.readString();
+
+        return response;
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseEtwsNotification: stub!");
+        return null;
+    }
+    // MTK-END, SMS part
+
+    public void setTrm(int mode, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_TRM, null);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(mode);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void queryModemType(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_MODEM_TYPE, response);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void storeModemType(int modemType, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_STORE_MODEM_TYPE, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(modemType);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void reloadModemType(int modemType, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RELOAD_MODEM_TYPE, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(modemType);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void setStkEvdlCallByAP(int enabled, Message response) {
+        RILRequest rr =
+                //RILRequest.obtain(RIL_REQUEST_STK_EVDL_CALL_BY_AP, response, mySimId);
+                RILRequest.obtain(RIL_REQUEST_STK_EVDL_CALL_BY_AP, response);
+        if (RILJ_LOGD) riljLog(rr.serialString() + ">>> " + requestToString(rr.mRequest));
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(enabled);
+        send(rr);
+    }
+
+    /// M: CC053: MoMS [Mobile Managerment] @{
+    // 3. Permission Control for Conference call
+    /**
+    * To check sub-permission for MoMS before using API.
+    *
+    * @param subPermission  The permission to be checked.
+    *
+    * @return Return true if the permission is granted else return false.
+    */
+    private boolean checkMoMSSubPermission(String subPermission) {
+        riljLog("MoMS: no-op!");
+        /*
+        try {
+            IMobileManagerService mMobileManager;
+            IBinder binder = ServiceManager.getService(Context.MOBILE_SERVICE);
+            mMobileManager = IMobileManagerService.Stub.asInterface(binder);
+            int result = mMobileManager.checkPermission(subPermission, Binder.getCallingUid());
+            if (result != PackageManager.PERMISSION_GRANTED) {
+                riljLog("[Error]Subpermission is not granted!!");
+                return false;
+            }
+        } catch (Exception e) {
+            riljLog("[Error]Failed to chcek permission: " +  subPermission);
+            return false;
+        }
+        */
+
+        return true;
+    }
+    /// @}
+
+    /// M: CC010: Add RIL interface @{
+    private Object
+    responseCrssNotification(Parcel p) {
+        // MTK TODO
+        /*
+        SuppCrssNotification notification = new SuppCrssNotification();
+
+        notification.code = p.readInt();
+        notification.type = p.readInt();
+        notification.number = p.readString();
+        notification.alphaid = p.readString();
+        notification.cli_validity = p.readInt();
+
+        return notification;
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseCrssNotification: stub!");
+        return null;
+    }
+    /// @}
+
+    /// M: CC010: Add RIL interface @{
+    public void
+    hangupAll(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP_ALL,
+                                        result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void forceReleaseCall(int index, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_FORCE_RELEASE_CALL, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(index);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " " + index);
+
+        send(rr);
+    }
+
+    public void setCallIndication(int mode, int callId, int seqNumber, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_CALL_INDICATION, result);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeInt(mode);
+        rr.mParcel.writeInt(callId);
+        rr.mParcel.writeInt(seqNumber);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " " + mode + ", " + callId + ", " + seqNumber);
+
+        send(rr);
+    }
+
+    // ported from CM12.1 MediaTekRIL
+    private void setCallIndication(final String[] incomingCallInfo) {
+        final int callId = Integer.parseInt(incomingCallInfo[0]);
+        final int callMode = Integer.parseInt(incomingCallInfo[3]);
+        final int seqNumber = Integer.parseInt(incomingCallInfo[4]);
+        // just call into the MTK impl
+        setCallIndication(callMode, callId, seqNumber, null);
+    }
+
+    public void
+    emergencyDial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_EMERGENCY_DIAL, result);
+
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeInt(clirMode);
+        rr.mParcel.writeInt(0); // UUS information is absent
+
+        if (uusInfo == null) {
+            rr.mParcel.writeInt(0); // UUS information is absent
+        } else {
+            rr.mParcel.writeInt(1); // UUS information is present
+            rr.mParcel.writeInt(uusInfo.getType());
+            rr.mParcel.writeInt(uusInfo.getDcs());
+            rr.mParcel.writeByteArray(uusInfo.getUserData());
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /* M: IMS VoLTE conference dial feature start*/
+    /**
+     * Dial conference call.
+     * @param participants participants' dailing number.
+     * @param clirMode indication to present the dialing number or not.
+     * @param isVideoCall indicate the call is belong to video call or voice call.
+     * @param result the command result.
+     */
+    public void
+    conferenceDial(String[] participants, int clirMode, boolean isVideoCall, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CONFERENCE_DIAL, result);
+
+        int numberOfParticipants = participants.length;
+        /* numberOfStrings is including
+         * 1. isvideoCall
+         * 2. numberofparticipants
+         * 3. participants numbers
+         * 4. clirmod
+         */
+        int numberOfStrings = 1 + 1 + numberOfParticipants + 1 ;
+        List<String> participantList = Arrays.asList(participants);
+
+        if (RILJ_LOGD) {
+            Rlog.d(RILJ_LOG_TAG, "conferenceDial: numberOfParticipants "
+                    + numberOfParticipants + "numberOfStrings:" + numberOfStrings);
+        }
+
+        rr.mParcel.writeInt(numberOfStrings);
+
+        if (isVideoCall) {
+            rr.mParcel.writeString(Integer.toString(1));
+        } else {
+            rr.mParcel.writeString(Integer.toString(0));
+        }
+
+        rr.mParcel.writeString(Integer.toString(numberOfParticipants));
+
+        for (String dialNumber : participantList) {
+            rr.mParcel.writeString(dialNumber);
+            if (RILJ_LOGD) {
+                Rlog.d(RILJ_LOG_TAG, "conferenceDial: dialnumber " + dialNumber);
+            }
+        }
+        rr.mParcel.writeString(Integer.toString(clirMode));
+        if (RILJ_LOGD) {
+            Rlog.d(RILJ_LOG_TAG, "conferenceDial: clirMode " + clirMode);
+        }
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+
+    }
+    /* IMS VoLTE conference dial feature end*/
+
+    public void setEccServiceCategory(int serviceCategory) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_ECC_SERVICE_CATEGORY, null);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(serviceCategory);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+            + " " + serviceCategory);
+
+        send(rr);
+    }
+
+    private void setEccList() {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_ECC_LIST, null);
+        ArrayList<PhoneNumberUtils.EccEntry> eccList = PhoneNumberUtils.getEccList();
+
+        rr.mParcel.writeInt(eccList.size() * 3);
+        for (PhoneNumberUtils.EccEntry entry : eccList) {
+            rr.mParcel.writeString(entry.getEcc());
+            rr.mParcel.writeString(entry.getCategory());
+            String strCondition = entry.getCondition();
+            if (strCondition.equals(PhoneNumberUtils.EccEntry.ECC_FOR_MMI))
+                strCondition = PhoneNumberUtils.EccEntry.ECC_NO_SIM;
+            rr.mParcel.writeString(strCondition);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+    /// @}
+
+    /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+    public void setSpeechCodecInfo(boolean enable, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_SPEECH_CODEC_INFO,
+                response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(enable ? 1 : 0);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+            + " " + enable);
+        send(rr);
+    }
+    /// @}
+
+    /// M: For 3G VT only @{
+    public void
+    vtDial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_VT_DIAL, result);
+
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeInt(clirMode);
+
+        if (uusInfo == null) {
+            rr.mParcel.writeInt(0); // UUS information is absent
+        } else {
+            rr.mParcel.writeInt(1); // UUS information is present
+            rr.mParcel.writeInt(uusInfo.getType());
+            rr.mParcel.writeInt(uusInfo.getDcs());
+            rr.mParcel.writeByteArray(uusInfo.getUserData());
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void
+    acceptVtCallWithVoiceOnly(int callId, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_VOICE_ACCEPT, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " +
+                requestToString(rr.mRequest) + " " + callId);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callId);
+
+        send(rr);
+    }
+
+    public void replaceVtCall(int index, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_REPLACE_VT_CALL, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(index);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+    /// @}
+
+    /// M: IMS feature. @{
+    public void addConferenceMember(int confCallId, String address, int callIdToAdd, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER, response);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(Integer.toString(confCallId));
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeString(Integer.toString(callIdToAdd));
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void removeConferenceMember(int confCallId, String address, int callIdToRemove, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER, response);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(Integer.toString(confCallId));
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeString(Integer.toString(callIdToRemove));
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    /**
+     * To resume the call.
+     * @param callIdToResume toIndicate which call session to resume.
+     * @param response command response.
+     */
+    public void resumeCall(int callIdToResume, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RESUME_CALL, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callIdToResume);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    /**
+     * To hold the call.
+     * @param callIdToHold toIndicate which call session to hold.
+     * @param response command response.
+     */
+    public void holdCall(int callIdToHold, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_HOLD_CALL, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callIdToHold);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+    /// @}
+
+    /* M: SS part */
+    public void
+    changeBarringPassword(String facility, String oldPwd, String newPwd,
+        String newCfm, Message result) {
+        //RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_BARRING_PASSWORD, result, mySimId);
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_BARRING_PASSWORD, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mParcel.writeInt(4);
+        rr.mParcel.writeString(facility);
+        rr.mParcel.writeString(oldPwd);
+        rr.mParcel.writeString(newPwd);
+        rr.mParcel.writeString(newCfm);
+        send(rr);
+    }
+
+    public void setCLIP(boolean enable, Message result) {
+        //RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_CLIP, result, mySimId);
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_CLIP, result);
+
+        // count ints
+        rr.mParcel.writeInt(1);
+
+        if (enable) {
+            rr.mParcel.writeInt(1);
+        } else {
+            rr.mParcel.writeInt(0);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + enable);
+
+        send(rr);
+    }
+    /* M: SS part end */
+
+    /* M: Network part start */
+    public String lookupOperatorNameFromNetwork(long subId, String numeric, boolean desireLongName) {
+        int phoneId = SubscriptionManager.getPhoneId((int) subId);
+        String nitzOperatorNumeric = null;
+        String nitzOperatorName = null;
+
+        nitzOperatorNumeric = TelephonyManager.getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_NITZ_OPER_CODE, "");
+        if ((numeric != null) && (numeric.equals(nitzOperatorNumeric))) {
+            if (desireLongName == true) {
+                nitzOperatorName = TelephonyManager.getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_NITZ_OPER_LNAME, "");
+            } else {
+                nitzOperatorName = TelephonyManager.getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_NITZ_OPER_SNAME, "");
+            }
+        }
+
+        /* ALPS00273663 handle UCS2 format name : prefix + hex string ex: "uCs2806F767C79D1" */
+        if ((nitzOperatorName != null) && (nitzOperatorName.startsWith("uCs2") == true))
+        {
+            riljLog("lookupOperatorNameFromNetwork handling UCS2 format name");
+            try {
+                nitzOperatorName = new String(IccUtils.hexStringToBytes(nitzOperatorName.substring(4)), "UTF-16");
+            } catch (UnsupportedEncodingException ex) {
+                riljLog("lookupOperatorNameFromNetwork UnsupportedEncodingException");
+            }
+        }
+
+        riljLog("lookupOperatorNameFromNetwork numeric= " + numeric + ",subId= " + subId + ",nitzOperatorNumeric= " + nitzOperatorNumeric + ",nitzOperatorName= " + nitzOperatorName);
+
+        return nitzOperatorName;
+    }
+
+    @Override
+    public void
+    setNetworkSelectionModeManualWithAct(String operatorNumeric, String act, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + operatorNumeric + "" + act);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(operatorNumeric);
+        rr.mParcel.writeString(act);
+        rr.mParcel.writeString("0"); //the 3rd parameter is for MTK RIL to identify it shall be processed as semi auto network selection mode or not
+
+        send(rr);
+    }
+
+    private Object
+    responseNetworkInfoWithActs(Parcel p) {
+        String strings[] = (String []) responseStrings(p);
+        ArrayList<NetworkInfoWithAcT> ret;
+
+        if (strings.length % 4 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_GET_POL_LIST: invalid response. Got "
+                + strings.length + " strings, expected multible of 5");
+        }
+
+        ret = new ArrayList<NetworkInfoWithAcT>(strings.length / 4);
+
+        String strOperName = null;
+        String strOperNumeric = null;
+        int nAct = 0;
+        int nIndex = 0;
+
+        for (int i = 0 ; i < strings.length ; i += 4) {
+            strOperName = null;
+            strOperNumeric = null;
+            if (strings[i] != null) {
+                nIndex = Integer.parseInt(strings[i]);
+            } else {
+                Rlog.d(RILJ_LOG_TAG, "responseNetworkInfoWithActs: no invalid index. i is " + i);
+            }
+
+            if (strings[i + 1] != null) {
+                int format = Integer.parseInt(strings[i + 1]);
+                switch (format) {
+                    case 0:
+                    case 1:
+                        strOperName = strings[i + 2];
+                        break;
+                    case 2:
+                        if (strings[i + 2] != null) {
+                            strOperNumeric = strings[i + 2];
+                            strOperName = SpnOverride.getInstance().lookupOperatorName(SubscriptionManager.getSubIdUsingPhoneId(mInstanceId), strings[i + 2], true, mContext);
+                        }
+                        break;
+                    default:
+                        break;
+                }
+            }
+
+            if (strings[i + 3] != null) {
+                nAct = Integer.parseInt(strings[i + 3]);
+            } else {
+                Rlog.d(RILJ_LOG_TAG, "responseNetworkInfoWithActs: no invalid Act. i is " + i);
+            }
+            if (strOperNumeric != null && !strOperNumeric.equals("?????")) {
+                ret.add(
+                    new NetworkInfoWithAcT(
+                        strOperName,
+                        strOperNumeric,
+                        nAct,
+                        nIndex));
+            } else {
+                Rlog.d(RILJ_LOG_TAG, "responseNetworkInfoWithActs: invalid oper. i is " + i);
+            }
+        }
+
+        return ret;
+    }
+
+    public void
+    setNetworkSelectionModeSemiAutomatic(String operatorNumeric, String act, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + operatorNumeric + "" + act);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(operatorNumeric);
+        rr.mParcel.writeString(act);
+        rr.mParcel.writeString("1"); //the 3rd parameter is for MTK RIL to identify it shall be processed as semi auto network selection mode
+
+        send(rr);
+    }
+
+    public void getPOLCapabilty(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_POL_CAPABILITY, response);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void getCurrentPOLList(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_POL_LIST, response);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void setPOLEntry(int index, String numeric, int nAct, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_POL_ENTRY, response);
+        if (numeric == null || (numeric.length() == 0)) {
+            rr.mParcel.writeInt(1);
+            rr.mParcel.writeString(Integer.toString(index));
+        } else {
+            rr.mParcel.writeInt(3);
+            rr.mParcel.writeString(Integer.toString(index));
+            rr.mParcel.writeString(numeric);
+            rr.mParcel.writeString(Integer.toString(nAct));
+        }
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    // Femtocell (CSG) feature START
+    public void getFemtoCellList(String operatorNumeric, int rat, Message response) {
+        RILRequest rr
+        = RILRequest.obtain(RIL_REQUEST_GET_FEMTOCELL_LIST,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeString(operatorNumeric);
+        rr.mParcel.writeString(Integer.toString(rat));
+        send(rr);
+    }
+
+    public void abortFemtoCellList(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ABORT_FEMTOCELL_LIST, response);
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void selectFemtoCell(FemtoCellInfo femtocell, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SELECT_FEMTOCELL,
+                                    response);
+        int act = femtocell.getCsgRat();
+
+        if (act == ServiceState.RIL_RADIO_TECHNOLOGY_LTE) {
+            act = 7;
+        } else if (act == ServiceState.RIL_RADIO_TECHNOLOGY_UMTS) {
+            act = 2;
+        } else {
+            act = 0;
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " csgId=" + femtocell.getCsgId() + " plmn=" + femtocell.getOperatorNumeric() + " rat=" + femtocell.getCsgRat() + " act=" + act);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(femtocell.getOperatorNumeric());
+        rr.mParcel.writeString(Integer.toString(act));
+        rr.mParcel.writeString(Integer.toString(femtocell.getCsgId()));
+
+        send(rr);
+    }
+    // Femtocell (CSG) feature END
+
+    // M: CC33 LTE.
+    @Override
+    public void
+    setDataOnToMD(boolean enable, Message result) {
+        //AT+EDSS = <on/off>
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_DATA_ON_TO_MD, result);
+        int type = enable ? 1 : 0;
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(type);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                                + requestToString(rr.mRequest) + ": " + type);
+        send(rr);
+    }
+
+    @Override
+    public void
+    setRemoveRestrictEutranMode(boolean enable, Message result) {
+        //AT+ECODE33 = <on/off>
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE, result);
+        int type = enable ? 1 : 0;
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(type);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                                + requestToString(rr.mRequest) + ": " + type);
+        send(rr);
+    }
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    @Override
+    public void
+    setLteAccessStratumReport(boolean enable, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_LTE_ACCESS_STRATUM_REPORT, result);
+        int type = enable ? 1 : 0;
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(type);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                                + requestToString(rr.mRequest) + ": " + type);
+        send(rr);
+    }
+
+    @Override
+    public void
+    setLteUplinkDataTransfer(int state, int interfaceId, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_LTE_UPLINK_DATA_TRANSFER, result);
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeInt(state);
+        rr.mParcel.writeInt(interfaceId);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                                + requestToString(rr.mRequest)
+                                + " state = " + state
+                                + ", interfaceId = " + interfaceId);
+        send(rr);
+    }
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    public boolean isGettingAvailableNetworks() {
+        synchronized (mRequestList) {
+            for (int i = 0, s = mRequestList.size() ; i < s ; i++) {
+                RILRequest rr = mRequestList.valueAt(i);
+                if (rr != null &&
+                    (rr.mRequest == RIL_REQUEST_QUERY_AVAILABLE_NETWORKS ||
+                     rr.mRequest == RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT)) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /* M: Network part end */
+    // IMS
+    public void setIMSEnabled(boolean enable, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_IMS_ENABLE, response);
+
+        rr.mParcel.writeInt(1);
+        if (enable) {
+            rr.mParcel.writeInt(1);
+        } else {
+            rr.mParcel.writeInt(0);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    // M: Fast Dormancy
+    public void setScri(boolean forceRelease, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_SCRI, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(forceRelease ? 1 : 0);
+
+        send(rr);
+
+    }
+
+    //[New R8 modem FD]
+    public void setFDMode(int mode, int parameter1, int parameter2, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_FD_MODE, response);
+
+        //AT+EFD=<mode>[,<param1>[,<param2>]]
+        //mode=0:disable modem Fast Dormancy; mode=1:enable modem Fast Dormancy
+        //mode=3:inform modem the screen status; parameter1: screen on or off
+        //mode=2:Fast Dormancy inactivity timer; parameter1:timer_id; parameter2:timer_value
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        if (mode == 0 || mode == 1) {
+            rr.mParcel.writeInt(1);
+            rr.mParcel.writeInt(mode);
+        } else if (mode == 3) {
+            rr.mParcel.writeInt(2);
+            rr.mParcel.writeInt(mode);
+            rr.mParcel.writeInt(parameter1);
+        } else if (mode == 2) {
+            rr.mParcel.writeInt(3);
+            rr.mParcel.writeInt(mode);
+            rr.mParcel.writeInt(parameter1);
+            rr.mParcel.writeInt(parameter2);
+        }
+
+        send(rr);
+
+    }
+
+    // @argument:
+    // enable: yes   -> data centric
+    //         false -> voice centric
+    public void setDataCentric(boolean enable, Message response) {
+        if (RILJ_LOGD) riljLog("setDataCentric");
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_DATA_CENTRIC, response);
+
+        rr.mParcel.writeInt(1);
+        if (enable) {
+            rr.mParcel.writeInt(1);
+        } else {
+            rr.mParcel.writeInt(0);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+
+    /// M: CC010: Add RIL interface @{
+    /**
+     * Notify modem about IMS call status.
+     * @param existed True if there is at least one IMS call existed, else return false.
+     * @param response User-defined message code.
+     */
+    @Override
+    public void setImsCallStatus(boolean existed, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_IMS_CALL_STATUS, null);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(existed ? 1 : 0);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+    /// @}
+
+    /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+    /**
+     * Transfer IMS call to CS modem.
+     *
+     * @param numberOfCall The number of call
+     * @param callList IMS call context
+     */
+     @Override
+     public void setSrvccCallContextTransfer(int numberOfCall, SrvccCallContext[] callList) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER, null);
+
+        if ((numberOfCall <= 0) || (callList == null)) {
+              return;
+        }
+
+        rr.mParcel.writeInt(numberOfCall * 9 + 1);
+        rr.mParcel.writeString(Integer.toString(numberOfCall));
+        for (int i = 0; i < numberOfCall; i++) {
+            rr.mParcel.writeString(Integer.toString(callList[i].getCallId()));
+            rr.mParcel.writeString(Integer.toString(callList[i].getCallMode()));
+            rr.mParcel.writeString(Integer.toString(callList[i].getCallDirection()));
+            rr.mParcel.writeString(Integer.toString(callList[i].getCallState()));
+            rr.mParcel.writeString(Integer.toString(callList[i].getEccCategory()));
+            rr.mParcel.writeString(Integer.toString(callList[i].getNumberType()));
+            rr.mParcel.writeString(callList[i].getNumber());
+            rr.mParcel.writeString(callList[i].getName());
+            rr.mParcel.writeString(Integer.toString(callList[i].getCliValidity()));
+        }
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+     }
+
+     /**
+     * Update IMS registration status to modem.
+     *
+     * @param regState IMS registration state
+     *                 0: IMS unregistered
+     *                 1: IMS registered
+     * @param regType  IMS registration type
+     *                 0: Normal IMS registration
+     *                 1: Emergency IMS registration
+     * @param reason   The reason of state transition from registered to unregistered
+     *                 0: Unspecified
+     *                 1: Power off
+     *                 2: RF off
+     */
+     public void updateImsRegistrationStatus(int regState, int regType, int reason) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS, null);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeInt(regState);
+        rr.mParcel.writeInt(regType);
+        rr.mParcel.writeInt(reason);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+     }
+     /// @}
+
+    /* M: C2K part start */
+    @Override
+    public void setViaTRM(int mode, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_VIA_TRM, null);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(mode);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    @Override
+    public void getNitzTime(Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_GET_NITZ_TIME, result);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void requestSwitchHPF(boolean enableHPF, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SWITCH_HPF, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + enableHPF);
+        }
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(enableHPF ? 1 : 0);
+
+        send(rr);
+    }
+
+    @Override
+    public void setAvoidSYS(boolean avoidSYS, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_AVOID_SYS, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + avoidSYS);
+        }
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(avoidSYS ? 1 : 0);
+
+        send(rr);
+    }
+
+    @Override
+    public void getAvoidSYSList(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_QUERY_AVOID_SYS, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void queryCDMANetworkInfo(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_QUERY_CDMA_NETWORK_INFO, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void setOplmn(String oplmnInfo, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SEND_OPLMN, response);
+        rr.mParcel.writeString(oplmnInfo);
+        riljLog("sendOplmn, OPLMN is" + oplmnInfo);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    @Override
+    public void getOplmnVersion(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_OPLMN_VERSION, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    @Override
+    public void requestAGPSTcpConnected(int connected, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_AGPS_TCP_CONNIND, result);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(connected);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + connected);
+        }
+        send(rr);
+    }
+
+    @Override
+    public void requestAGPSSetMpcIpPort(String ip, String port, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_AGPS_SET_MPC_IPPORT, result);
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeString(ip);
+        rr.mParcel.writeString(port);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " : " + ip + ", " + port);
+        }
+        send(rr);
+    }
+
+    @Override
+    public void requestAGPSGetMpcIpPort(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_AGPS_GET_MPC_IPPORT, result);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    @Override
+    public void requestSetEtsDev(int dev, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_ETS_DEV, result);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(dev);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + dev);
+        }
+        send(rr);
+    }
+
+    @Override
+    public void setArsiReportThreshold(int threshold, Message response) {
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_SET_ARSI_THRESHOLD, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(threshold);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " : " + threshold);
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void queryCDMASmsAndPBStatus(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void queryCDMANetWorkRegistrationState(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_QUERY_NETWORK_REGISTRATION, response);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void setMeid(String meid, Message response) {
+        RILRequest rr
+               = RILRequest.obtain(RIL_REQUEST_SET_MEID, response);
+
+       rr.mParcel.writeString(meid);
+       if (RILJ_LOGD) {
+           riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + meid);
+       }
+
+       send(rr);
+   }
+
+    @Override
+    public void setMdnNumber(String mdn, Message response) {
+         RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_WRITE_MDN, response);
+
+        rr.mParcel.writeString(mdn);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + mdn);
+        }
+
+        send(rr);
+    }
+
+    private Object responseGetNitzTime(Parcel p) {
+        Object[] result = new Object[2];
+        String response;
+
+        response = p.readString();
+        long nitzReceiveTime = p.readLong();
+        result[0] = response;
+        result[1] = Long.valueOf(nitzReceiveTime);
+
+        return result;
+    }
+
+    /// M: UTK started @{
+    @Override
+    public void getUtkLocalInfo(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_LOCAL_INFO, result);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void requestUtkRefresh(int refreshType, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_UTK_REFRESH, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(refreshType);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void reportUtkServiceIsRunning(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING, result);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void profileDownload(String profile, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_STK_SET_PROFILE, response);
+
+        rr.mParcel.writeString(profile);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+    }
+
+    @Override
+    public void handleCallSetupRequestFromUim(boolean accept, Message response) {
+        RILRequest rr = RILRequest.obtain(
+            RILConstants.RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM,
+            response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(accept ? 1 : 0);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + (accept ? 1 : 0));
+        }
+
+        send(rr);
+    }
+    /// UTK end @}
+
+    ///M: [C2K][SVLTE] Removt SIM access feature @{
+    @Override
+    public void configModemStatus(int modemStatus, int remoteSimProtocol, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CONFIG_MODEM_STATUS, result);
+
+        // count ints
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeInt(modemStatus);
+        rr.mParcel.writeInt(remoteSimProtocol);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + modemStatus + ", " + remoteSimProtocol);
+        }
+
+        send(rr);
+    }
+    /// @}
+
+    /// M: [C2K][SVLTE] C2K SVLTE CDMA eHPRD control @{
+    @Override
+    public void configEvdoMode(int evdoMode, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CONFIG_EVDO_MODE, result);
+
+        // count ints
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(evdoMode);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + evdoMode);
+        }
+
+        send(rr);
+    }
+    /// @}
+
+    ///M: [C2K][IRAT] code start @{
+    @Override
+    public void confirmIratChange(int apDecision, Message response) {
+        RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_CONFIRM_INTER_3GPP_IRAT_CHANGE,
+                response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(apDecision);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + apDecision);
+        }
+        send(rr);
+    }
+
+    @Override
+    public void requestSetPsActiveSlot(int psSlot, Message response) {
+        RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_SET_ACTIVE_PS_SLOT, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(psSlot);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + psSlot);
+        }
+        send(rr);
+    }
+
+    @Override
+    public void syncNotifyDataCallList(AsyncResult dcList) {
+        riljLog("[C2K_IRAT_RIL] notify data call list!");
+        mDataNetworkStateRegistrants.notifyRegistrants(dcList);
+    }
+
+    @Override
+    public void requestDeactivateLinkDownPdn(Message response) {
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_DEACTIVATE_LINK_DOWN_PDN, response);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    private Object responseIratStateChange(Parcel p) {
+        // MTK TODO
+        /*
+        MdIratInfo pdnIratInfo = new MdIratInfo();
+        pdnIratInfo.sourceRat = p.readInt();
+        pdnIratInfo.targetRat = p.readInt();
+        pdnIratInfo.action = p.readInt();
+        pdnIratInfo.type = IratType.getIratTypeFromInt(p.readInt());
+        riljLog("[C2K_IRAT_RIL]responseIratStateChange: pdnIratInfo = " + pdnIratInfo);
+        return pdnIratInfo;
+        */
+        Rlog.e(RILJ_LOG_TAG, "responseIratStateChange: stub!");
+        return null;
+    }
+    ///@} [C2K] IRAT code end
+
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @{
+    @Override
+    public void setSvlteRatMode(int radioTechMode, int preSvlteMode, int svlteMode,
+            int preRoamingMode, int roamingMode, boolean is3GDualModeCard, Message response) {
+        RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_SET_SVLTE_RAT_MODE, response);
+        rr.mParcel.writeInt(6);
+        rr.mParcel.writeInt(radioTechMode);
+        rr.mParcel.writeInt(preSvlteMode);
+        rr.mParcel.writeInt(svlteMode);
+        rr.mParcel.writeInt(preRoamingMode);
+        rr.mParcel.writeInt(roamingMode);
+        rr.mParcel.writeInt(is3GDualModeCard ? 1 : 0);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " radioTechMode: " + radioTechMode
+                    + " preSvlteMode: " + preSvlteMode + " svlteMode: " + svlteMode
+                    + " preRoamingMode: " + preRoamingMode + " roamingMode: " + roamingMode
+                    + " is3GDualModeCard: " + is3GDualModeCard);
+        }
+        send(rr);
+    }
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @}
+
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @}
+    @Override
+    public void setStkUtkMode(int stkUtkMode, Message response) {
+        RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_SET_STK_UTK_MODE, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(stkUtkMode);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " stkUtkMode: " + stkUtkMode);
+        }
+        send(rr);
+    }
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @}
+
+    /// M: [C2K][SVLTE] Update RIL instance id for SVLTE switch ActivePhone. @{
+    @Override
+    public void setInstanceId(int instanceId) {
+        mInstanceId = instanceId;
+    }
+    /// @}
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @{
+
+    @Override
+    public void setRegistrationSuspendEnabled(int enabled, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_REG_SUSPEND_ENABLED, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(enabled);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RESUME_REGISTRATION, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(sessionId);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    @Override
+    public void setCdmaRegistrationSuspendEnabled(boolean enabled, Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_REG_SUSPEND_ENABLED_CDMA, response);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(enabled ? 1 : 0);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " enable=" + enabled);
+        }
+        send(rr);
+    }
+
+    @Override
+    public void setResumeCdmaRegistration(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RESUME_REGISTRATION_CDMA, response);
+        mVoiceNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+    /* M: C2K part end */
+
+    //[ALPS01810775,ALPS01868743]-Start
+    public int getDisplayState() {
+        return mDefaultDisplayState;
+    }
+    //[ALPS01810775,ALPS01868743]-End
+
+    // M: [C2K] SVLTE Remote SIM Access start.
+    private int getFullCardType(int slot) {
+        String cardType;
+        if (slot == 0) {
+            Rlog.d(RILJ_LOG_TAG, "getFullCardType slot0");
+            cardType = SystemProperties.get(PROPERTY_RIL_FULL_UICC_TYPE[0]);
+        } else if (slot == 1) {
+            Rlog.d(RILJ_LOG_TAG, "getFullCardType slot1");
+            cardType = SystemProperties.get(PROPERTY_RIL_FULL_UICC_TYPE[1]);
+        } else {
+            Rlog.d(RILJ_LOG_TAG, "getFullCardType invalid slotId = " + slot);
+            return 0;
+        }
+        Rlog.d(RILJ_LOG_TAG, "getFullCardType=" + cardType);
+        String appType[] = cardType.split(",");
+        int fullType = 0;
+        for (int i = 0; i < appType.length; i++) {
+            if ("USIM".equals(appType[i])) {
+                fullType = fullType | CARD_TYPE_USIM;
+            } else if ("SIM".equals(appType[i])) {
+                fullType = fullType | CARD_TYPE_SIM;
+            } else if ("CSIM".equals(appType[i])) {
+                fullType = fullType | CARD_TYPE_CSIM;
+            } else if ("RUIM".equals(appType[i])) {
+                fullType = fullType | CARD_TYPE_RUIM;
+            }
+        }
+        Rlog.d(RILJ_LOG_TAG, "fullType=" + fullType);
+        return fullType;
+    }
+
+    /**
+     * Set the xTK mode.
+     * @param mode The xTK mode.
+     */
+    public void setStkSwitchMode(int mode) { // Called by SvlteRatController
+        if (RILJ_LOGD) {
+            riljLog("setStkSwitchMode=" + mode + " old value=" + mStkSwitchMode);
+        }
+        mStkSwitchMode = mode;
+    }
+
+    /**
+     * Set the UTK Bip Ps type .
+     * @param mBipPsType The Bip type.
+     */
+    public void setBipPsType(int type) { // Called by SvltePhoneProxy
+        if (RILJ_LOGD) {
+            riljLog("setBipPsType=" + type + " old value=" + mBipPsType);
+        }
+        mBipPsType = type;
+    }
+    // M: [C2K] SVLTE Remote SIM Access end.
+
+    /**
+     * Switch antenna.
+     * @param callState call state, 0 means call disconnected and 1 means call established.
+     * @param ratMode RAT mode, 0 means GSM and 7 means C2K.
+     */
+    @Override
+    public void switchAntenna(int callState, int ratMode) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SWITCH_ANTENNA, null);
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeInt(callState);
+        rr.mParcel.writeInt(ratMode);
+
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString()
+                + "> " + requestToString(rr.mRequest) + " callState: " + callState
+                + ", ratMode:" + ratMode);
+        }
+
+        send(rr);
+    }
+
+    /**
+     * Switch RUIM card to SIM or switch SIM to RUIM.
+     * @param cardtype that to be switched.
+     */
+    public void switchCardType(int cardtype) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SWITCH_CARD_TYPE, null);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(cardtype);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString()
+                + "> " + requestToString(rr.mRequest) + " cardtype: " + cardtype);
+        }
+        send(rr);
+    }
+
+    /**
+     * Enable or disable MD3 Sleep.
+     * @param enable MD3 sleep.
+     */
+    public void enableMd3Sleep(int enable) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENABLE_MD3_SLEEP, null);
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(enable);
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString()
+                + "> " + requestToString(rr.mRequest) + " enable MD3 sleep: " + enable);
+        }
+        send(rr);
+    }
+}
diff --git a/src/java/com/android/internal/telephony/PhbEntry.java b/src/java/com/android/internal/telephony/PhbEntry.java
new file mode 100644
index 0000000..cefc222
--- /dev/null
+++ b/src/java/com/android/internal/telephony/PhbEntry.java
@@ -0,0 +1,71 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+/**
+ * See also RIL_PhbEntryStrucutre in include/telephony/ril.h
+ *
+ * {@hide}
+ */
+public class PhbEntry {
+    public int type;
+    public int index;
+    public String number;
+    public int ton;
+    public String alphaId;
+
+    public String toString() {
+        return super.toString() + "type: " + type + " index: " + index
+            + " number: " + number + " ton: " + ton + " alphaId: " + alphaId;
+    }
+}
+
diff --git a/src/java/com/android/internal/telephony/PhoneFactory.java b/src/java/com/android/internal/telephony/PhoneFactory.java
index 2738a0c..99b623c 100644
--- a/src/java/com/android/internal/telephony/PhoneFactory.java
+++ b/src/java/com/android/internal/telephony/PhoneFactory.java
@@ -45,6 +45,21 @@
 import com.android.internal.telephony.uicc.UiccController;
 import com.android.internal.util.IndentingPrintWriter;
 
+import com.mediatek.internal.telephony.NetworkManager;
+import com.mediatek.internal.telephony.RadioManager;
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+// import com.mediatek.internal.telephony.ltedc.LteDcPhoneProxy;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteDcPhone;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteModeController;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvltePhoneProxy;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteRoamingController;
+import com.mediatek.internal.telephony.ltedc.svlte.SvlteUtils;
+// import com.mediatek.internal.telephony.uicc.SvlteUiccController;
+import com.mediatek.internal.telephony.worldphone.IWorldPhone;
+import com.mediatek.internal.telephony.worldphone.WorldPhoneUtil;
+import com.mediatek.internal.telephony.worldphone.WorldPhoneWrapper;
+import com.mediatek.internal.telephony.worldphone.WorldMode;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.lang.reflect.Constructor;
@@ -80,6 +95,29 @@
 
     static private final HashMap<String, LocalLog>sLocalLogs = new HashMap<String, LocalLog>();
 
+    // MTK
+    // static private SvlteUiccController sSvlteUiccController;  // MTK TODO
+    // MTK-END, Refine SVLTE remote SIM APP type, 2015/04/29
+    //MTK-START [mtk06800]  RadioManager for proprietary power on flow
+    static private RadioManager mRadioManager;
+    //MTK-END [mtk06800]  RadioManager for proprietary power on flow
+    static private NetworkManager mNetworkManager;
+
+    static private IWorldPhone sWorldPhone = null;
+
+    /* C2K support start */
+    static final String EVDO_DT_SUPPORT = "ril.evdo.dtsupport";
+
+    // MTK TODO
+    /*
+    // SVLTE RIL instance
+    static private CommandsInterface[] sCommandsInterfaceLteDcs;
+    // SVLTE LTE dual connection PhoneProxy
+    static private LteDcPhoneProxy[] sLteDcPhoneProxys;
+    static private int sActiveSvlteModeSlotId;
+    */
+    /* C2K support end */
+
     //***** Class Methods
 
     public static void makeDefaultPhones(Context context) {
@@ -135,15 +173,69 @@ public static void makeDefaultPhone(Context context) {
                 int[] networkModes = new int[numPhones];
                 sProxyPhones = new PhoneProxy[numPhones];
                 sCommandsInterfaces = new RIL[numPhones];
+                /// M: SVLTE solution2 modify, expand to object array
+                /// and get active svlte mode slot id. @{
+                // MTK TODO
+                /*
+                if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                    sLteDcPhoneProxys = new SvltePhoneProxy[numPhones];
+                    sCommandsInterfaceLteDcs = new CommandsInterface[numPhones];
+                    sActiveSvlteModeSlotId = SvlteModeController.getActiveSvlteModeSlotId();
+                    SvlteModeController.setCdmaSocketSlotId(sActiveSvlteModeSlotId
+                            == SvlteModeController.CSFB_ON_SLOT
+                            ? PhoneConstants.SIM_ID_1 : sActiveSvlteModeSlotId);
+                }
+                */
+                /// @}
+                //[ALPS01784188]
+                int capabilityPhoneId = Integer.valueOf(
+                        SystemProperties.get(PhoneConstants.PROPERTY_CAPABILITY_SWITCH, "1"));
                 String sRILClassname = SystemProperties.get("ro.telephony.ril_class", "RIL").trim();
                 Rlog.i(LOG_TAG, "RILClassname is " + sRILClassname);
 
                 for (int i = 0; i < numPhones; i++) {
                     // reads the system properties and makes commandsinterface
                     // Get preferred network type.
+                    // MTK
+                    /*
                     networkModes[i] = RILConstants.PREFERRED_NETWORK_MODE;
 
                     Rlog.i(LOG_TAG, "Network Mode set to " + Integer.toString(networkModes[i]));
+                    */
+
+                    // EVDO project need phone type to be C+G
+                    if (CdmaFeatureOptionUtils.isEvdoDTSupport()) {
+                        try {
+                            networkModes[i] =
+                                    TelephonyManager.getIntAtIndex(context.getContentResolver(),
+                                    Settings.Global.PREFERRED_NETWORK_MODE, i);
+                        } catch (SettingNotFoundException snfe) {
+                            Rlog.e(LOG_TAG, "Settings Exception Reading Value At Index for"
+                                    + " Settings.Global.PREFERRED_NETWORK_MODE");
+                            networkModes[i] = preferredNetworkMode;
+                        }
+                        // workaround for cannot get phone 1 network mode
+                        if (i == 1) {
+                            networkModes[i] = RILConstants.NETWORK_MODE_GSM_ONLY;
+                        }
+                        Rlog.i(LOG_TAG, "EVDO Network Mode set to " +
+                        Integer.toString(networkModes[i]));
+                    } else {
+                        if (i == (capabilityPhoneId - 1)) {
+                            networkModes[i] = calculatePreferredNetworkType(context);
+                        } else {
+                            networkModes[i] = RILConstants.NETWORK_MODE_GSM_ONLY;
+                        }
+                        /// M: SVLTE solution2 modify, calculate network type for SVLTE @{
+                        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                            networkModes[i] = calculateNetworkType(context, i);
+                        }
+                        /// @}
+                    }
+                    Rlog.i(LOG_TAG, "RILJ Sub = " + i);
+                    Rlog.i(LOG_TAG, "capabilityPhoneId=" + capabilityPhoneId
+                            + " Network Mode set to " + Integer.toString(networkModes[i]));
+
                     // Use reflection to construct the RIL class (defaults to RIL)
                     try {
                         sCommandsInterfaces[i] = instantiateCustomRIL(
@@ -167,6 +259,24 @@ public static void makeDefaultPhone(Context context) {
                 // call getInstance()
                 mUiccController = UiccController.make(context, sCommandsInterfaces);
 
+                // MTK-START, Refine SVLTE remote SIM APP type, 2015/04/29
+                // MTK TODO
+                /*
+                if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                    sSvlteUiccController = SvlteUiccController.make();
+                }
+                */
+                // MTK-END, Refine SVLTE remote SIM APP type, 2015/04/29
+                //MTK-START [mtk06800] create RadioManager for proprietary power on flow
+                mRadioManager = RadioManager.init(context, numPhones, sCommandsInterfaces);
+                //MTK-END [mtk06800] create RadioManager for proprietary power on flow
+                mNetworkManager = NetworkManager.init(context, numPhones, sCommandsInterfaces);
+
+                // MTK SVLTE
+                if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                    svlteInit(context);
+                } else {
+
                 for (int i = 0; i < numPhones; i++) {
                     PhoneBase phone = null;
                     int phoneType = TelephonyManager.getPhoneType(networkModes[i]);
@@ -181,6 +291,7 @@ public static void makeDefaultPhone(Context context) {
 
                     sProxyPhones[i] = new PhoneProxy(phone);
                 }
+                }  // MTK
                 mProxyController = ProxyController.getInstance(context, sProxyPhones,
                         mUiccController, sCommandsInterfaces);
 
@@ -218,6 +329,18 @@ public static void makeDefaultPhone(Context context) {
                 for (int i = 0; i < numPhones; i++) {
                     sProxyPhones[i].startMonitoringImsService();
                 }
+
+                // MTK
+                //[WorldMode]
+                if (WorldPhoneUtil.isWorldModeSupport() && WorldPhoneUtil.isWorldPhoneSupport()) {
+                    Rlog.i(LOG_TAG, "World mode support");
+                    WorldMode.init();
+                } else if (WorldPhoneUtil.isWorldPhoneSupport()) {
+                    Rlog.i(LOG_TAG, "World phone support");
+                    sWorldPhone = WorldPhoneWrapper.getWorldPhoneInstance();
+                } else {
+                    Rlog.i(LOG_TAG, "World phone not support");
+                }
             }
         }
     }
@@ -268,6 +391,11 @@ public static Phone getPhone(int phoneId) {
                 if (DBG) dbgInfo = "phoneId == DEFAULT_PHONE_ID return sProxyPhone";
                 phone = sProxyPhone;
             } else {
+            	/// M: for SVLTE @{
+                if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+                    phoneId = SvlteUtils.getSvltePhoneIdByPhoneId(phoneId);
+                }
+                /// @}
                 if (DBG) dbgInfo = "phoneId != DEFAULT_PHONE_ID return sProxyPhones[phoneId]";
                 phone = (((phoneId >= 0)
                                 && (phoneId < TelephonyManager.getDefault().getPhoneCount()))
@@ -571,4 +699,137 @@ public static void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
             ipw.flush();
         }
     }
+
+    // MTK
+
+    public static int calculatePreferredNetworkType(Context context) {
+        // TODO: allow overriding like in the AOSP impl
+        int networkType = android.provider.Settings.Global.getInt(context.getContentResolver(),
+                android.provider.Settings.Global.PREFERRED_NETWORK_MODE,
+                RILConstants.PREFERRED_NETWORK_MODE);
+        Rlog.d(LOG_TAG, "calculatePreferredNetworkType: networkType = " + networkType);
+        return networkType;
+    }
+
+    /// M: SVLTE solution2 modify, svlte will create Phones,
+    /// Ril of inactive phone and SvltePhoneProxy here. @{
+    // MTK TODO
+
+    private static void svlteInit(Context context) {
+        /*
+        PhoneBase svlteDcPhone = null;
+        PhoneBase cdmaPhone = null;
+        int networkType = -1;
+        int cdmaSubscription = CdmaSubscriptionSourceManager.getDefault(context);
+        int numPhones = TelephonyManager.getDefault().getPhoneCount();
+        for (int phoneId = 0; phoneId < numPhones; phoneId++) {
+            networkType = calculateNetworkType(context, SvlteUtils.getLteDcPhoneId(phoneId));
+            Rlog.i(LOG_TAG, "svlteInit, phoneId = " + phoneId + ", networkType = " + networkType);
+            if (sActiveSvlteModeSlotId == phoneId) {
+                cdmaPhone = new CDMAPhone(context,
+                                          sCommandsInterfaces[phoneId],
+                                          sPhoneNotifier,
+                                          phoneId);
+
+                sCommandsInterfaceLteDcs[phoneId] = new RIL(context,
+                                                            networkType,
+                                                            cdmaSubscription,
+                                                            SvlteUtils.getLteDcPhoneId(phoneId));
+                svlteDcPhone = new SvlteDcPhone(context,
+                                                sCommandsInterfaceLteDcs[phoneId],
+                                                sPhoneNotifier,
+                                                SvlteUtils.getLteDcPhoneId(phoneId));
+                sLteDcPhoneProxys[phoneId] = new SvltePhoneProxy(svlteDcPhone,
+                                                     cdmaPhone,
+                                                     SvlteModeController.RADIO_TECH_MODE_SVLTE);
+            } else {
+                svlteDcPhone = new SvlteDcPhone(context,
+                                                sCommandsInterfaces[phoneId],
+                                                sPhoneNotifier,
+                                                phoneId);
+                //sCommandsInterfaceLteDcs is for cdma phone in csfb mode.
+                sCommandsInterfaceLteDcs[phoneId] = new RIL(context,
+                                                            networkType,
+                                                            cdmaSubscription,
+                                                            SvlteUtils.getLteDcPhoneId(phoneId));
+                cdmaPhone = new CDMAPhone(context,
+                                          sCommandsInterfaceLteDcs[phoneId],
+                                          sPhoneNotifier,
+                                          SvlteUtils.getLteDcPhoneId(phoneId));
+
+                sLteDcPhoneProxys[phoneId] = new SvltePhoneProxy(svlteDcPhone,
+                                                     cdmaPhone,
+                                                     SvlteModeController.RADIO_TECH_MODE_CSFB);
+            }
+            sLteDcPhoneProxys[phoneId].initialize();
+            sProxyPhones[phoneId] = sLteDcPhoneProxys[phoneId];
+        }
+        SvlteModeController.make(context);
+        sLteDcPhoneProxys[SvlteModeController.getInstance().getCdmaSocketSlotId()]
+                .getNLtePhone().mCi.connectRilSocket();
+        int sCdmaSocketSlotId = SvlteModeController.getInstance().getCdmaSocketSlotId();
+        mUiccController.setSvlteCi(sCommandsInterfaceLteDcs[sCdmaSocketSlotId]);
+        mUiccController.setSvlteIndex(sCdmaSocketSlotId);
+        SvlteRoamingController.make(sLteDcPhoneProxys);
+        */
+    }
+    /// @}
+    /// M: SVLTE solution2 modify,calculate network type by phoneId. @{
+    private static int calculateNetworkType(Context context, int phoneId) {
+        int networkMode = -1;
+        int capabilityPhoneId = Integer.valueOf(
+                        SystemProperties.get(PhoneConstants.PROPERTY_CAPABILITY_SWITCH, "1")) - 1;
+
+        if (!SvlteUtils.isValidPhoneId(phoneId)) {
+            Rlog.i(LOG_TAG, "calculateNetworkType error, phone id : " + phoneId);
+            return networkMode;
+        }
+
+        // MTK TODO
+        /*
+        if (sActiveSvlteModeSlotId == phoneId) {
+            networkMode = RILConstants.NETWORK_MODE_CDMA;
+            return networkMode;
+        } else */ if (SvlteUtils.isValidateSlotId(phoneId)) {
+            if (phoneId == capabilityPhoneId) {
+                networkMode = calculatePreferredNetworkType(context);
+            } else {
+                networkMode = RILConstants.NETWORK_MODE_GSM_ONLY;
+            }
+            return networkMode;
+        }
+
+        phoneId = SvlteUtils.getSlotId(phoneId);
+
+        //handle second phone in svltepohoneproxy
+        // MTK TODO
+        /*
+        if (sActiveSvlteModeSlotId != phoneId) {
+            networkMode = RILConstants.NETWORK_MODE_CDMA;
+        } else */ if (SvlteUtils.isValidateSlotId(phoneId)) {
+            if (phoneId == capabilityPhoneId) {
+                networkMode = calculatePreferredNetworkType(context);
+            } else {
+                networkMode = RILConstants.NETWORK_MODE_GSM_ONLY;
+            }
+        }
+        return networkMode;
+    }
+    /// @}
+
+    public static IWorldPhone getWorldPhone() {
+        if (sWorldPhone == null) {
+            Rlog.d(LOG_TAG, "sWorldPhone is null");
+        }
+
+        return sWorldPhone;
+    }
+
+    public static boolean isEvdoDTSupport() {
+        if (SystemProperties.get(EVDO_DT_SUPPORT).equals("1")) {
+            return true;
+        } else {
+            return false;
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/RIL.java b/src/java/com/android/internal/telephony/RIL.java
index f26a2fa..d73d55f 100644
--- a/src/java/com/android/internal/telephony/RIL.java
+++ b/src/java/com/android/internal/telephony/RIL.java
@@ -79,6 +79,8 @@
 import com.android.internal.telephony.TelephonyDevController;
 import com.android.internal.telephony.HardwareConfig;
 
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+
 import java.io.ByteArrayInputStream;
 import java.io.DataInputStream;
 import java.io.FileDescriptor;
@@ -296,7 +298,7 @@ private RILRequest() {
     //***** Constants
 
     // match with constant in ril.cpp
-    static final int RIL_MAX_COMMAND_BYTES = (8 * 1024);
+    static final int RIL_MAX_COMMAND_BYTES = (20 * 1024);  // MTK
     static final int RESPONSE_SOLICITED = 0;
     static final int RESPONSE_UNSOLICITED = 1;
 
@@ -681,36 +683,57 @@ public RIL(Context context, int preferredNetworkType,
                 DEFAULT_WAKE_LOCK_TIMEOUT);
         mWakeLockCount = 0;
 
-        mSenderThread = new HandlerThread("RILSender" + mInstanceId);
-        mSenderThread.start();
-
-        Looper looper = mSenderThread.getLooper();
-        mSender = new RILSender(looper);
-
-        ConnectivityManager cm = (ConnectivityManager)context.getSystemService(
-                Context.CONNECTIVITY_SERVICE);
-        if (cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE) == false) {
-            riljLog("Not starting RILReceiver: wifi-only");
-        } else {
-            riljLog("Starting RILReceiver" + mInstanceId);
-            mReceiver = new RILReceiver();
-            mReceiverThread = new Thread(mReceiver, "RILReceiver" + mInstanceId);
-            mReceiverThread.start();
-
+        ///M: SVLTE solution2 C2K RIL connect/disconnect  control. @{
+        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+            if (mPreferredNetworkType != RILConstants.NETWORK_MODE_CDMA) {
+                connectRild();
+            }
             DisplayManager dm = (DisplayManager)context.getSystemService(
                     Context.DISPLAY_SERVICE);
             mDefaultDisplay = dm.getDisplay(Display.DEFAULT_DISPLAY);
             dm.registerDisplayListener(mDisplayListener, null);
-            mDefaultDisplayState = mDefaultDisplay.getState();
+        } else {
+            mSenderThread = new HandlerThread("RILSender" + mInstanceId);
+            mSenderThread.start();
+
+            Looper looper = mSenderThread.getLooper();
+            mSender = new RILSender(looper);;
+
+            ConnectivityManager cm = (ConnectivityManager)context.getSystemService(
+                    Context.CONNECTIVITY_SERVICE);
+            if (cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE) == false) {
+                riljLog("Not starting RILReceiver: wifi-only");
+            } else {
+                riljLog("Starting RILReceiver" + mInstanceId);
+                mReceiver = createRILReceiver();
+                mReceiverThread = new Thread(mReceiver, "RILReceiver" + mInstanceId);
+                mReceiverThread.start();
+
+                DisplayManager dm = (DisplayManager)context.getSystemService(
+                        Context.DISPLAY_SERVICE);
+                mDefaultDisplay = dm.getDisplay(Display.DEFAULT_DISPLAY);
+                dm.registerDisplayListener(mDisplayListener, null);
+                mDefaultDisplayState = mDefaultDisplay.getState();
+
+                IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
+                Intent batteryStatus = context.registerReceiver(mBatteryStateListener, filter);
+                if (batteryStatus != null) {
+                    // 0 means it's on battery
+                    mIsDevicePlugged = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, 0) != 0;
+                }
 
-            IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
-            Intent batteryStatus = context.registerReceiver(mBatteryStateListener, filter);
-            if (batteryStatus != null) {
-                // 0 means it's on battery
-                mIsDevicePlugged = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, 0) != 0;
             }
+
         }
 
+        /// @}
+        // xen0n: (useless) refactoring
+        /*
+        IntentFilter filter = new IntentFilter();
+        filter.addAction("com.mtk.TEST_TRM");
+        context.registerReceiver(mIntentReceiver, filter);
+        */
+
         TelephonyDevController tdc = TelephonyDevController.getInstance();
         tdc.registerRIL(this);
     }
@@ -1919,7 +1942,10 @@ public void requestShutdown(Message result) {
                             Message response) {
         RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_FACILITY_LOCK, response);
 
-        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        // MTK
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                                                 + " [" + facility + " " + serviceClass
+                                                 + " " + appId + "]");
 
         boolean oldRil = needsOldRilFeature("facilitylock");
 
@@ -2369,7 +2395,7 @@ private void updateScreenState() {
         }
     }
 
-    protected void sendScreenState(boolean on) {
+    public /* MTK */ void sendScreenState(boolean on) {
         RILRequest rr = RILRequest.obtain(RIL_REQUEST_SCREEN_STATE, null);
         rr.mParcel.writeInt(1);
         rr.mParcel.writeInt(on ? 1 : 0);
@@ -3633,7 +3659,10 @@ public boolean needsOldRilFeature(String feature) {
         IccRefreshResponse response = new IccRefreshResponse();
 
         response.refreshResult = p.readInt();
-        response.efId   = p.readInt();
+        // xen0n
+        // response.efId   = p.readInt();
+        response.efId = new int[1];
+        response.efId[0] = p.readInt();
         response.aid = p.readString();
         return response;
     }
@@ -4240,6 +4269,10 @@ protected Object responseActivityData(Parcel p) {
             case RIL_REQUEST_SETUP_DATA_CALL: return "SETUP_DATA_CALL";
             case RIL_REQUEST_SIM_IO: return "SIM_IO";
             case RIL_REQUEST_SEND_USSD: return "SEND_USSD";
+            /* M: SS part */
+            ///M: For query CNAP
+            case RIL_REQUEST_SEND_CNAP: return "SEND_CNAP";
+            /* M: SS part end */
             case RIL_REQUEST_CANCEL_USSD: return "CANCEL_USSD";
             case RIL_REQUEST_GET_CLIR: return "GET_CLIR";
             case RIL_REQUEST_SET_CLIR: return "SET_CLIR";
@@ -4259,6 +4292,7 @@ protected Object responseActivityData(Parcel p) {
             case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: return "SET_NETWORK_SELECTION_AUTOMATIC";
             case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: return "SET_NETWORK_SELECTION_MANUAL";
             case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : return "QUERY_AVAILABLE_NETWORKS ";
+            case RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS : return "ABORT_QUERY_AVAILABLE_NETWORKS";
             case RIL_REQUEST_DTMF_START: return "DTMF_START";
             case RIL_REQUEST_DTMF_STOP: return "DTMF_STOP";
             case RIL_REQUEST_BASEBAND_VERSION: return "BASEBAND_VERSION";
@@ -4346,6 +4380,195 @@ protected Object responseActivityData(Parcel p) {
             case RIL_REQUEST_STOP_LCE: return "RIL_REQUEST_STOP_LCE";
             case RIL_REQUEST_PULL_LCEDATA: return "RIL_REQUEST_PULL_LCEDATA";
             case RIL_REQUEST_GET_ACTIVITY_INFO: return "RIL_REQUEST_GET_ACTIVITY_INFO";
+
+            /// M: CC010: Add RIL interface @{
+            case RIL_REQUEST_HANGUP_ALL: return "HANGUP_ALL";
+            case RIL_REQUEST_FORCE_RELEASE_CALL: return "FORCE_RELEASE_CALL";
+            case RIL_REQUEST_SET_CALL_INDICATION: return "SET_CALL_INDICATION";
+            case RIL_REQUEST_EMERGENCY_DIAL: return "EMERGENCY_DIAL";
+            case RIL_REQUEST_SET_ECC_SERVICE_CATEGORY: return "SET_ECC_SERVICE_CATEGORY";
+            case RIL_REQUEST_SET_ECC_LIST: return "SET_ECC_LIST";
+            /// @}
+            /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+            case RIL_REQUEST_SET_SPEECH_CODEC_INFO: return "SET_SPEECH_CODEC_INFO";
+            /// @}
+            /// M: For 3G VT only @{
+            case RIL_REQUEST_VT_DIAL: return "RIL_REQUEST_VT_DIAL";
+            case RIL_REQUEST_VOICE_ACCEPT: return "VOICE_ACCEPT";
+            case RIL_REQUEST_REPLACE_VT_CALL: return "RIL_REQUEST_REPLACE_VT_CALL";
+            /// @}
+
+            /// M: IMS feature. @{
+            case RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER: return "RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER";
+            case RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER: return "RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER";
+            case RIL_REQUEST_DIAL_WITH_SIP_URI: return "RIL_REQUEST_DIAL_WITH_SIP_URI";
+            case RIL_REQUEST_RESUME_CALL: return "RIL_REQUEST_RESUNME_CALL";
+            case RIL_REQUEST_HOLD_CALL: return "RIL_REQUEST_HOLD_CALL";
+            /// @}
+
+            //MTK-START SS
+            case RIL_REQUEST_GET_COLP: return "GET_COLP";
+            case RIL_REQUEST_SET_COLP: return "SET_COLP";
+            case RIL_REQUEST_GET_COLR: return "GET_COLR";
+            //MTK-END SS
+
+            //MTK-START SIM ME lock
+            case RIL_REQUEST_QUERY_SIM_NETWORK_LOCK: return "QUERY_SIM_NETWORK_LOCK";
+            case RIL_REQUEST_SET_SIM_NETWORK_LOCK: return "SET_SIM_NETWORK_LOCK";
+            //MTK-END SIM ME lock
+            //ISIM
+            case RIL_REQUEST_GENERAL_SIM_AUTH: return "RIL_REQUEST_GENERAL_SIM_AUTH";
+            case RIL_REQUEST_OPEN_ICC_APPLICATION: return "RIL_REQUEST_OPEN_ICC_APPLICATION";
+            case RIL_REQUEST_GET_ICC_APPLICATION_STATUS: return "RIL_REQUEST_GET_ICC_APPLICATION_STATUS";
+            case RIL_REQUEST_SIM_IO_EX: return "SIM_IO_EX";
+
+            // PHB Start
+            case RIL_REQUEST_QUERY_PHB_STORAGE_INFO: return "RIL_REQUEST_QUERY_PHB_STORAGE_INFO";
+            case RIL_REQUEST_WRITE_PHB_ENTRY: return "RIL_REQUEST_WRITE_PHB_ENTRY";
+            case RIL_REQUEST_READ_PHB_ENTRY: return "RIL_REQUEST_READ_PHB_ENTRY";
+            case RIL_REQUEST_QUERY_UPB_CAPABILITY: return "RIL_REQUEST_QUERY_UPB_CAPABILITY";
+            case RIL_REQUEST_EDIT_UPB_ENTRY: return "RIL_REQUEST_EDIT_UPB_ENTRY";
+            case RIL_REQUEST_DELETE_UPB_ENTRY: return "RIL_REQUEST_DELETE_UPB_ENTRY";
+            case RIL_REQUEST_READ_UPB_GAS_LIST: return "RIL_REQUEST_READ_UPB_GAS_LIST";
+            case RIL_REQUEST_READ_UPB_GRP: return "RIL_REQUEST_READ_UPB_GRP";
+            case RIL_REQUEST_WRITE_UPB_GRP: return "RIL_REQUEST_WRITE_UPB_GRP";
+            case RIL_REQUEST_GET_PHB_STRING_LENGTH: return "RIL_REQUEST_GET_PHB_STRING_LENGTH";
+            case RIL_REQUEST_GET_PHB_MEM_STORAGE: return "RIL_REQUEST_GET_PHB_MEM_STORAGE";
+            case RIL_REQUEST_SET_PHB_MEM_STORAGE: return "RIL_REQUEST_SET_PHB_MEM_STORAGE";
+            case RIL_REQUEST_READ_PHB_ENTRY_EXT: return "RIL_REQUEST_READ_PHB_ENTRY_EXT";
+            case RIL_REQUEST_WRITE_PHB_ENTRY_EXT: return "RIL_REQUEST_WRITE_PHB_ENTRY_EXT";
+            // PHB End
+
+            /* M: network part start */
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT: return "SET_NETWORK_SELECTION_MANUAL_WITH_ACT";
+            case RIL_REQUEST_GET_POL_CAPABILITY: return "RIL_REQUEST_GET_POL_CAPABILITY";
+            case RIL_REQUEST_GET_POL_LIST: return "RIL_REQUEST_GET_POL_LIST";
+            case RIL_REQUEST_SET_POL_ENTRY: return "RIL_REQUEST_SET_POL_ENTRY";
+            case RIL_REQUEST_SET_TRM: return "RIL_REQUEST_SET_TRM";
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT : return "QUERY_AVAILABLE_NETWORKS_WITH_ACT";
+            //Femtocell (CSG) feature START
+            case RIL_REQUEST_GET_FEMTOCELL_LIST: return "RIL_REQUEST_GET_FEMTOCELL_LIST";
+            case RIL_REQUEST_ABORT_FEMTOCELL_LIST: return "RIL_REQUEST_ABORT_FEMTOCELL_LIST";
+            case RIL_REQUEST_SELECT_FEMTOCELL: return "RIL_REQUEST_SELECT_FEMTOCELL";
+            //Femtocell (CSG) feature END
+            /* M: network part end */
+            case RIL_REQUEST_STK_EVDL_CALL_BY_AP: return "RIL_REQUEST_STK_EVDL_CALL_BY_AP";
+            case RIL_REQUEST_QUERY_MODEM_TYPE: return "RIL_REQUEST_QUERY_MODEM_TYPE";
+            case RIL_REQUEST_STORE_MODEM_TYPE: return "RIL_REQUEST_STORE_MODEM_TYPE";
+            case RIL_REQUEST_SIM_GET_ATR: return "SIM_GET_ATR";
+            case RIL_REQUEST_SIM_OPEN_CHANNEL_WITH_SW: return "SIM_OPEN_CHANNEL_WITH_SW";
+
+            // IMS
+            case RIL_REQUEST_SET_IMS_ENABLE: return "RIL_REQUEST_SET_IMS_ENABLE";
+
+            // M: Fast Dormancy
+            case RIL_REQUEST_SET_SCRI: return "RIL_REQUEST_SET_SCRI";
+            case RIL_REQUEST_SET_FD_MODE: return "RIL_REQUEST_SET_FD_MODE";
+            // MTK-START, SMS part
+            case RIL_REQUEST_GET_SMS_PARAMS: return "RIL_REQUEST_GET_SMS_PARAMS";
+            case RIL_REQUEST_SET_SMS_PARAMS: return "RIL_REQUEST_SET_SMS_PARAMS";
+            case RIL_REQUEST_GET_SMS_SIM_MEM_STATUS: return "RIL_REQUEST_GET_SMS_SIM_MEM_STATUS";
+            case RIL_REQUEST_SET_ETWS: return "RIL_REQUEST_SET_ETWS";
+            case RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO:
+                return "RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO";
+            case RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO:
+                return "RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO";
+            case RIL_REQUEST_GET_CB_CONFIG_INFO: return "RIL_REQUEST_GET_CB_CONFIG_INFO";
+            case RIL_REQUEST_REMOVE_CB_MESSAGE: return "RIL_REQUEST_REMOVE_CB_MESSAGE";
+            // MTK-END, SMS part
+            case RIL_REQUEST_SET_DATA_CENTRIC: return "RIL_REQUEST_SET_DATA_CENTRIC";
+
+            case RIL_REQUEST_MODEM_POWEROFF: return "MODEM_POWEROFF";
+            case RIL_REQUEST_MODEM_POWERON: return "MODEM_POWERON";
+            // M: CC33 LTE.
+            case RIL_REQUEST_SET_DATA_ON_TO_MD: return "RIL_REQUEST_SET_DATA_ON_TO_MD";
+            case RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE: return "RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE";
+            case RIL_REQUEST_BTSIM_CONNECT: return "RIL_REQUEST_BTSIM_CONNECT";
+            case RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF: return "RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF";
+            case RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM: return "RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM";
+            case RIL_REQUEST_BTSIM_TRANSFERAPDU: return "RIL_REQUEST_SEND_BTSIM_TRANSFERAPDU";
+
+            /// M: IMS VoLTE conference dial feature. @{
+            case RIL_REQUEST_CONFERENCE_DIAL: return "RIL_REQUEST_CONFERENCE_DIAL";
+            /// @}
+            case RIL_REQUEST_RELOAD_MODEM_TYPE: return "RIL_REQUEST_RELOAD_MODEM_TYPE";
+            /// M: CC010: Add RIL interface @{
+            case RIL_REQUEST_SET_IMS_CALL_STATUS: return "RIL_REQUEST_SET_IMS_CALL_STATUS";
+            /// @}
+
+            /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+            case RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER: return "RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER";
+            case RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS: return "RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS";
+            /// @}
+
+            /// M: SVLTE remote SIM access feature
+            case RIL_REQUEST_CONFIG_MODEM_STATUS: return "RIL_REQUEST_CONFIG_MODEM_STATUS";
+            /* M: C2K part start */
+            case RIL_REQUEST_GET_NITZ_TIME: return "RIL_REQUEST_GET_NITZ_TIME";
+            case RIL_REQUEST_QUERY_UIM_INSERTED: return "RIL_REQUEST_QUERY_UIM_INSERTED";
+            case RIL_REQUEST_SWITCH_HPF: return "RIL_REQUEST_SWITCH_HPF";
+            case RIL_REQUEST_SET_AVOID_SYS: return "RIL_REQUEST_SET_AVOID_SYS";
+            case RIL_REQUEST_QUERY_AVOID_SYS: return "RIL_REQUEST_QUERY_AVOID_SYS";
+            case RIL_REQUEST_QUERY_CDMA_NETWORK_INFO: return "RIL_REQUEST_QUERY_CDMA_NETWORK_INFO";
+            case RIL_REQUEST_GET_LOCAL_INFO: return "RIL_REQUEST_GET_LOCAL_INFO";
+            case RIL_REQUEST_UTK_REFRESH: return "RIL_REQUEST_UTK_REFRESH";
+            case RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS:
+                return "RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS";
+            case RIL_REQUEST_QUERY_NETWORK_REGISTRATION:
+                return "RIL_REQUEST_QUERY_NETWORK_REGISTRATION";
+            case RIL_REQUEST_AGPS_TCP_CONNIND: return "RIL_REQUEST_AGPS_TCP_CONNIND";
+            case RIL_REQUEST_AGPS_SET_MPC_IPPORT: return "RIL_REQUEST_AGPS_SET_MPC_IPPORT";
+            case RIL_REQUEST_AGPS_GET_MPC_IPPORT: return "RIL_REQUEST_AGPS_GET_MPC_IPPORT";
+            case RIL_REQUEST_SET_MEID: return "RIL_REQUEST_SET_MEID";
+            case RIL_REQUEST_SET_ETS_DEV: return "RIL_REQUEST_SET_ETS_DEV";
+            case RIL_REQUEST_WRITE_MDN: return "RIL_REQUEST_WRITE_MDN";
+            case RIL_REQUEST_SET_VIA_TRM: return "RIL_REQUEST_SET_VIA_TRM";
+            case RIL_REQUEST_SET_ARSI_THRESHOLD: return "RIL_REQUEST_SET_ARSI_THRESHOLD";
+            case RIL_REQUEST_QUERY_UTK_MENU_FROM_MD: return "RIL_REQUEST_QUERY_UTK_MENU_FROM_MD";
+            case RIL_REQUEST_QUERY_STK_MENU_FROM_MD: return "RIL_REQUEST_QUERY_STK_MENU_FROM_MD";
+            /* M: C2K part end */
+            // M: [C2K][MD IRAT]RIL
+            case RIL_REQUEST_SET_ACTIVE_PS_SLOT: return "RIL_REQUEST_SET_ACTIVE_PS_SLOT";
+            case RIL_REQUEST_CONFIRM_INTER_3GPP_IRAT_CHANGE:
+                return "RIL_REQUEST_CONFIRM_INTER_3GPP_IRAT_CHANGE";
+            case RIL_REQUEST_DEACTIVATE_LINK_DOWN_PDN:
+                return "RIL_REQUEST_DEACTIVATE_LINK_DOWN_PDN";
+            /// @}
+            /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @{
+            case RIL_REQUEST_SET_SVLTE_RAT_MODE: return "RIL_REQUEST_SET_SVLTE_RAT_MODE";
+            /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @}
+
+            /// M: [C2K][IR] Support SVLTE IR feature. @{
+            case RIL_REQUEST_SET_REG_SUSPEND_ENABLED: return "RIL_REQUEST_SET_REG_SUSPEND_ENABLED";
+            case RIL_REQUEST_RESUME_REGISTRATION: return "RIL_REQUEST_RESUME_REGISTRATION";
+            case RIL_REQUEST_SET_REG_SUSPEND_ENABLED_CDMA:
+                return "RIL_REQUEST_SET_REG_SUSPEND_ENABLED_CDMA";
+            case RIL_REQUEST_RESUME_REGISTRATION_CDMA:
+                return "RIL_REQUEST_RESUME_REGISTRATION_CDMA";
+            case RIL_REQUEST_CONFIG_EVDO_MODE:
+                return "RIL_REQUEST_CONFIG_EVDO_MODE";
+            /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+            case RIL_UNSOL_CDMA_SIGNAL_FADE:
+                return "RIL_UNSOL_CDMA_SIGNAL_FADE";
+            // M: Notify RILJ that the AT+EFNM was received
+            case RIL_UNSOL_CDMA_TONE_SIGNALS:
+                return "RIL_UNSOL_CDMA_TONE_SIGNALS";
+
+            case RIL_REQUEST_SET_STK_UTK_MODE:
+                return "RIL_REQUEST_SET_STK_UTK_MODE";
+
+            case RIL_REQUEST_SWITCH_ANTENNA: return "RIL_REQUEST_SWITCH_ANTENNA";
+            case RIL_REQUEST_SWITCH_CARD_TYPE: return "RIL_REQUEST_SWITCH_CARD_TYPE";
+            case RIL_REQUEST_ENABLE_MD3_SLEEP: return "RIL_REQUEST_ENABLE_MD3_SLEEP";
+
+            // M: [LTE][Low Power][UL traffic shaping] Start
+            case RIL_REQUEST_SET_LTE_ACCESS_STRATUM_REPORT:
+                return "RIL_REQUEST_SET_LTE_ACCESS_STRATUM_REPORT";
+            case RIL_REQUEST_SET_LTE_UPLINK_DATA_TRANSFER:
+                return "RIL_REQUEST_SET_LTE_UPLINK_DATA_TRANSFER";
+            // M: [LTE][Low Power][UL traffic shaping] End
+
             default: return "<unknown request>";
         }
     }
@@ -4409,6 +4632,132 @@ protected Object responseActivityData(Parcel p) {
             case RIL_UNSOL_ON_SS: return "UNSOL_ON_SS";
             case RIL_UNSOL_STK_CC_ALPHA_NOTIFY: return "UNSOL_STK_CC_ALPHA_NOTIFY";
             case RIL_UNSOL_LCEDATA_RECV: return "UNSOL_LCE_INFO_RECV";
+
+            /// M: CC010: Add RIL interface @{
+            case RIL_UNSOL_CALL_FORWARDING: return "UNSOL_CALL_FORWARDING";
+            case RIL_UNSOL_CRSS_NOTIFICATION: return "UNSOL_CRSS_NOTIFICATION";
+            case RIL_UNSOL_INCOMING_CALL_INDICATION: return "UNSOL_INCOMING_CALL_INDICATION";
+            case RIL_UNSOL_CIPHER_INDICATION: return "UNSOL_CIPHER_INDICATION";
+            //case RIL_UNSOL_CNAP: return "UNSOL_CNAP"; //obsolete
+            /// @}
+            /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+            case RIL_UNSOL_SPEECH_CODEC_INFO: return "UNSOL_SPEECH_CODEC_INFO";
+            /// @}
+            //MTK-START multiple application support
+            case RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED: return "RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED";
+            //MTK-END multiple application support
+            case RIL_UNSOL_SIM_MISSING: return "UNSOL_SIM_MISSING";
+            case RIL_UNSOL_VIRTUAL_SIM_ON: return "UNSOL_VIRTUAL_SIM_ON";
+            case RIL_UNSOL_VIRTUAL_SIM_OFF: return "UNSOL_VIRTUAL_SIM_ON_OFF";
+            case RIL_UNSOL_SIM_RECOVERY: return "UNSOL_SIM_RECOVERY";
+            case RIL_UNSOL_SIM_PLUG_OUT: return "UNSOL_SIM_PLUG_OUT";
+            case RIL_UNSOL_SIM_PLUG_IN: return "UNSOL_SIM_PLUG_IN";
+            case RIL_UNSOL_TRAY_PLUG_IN: return "UNSOL_TRAY_PLUG_IN";
+            case RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED: return "RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED";
+            case RIL_UNSOL_DATA_ALLOWED: return "RIL_UNSOL_DATA_ALLOWED";
+            case RIL_UNSOL_PHB_READY_NOTIFICATION: return "UNSOL_PHB_READY_NOTIFICATION";
+            case RIL_UNSOL_IMEI_LOCK: return "UNSOL_IMEI_LOCK";
+            case RIL_UNSOL_RESPONSE_ACMT: return "UNSOL_ACMT_INFO";
+            case RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_MMRR_STATUS_CHANGED: return "UNSOL_RESPONSE_MMRR_STATUS_CHANGED";
+            case RIL_UNSOL_NEIGHBORING_CELL_INFO: return "UNSOL_NEIGHBORING_CELL_INFO";
+            case RIL_UNSOL_NETWORK_INFO: return "UNSOL_NETWORK_INFO";
+            case RIL_UNSOL_FEMTOCELL_INFO: return "RIL_UNSOL_FEMTOCELL_INFO";
+            case RIL_UNSOL_INVALID_SIM: return "RIL_UNSOL_INVALID_SIM";
+            case RIL_UNSOL_IMS_ENABLE_DONE: return "RIL_UNSOL_IMS_ENABLE_DONE";
+            case RIL_UNSOL_IMS_DISABLE_DONE: return "RIL_UNSOL_IMS_DISABLE_DONE";
+            case RIL_UNSOL_IMS_REGISTRATION_INFO: return "RIL_UNSOL_IMS_REGISTRATION_INFO";
+            case RIL_UNSOL_STK_SETUP_MENU_RESET: return "RIL_UNSOL_STK_SETUP_MENU_RESET";
+            case RIL_UNSOL_RESPONSE_PLMN_CHANGED: return "RIL_UNSOL_RESPONSE_PLMN_CHANGED";
+            case RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED: return "RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED";
+            //Remote SIM ME lock related APIs [Start]
+            case RIL_UNSOL_MELOCK_NOTIFICATION: return "RIL_UNSOL_MELOCK_NOTIFICATION";
+            //Remote SIM ME lock related APIs [End]
+            // M: Fast Dormancy
+            case RIL_UNSOL_SCRI_RESULT: return "RIL_UNSOL_SCRI_RESULT";
+            case RIL_UNSOL_STK_EVDL_CALL: return "RIL_UNSOL_STK_EVDL_CALL";
+            case RIL_UNSOL_STK_CALL_CTRL: return "RIL_UNSOL_STK_CALL_CTRL";
+
+            /// M: IMS feature. @{
+            case RIL_UNSOL_ECONF_SRVCC_INDICATION: return "RIL_UNSOL_ECONF_SRVCC_INDICATION";
+            //For updating conference call merged/added result.
+            case RIL_UNSOL_ECONF_RESULT_INDICATION: return "RIL_UNSOL_ECONF_RESULT_INDICATION";
+            //For updating call mode and pau information.
+            case RIL_UNSOL_CALL_INFO_INDICATION : return "RIL_UNSOL_CALL_INFO_INDICATION";
+            /// @}
+
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO: return "RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO";
+            case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION: return "RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION";
+            // M: CC33 LTE.
+            case RIL_UNSOL_RAC_UPDATE: return "RIL_UNSOL_RAC_UPDATE";
+            case RIL_UNSOL_REMOVE_RESTRICT_EUTRAN: return "RIL_UNSOL_REMOVE_RESTRICT_EUTRAN";
+
+            //MTK-START for MD state change
+            case RIL_UNSOL_MD_STATE_CHANGE: return "RIL_UNSOL_MD_STATE_CHANGE";
+            //MTK-END for MD state change
+
+            case RIL_UNSOL_MO_DATA_BARRING_INFO: return "RIL_UNSOL_MO_DATA_BARRING_INFO";
+            case RIL_UNSOL_SSAC_BARRING_INFO: return "RIL_UNSOL_SSAC_BARRING_INFO";
+
+            case RIL_UNSOL_SET_ATTACH_APN: return "RIL_UNSOL_SET_ATTACH_APN";
+
+            /// M: CC071: Add Customer proprietary-IMS RIL interface. @{
+            case RIL_UNSOL_EMERGENCY_BEARER_SUPPORT_NOTIFY: return "RIL_UNSOL_EMERGENCY_BEARER_SUPPORT_NOTIFY";
+            /// @}
+
+            /* M: C2K part start */
+            case RIL_UNSOL_CDMA_CALL_ACCEPTED: return "RIL_UNSOL_CDMA_CALL_ACCEPTED";
+            case RIL_UNSOL_UTK_SESSION_END: return "RIL_UNSOL_UTK_SESSION_END";
+            case RIL_UNSOL_UTK_PROACTIVE_COMMAND: return "RIL_UNSOL_UTK_PROACTIVE_COMMAND";
+            case RIL_UNSOL_UTK_EVENT_NOTIFY: return "RIL_UNSOL_UTK_EVENT_NOTIFY";
+            case RIL_UNSOL_VIA_GPS_EVENT: return "RIL_UNSOL_VIA_GPS_EVENT";
+            case RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE: return "RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE";
+            case RIL_UNSOL_VIA_INVALID_SIM_DETECTED: return "RIL_UNSOL_VIA_INVALID_SIM_DETECTED";
+            /// M: [C2K][IR] Support SVLTE IR feature. @{
+            case RIL_UNSOL_CDMA_PLMN_CHANGED: return "RIL_UNSOL_CDMA_PLMN_CHANGED";
+            /// M: [C2K][IR] Support SVLTE IR feature. @}
+            /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @{
+            case RIL_UNSOL_GMSS_RAT_CHANGED: return "RIL_UNSOL_GMSS_RAT_CHANGED";
+            /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @}
+            /// M: [C2K] for ps type changed.
+            case RIL_UNSOL_RESPONSE_DATA_NETWORK_TYPE_CHANGED:
+                return "RIL_UNSOL_RESPONSE_DATA_NETWORK_TYPE_CHANGED";
+            /* M: C2K part end */
+            case RIL_UNSOL_ABNORMAL_EVENT: return "RIL_UNSOL_ABNORMAL_EVENT";
+            case RIL_UNSOL_CDMA_CARD_TYPE: return "RIL_UNSOL_CDMA_CARD_TYPE";
+            /// M: [C2K][MD IRAT] start
+            case RIL_UNSOL_INTER_3GPP_IRAT_STATE_CHANGE:
+                return "UNSOL_INTER_3GPP_IRAT_STATE_CHANGE";
+            /// @} [C2K][MD IRAT] end
+            /// M:[C2K] for eng mode
+            case RIL_UNSOL_ENG_MODE_NETWORK_INFO: return "RIL_UNSOL_ENG_MODE_NETWORK_INFO";
+            // MTK-START, SMS part
+            // SMS ready notification
+            case RIL_UNSOL_SMS_READY_NOTIFICATION: return "RIL_UNSOL_SMS_READY_NOTIFICATION";
+            // New sms but phone storage is full
+            case RIL_UNSOL_ME_SMS_STORAGE_FULL: return "RIL_UNSOL_ME_SMS_STORAGE_FULL";
+            // ETWS primary notification
+            case RIL_UNSOL_RESPONSE_ETWS_NOTIFICATION: return "RIL_UNSOL_RESPONSE_ETWS_NOTIFICATION";
+            // MTK-END, SMS part
+            case RIL_UNSOL_CDMA_IMSI_READY: return "RIL_UNSOL_CDMA_IMSI_READY";
+            case RIL_UNSOL_IMSI_REFRESH_DONE: return "RIL_UNSOL_IMSI_REFRESH_DONE";
+            // M: Notify RILJ that the AT+EUSIM was received
+            case RIL_UNSOL_EUSIM_READY: return "UNSOL_EUSIM_READY";
+            /// M: BIP {
+            case RIL_UNSOL_STK_BIP_PROACTIVE_COMMAND: return "UNSOL_STK_BIP_PROACTIVE_COMMAND";
+            /// M: BIP }
+            //WorldMode
+            case RIL_UNSOL_WORLD_MODE_CHANGED: return "RIL_UNSOL_WORLD_MODE_CHANGED";
+            /// M: For 3G VT only @{
+            case RIL_UNSOL_VT_STATUS_INFO: return "UNSOL_VT_STATUS_INFO";
+            case RIL_UNSOL_VT_RING_INFO: return "UNSOL_VT_RING_INFO";
+            /// @}
+            //M: Add for ECC only
+            case RIL_UNSOL_NETWORK_EXIST: return "UNSOL_NETWORK_EXIST";
+            case RIL_UNSOL_LTE_ACCESS_STRATUM_STATE_CHANGE:
+                return "RIL_UNSOL_LTE_ACCESS_STRATUM_STATE_CHANGE";
+            // M: [LTE][Low Power][UL traffic shaping] End
+
             default: return "<unknown response>";
         }
     }
@@ -4439,7 +4788,8 @@ protected void unsljLogvRet(int response, Object ret) {
         riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
     }
 
-    private Object
+    // xen0n: changed to protected for access from MediaTekRIL
+    protected Object
     responseSsData(Parcel p) {
         int num;
         SsData ssData = new SsData();
@@ -5044,4 +5394,149 @@ public void getModemActivityInfo(Message response) {
         }
         send(rr);
     }
+
+    // MTK
+    // xen0n: move MTK-specific method implementations into MediaTekRIL
+
+    protected void unexpectedMTKCall() {
+        Rlog.e(RILJ_LOG_TAG, "MTK-only method called on generic RIL!", new Exception());
+    }
+
+    @Override
+    public void supplyNetworkDepersonalization(String netpin, Message result)  {
+        unexpectedMTKCall();
+    }
+
+    /* M: SS part */
+    public void changeBarringPassword(String facility, String oldPwd, String newPwd,
+        String newCfm , Message result) {
+        unexpectedMTKCall();
+    }
+    /* M: SS part end */
+
+    @Override
+    public void setBandMode(int[] bandMode, Message response) {
+        unexpectedMTKCall();
+    }
+
+    @Override
+    public void handleCallSetupRequestFromSim(
+            boolean accept, int resCode, Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void getCOLR(Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void setCOLP(boolean enable, Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void getCOLP(Message response) {
+        unexpectedMTKCall();
+    }
+
+    // Added by M begin
+    @Override
+    public void iccGetATR(Message response) {
+        unexpectedMTKCall();
+    }
+
+    @Override
+    public void iccOpenChannelWithSw(String AID, Message result){
+        unexpectedMTKCall();
+    }
+    // Added by M end
+
+    @Override
+    public void setTrm(int mode, Message result) {
+        unexpectedMTKCall();
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+        unexpectedMTKCall();
+    }
+
+    @Override
+    public void queryModemType(Message response) {
+        unexpectedMTKCall();
+    }
+
+    @Override
+    public void storeModemType(int modemType, Message response) {
+        unexpectedMTKCall();
+    }
+
+    @Override
+    public void reloadModemType(int modemType, Message response) {
+        unexpectedMTKCall();
+    }
+
+    // M: Fast Dormancy
+    public void setScri(boolean forceRelease, Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void setFDMode(int mode, int parameter1, int parameter2, Message response) {
+        unexpectedMTKCall();
+    }
+
+    //UTK start
+    public void getUtkLocalInfo(Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void requestUtkRefresh(int type, Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void reportUtkServiceIsRunning(Message result) {
+        unexpectedMTKCall();
+    }
+
+    public void profileDownload(String profile, Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void handleCallSetupRequestFromUim(boolean accept, Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void queryUtkSetupMenuFromMD(String contents, Message response) {
+        unexpectedMTKCall();
+    }
+
+    public void setStkSwitchMode(int mode) {
+        unexpectedMTKCall();
+    }
+
+    public void setBipPsType(int type) {
+        unexpectedMTKCall();
+    }
+    //UTK end
+
+    ///M: C2K RIL SWITCH @{
+    protected void connectRild() {
+        mSenderThread = new HandlerThread("RILSender" + mInstanceId);
+        mSenderThread.start();
+        Looper looper = mSenderThread.getLooper();
+        mSender = new RILSender(looper);
+
+        riljLog("Starting RILReceiver" + mInstanceId);
+        mReceiver = new RILReceiver();
+        mReceiverThread = new Thread(mReceiver, "RILReceiver" + mInstanceId);
+        mReceiverThread.start();
+    }
+
+    @Override
+    public void connectRilSocket() {
+        unexpectedMTKCall();
+    }
+
+    @Override
+    public void disconnectRilSocket() {
+        unexpectedMTKCall();
+    }
 }
diff --git a/src/java/com/android/internal/telephony/ServiceStateTracker.java b/src/java/com/android/internal/telephony/ServiceStateTracker.java
index c835707..9d3765d 100644
--- a/src/java/com/android/internal/telephony/ServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/ServiceStateTracker.java
@@ -185,6 +185,13 @@
     protected static final int EVENT_IMS_STATE_DONE                    = 47;
     protected static final int EVENT_IMS_CAPABILITY_CHANGED            = 48;
 
+    // MTK events
+    // MTK TODO
+    protected static final int EVENT_SET_IMS_ENABLED_DONE = 109;
+    protected static final int EVENT_SET_IMS_DISABLE_DONE = 110;
+    protected static final int EVENT_IMS_DISABLED_URC = 111;
+    protected static final int EVENT_IMS_REGISTRATION_INFO = 112;
+
     protected static final String TIMEZONE_PROPERTY = "persist.sys.timezone";
 
     /**
diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index 7dc9c1a..8f9703c 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -43,6 +43,8 @@
 import java.util.Objects;
 import com.android.internal.telephony.IccCardConstants.State;
 
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -137,6 +139,10 @@ public synchronized void dump(FileDescriptor fd, PrintWriter pw, String[] args)
 
     private int[] colorArr;
 
+    // MTK
+    private static final boolean MTK_LTEDC_SUPPORT = CdmaFeatureOptionUtils.isCdmaLteDcSupport();
+    private boolean mIsReady = false;
+
     public static SubscriptionController init(Phone phone) {
         synchronized (SubscriptionController.class) {
             if (sInstance == null) {
@@ -249,6 +255,9 @@ public void notifySubscriptionInfoChanged() {
              // Should never happen because its always available.
          }
 
+         // MTK
+         setReadyState(true);
+
          // FIXME: Remove if listener technique accepted.
          broadcastSimInfoContentChanged();
      }
@@ -1275,6 +1284,9 @@ public int clearSubInfo() {
                 return 0;
             }
 
+            // MTK
+            setReadyState(false);
+
             sSlotIdxToSubId.clear();
             if (DBG) logdl("[clearSubInfo]- clear size=" + size);
             return size;
@@ -1564,6 +1576,26 @@ protected boolean shouldDefaultBeCleared(List<SubscriptionInfo> records, int sub
     // FIXME: We need we should not be assuming phoneId == slotId as it will not be true
     // when there are multiple subscriptions per sim and probably for other reasons.
     public int getSubIdUsingPhoneId(int phoneId) {
+    	// MTK-START
+        // Add the special handle for LTE_DC_PHONE_ID
+        if (MTK_LTEDC_SUPPORT) {
+            if (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_1) {
+                logd("[getSubIdUsingPhoneId]- phone is LTE_DC_PHONE_ID_1.");
+                if (!isReady()) {
+                    return SubscriptionManager.LTE_DC_SUB_ID_1 - 2;
+                } else {
+                    return SubscriptionManager.LTE_DC_SUB_ID_1;
+                }
+            } else if (phoneId == SubscriptionManager.LTE_DC_PHONE_ID_2) {
+                logd("[getSubIdUsingPhoneId]- phone is LTE_DC_PHONE_ID_2.");
+                if (!isReady()) {
+                    return SubscriptionManager.LTE_DC_SUB_ID_2 - 2;
+                } else {
+                    return SubscriptionManager.LTE_DC_SUB_ID_2;
+                }
+            }
+        }
+        // MTK-END
         int[] subIds = getSubId(phoneId);
         if (subIds == null || subIds.length == 0) {
             return SubscriptionManager.INVALID_SUBSCRIPTION_ID;
@@ -1869,4 +1901,24 @@ public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
             Binder.restoreCallingIdentity(token);
         }
     }
+
+    // MTK
+
+    /**
+     * Query if sub module always initialization done.
+     *
+     */
+   public boolean isReady() {
+        logd("[isReady]- " + mIsReady);
+        return mIsReady;
+   }
+
+    /**
+     * Set sub module initialization state.
+     *
+     */
+    public void setReadyState(boolean isReady) {
+        logd("[setReadyState]- " + isReady);
+        mIsReady = isReady;
+    }
 }
diff --git a/src/java/com/android/internal/telephony/SuppSrvRequest.java b/src/java/com/android/internal/telephony/SuppSrvRequest.java
new file mode 100644
index 0000000..912b769
--- /dev/null
+++ b/src/java/com/android/internal/telephony/SuppSrvRequest.java
@@ -0,0 +1,101 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.android.internal.telephony;
+
+import android.os.Message;
+import android.os.Parcel;
+
+/**
+ * SuppSrvRequest: to encapsulate a Supplementary Service Request.
+ *
+ *  @hide
+ */
+public class SuppSrvRequest {
+    int mRequestCode;
+    Message mResultCallback;
+    public Parcel mParcel;
+
+    // Request Code
+    public static final int SUPP_SRV_REQ_SET_CLIP               = 1;
+    public static final int SUPP_SRV_REQ_GET_CLIP               = 2;
+    public static final int SUPP_SRV_REQ_SET_CLIR               = 3;
+    public static final int SUPP_SRV_REQ_GET_CLIR               = 4;
+    public static final int SUPP_SRV_REQ_SET_COLP               = 5;
+    public static final int SUPP_SRV_REQ_GET_COLP               = 6;
+    public static final int SUPP_SRV_REQ_SET_COLR               = 7;
+    public static final int SUPP_SRV_REQ_GET_COLR               = 8;
+    public static final int SUPP_SRV_REQ_SET_CB                 = 9;
+    public static final int SUPP_SRV_REQ_GET_CB                 = 10;
+    public static final int SUPP_SRV_REQ_SET_CF                 = 11;
+    public static final int SUPP_SRV_REQ_GET_CF                 = 12;
+    public static final int SUPP_SRV_REQ_SET_CW                 = 13;
+    public static final int SUPP_SRV_REQ_GET_CW                 = 14;
+    public static final int SUPP_SRV_REQ_MMI_CODE               = 15;
+    public static final int SUPP_SRV_REQ_GET_CF_IN_TIME_SLOT    = 16;
+    public static final int SUPP_SRV_REQ_SET_CF_IN_TIME_SLOT    = 17;
+
+    /**
+     * Create SuppSrvRequest object with request and callback.
+     * @param request SS request code
+     * @param resultCallback callback Message
+     * @return the created SuppSrvRequest object
+     */
+    public static SuppSrvRequest obtain(int request, Message resultCallback) {
+        SuppSrvRequest ss = new SuppSrvRequest();
+
+        ss.mRequestCode = request;
+        ss.mResultCallback = resultCallback;
+        ss.mParcel = Parcel.obtain();
+
+        return ss;
+    }
+
+    private SuppSrvRequest() {
+    }
+
+    public Message getResultCallback() {
+        return mResultCallback;
+    }
+
+    public void setResultCallback(Message resultCallback) {
+        mResultCallback = resultCallback;
+    }
+
+    public int getRequestCode() {
+        return mRequestCode;
+    }
+}
+
diff --git a/src/java/com/android/internal/telephony/cat/AppInterface.java b/src/java/com/android/internal/telephony/cat/AppInterface.java
index d48a82b..278cd29 100644
--- a/src/java/com/android/internal/telephony/cat/AppInterface.java
+++ b/src/java/com/android/internal/telephony/cat/AppInterface.java
@@ -82,6 +82,12 @@
         RECEIVE_DATA(0x42),
         SEND_DATA(0x43),
         GET_CHANNEL_STATUS(0x44);
+        ACTIVATE(0x70),
+        // MTK
+        /**
+         * Proprietay message for Call Control alpha id display
+         */
+        CALLCTRL_RSP_MSG(0XFF);
 
         private int mValue;
 
diff --git a/src/java/com/android/internal/telephony/cat/CatCmdMessage.java b/src/java/com/android/internal/telephony/cat/CatCmdMessage.java
index 62d8869..36dedf6 100644
--- a/src/java/com/android/internal/telephony/cat/CatCmdMessage.java
+++ b/src/java/com/android/internal/telephony/cat/CatCmdMessage.java
@@ -35,6 +35,9 @@
     private CallSettings mCallSettings = null;
     private SetupEventListSettings mSetupEventListSettings = null;
     private boolean mLoadIconFailed = false;
+    // MTK
+    public int mInfoType = 0;
+    public String mDestAddress = null;
 
     /*
      * Container for Launch Browser command settings.
@@ -121,6 +124,13 @@
             mSetupEventListSettings.eventList = ((SetEventListParams) cmdParams).mEventInfo;
             break;
         case PROVIDE_LOCAL_INFORMATION:
+         break;
+        // MTK
+        case CALLCTRL_RSP_MSG:
+            mTextMsg = ((CallCtrlBySimParams) cmdParams).mTextMsg;
+            mInfoType = ((CallCtrlBySimParams) cmdParams).mInfoType;
+            mDestAddress = ((CallCtrlBySimParams) cmdParams).mDestAddress;
+            break;
         case REFRESH:
         default:
             break;
diff --git a/src/java/com/android/internal/telephony/cat/CatService.java b/src/java/com/android/internal/telephony/cat/CatService.java
index 3b25293..514bf75 100755
--- a/src/java/com/android/internal/telephony/cat/CatService.java
+++ b/src/java/com/android/internal/telephony/cat/CatService.java
@@ -938,11 +938,52 @@ public void handleMessage(Message msg) {
             }
             break;
         case MSG_ID_ALPHA_NOTIFY:
+            // MTK
             CatLog.d(this, "Received CAT CC Alpha message from card");
             if (msg.obj != null) {
                 AsyncResult ar = (AsyncResult) msg.obj;
                 if (ar != null && ar.result != null) {
-                    broadcastAlphaMessage((String)ar.result);
+                    if (ar.result instanceof String) {
+                        broadcastAlphaMessage((String)ar.result);
+                    } else if (ar.result instanceof String[]) {
+                        // MTK
+                        String[] callCtrlInfo = (String[]) ar.result;
+                        CatLog.d(this, "callCtrlInfo.length: " + callCtrlInfo.length + "," +
+                                callCtrlInfo[0] + "," + callCtrlInfo[1] + "," +
+                                callCtrlInfo[2]);
+                        byte[] rawData = null;
+                        try {
+                            if (null != callCtrlInfo[1] && callCtrlInfo[1].length() > 0) {
+                                rawData = IccUtils.hexStringToBytes(callCtrlInfo[1]);
+                            } else {
+                                CatLog.d(this, "Null CC alpha id.");
+                                break;
+                            }
+                        } catch (Exception e) {
+                            // zombie messages are dropped
+                            CatLog.d(this, "CC message drop");
+                            break;
+                        }
+                        String alphaId = null;
+                        try {
+                            alphaId = IccUtils.adnStringFieldToString(
+                                    rawData, 0, rawData.length);
+                        } catch (IndexOutOfBoundsException e) {
+                            CatLog.d(this, "IndexOutOfBoundsException adnStringFieldToString");
+                            break;
+                        }
+                        CatLog.d(this, "CC Alpha msg: " + alphaId + ", sim id: " + mSlotId);
+                        TextMessage textMessage = new TextMessage();
+                        CommandDetails cmdDet = new CommandDetails();
+                        cmdDet.typeOfCommand = AppInterface.CommandType.CALLCTRL_RSP_MSG.value();
+                        textMessage.text = alphaId;
+                        CallCtrlBySimParams cmdParams = new CallCtrlBySimParams(cmdDet,
+                                textMessage, Integer.parseInt(callCtrlInfo[0]), callCtrlInfo[2]);
+                        CatCmdMessage cmdMsg = new CatCmdMessage(cmdParams);
+                        broadcastCatCmdIntent(cmdMsg);
+                    } else {
+                        CatLog.d(this, "CAT Alpha message: unexpected response type!");
+                    }
                 } else {
                     CatLog.d(this, "CAT Alpha message: ar.result is null");
                 }
diff --git a/src/java/com/android/internal/telephony/cat/CommandParams.java b/src/java/com/android/internal/telephony/cat/CommandParams.java
index 57fad97..bfbb105 100644
--- a/src/java/com/android/internal/telephony/cat/CommandParams.java
+++ b/src/java/com/android/internal/telephony/cat/CommandParams.java
@@ -245,3 +245,22 @@ boolean setIcon(Bitmap icon) {
         ussdString = ussdstring;
     }
 }
+
+// MTK
+
+/**
+ * CallCtrlBySimParams class for CC by SIM parameters.
+ */
+class CallCtrlBySimParams extends CommandParams {
+    TextMessage mTextMsg;
+    int mInfoType;
+    String mDestAddress;
+
+    CallCtrlBySimParams(CommandDetails cmdDet, TextMessage textMsg,
+        int infoType, String destAddress) {
+        super(cmdDet);
+        mTextMsg = textMsg;
+        mInfoType = infoType;
+        mDestAddress = destAddress;
+    }
+}
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
index 35d9d57..8adc8d7 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
@@ -81,6 +81,10 @@
 import com.android.internal.util.AsyncChannel;
 import com.android.internal.util.ArrayUtils;
 
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+import com.mediatek.internal.telephony.dataconnection.IaExtendParam;
+import com.mediatek.internal.telephony.ltedc.svlte.SvlteUtils;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -2990,15 +2994,19 @@ protected boolean onUpdateIcc() {
 
         int dataRat = mPhone.getServiceState().getRilDataRadioTechnology();
         int appFamily = UiccController.getFamilyFromRadioTechnology(dataRat);
-        IccRecords newIccRecords = getUiccRecords(appFamily);
+        final int mtkFamily = getUiccFamily(mPhone);  // MTK
+        IccRecords newIccRecords = getUiccRecords(mtkFamily /* appFamily */);
         log("onUpdateIcc: newIccRecords " + ((newIccRecords != null) ?
                 newIccRecords.getClass().getName() : null));
+        // MTK stack would fail to perform IA with this as on MTK dataRat is set late *AFTER* IA
+        /*
         if (dataRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
             // Ignore this. This could be due to data not registered
             // We want to ignore RADIO_TECHNOLOGY_UNKNOWN so that we do not tear down data
             // call in case we are out of service.
             return false;
         }
+        */
 
         IccRecords r = mIccRecords.get();
         if (r != newIccRecords) {
@@ -3021,6 +3029,65 @@ protected boolean onUpdateIcc() {
             // Records changed -> return true
             result = true;
         }
+
+        // MTK TODO
+        /*
+        // M: [C2K][IRAT] Register for LTE records loaded.
+        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport() && SvlteUtils.isActiveSvlteMode(mPhone)) {
+            IccRecords newLteIccRecords = getUiccRecords(UiccController.APP_FAM_3GPP);
+            IccRecords oldLteIccRecords = mLteIccRecords.get();
+            log("[IRAT_DcTracker] Register for LTE IccRecords: newLteIccRecords = "
+                    + newLteIccRecords
+                    + ", oldLteIccRecords = "
+                    + oldLteIccRecords);
+
+            // Do not judge whether the records is the same before registering
+            // LTE records, because only single SIM record on Android, the SIM
+            // record instance is always the same.
+            if (oldLteIccRecords != null) {
+                log("Removing stale LTE icc objects.");
+                oldLteIccRecords.unregisterForRecordsLoaded(this);
+                mLteIccRecords.set(null);
+
+                // Register back the records loaded event if it is removed.
+                if (oldLteIccRecords == newIccRecords) {
+                    newIccRecords.registerForRecordsLoaded(this,
+                            DctConstants.EVENT_RECORDS_LOADED, null);
+                }
+            }
+            if (newLteIccRecords != null) {
+                log("New LTE records found");
+                mLteIccRecords.set(newLteIccRecords);
+                newLteIccRecords.registerForRecordsLoaded(this,
+                        LteDcConstants.EVENT_LTE_RECORDS_LOADED, null);
+            }
+        }
+
+        if (mAllApnSettings != null && r == null && newIccRecords == null) {
+            mAllApnSettings.clear();
+        }
+
+        //MTK START: FDN Support
+        UiccCardApplication app = mUiccCardApplication.get();
+        UiccCardApplication newUiccCardApp = mUiccController.getUiccCardApplication(
+                mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA ?
+                UiccController.APP_FAM_3GPP2 : UiccController.APP_FAM_3GPP);
+
+        if (app != newUiccCardApp) {
+            if (app != null) {
+                log("Removing stale UiccCardApplication objects.");
+                app.unregisterForFdnChanged(this);
+                mUiccCardApplication.set(null);
+            }
+
+            if (newUiccCardApp != null) {
+                log("New UiccCardApplication found");
+                newUiccCardApp.registerForFdnChanged(this, DctConstants.EVENT_FDN_CHANGED, null);
+                mUiccCardApplication.set(newUiccCardApp);
+            }
+        }
+        //MTK END: FDN Support
+        */
         return result;
     }
 
@@ -3319,4 +3386,65 @@ private void cleanUpConnectionsOnUpdatedApns(boolean tearDown) {
             notifyAllDataDisconnected();
         }
     }
+
+    // MTK
+
+    private static final String PROP_NAME_SET_TEST_RAT = "mtk.test.rat";
+
+    // Set APP family to unknown when radio technology is not specified.
+    public static final int APP_FAM_UNKNOWN = 0;
+
+    // NOTE: DcTracker.java:4983
+    private int getUiccFamily(PhoneBase phone) {
+        int family = UiccController.APP_FAM_3GPP;
+        if (!CdmaFeatureOptionUtils.isCdmaLteDcSupport() || !SvlteUtils.isActiveSvlteMode(phone)) {
+            if (phone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
+                family = UiccController.APP_FAM_3GPP2;
+            }
+        } else {
+            int radioTech = getRilDataRadioTechnology(phone);
+            if (radioTech != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
+                family = getUiccFamilyByRat(radioTech);
+            } else {
+                // Return 3GPP2 family if the phone is CDMA.
+                if (phone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
+                    family = UiccController.APP_FAM_3GPP2;
+                }
+            }
+            log("[IRAT_DcTracker] getUiccFamily: radioTech = " + radioTech
+                    + ", family=" + family + ", phone = " + phone);
+        }
+        return family;
+    }
+
+    private int getRilDataRadioTechnology(PhoneBase phone) {
+        int testRat = SystemProperties.getInt(PROP_NAME_SET_TEST_RAT, 0);
+        if (testRat != 0) {
+            log("[IRAT_DcTracker] Use test RAT " + testRat + " instead of "
+                    + phone.getServiceState().getRilDataRadioTechnology()
+                    + " for test.");
+            return testRat;
+        }
+        return phone.getServiceState().getRilDataRadioTechnology();
+    }
+
+    // NOTE: DcTracker.java:5082
+    /**
+     * M: Get Uicc Family by radio technology.
+     * @param radioTech Ratio technology.
+     * @return APP family of the RAT.
+     */
+    private static int getUiccFamilyByRat(int radioTech) {
+        if (radioTech == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
+            return APP_FAM_UNKNOWN;
+        }
+
+        if ((radioTech >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A
+                && radioTech <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A)
+                || radioTech == ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_B) {
+            return UiccController.APP_FAM_3GPP2;
+        } else {
+            return UiccController.APP_FAM_3GPP;
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java b/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
index 8850c97..3fccc7d 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
@@ -57,11 +57,17 @@
 import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneBase;
 import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.RILConstants;
 import com.android.internal.telephony.uicc.IccRecords;
 import com.android.internal.telephony.uicc.UiccController;
 import com.android.internal.util.AsyncChannel;
 import com.android.internal.util.ArrayUtils;
 
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+// import com.mediatek.internal.telephony.dataconnection.DataSubSelector;
+import com.mediatek.internal.telephony.dataconnection.IaExtendParam;
+import com.mediatek.internal.telephony.ltedc.svlte.SvlteUtils;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -1770,6 +1776,66 @@ protected void restartDataStallAlarm() {
     }
 
     protected void setInitialAttachApn() {
+    	// MTK
+        // M:[C2K][IRAT] Set initial attach APN for SVLTE. {@
+        if (mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
+            if (CdmaFeatureOptionUtils.isCdmaLteDcSupport() && SvlteUtils.isActiveSvlteMode(mPhone)
+                    && mSvlteOperatorNumeric != null) {
+                // MTK TODO
+                // setInitialAttachApnForSvlte();
+            } else {
+                log("[IRAT_DcTracker] DO NOT setInitialApn for CDMA: numeric = "
+                        + mSvlteOperatorNumeric);
+            }
+            return;
+        } else if (mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_GSM) {
+            log("[IRAT_DcTracker] GSM setInitialAttachApn: numeric = "
+                    + mSvlteOperatorNumeric);
+            if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()
+                    && SvlteUtils.isActiveSvlteMode(mPhone)) {
+                if (mSvlteOperatorNumeric != null) {
+                    // Since only CTLTE/Empty APN can be used to attach LTE
+                    // network for CT network, only set CTLTE as initial attach.
+                    if (OPERATOR_NUMERIC_CTLTE.equals(mSvlteOperatorNumeric)) {
+                        // MTK TODO
+                        // setInitialAttachApnForSvlte();
+                        return;
+                    }
+                    // Else if the SIM is not CT card(not equals 46011), follow
+                    // the default flow.
+                } else {
+                    // Do nothing since LTE records is not loaded yet.
+                    log("[IRAT_DcTracker] GSM ignore IA because SIM not loaded.");
+                    IccRecords r = mIccRecords.get();
+                    String operatorNumeric = (r != null) ? r.getOperatorNumeric() : "";
+                    if (operatorNumeric == null || operatorNumeric.length() == 0) {
+                        log("setInitialApn: but no operator numeric");
+                        return;
+                    }
+                }
+            }
+        }
+        // M: @}
+
+        // MTK TODO: mInitialAttachApnSetting
+        // ApnSetting previousAttachApn = mInitialAttachApnSetting;
+        IccRecords r = mIccRecords.get();
+        String operatorNumeric = (r != null) ? r.getOperatorNumeric() : "";
+        if (operatorNumeric == null || operatorNumeric.length() == 0) {
+            log("setInitialApn: but no operator numeric");
+            return;
+        }
+
+        String[] dualApnPlmnList = null;
+        /*
+        if (MTK_DUAL_APN_SUPPORT == true) {
+            dualApnPlmnList = mPhone.getContext().getResources()
+                        .getStringArray(com.mediatek.internal.R.array.dtag_dual_apn_plmn_list);
+        }
+        */
+
+        // log("setInitialApn: current attach Apn [" + mInitialAttachApnSetting + "]");
+
         ApnSetting iaApnSetting = null;
         ApnSetting defaultApnSetting = null;
         ApnSetting firstApnSetting = null;
@@ -1820,13 +1886,29 @@ protected void setInitialAttachApn() {
         }
 
         if (initialAttachApnSetting == null) {
+            // MTK
+            if (operatorNumeric == null) {
+                if (DBG) log("setInitialAttachApn: but no operator and no available apn");
+            } else {
             if (DBG) log("setInitialAttachApn: X There in no available apn");
+            IaExtendParam param = new IaExtendParam(operatorNumeric, dualApnPlmnList);
+            mPhone.mCi.setInitialAttachApn("", RILConstants.SETUP_DATA_PROTOCOL_IP, -1, "", "",
+                    (Object) param, null);
+            } // MTK
         } else {
+        	// MTK
+            if (operatorNumeric == null) {
+                if (DBG) log("setInitialAttachApn: but no operator");
+            } else {
             if (DBG) log("setInitialAttachApn: X selected Apn=" + initialAttachApnSetting);
 
+            IaExtendParam param = new IaExtendParam(operatorNumeric,
+                        initialAttachApnSetting.canHandleType(PhoneConstants.APN_TYPE_IMS),
+                        dualApnPlmnList);
             mPhone.mCi.setInitialAttachApn(initialAttachApnSetting.apn,
                     initialAttachApnSetting.protocol, initialAttachApnSetting.authType,
-                    initialAttachApnSetting.user, initialAttachApnSetting.password, null);
+                    initialAttachApnSetting.user, initialAttachApnSetting.password, /* MTK */ param, null);
+            }  // MTK
         }
     }
 
@@ -2017,4 +2099,30 @@ public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         pw.println(" mDataRoamingSettingObserver=" + mDataRoamingSettingObserver);
         pw.flush();
     }
+
+    // MTK
+
+    protected static final String PROPERTY_MOBILE_DATA_ENABLE = "persist.radio.mobile.data";
+    protected static final boolean DUALTALK_SPPORT =
+            SystemProperties.getInt("ro.mtk_dt_support", 0) == 1;
+    protected ApnSetting mInitialAttachApnSetting;
+    protected Handler mWorkerHandler;
+    protected boolean mDataRoamingEnabled;
+    private static final String NO_SIM_VALUE = "N/A";
+    private String[] PROPERTY_ICCID = {
+        "ril.iccid.sim1",
+        "ril.iccid.sim2",
+        "ril.iccid.sim3",
+        "ril.iccid.sim4",
+    };
+
+    // M: [C2K][IRAT] Record initial attach APN for SVLTE, distinguish with
+    // original initial attach APN.
+    // TODO: move C2K logic to OP09 if it is not OM request.
+    protected static final String OPERATOR_NUMERIC_CTLTE = "46011";
+    protected static final String OPERATOR_NUMERIC_VODAFONE = "20404";
+    protected static final String OPERATOR_NUMERIC_HUTCHISON = "45403";
+
+    protected String mSvlteOperatorNumeric;
+    protected ApnSetting mSvlteIaApnSetting;
 }
diff --git a/src/java/com/android/internal/telephony/gsm/CallFailCause.java b/src/java/com/android/internal/telephony/gsm/CallFailCause.java
index 994dfa0..e46f8e3 100644
--- a/src/java/com/android/internal/telephony/gsm/CallFailCause.java
+++ b/src/java/com/android/internal/telephony/gsm/CallFailCause.java
@@ -56,4 +56,33 @@
     static final int DIAL_MODIFIED_TO_DIAL = 246;
 
     static final int ERROR_UNSPECIFIED = 0xffff;
+
+    // MTK
+
+    static final int NO_ROUTE_TO_DESTINATION = NO_ROUTE_TO_DESTINAON;
+    static final int NO_USER_RESPONDING = CALL_FAIL_NO_USER_RESPONDING;
+    static final int USER_ALERTING_NO_ANSWER = CALL_FAIL_NO_ANSWER_FROM_USER;
+    static final int PRE_EMPTION = PREEMPTION;
+    static final int DESTINATION_OUT_OF_ORDER = CALL_FAIL_DESTINATION_OUT_OF_ORDER;
+    static final int INVALID_NUMBER_FORMAT = INVALID_NUMBER;
+    static final int RESOURCE_UNAVAILABLE = RESOURCES_UNAVAILABLE_OR_UNSPECIFIED;
+    static final int INCOMING_CALL_BARRED_WITHIN_CUG = INCOMING_CALLS_BARRED_WITHIN_CUG;
+    static final int BEARER_NOT_AUTHORIZED = BEARER_CAPABILITY_NOT_AUTHORIZED;
+    static final int SERVICE_NOT_AVAILABLE = SERVICE_OPTION_NOT_AVAILABLE;
+    static final int BEARER_NOT_IMPLEMENT = BEARER_SERVICE_NOT_IMPLEMENTED;
+    static final int FACILITY_NOT_IMPLEMENT = REQUESTED_FACILITY_NOT_IMPLEMENTED;
+    static final int RESTRICTED_BEARER_AVAILABLE = ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE;
+    static final int OPTION_NOT_AVAILABLE = SERVICE_OR_OPTION_NOT_IMPLEMENTED;
+    static final int INVALID_TRANSACTION_ID_VALUE = INVALID_TRANSACTION_IDENTIFIER;
+    static final int INVALID_TRANSIT_NETWORK_SELECTION = INVALID_TRANSIT_NW_SELECTION;
+    static final int MESSAGE_TYPE_NON_EXISTENT = MESSAGE_TYPE_NON_IMPLEMENTED;
+    static final int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROT_STATE = MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE;
+    static final int IE_NON_EXISTENT_OR_NOT_IMPLEMENTED = INFORMATION_ELEMENT_NON_EXISTENT;
+    static final int RECOVERY_ON_TIMER_EXPIRY = RECOVERY_ON_TIMER_EXPIRED;
+    static final int CM_MM_RR_CONNECTION_RELEASE = 2165;
+
+    /// M: IMS feature. @{
+    /* Normal call failed, need to dial as ECC */
+    static final int IMS_EMERGENCY_REREG = 380;
+    /// @}
 }
diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index c035b2b..c8f83ff 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -1421,7 +1421,12 @@ public void setDataEnabled(boolean enable) {
             // Complete pending USSD
 
             if (isUssdRelease) {
-                found.onUssdRelease();
+                // MTK weirdness
+                if(ussdMessage != null) {
+                    found.onUssdFinished(ussdMessage, isUssdRequest);
+                } else {
+                    found.onUssdRelease();
+                }
             } else if (isUssdError) {
                 found.onUssdFinishedError();
             } else {
diff --git a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index d432104..cc7a29e 100755
--- a/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -225,6 +225,11 @@ public GsmServiceStateTracker(GSMPhone phone) {
         mCi.setOnNITZTime(this, EVENT_NITZ_TIME, null);
         mCi.setOnRestrictedStateChanged(this, EVENT_RESTRICTED_STATE_CHANGED, null);
 
+        if (SystemProperties.get("ro.mtk_ims_support").equals("1")) {
+            // mCi.registerForImsDisable(this, EVENT_IMS_DISABLED_URC, null);  // completely unused
+            mCi.registerForImsRegistrationInfo(this, EVENT_IMS_REGISTRATION_INFO, null);
+        }
+
         // system setting property AIRPLANE_MODE_ON is set in Settings.
         int airplaneMode = Settings.Global.getInt(
                 phone.getContext().getContentResolver(),
@@ -274,6 +279,11 @@ public void dispose() {
         if (mIccRecords != null) {mIccRecords.unregisterForRecordsLoaded(this);}
         mCi.unSetOnRestrictedStateChanged(this);
         mCi.unSetOnNITZTime(this);
+        // xen0n: MTK forgot to unregister this
+        if (SystemProperties.get("ro.mtk_ims_support").equals("1")) {
+            // mCi.unregisterForImsDisable(this);  // completely unused
+            mCi.unregisterForImsRegistrationInfo(this);
+        }
         mCr.unregisterContentObserver(mAutoTimeObserver);
         mCr.unregisterContentObserver(mAutoTimeZoneObserver);
         mPhone.getContext().unregisterReceiver(mIntentReceiver);
@@ -505,6 +515,31 @@ public void handleMessage (Message msg) {
                 updateSpnDisplay();
                 break;
 
+            // MTK
+            // seems totally useless besides debug purposes... but let's debug it anyway
+            case EVENT_IMS_REGISTRATION_INFO:
+                // xen0n: don't pollute namespace with otherwise unused variables
+                int mImsRegInfo = -1;
+                int mImsExtInfo = -1;
+
+                log("handle EVENT_IMS_REGISTRATION_INFO");
+                ar = (AsyncResult) msg.obj;
+                /// M: Simulate IMS Registration @{
+                /*
+                if (SystemProperties.getInt("persist.ims.simulate", 0) == 1) {
+                    ((int[]) ar.result)[0] = (mImsRegistry ? 1 : 0);
+                    log("Override EVENT_IMS_REGISTRATION_INFO: new mImsRegInfo=" +
+                            ((int[]) ar.result)[0]);
+                }
+                */
+                /// @}
+                mImsRegInfo = ((int[]) ar.result)[0];  // xen0n
+                if (((int[]) ar.result)[1] > 0) {
+                    mImsExtInfo = ((int[]) ar.result)[1];
+                }
+                log("ImsRegistrationInfoResult [" + mImsRegInfo + ", " + mImsExtInfo + "]");
+                break;
+
             default:
                 super.handleMessage(msg);
             break;
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
index 73f7a0a..2c77ca8 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
@@ -598,6 +598,115 @@ public void getRadioCapability(Message response) {
     @Override
     public boolean needsOldRilFeature(String feature) { return false; }
 
+    // MTK
+
+    @Override
+    public void supplyNetworkDepersonalization(String netpin, Message result) {
+    }
+
+    /* M: SS part */
+    public void changeBarringPassword(String facility, String oldPwd, String newPwd,
+        String newCfm , Message result) {
+    }
+    /* M: SS part end */
+
+    @Override
+    public void setBandMode(int[] bandMode, Message response) {
+    }
+
+    @Override
+    public void handleCallSetupRequestFromSim(
+            boolean accept, int resCode, Message response) {
+    }
+
+    public void getCOLR(Message response) {
+    }
+
+    public void setCOLP(boolean enable, Message response) {
+    }
+
+    public void getCOLP(Message response) {
+    }
+
+    // Added by M begin
+    @Override
+    public void iccGetATR(Message response) {
+    }
+
+    @Override
+    public void iccOpenChannelWithSw(String AID, Message result){
+    }
+    // Added by M end
+
+    @Override
+    public void setTrm(int mode, Message result) {
+    }
+
+    @Override
+    public void setOnPlmnChangeNotification(Handler h, int what, Object obj) {
+    }
+
+    @Override
+    public void unSetOnPlmnChangeNotification(Handler h) {
+    }
+
+    @Override
+    public void setOnRegistrationSuspended(Handler h, int what, Object obj) {
+    }
+
+    @Override
+    public void unSetOnRegistrationSuspended(Handler h) {
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+    }
+
+    @Override
+    public void queryModemType(Message response) {
+    }
+
+    @Override
+    public void storeModemType(int modemType, Message response) {
+    }
+
+    @Override
+    public void reloadModemType(int modemType, Message response) {
+    }
+
+    // M: Fast Dormancy
+    public void setScri(boolean forceRelease, Message response) {
+    }
+
+    public void setFDMode(int mode, int parameter1, int parameter2, Message response) {
+    }
+
+    //UTK start
+    public void getUtkLocalInfo(Message response) {
+    }
+
+    public void requestUtkRefresh(int type, Message response) {
+    }
+
+    public void reportUtkServiceIsRunning(Message result) {
+    }
+
+    public void profileDownload(String profile, Message response) {
+    }
+
+    public void handleCallSetupRequestFromUim(boolean accept, Message response) {
+    }
+
+    public void queryUtkSetupMenuFromMD(String contents, Message response) {
+    }
+
+    public void setStkSwitchMode(int mode) {
+    }
+
+    public void setBipPsType(int type) {
+    }
+    //UTK end
+
     @Override
     public void startLceService(int reportIntervalMs, boolean pullMode, Message result) {
     }
diff --git a/src/java/com/android/internal/telephony/sip/SipCommandInterface.java b/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
index 5e69f81..6d7122e 100644
--- a/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
+++ b/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
@@ -596,6 +596,115 @@ public void requestShutdown(Message result) {
     @Override
     public boolean needsOldRilFeature(String feature) { return false; }
 
+    // MTK
+
+    @Override
+    public void supplyNetworkDepersonalization(String netpin, Message result) {
+    }
+
+    /* M: SS part */
+    public void changeBarringPassword(String facility, String oldPwd, String newPwd,
+        String newCfm , Message result) {
+    }
+    /* M: SS part end */
+
+    @Override
+    public void setBandMode(int[] bandMode, Message response) {
+    }
+
+    @Override
+    public void handleCallSetupRequestFromSim(
+            boolean accept, int resCode, Message response) {
+    }
+
+    public void getCOLR(Message response) {
+    }
+
+    public void setCOLP(boolean enable, Message response) {
+    }
+
+    public void getCOLP(Message response) {
+    }
+
+    // Added by M begin
+    @Override
+    public void iccGetATR(Message response) {
+    }
+
+    @Override
+    public void iccOpenChannelWithSw(String AID, Message result){
+    }
+    // Added by M end
+
+    @Override
+    public void setTrm(int mode, Message result) {
+    }
+
+    @Override
+    public void setOnPlmnChangeNotification(Handler h, int what, Object obj) {
+    }
+
+    @Override
+    public void unSetOnPlmnChangeNotification(Handler h) {
+    }
+
+    @Override
+    public void setOnRegistrationSuspended(Handler h, int what, Object obj) {
+    }
+
+    @Override
+    public void unSetOnRegistrationSuspended(Handler h) {
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+    }
+
+    @Override
+    public void queryModemType(Message response) {
+    }
+
+    @Override
+    public void storeModemType(int modemType, Message response) {
+    }
+
+    @Override
+    public void reloadModemType(int modemType, Message response) {
+    }
+
+    // M: Fast Dormancy
+    public void setScri(boolean forceRelease, Message response) {
+    }
+
+    public void setFDMode(int mode, int parameter1, int parameter2, Message response) {
+    }
+
+    //UTK start
+    public void getUtkLocalInfo(Message response) {
+    }
+
+    public void requestUtkRefresh(int type, Message response) {
+    }
+
+    public void reportUtkServiceIsRunning(Message result) {
+    }
+
+    public void profileDownload(String profile, Message response) {
+    }
+
+    public void handleCallSetupRequestFromUim(boolean accept, Message response) {
+    }
+
+    public void queryUtkSetupMenuFromMD(String contents, Message response) {
+    }
+
+    public void setStkSwitchMode(int mode) {
+    }
+
+    public void setBipPsType(int type) {
+    }
+    //UTK end
+
     @Override
     public void startLceService(int reportIntervalMs, boolean pullMode, Message result) {
     }
diff --git a/src/java/com/android/internal/telephony/test/SimulatedCommands.java b/src/java/com/android/internal/telephony/test/SimulatedCommands.java
index 745378c..d804c4b 100644
--- a/src/java/com/android/internal/telephony/test/SimulatedCommands.java
+++ b/src/java/com/android/internal/telephony/test/SimulatedCommands.java
@@ -1776,6 +1776,141 @@ public void requestShutdown(Message result) {
     @Override
     public boolean needsOldRilFeature(String feature) { return false; }
 
+    // MTK
+
+    @Override
+    public void supplyNetworkDepersonalization(String netpin, Message result)  {
+        unimplemented(result);
+    }
+
+    @Override
+    public void setBandMode(int[] bandMode, Message response) {
+        resultSuccess(response, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void handleCallSetupRequestFromSim(
+            boolean accept, int resCode, Message response) {
+        resultSuccess(response, null);
+    }
+
+    /* M: SS part */
+    public void getCOLR(Message response) {
+        unimplemented(response);
+    }
+
+    public void setCOLP(boolean enable, Message response) {
+        unimplemented(response);
+    }
+
+    public void getCOLP(Message response) {
+        unimplemented(response);
+    }
+    /* M: SS part end */
+
+    /* M: SS part */
+    public void changeBarringPassword(String facility, String oldPwd, String newPwd,
+        String newCfm , Message result) {
+            unimplemented(result);
+    }
+    /* M: SS part end */
+
+    /// M: CC010: Add RIL interface @{
+    public void emergencyDial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        resultSuccess(result, null);
+    }
+
+    public void hangupAll(Message result) {
+        resultSuccess(result, null);
+    }
+
+    public void forceReleaseCall(int index, Message response) {
+        unimplemented(response);
+    }
+
+    public void setCallIndication(int mode, int callId, int seqNumber, Message response) {
+        unimplemented(response);
+    }
+    /// @}
+
+    // Added by M begin
+    @Override
+    public void iccGetATR(Message response) {
+        unimplemented(response);
+    }
+
+    @Override
+    public void iccOpenChannelWithSw(String AID, Message response) {
+        unimplemented(response);
+    }
+    // Added by M end
+
+    @Override
+    public void setTrm(int mode, Message result) {
+    }
+
+    @Override
+    public void setResumeRegistration(int sessionId, Message response) {
+    }
+
+    @Override
+    public void queryModemType(Message response) {
+    }
+
+    @Override
+    public void storeModemType(int modemType, Message response) {
+    }
+
+    @Override
+    public void reloadModemType(int modemType, Message response) {
+    }
+
+    // M: Fast Dormancy
+    public void setScri(boolean forceRelease, Message response) {
+        resultSuccess(response, null);
+    }
+
+    public void setFDMode(int mode, int parameter1, int parameter2, Message response) {
+    }
+
+    // UTK start
+    public void getUtkLocalInfo(Message response) {
+        unimplemented(response);
+    }
+
+    public void requestUtkRefresh(int type, Message response) {
+        unimplemented(response);
+    }
+
+    public void handleCallSetupRequestFromUim(boolean accept, Message response) {
+        unimplemented(response);
+    }
+
+    public void reportUtkServiceIsRunning(Message result) {
+        resultSuccess(result, null);
+    }
+
+    public void profileDownload(String profile, Message response) {
+        resultSuccess(response, null);
+    }
+
+    public void queryUtkSetupMenuFromMD(String contents, Message response) {
+        resultSuccess(response, null);
+    }
+
+
+    @Override
+    public void setStkSwitchMode(int mode) {
+    }
+
+    @Override
+    public void setBipPsType(int type) {
+    }
+    //UTK end
+
     @Override
     public void startLceService(int report_interval_ms, boolean pullMode, Message result) {
         unimplemented(result);
diff --git a/src/java/com/android/internal/telephony/uicc/IccCardProxy.java b/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
index ce8a671..f9c6a43 100644
--- a/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
+++ b/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
@@ -33,6 +33,7 @@
 import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
 
+import com.android.internal.telephony.CommandException;
 import com.android.internal.telephony.CommandsInterface;
 import com.android.internal.telephony.IccCard;
 import com.android.internal.telephony.IccCardConstants;
@@ -50,6 +51,10 @@
 import com.android.internal.telephony.uicc.IccCardStatus.PinState;
 import com.android.internal.telephony.uicc.UiccController;
 
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteModeController;
+// import com.mediatek.internal.telephony.uicc.SvlteUiccUtils;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 
@@ -127,8 +132,10 @@ public IccCardProxy(Context context, CommandsInterface ci, int phoneId) {
                 ci, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
         mUiccController = UiccController.getInstance();
         mUiccController.registerForIccChanged(this, EVENT_ICC_CHANGED, null);
+        mUiccController.registerForIccRecovery(this, EVENT_ICC_RECOVERY, null);  // MTK
         ci.registerForOn(this,EVENT_RADIO_ON, null);
         ci.registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_UNAVAILABLE, null);
+        ci.registerForNotAvailable(this, EVENT_NOT_AVAILABLE, null);  // MTK
 
         resetProperties();
         setExternalState(State.NOT_READY, false);
@@ -139,9 +146,11 @@ public void dispose() {
             log("Disposing");
             //Cleanup icc references
             mUiccController.unregisterForIccChanged(this);
+            mUiccController.unregisterForIccRecovery(this);  // MTK
             mUiccController = null;
             mCi.unregisterForOn(this);
             mCi.unregisterForOffOrNotAvailable(this);
+            mCi.unregisterForNotAvailable(this);  // MTK
             mCdmaSSM.dispose(this);
         }
     }
@@ -240,7 +249,27 @@ public void handleMessage(Message msg) {
                 break;
             case EVENT_ICC_CHANGED:
                 if (mInitialized) {
-                    updateIccAvailability();
+                    // MTK
+                    AsyncResult ar = (AsyncResult) msg.obj;
+                    int index = mPhoneId;
+
+                    if (ar != null && ar.result instanceof Integer) {
+                        index = ((Integer) ar.result).intValue();
+                        log("handleMessage (EVENT_ICC_CHANGED) , index = " + index);
+                    } else {
+                        log("handleMessage (EVENT_ICC_CHANGED), come from myself");
+                    }
+
+                    // SVLTE
+                    // MTK TODO
+                    /*
+                    if (CdmaFeatureOptionUtils.isCdmaLteDcSupport() && index == 100) {
+                        index = SvlteModeController.getCdmaSocketSlotId();
+                    }
+                    */
+                    if (index == mPhoneId) {
+                        updateIccAvailability();
+                    }
                 }
                 break;
             case EVENT_ICC_ABSENT:
@@ -284,6 +313,11 @@ public void handleMessage(Message msg) {
                 broadcastIccStateChangedIntent(IccCardConstants.INTENT_VALUE_ICC_IMSI, null);
                 break;
             case EVENT_NETWORK_LOCKED:
+                // MTK
+                if (mUiccApplication == null) {
+                        loge("getIccStateReason: NETWORK_LOCKED but mUiccApplication is null!");
+                    return;
+                }
                 mNetworkLockedRegistrants.notifyRegistrants();
                 setExternalState(State.NETWORK_LOCKED);
                 break;
@@ -319,6 +353,34 @@ public void handleMessage(Message msg) {
                 onRecordsLoaded();
                 break;
 
+            // MTK
+            case EVENT_NOT_AVAILABLE:
+                log("handleMessage (EVENT_NOT_AVAILABLE)");
+                setExternalState(State.NOT_READY);
+                break;
+
+            case EVENT_ICC_RECOVERY: {
+                AsyncResult ar = (AsyncResult) msg.obj;
+                Integer index = (Integer) ar.result;
+                log("handleMessage (EVENT_ICC_RECOVERY) , index = " + index);
+                if (index == mPhoneId) {
+                    if (DBG) log("mRecoveryRegistrants notify");
+                    mRecoveryRegistrants.notifyRegistrants();
+                }
+                break;
+            }
+
+            case EVENT_ICC_FDN_CHANGED:
+                mFdnChangedRegistrants.notifyRegistrants();
+                break;
+
+            case EVENT_ICC_REFRESH:
+                log("EVENT_ICC_REFRESH");
+                if (mIccRecords != null) {
+                    mIccRecords.onRefresh(true, null);
+                }
+                break;
+
             default:
                 loge("Unhandled message with number: " + msg.what);
                 break;
@@ -432,6 +494,10 @@ private void updateExternalState() {
             case APPSTATE_READY:
                 setExternalState(State.READY);
                 break;
+            // MTK
+            default:
+                setExternalState(State.UNKNOWN);
+                break;
         }
     }
 
@@ -443,6 +509,8 @@ private void registerUiccCardEvents() {
             mUiccApplication.registerForReady(this, EVENT_APP_READY, null);
             mUiccApplication.registerForLocked(this, EVENT_ICC_LOCKED, null);
             mUiccApplication.registerForNetworkLocked(this, EVENT_NETWORK_LOCKED, null);
+            // MTK
+            mUiccApplication.registerForFdnChanged(this, EVENT_ICC_FDN_CHANGED, null);
         }
         if (mIccRecords != null) {
             mIccRecords.registerForImsiReady(this, EVENT_IMSI_READY, null);
@@ -456,6 +524,7 @@ private void unregisterUiccCardEvents() {
         if (mUiccApplication != null) mUiccApplication.unregisterForReady(this);
         if (mUiccApplication != null) mUiccApplication.unregisterForLocked(this);
         if (mUiccApplication != null) mUiccApplication.unregisterForNetworkLocked(this);
+        if (mUiccApplication != null) mUiccApplication.unregisterForFdnChanged(this);  // MTK
         if (mIccRecords != null) mIccRecords.unregisterForImsiReady(this);
         if (mIccRecords != null) mIccRecords.unregisterForRecordsLoaded(this);
         if (mIccRecords != null) mIccRecords.unregisterForRecordsEvents(this);
@@ -578,6 +647,16 @@ private void processLockedState() {
     }
 
     private void setExternalState(State newState) {
+
+        // MTK
+        if (newState == State.PIN_REQUIRED && mUiccApplication != null) {
+            PinState pin1State = mUiccApplication.getPin1State();
+            if (pin1State == PinState.PINSTATE_ENABLED_PERM_BLOCKED) {
+                setExternalState(State.PERM_DISABLED);
+                return;
+            }
+        }
+
         setExternalState(newState, false);
     }
 
@@ -613,6 +692,23 @@ private String getIccStateReason(State state) {
             case PIN_REQUIRED: return IccCardConstants.INTENT_VALUE_LOCKED_ON_PIN;
             case PUK_REQUIRED: return IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK;
             case NETWORK_LOCKED: return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK;
+            // MTK TODO
+            /*
+            case NETWORK_LOCKED:
+                switch (mUiccApplication.getPersoSubState()) {
+                        case PERSOSUBSTATE_SIM_NETWORK:
+                            return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK;
+                        case PERSOSUBSTATE_SIM_NETWORK_SUBSET:
+                            return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK_SUBSET;
+                        case PERSOSUBSTATE_SIM_CORPORATE:
+                            return IccCardConstants.INTENT_VALUE_LOCKED_CORPORATE;
+                        case PERSOSUBSTATE_SIM_SERVICE_PROVIDER:
+                            return IccCardConstants.INTENT_VALUE_LOCKED_SERVICE_PROVIDER;
+                        case PERSOSUBSTATE_SIM_SIM:
+                            return IccCardConstants.INTENT_VALUE_LOCKED_SIM;
+                        default: return null;
+                }
+            */
             case PERM_DISABLED: return IccCardConstants.INTENT_VALUE_ABSENT_ON_PERM_DISABLED;
             case CARD_IO_ERROR: return IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR;
             default: return null;
@@ -719,7 +815,10 @@ public void supplyPin(String pin, Message onComplete) {
             if (mUiccApplication != null) {
                 mUiccApplication.supplyPin(pin, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to supplyPin, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -733,7 +832,10 @@ public void supplyPuk(String puk, String newPin, Message onComplete) {
             if (mUiccApplication != null) {
                 mUiccApplication.supplyPuk(puk, newPin, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to supplyPuk, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -747,7 +849,10 @@ public void supplyPin2(String pin2, Message onComplete) {
             if (mUiccApplication != null) {
                 mUiccApplication.supplyPin2(pin2, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to supplyPin2, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -761,7 +866,10 @@ public void supplyPuk2(String puk2, String newPin2, Message onComplete) {
             if (mUiccApplication != null) {
                 mUiccApplication.supplyPuk2(puk2, newPin2, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to supplyPuk2, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -825,7 +933,10 @@ public void setIccLockEnabled(boolean enabled, String password, Message onComple
             if (mUiccApplication != null) {
                 mUiccApplication.setIccLockEnabled(enabled, password, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to setIccLockEnabled, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -839,7 +950,10 @@ public void setIccFdnEnabled(boolean enabled, String password, Message onComplet
             if (mUiccApplication != null) {
                 mUiccApplication.setIccFdnEnabled(enabled, password, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to setIccFdnEnabled, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -853,7 +967,10 @@ public void changeIccLockPassword(String oldPassword, String newPassword, Messag
             if (mUiccApplication != null) {
                 mUiccApplication.changeIccLockPassword(oldPassword, newPassword, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to changeIccLockPassword, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -867,7 +984,10 @@ public void changeIccFdnPassword(String oldPassword, String newPassword, Message
             if (mUiccApplication != null) {
                 mUiccApplication.changeIccFdnPassword(oldPassword, newPassword, onComplete);
             } else if (onComplete != null) {
-                Exception e = new RuntimeException("ICC card is absent.");
+                // MTK
+                // Exception e = new RuntimeException("ICC card is absent.");
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to changeIccFdnPassword, hasIccCard = " + hasIccCard());
                 AsyncResult.forMessage(onComplete).exception = e;
                 onComplete.sendToTarget();
                 return;
@@ -896,10 +1016,32 @@ public boolean isApplicationOnIcc(IccCardApplicationStatus.AppType type) {
     @Override
     public boolean hasIccCard() {
         synchronized (mLock) {
-            if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
-                return true;
+            // MTK
+            /*
+             if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+                 return true;
+             }
+             return false;
+            */
+            boolean isSimInsert = false;
+
+            // To obtain correct status earily,
+            // we use system property value to detemine sim inserted state.
+            String iccId = null;
+            iccId = SystemProperties.get(PROPERTY_ICCID_SIM[mPhoneId]);
+
+            if (DBG) log("iccId = " + iccId);
+            if ((iccId != null) && !(iccId.equals("")) && !(iccId.equals(ICCID_STRING_FOR_NO_SIM))) {
+                isSimInsert = true;
             }
-            return false;
+
+            if (!isSimInsert && mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+                isSimInsert = true;
+            }
+
+            if (DBG) log("hasIccCard(): isSimInsert =  " + isSimInsert + " ,CardState = " + ((mUiccCard != null) ? mUiccCard.getCardState() : ""));
+
+            return isSimInsert;
         }
     }
 
@@ -911,11 +1053,11 @@ public IccRecords getIccRecord() {
         return mIccRecords;
     }
     private void log(String s) {
-        Rlog.d(LOG_TAG, s);
+        Rlog.d(LOG_TAG, s /* MTK */ + " (slot " + mPhoneId + ")");
     }
 
     private void loge(String msg) {
-        Rlog.e(LOG_TAG, msg);
+        Rlog.e(LOG_TAG, msg /* MTK */ + " (slot " + mPhoneId + ")");
     }
 
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
@@ -950,4 +1092,214 @@ public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
 
         pw.flush();
     }
+
+    // MTK
+
+    private static final int EVENT_ICC_REFRESH = 12;
+
+    private static final int EVENT_ICC_RECOVERY = 100;
+    private static final int EVENT_ICC_FDN_CHANGED = 101;
+    private static final int EVENT_NOT_AVAILABLE = 102;
+
+    private RegistrantList mRecoveryRegistrants = new RegistrantList();
+    private RegistrantList mFdnChangedRegistrants = new RegistrantList();
+
+    // private PersoSubState mNetworkLockState = PersoSubState.PERSOSUBSTATE_UNKNOWN;
+
+
+    private static final String ICCID_STRING_FOR_NO_SIM = "N/A";
+    private String[] PROPERTY_ICCID_SIM = {
+        "ril.iccid.sim1",
+        "ril.iccid.sim2",
+        "ril.iccid.sim3",
+        "ril.iccid.sim4",
+    };
+
+    private static final String COMMON_SLOT_PROPERTY = "";
+    private static Intent sInternalIntent = null;
+
+    /**
+     * Refresh and load all of sim files if active phone is switched to svltephone.
+     */
+    public void updateIccRefresh() {
+        sendMessage(obtainMessage(EVENT_ICC_REFRESH));
+    }
+
+    @Override
+    public void supplyNetworkDepersonalization(String pin, Message onComplete) {
+        synchronized (mLock) {
+            if (mUiccApplication != null) {
+                mUiccApplication.supplyNetworkDepersonalization(pin, onComplete);
+            } else if (onComplete != null) {
+                Exception e = new RuntimeException("CommandsInterface is not set.");
+                AsyncResult.forMessage(onComplete).exception = e;
+                onComplete.sendToTarget();
+                return;
+            }
+        }
+    }
+
+    /**
+     * Query the SIM ME Lock type required to unlock.
+     *
+     * @return SIM ME Lock type
+     */
+    public PersoSubState getNetworkPersoType() {
+        synchronized (mLock) {
+            if (mUiccApplication != null) {
+                return mUiccApplication.getPersoSubState();
+            }
+            return PersoSubState.PERSOSUBSTATE_UNKNOWN;
+        }
+    }
+
+    /**
+     * Check whether ICC network lock is enabled
+     * This is an async call which returns lock state to applications directly
+     */
+    @Override
+    public void queryIccNetworkLock(int category, Message onComplete) {
+        if (DBG) log("queryIccNetworkLock(): category =  "  category);
+        synchronized (mLock) {
+            if (mUiccApplication != null) {
+                mUiccApplication.queryIccNetworkLock(category, onComplete);
+            } else if (onComplete != null) {
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to queryIccNetworkLock, hasIccCard = "  hasIccCard());
+                AsyncResult.forMessage(onComplete).exception = e;
+                onComplete.sendToTarget();
+                return;
+            }
+        }
+    }
+
+    /**
+     * Set the ICC network lock enabled or disabled
+     * When the operation is complete, onComplete will be sent to its handler
+     */
+    @Override
+    public void setIccNetworkLockEnabled(int category,
+            int lockop, String password, String data_imsi, String gid1, String gid2, Message onComplete) {
+        if (DBG) log("SetIccNetworkEnabled(): category = "  category
+            + " lockop = " + lockop + " password = " + password
+            + " data_imsi = " + data_imsi + " gid1 = " + gid1 + " gid2 = " + gid2);
+        synchronized (mLock) {
+            if (mUiccApplication != null) {
+                mUiccApplication.setIccNetworkLockEnabled(
+                    category, lockop, password, data_imsi, gid1, gid2, onComplete);
+            } else if (onComplete != null) {
+                Exception e = CommandException.fromRilErrno(RILConstants.RADIO_NOT_AVAILABLE);
+                log("Fail to setIccNetworkLockEnabled, hasIccCard = " + hasIccCard());
+                AsyncResult.forMessage(onComplete).exception = e;
+                onComplete.sendToTarget();
+                return;
+            }
+        }
+    }
+
+    /**
+     * Used by SIM ME lock related enhancement feature(Modem SML change feature).
+     */
+    public void repollIccStateForModemSmlChangeFeatrue(boolean needIntent) {
+        if (DBG) log("repollIccStateForModemSmlChangeFeatrue, needIntent = " + needIntent);
+        synchronized (mLock) {
+            mUiccController.repollIccStateForModemSmlChangeFeatrue(mPhoneId, needIntent);
+        }
+    }
+
+    public void exchangeSimIo(int fileID, int command,
+                              int p1, int p2, int p3, String pathID, String data, String pin2, Message onComplete) {
+        synchronized (mLock) {
+            if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+                mUiccCard.exchangeSimIo(fileID, command, p1, p2, p3, pathID,
+                        data, pin2, onComplete);
+            }
+        }
+    }
+
+    public void iccGetAtr(Message onComplete) {
+        synchronized (mLock) {
+            if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+                mUiccCard.iccGetAtr(onComplete);
+            }
+        }
+    }
+
+    public void openLogicalChannelWithSw(String AID, Message onComplete) {
+        synchronized (mLock) {
+            if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+                mUiccCard.iccOpenChannelWithSw(AID, onComplete);
+            }
+        }
+    }
+
+    // retrun usim property or use uicccardapplication app type
+    public String getIccCardType() {
+        synchronized (mLock) {
+            if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+                return mUiccCard.getIccCardType();
+            }
+            return "";
+        }
+    }
+
+    // MTK-START
+    /**
+     * Request to get SVLTE UICC card type.
+     *
+     * @return index for UICC card type
+     *
+     */
+    public int getSvlteCardType() {
+        synchronized (mLock) {
+            if (mUiccCard != null && mUiccCard.getCardState() != CardState.CARDSTATE_ABSENT) {
+                return mUiccCard.getSvlteCardType();
+            }
+            return 0;
+        }
+    }
+    // MTK-END
+
+    public void registerForRecovery(Handler h, int what, Object obj) {
+        synchronized (mLock) {
+            Registrant r = new Registrant(h, what, obj);
+
+            mRecoveryRegistrants.add(r);
+
+            if (getState() == State.READY) {
+                r.notifyRegistrant();
+            }
+        }
+    }
+
+    public void unregisterForRecovery(Handler h) {
+        synchronized (mLock) {
+            mRecoveryRegistrants.remove(h);
+        }
+    }
+
+    /**
+     * Notifies handler in case of FDN changed
+     */
+    @Override
+    public void registerForFdnChanged(Handler h, int what, Object obj) {
+        synchronized (mLock) {
+            synchronized (mLock) {
+                Registrant r = new Registrant(h, what, obj);
+
+                mFdnChangedRegistrants.add(r);
+
+                if (getIccFdnEnabled()) {
+                    r.notifyRegistrant();
+                }
+            }
+        }
+    }
+
+    @Override
+    public void unregisterForFdnChanged(Handler h) {
+        synchronized (mLock) {
+            mFdnChangedRegistrants.remove(h);
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/uicc/IccFileHandler.java b/src/java/com/android/internal/telephony/uicc/IccFileHandler.java
index a348110..9debae8 100644
--- a/src/java/com/android/internal/telephony/uicc/IccFileHandler.java
+++ b/src/java/com/android/internal/telephony/uicc/IccFileHandler.java
@@ -289,7 +289,7 @@ public void loadEFTransparent(int fileid, Message onLoaded) {
                         fileid, 0, onLoaded);
 
         mCi.iccIOForApp(COMMAND_GET_RESPONSE, fileid, getEFPath(fileid),
-                        0, 0, 0, null, null, mAid, response);
+                        0, 0, GET_RESPONSE_EF_SIZE_BYTES, null, null, mAid, response);
     }
 
     /**
diff --git a/src/java/com/android/internal/telephony/uicc/IccRecords.java b/src/java/com/android/internal/telephony/uicc/IccRecords.java
index 70c609d..3ea31e6 100644
--- a/src/java/com/android/internal/telephony/uicc/IccRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/IccRecords.java
@@ -549,6 +549,13 @@ protected static String findBestLanguage(byte[] languages, String[] locales)
 
     protected abstract void handleFileUpdate(int efid);
 
+    // xen0n
+    protected void handleFileUpdate(int[] efids) {
+        for (int efid : efids) {
+            handleFileUpdate(efid);
+        }
+    }
+
     protected void broadcastRefresh() {
     }
 
diff --git a/src/java/com/android/internal/telephony/uicc/IccRefreshResponse.java b/src/java/com/android/internal/telephony/uicc/IccRefreshResponse.java
index c1d29f8..d7f5522 100644
--- a/src/java/com/android/internal/telephony/uicc/IccRefreshResponse.java
+++ b/src/java/com/android/internal/telephony/uicc/IccRefreshResponse.java
@@ -28,12 +28,19 @@
     public static final int REFRESH_RESULT_INIT = 1;        /* The Icc has been initialized */
     public static final int REFRESH_RESULT_RESET = 2;       /* The Icc was reset */
 
+    // MTK
+    public static final int REFRESH_RESULT_APP_INIT = 3; /* UICC APP reset, for wifi calling */
+    public static final int REFRESH_INIT_FULL_FILE_UPDATED = 4;  /* SIM init and full file upload */
+    public static final int REFRESH_INIT_FILE_UPDATED = 5;  /* SIM init and single file updated */
+
     public int             refreshResult;      /* Sim Refresh result */
-    public int             efId;               /* EFID */
+    public int[]           efId;               /* EFID */
     public String          aid;                /* null terminated string, e.g.,
                                                   from 0xA0, 0x00 -> 0x41,
                                                   0x30, 0x30, 0x30 */
                                                /* Example: a0000000871002f310ffff89080000ff */
+    // MTK
+    public int             sessionId;          /* active channel id */
 
     @Override
     public String toString() {
diff --git a/src/java/com/android/internal/telephony/uicc/SpnOverride.java b/src/java/com/android/internal/telephony/uicc/SpnOverride.java
index 3a01af6..7b9192c 100644
--- a/src/java/com/android/internal/telephony/uicc/SpnOverride.java
+++ b/src/java/com/android/internal/telephony/uicc/SpnOverride.java
@@ -26,11 +26,23 @@
 import org.xmlpull.v1.XmlPullParserException;
 
 import android.os.Environment;
+import android.os.SystemProperties;
 import android.telephony.Rlog;
 import android.util.Xml;
 
 import com.android.internal.util.XmlUtils;
 
+import java.util.ArrayList;
+
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.PhoneConstants;
+import android.telephony.SubscriptionManager;
+import android.content.Context;
+
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+import com.mediatek.internal.telephony.ltedc.svlte.SvlteUtils;
+
 public class SpnOverride {
     private HashMap<String, String> mCarrierSpnMap;
 
@@ -42,6 +54,36 @@
     SpnOverride () {
         mCarrierSpnMap = new HashMap<String, String>();
         loadSpnOverrides();
+
+        // xen0n: initialize the static contents only once
+        // race conditions can be ignored as the init operations should be
+        // idempotent
+        // MTK-START
+        // MVNO-API
+        // EF_SPN
+        if (CarrierVirtualSpnMapByEfSpn == null) {
+            CarrierVirtualSpnMapByEfSpn = new HashMap<String, String>();
+            loadVirtualSpnOverridesByEfSpn();
+        }
+
+        // IMSI
+        if (CarrierVirtualSpnMapByImsi == null) {
+            this.CarrierVirtualSpnMapByImsi = new ArrayList();
+            this.loadVirtualSpnOverridesByImsi();
+        }
+
+        // EF_PNN
+        if (CarrierVirtualSpnMapByEfPnn == null) {
+            CarrierVirtualSpnMapByEfPnn = new HashMap<String, String>();
+            loadVirtualSpnOverridesByEfPnn();
+        }
+
+        // EF_GID1
+        if (CarrierVirtualSpnMapByEfGid1 == null) {
+            CarrierVirtualSpnMapByEfGid1 = new HashMap<String, String>();
+            loadVirtualSpnOverridesByEfGid1();
+        }
+        // MTK-END
     }
 
     boolean containsCarrier(String carrier) {
@@ -111,4 +153,428 @@ private void loadSpnOverrides() {
         }
     }
 
+    // MTK
+
+    // MTK-START
+    private static SpnOverride sInstance;
+    static final Object sInstSync = new Object();
+
+    // MVNO-API START
+    // EF_SPN
+    private static HashMap<String, String> CarrierVirtualSpnMapByEfSpn;
+    private static final String PARTNER_VIRTUAL_SPN_BY_EF_SPN_OVERRIDE_PATH = "etc/virtual-spn-conf-by-efspn.xml";
+
+    // IMSI
+    private ArrayList CarrierVirtualSpnMapByImsi;
+    private static final String PARTNER_VIRTUAL_SPN_BY_IMSI_OVERRIDE_PATH = "etc/virtual-spn-conf-by-imsi.xml";
+
+    // EF_PNN
+    private static HashMap<String, String> CarrierVirtualSpnMapByEfPnn;
+    private static final String PARTNER_VIRTUAL_SPN_BY_EF_PNN_OVERRIDE_PATH = "etc/virtual-spn-conf-by-efpnn.xml";
+
+    // EF_GID1
+    private static HashMap<String, String> CarrierVirtualSpnMapByEfGid1;
+    private static final String PARTNER_VIRTUAL_SPN_BY_EF_GID1_OVERRIDE_PATH = "etc/virtual-spn-conf-by-efgid1.xml";
+
+    public class VirtualSpnByImsi {
+        public String pattern;
+        public String name;
+        public VirtualSpnByImsi(String pattern, String name) {
+            this.pattern = pattern;
+            this.name = name;
+        }
+    }
+    // MVNO-API END
+
+    public static SpnOverride getInstance() {
+        synchronized (sInstSync) {
+            if (sInstance == null) {
+                sInstance = new SpnOverride();
+            }
+        }
+        return sInstance;
+    }
+    // MTK-END
+
+    // MTK-START
+    // MVNO-API START
+    private static void loadVirtualSpnOverridesByEfSpn() {
+        FileReader spnReader;
+        Rlog.d(LOG_TAG, "loadVirtualSpnOverridesByEfSpn");
+        final File spnFile = new File(Environment.getRootDirectory(), PARTNER_VIRTUAL_SPN_BY_EF_SPN_OVERRIDE_PATH);
+
+        try {
+            spnReader = new FileReader(spnFile);
+        } catch (FileNotFoundException e) {
+            Rlog.w(LOG_TAG, "Can't open " +
+                    Environment.getRootDirectory() + "/" + PARTNER_VIRTUAL_SPN_BY_EF_SPN_OVERRIDE_PATH);
+            return;
+        }
+
+        try {
+            XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(spnReader);
+
+            XmlUtils.beginDocument(parser, "virtualSpnOverridesByEfSpn");
+
+            while (true) {
+                XmlUtils.nextElement(parser);
+
+                String name = parser.getName();
+                if (!"virtualSpnOverride".equals(name)) {
+                    break;
+                }
+
+                String mccmncspn = parser.getAttributeValue(null, "mccmncspn");
+                String spn = parser.getAttributeValue(null, "name");
+                Rlog.w(LOG_TAG, "test mccmncspn = " + mccmncspn + ", name = " + spn);
+                CarrierVirtualSpnMapByEfSpn.put(mccmncspn, spn);
+            }
+            spnReader.close();
+        } catch (XmlPullParserException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-efspn parser " + e);
+        } catch (IOException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-efspn parser " + e);
+        }
+    }
+
+    public String getSpnByEfSpn(String mccmnc, String spn) {
+        if (mccmnc == null || spn == null || mccmnc.isEmpty() || spn.isEmpty())
+            return null;
+
+        return CarrierVirtualSpnMapByEfSpn.get(mccmnc + spn);
+    }
+
+    private void loadVirtualSpnOverridesByImsi() {
+        FileReader spnReader;
+        Rlog.d(LOG_TAG, "loadVirtualSpnOverridesByImsi");
+        final File spnFile = new File(Environment.getRootDirectory(), PARTNER_VIRTUAL_SPN_BY_IMSI_OVERRIDE_PATH);
+
+        try {
+            spnReader = new FileReader(spnFile);
+        } catch (FileNotFoundException e) {
+            Rlog.w(LOG_TAG, "Can't open " +
+                    Environment.getRootDirectory() + "/" + PARTNER_VIRTUAL_SPN_BY_IMSI_OVERRIDE_PATH);
+            return;
+        }
+
+        try {
+            XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(spnReader);
+
+            XmlUtils.beginDocument(parser, "virtualSpnOverridesByImsi");
+
+            while (true) {
+                XmlUtils.nextElement(parser);
+
+                String name = parser.getName();
+                if (!"virtualSpnOverride".equals(name)) {
+                    break;
+                }
+
+                String imsipattern = parser.getAttributeValue(null, "imsipattern");
+                String spn = parser.getAttributeValue(null, "name");
+                Rlog.w(LOG_TAG, "test imsipattern = " + imsipattern + ", name = " + spn);
+                this.CarrierVirtualSpnMapByImsi.add(new VirtualSpnByImsi(imsipattern, spn));
+            }
+            spnReader.close();
+        } catch (XmlPullParserException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-imsi parser " + e);
+        } catch (IOException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-imsi parser " + e);
+        }
+    }
+
+    public String getSpnByImsi(String mccmnc, String imsi) {
+        if (mccmnc == null || imsi == null || mccmnc.isEmpty() || imsi.isEmpty())
+            return null;
+
+        VirtualSpnByImsi vsbi;
+        for (int i = 0; i < this.CarrierVirtualSpnMapByImsi.size(); i++) {
+            vsbi = (VirtualSpnByImsi) (this.CarrierVirtualSpnMapByImsi.get(i));
+            Rlog.w(LOG_TAG, "getSpnByImsi(): mccmnc = " + mccmnc + ", imsi = " +
+                    imsi + ", pattern = " + vsbi.pattern);
+
+            if (imsiMatches(vsbi.pattern, mccmnc + imsi) == true) {
+                return vsbi.name;
+            }
+        }
+        return null;
+    }
+
+    public String isOperatorMvnoForImsi(String mccmnc, String imsi) {
+        if (mccmnc == null || imsi == null || mccmnc.isEmpty() || imsi.isEmpty())
+            return null;
+
+        VirtualSpnByImsi vsbi;
+        String pattern;
+        for (int i = 0; i < this.CarrierVirtualSpnMapByImsi.size(); i++) {
+            vsbi = (VirtualSpnByImsi) (this.CarrierVirtualSpnMapByImsi.get(i));
+            Rlog.w(LOG_TAG, "isOperatorMvnoForImsi(): mccmnc = " + mccmnc +
+                    ", imsi = " + imsi + ", pattern = " + vsbi.pattern);
+
+            if (imsiMatches(vsbi.pattern, mccmnc + imsi) == true) {
+                return vsbi.pattern;
+            }
+        }
+        return null;
+    }
+
+   private boolean imsiMatches(String imsiDB, String imsiSIM) {
+        // Note: imsiDB value has digit number or 'x' character for seperating USIM information
+        // for MVNO operator. And then digit number is matched at same order and 'x' character
+        // could replace by any digit number.
+        // ex) if imsiDB inserted '310260x10xxxxxx' for GG Operator,
+        //     that means first 6 digits, 8th and 9th digit
+        //     should be set in USIM for GG Operator.
+        int len = imsiDB.length();
+        int idxCompare = 0;
+
+        Rlog.w(LOG_TAG, "mvno match imsi = " + imsiSIM + "pattern = " + imsiDB);
+        if (len <= 0) return false;
+        if (len > imsiSIM.length()) return false;
+
+        for (int idx = 0; idx < len; idx++) {
+            char c = imsiDB.charAt(idx);
+            if ((c == 'x') || (c == 'X') || (c == imsiSIM.charAt(idx))) {
+                continue;
+            } else {
+                return false;
+            }
+        }
+        return true;
+    }
+    private static void loadVirtualSpnOverridesByEfPnn() {
+        FileReader spnReader;
+        Rlog.d(LOG_TAG, "loadVirtualSpnOverridesByEfPnn");
+        final File spnFile = new File(Environment.getRootDirectory(), PARTNER_VIRTUAL_SPN_BY_EF_PNN_OVERRIDE_PATH);
+
+        try {
+            spnReader = new FileReader(spnFile);
+        } catch (FileNotFoundException e) {
+            Rlog.w(LOG_TAG, "Can't open " +
+                    Environment.getRootDirectory() + "/" + PARTNER_VIRTUAL_SPN_BY_EF_PNN_OVERRIDE_PATH);
+            return;
+        }
+
+        try {
+            XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(spnReader);
+
+            XmlUtils.beginDocument(parser, "virtualSpnOverridesByEfPnn");
+
+            while (true) {
+                XmlUtils.nextElement(parser);
+
+                String name = parser.getName();
+                if (!"virtualSpnOverride".equals(name)) {
+                    break;
+                }
+
+                String mccmncpnn = parser.getAttributeValue(null, "mccmncpnn");
+                String spn = parser.getAttributeValue(null, "name");
+                Rlog.w(LOG_TAG, "test mccmncpnn = " + mccmncpnn + ", name = " + spn);
+                CarrierVirtualSpnMapByEfPnn.put(mccmncpnn, spn);
+            }
+            spnReader.close();
+        } catch (XmlPullParserException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-efpnn parser " + e);
+        } catch (IOException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-efpnn parser " + e);
+        }
+    }
+
+    public String getSpnByEfPnn(String mccmnc, String pnn) {
+        if (mccmnc == null || pnn == null || mccmnc.isEmpty() || pnn.isEmpty())
+            return null;
+
+        return CarrierVirtualSpnMapByEfPnn.get(mccmnc + pnn);
+    }
+
+    private static void loadVirtualSpnOverridesByEfGid1() {
+        FileReader spnReader;
+        Rlog.d(LOG_TAG, "loadVirtualSpnOverridesByEfGid1");
+        final File spnFile = new File(Environment.getRootDirectory(), PARTNER_VIRTUAL_SPN_BY_EF_GID1_OVERRIDE_PATH);
+
+        try {
+            spnReader = new FileReader(spnFile);
+        } catch (FileNotFoundException e) {
+            Rlog.w(LOG_TAG, "Can't open " +
+                    Environment.getRootDirectory() + "/" + PARTNER_VIRTUAL_SPN_BY_EF_GID1_OVERRIDE_PATH);
+            return;
+        }
+
+        try {
+            XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(spnReader);
+
+            XmlUtils.beginDocument(parser, "virtualSpnOverridesByEfGid1");
+
+            while (true) {
+                XmlUtils.nextElement(parser);
+
+                String name = parser.getName();
+                if (!"virtualSpnOverride".equals(name)) {
+                    break;
+                }
+
+                String mccmncgid1 = parser.getAttributeValue(null, "mccmncgid1");
+                String spn = parser.getAttributeValue(null, "name");
+                Rlog.w(LOG_TAG, "test mccmncgid1 = " + mccmncgid1 + ", name = " + spn);
+                CarrierVirtualSpnMapByEfGid1.put(mccmncgid1, spn);
+            }
+            spnReader.close();
+        } catch (XmlPullParserException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-efgid1 parser " + e);
+        } catch (IOException e) {
+            Rlog.w(LOG_TAG, "Exception in virtual-spn-conf-by-efgid1 parser " + e);
+        }
+    }
+
+    public String getSpnByEfGid1(String mccmnc, String gid1) {
+        if (mccmnc == null || gid1 == null || mccmnc.isEmpty() || gid1.isEmpty())
+            return null;
+
+        return CarrierVirtualSpnMapByEfGid1.get(mccmnc + gid1);
+    }
+
+    public String lookupOperatorName(int subId, String numeric, boolean desireLongName, Context context) {
+        String operName = numeric;
+        Phone phone = null;
+        // MTK TODO
+        /*
+        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+            if (subId == SubscriptionManager.LTE_DC_SUB_ID_1) {
+                phone = SvlteUtils.getSvltePhoneProxy(PhoneConstants.SIM_ID_1)
+                    .getLtePhone();
+            } else if (subId == SubscriptionManager.LTE_DC_SUB_ID_2) {
+                phone = SvlteUtils.getSvltePhoneProxy(PhoneConstants.SIM_ID_2)
+                    .getLtePhone();
+            } else {
+                phone = PhoneFactory.getPhone(SubscriptionManager.getPhoneId(subId));
+            }
+        } else {
+        */
+            phone = PhoneFactory.getPhone(SubscriptionManager.getPhoneId(subId));
+        // }
+
+        // MVNO-API
+        String mvnoOperName = null;
+
+        if (phone == null) {
+            Rlog.w(LOG_TAG, "lookupOperatorName getPhone null");
+            return operName;
+        }
+
+        // MTK TODO
+        /*
+        mvnoOperName = getSpnByEfSpn(numeric,
+                phone.getMvnoPattern(PhoneConstants.MVNO_TYPE_SPN));
+        Rlog.w(LOG_TAG, "the result of searching mvnoOperName by EF_SPN: " + mvnoOperName);
+        */
+
+        if (mvnoOperName == null) // determine by IMSI
+            mvnoOperName = getSpnByImsi(numeric, phone.getSubscriberId());
+        Rlog.w(LOG_TAG, "the result of searching mvnoOperName by IMSI: " + mvnoOperName);
+
+        // MTK TODO
+        /*
+        if (mvnoOperName == null)
+            mvnoOperName = getSpnByEfPnn(numeric,
+                    phone.getMvnoPattern(PhoneConstants.MVNO_TYPE_PNN));
+        Rlog.w(LOG_TAG, "the result of searching mvnoOperName by EF_PNN: " + mvnoOperName);
+
+        if (mvnoOperName == null)
+            mvnoOperName = getSpnByEfGid1(numeric,
+                   phone.getMvnoPattern(PhoneConstants.MVNO_TYPE_GID));
+        Rlog.w(LOG_TAG, "the result of searching mvnoOperName by EF_GID1: " + mvnoOperName);
+        */
+
+        if (mvnoOperName != null)
+            operName = mvnoOperName;
+
+        boolean getFromResource = false;
+        String ctName = null;  // context.getText(com.mediatek.internal.R.string.ct_name).toString();
+        Rlog.d(LOG_TAG, "ctName:" + ctName);
+        if (ctName != null && ctName.equals(mvnoOperName)) {
+            Rlog.d(LOG_TAG, "Get from resource.");
+            getFromResource = true;
+            mvnoOperName = null;
+        }
+
+        if (mvnoOperName == null && desireLongName) { // MVNO-API
+            // ALFMS00040828 - add "46008"
+            /*
+            if ((numeric.equals("46000")) || (numeric.equals("46002")) || (numeric.equals("46007")) || (numeric.equals("46008"))) {
+                operName = context.getText(com.mediatek.R.string.oper_long_46000).toString();
+            } else if ((numeric.equals("46001")) || (numeric.equals("46009"))) {
+                operName = context.getText(com.mediatek.R.string.oper_long_46001).toString();
+            } else if ((numeric.equals("46003")) || (numeric.equals("46011")) || getFromResource) {
+                operName = context.getText(com.mediatek.R.string.oper_long_46003).toString();
+            } else if (numeric.equals("46601")) {
+                operName = context.getText(com.mediatek.R.string.oper_long_46601).toString();
+            } else if (numeric.equals("46692")) {
+                operName = context.getText(com.mediatek.R.string.oper_long_46692).toString();
+            } else if (numeric.equals("46697")) {
+                operName = context.getText(com.mediatek.R.string.oper_long_46697).toString();
+            } else if (numeric.equals("99998")) {
+                operName = context.getText(com.mediatek.R.string.oper_long_99998).toString();
+            } else if (numeric.equals("99999")) {
+                operName = context.getText(com.mediatek.R.string.oper_long_99999).toString();
+            } else {
+            */
+                // If can't found corresspoding operator in string resource, lookup from spn_conf.xml
+                if (containsCarrier(numeric)) {
+                    operName = getSpn(numeric);
+                } else {
+                    Rlog.w(LOG_TAG, "Can't find long operator name for " + numeric);
+                }
+            // }
+        }
+        else if (mvnoOperName == null && desireLongName == false) // MVNO-API
+        {
+            // ALFMS00040828 - add "46008"
+            /*
+            if ((numeric.equals("46000")) || (numeric.equals("46002")) || (numeric.equals("46007")) || (numeric.equals("46008"))) {
+                operName = context.getText(com.mediatek.R.string.oper_short_46000).toString();
+            } else if ((numeric.equals("46001")) || (numeric.equals("46009"))) {
+                operName = context.getText(com.mediatek.R.string.oper_short_46001).toString();
+            } else if ((numeric.equals("46003")) || (numeric.equals("46011")) || getFromResource) {
+                operName = context.getText(com.mediatek.R.string.oper_short_46003).toString();
+            } else if (numeric.equals("46601")) {
+                operName = context.getText(com.mediatek.R.string.oper_short_46601).toString();
+            } else if (numeric.equals("46692")) {
+                operName = context.getText(com.mediatek.R.string.oper_short_46692).toString();
+            } else if (numeric.equals("46697")) {
+                operName = context.getText(com.mediatek.R.string.oper_short_46697).toString();
+            } else if (numeric.equals("99997")) {
+                operName = context.getText(com.mediatek.R.string.oper_short_99997).toString();
+            } else if (numeric.equals("99999")) {
+                operName = context.getText(com.mediatek.R.string.oper_short_99999).toString();
+            } else {
+            */
+                Rlog.w(LOG_TAG, "Can't find short operator name for " + numeric);
+            // }
+        }
+
+        return operName;
+    }
+
+    public String lookupOperatorNameForDisplayName(int subId,
+            String numeric, boolean desireLongName, Context context) {
+        // xen0n: don't know why the original author duplicated ALL code of
+        // lookupOperatorName() with only the FIRST line modified...
+        return lookupOperatorName(subId, numeric, desireLongName, context);
+    }
+    // MVNO-API END
+
+    public boolean containsCarrierEx(String carrier) {
+        return containsCarrier(carrier);
+    }
+
+    public String getSpnEx(String carrier) {
+        return getSpn(carrier);
+    }
+    // MTK-END
+
 }
diff --git a/src/java/com/android/internal/telephony/uicc/UiccCard.java b/src/java/com/android/internal/telephony/uicc/UiccCard.java
index 9eb9659..8cc713a 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccCard.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccCard.java
@@ -44,6 +44,8 @@
 
 import com.android.internal.telephony.CommandsInterface;
 import com.android.internal.telephony.PhoneBase;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyIntents;
 import com.android.internal.telephony.CommandsInterface.RadioState;
 import com.android.internal.telephony.IccCardConstants.State;
 import com.android.internal.telephony.gsm.GSMPhone;
@@ -55,6 +57,10 @@
 import com.android.internal.telephony.cdma.CDMAPhone;
 import com.android.internal.telephony.cdma.CdmaSubscriptionSourceManager;
 
+// import com.mediatek.internal.telephony.IccCardType.SvlteCardType;
+import com.mediatek.internal.telephony.cdma.CdmaFeatureOptionUtils;
+// import com.mediatek.internal.telephony.ltedc.svlte.SvlteModeController;
+
 import android.os.SystemProperties;
 
 import com.android.internal.R;
@@ -136,42 +142,136 @@ public void dispose() {
             mUiccApplications = null;
             mCarrierPrivilegeRules = null;
             mUICCConfig = null;
+
+            // MTK
+            if (CdmaFeatureOptionUtils.isCdmaLteDcSupport() && mIsSvlte) {
+                mSvlteCi.unregisterForEusimReady(mHandler);
+                mCi.unregisterForCdmaCardType(mHandler);
+            }
         }
     }
 
     public void update(Context c, CommandsInterface ci, IccCardStatus ics) {
+        update(c, ci, ics, true);
+    }
+
+    // with MTK extension
+    public void update(Context c, CommandsInterface ci, IccCardStatus ics, boolean isUpdateSimInfo) {
         synchronized (mLock) {
             CardState oldState = mCardState;
             mCardState = ics.mCardState;
             mUniversalPinState = ics.mUniversalPinState;
-            mGsmUmtsSubscriptionAppIndex = ics.mGsmUmtsSubscriptionAppIndex;
-            mCdmaSubscriptionAppIndex = ics.mCdmaSubscriptionAppIndex;
+            // MTK SVLTE
+            // mGsmUmtsSubscriptionAppIndex = ics.mGsmUmtsSubscriptionAppIndex;
+            // mCdmaSubscriptionAppIndex = ics.mCdmaSubscriptionAppIndex;
             mImsSubscriptionAppIndex = ics.mImsSubscriptionAppIndex;
             mContext = c;
             mCi = ci;
 
+            // MTK-START
+            // check the UiccCard type.
+            int targetIndex = -1;
+            log("update mIsSvlte=" + mIsSvlte);
+            if (mIsSvlte) {
+                IccCardApplicationStatus.AppType appType =
+                        IccCardApplicationStatus.AppType.APPTYPE_UNKNOWN;
+                for (int i = 0; i < ics.mApplications.length; i++) {
+                    if (ics.mApplications[i] != null &&
+                            (ics.mApplications[i].app_type ==
+                                 IccCardApplicationStatus.AppType.APPTYPE_CSIM ||
+                             ics.mApplications[i].app_type ==
+                                 IccCardApplicationStatus.AppType.APPTYPE_RUIM ||
+                             ics.mApplications[i].app_type ==
+                                 IccCardApplicationStatus.AppType.APPTYPE_SIM ||
+                             ics.mApplications[i].app_type ==
+                                 IccCardApplicationStatus.AppType.APPTYPE_USIM)) {
+                        appType = ics.mApplications[i].app_type;
+                        break;
+                    }
+                }
+                log("update appType=" + appType);
+                if (appType == IccCardApplicationStatus.AppType.APPTYPE_CSIM ||
+                    appType == IccCardApplicationStatus.AppType.APPTYPE_RUIM) {
+                    mCdmaSubscriptionAppIndex = ics.mCdmaSubscriptionAppIndex;
+                    targetIndex = mCdmaSubscriptionAppIndex;
+                    //Reset gsm index if to conflict with cdma index
+                    if (targetIndex == mGsmUmtsSubscriptionAppIndex) {
+                        mGsmUmtsSubscriptionAppIndex = -1;
+                        log("reset mGsmUmtsSubscriptionAppIndex to "
+                            + mGsmUmtsSubscriptionAppIndex);
+                    }
+                } else if (appType == IccCardApplicationStatus.AppType.APPTYPE_SIM
+                        || appType == IccCardApplicationStatus.AppType.APPTYPE_USIM) {
+                    mGsmUmtsSubscriptionAppIndex = ics.mGsmUmtsSubscriptionAppIndex;
+                    targetIndex = mGsmUmtsSubscriptionAppIndex;
+                    //Reset cdma index if to conflict with gsm index
+                    if (targetIndex == mCdmaSubscriptionAppIndex) {
+                        mCdmaSubscriptionAppIndex = -1;
+                        log("reset mCdmaSubscriptionAppIndex to "
+                            + mCdmaSubscriptionAppIndex);
+                    }
+                } else {
+                    loge("update, but appType: " + appType);
+                }
+            } else {
+                mGsmUmtsSubscriptionAppIndex = ics.mGsmUmtsSubscriptionAppIndex;
+                mCdmaSubscriptionAppIndex = ics.mCdmaSubscriptionAppIndex;
+            }
+
+            log("update targetIndex=" + targetIndex +
+                    "  mGsmUmtsSubscriptionAppIndex=" + mGsmUmtsSubscriptionAppIndex +
+                    "  mCdmaSubscriptionAppIndex=" + mCdmaSubscriptionAppIndex +
+                    "  mUiccApplications.length=" + mUiccApplications.length);
+            // MTK-END
+
             //update applications
             if (mUICCConfig == null)
                 mUICCConfig = new UICCConfig();
             if (DBG) log(ics.mApplications.length + " applications");
             for ( int i = 0; i < mUiccApplications.length; i++) {
+                // MTK-START
+                if (targetIndex != i && targetIndex >= 0) {
+                    continue;
+                }
+                log("mUiccApplications[i]=" + mUiccApplications[i]);
+                // MTK-END
                 if (mUiccApplications[i] == null) {
                     //Create newly added Applications
                     if (i < ics.mApplications.length) {
                         mUiccApplications[i] = new UiccCardApplication(this,
-                                ics.mApplications[i], mContext, mCi);
+                                ics.mApplications[i], mContext,
+                                (mIsSvlte && targetIndex == mGsmUmtsSubscriptionAppIndex) ? mSvlteCi : mCi);
+                        log("new mUiccApplications[" + i + "]");
                     }
                 } else if (i >= ics.mApplications.length) {
                     //Delete removed applications
-                    mUiccApplications[i].dispose();
-                    mUiccApplications[i] = null;
+                    // MTK
+                    if (mUiccApplications[i] != null) {
+                        mUiccApplications[i].dispose();
+                        mUiccApplications[i] = null;
+                        log("dispose mUiccApplications[" + i + "]");
+                    }
                 } else {
                     //Update the rest
-                    mUiccApplications[i].update(ics.mApplications[i], mContext, mCi);
+                    // MTK
+                    if (mUiccApplications[i] != null) {
+                        mUiccApplications[i].update(ics.mApplications[i], mContext,
+                                (mIsSvlte && targetIndex == mGsmUmtsSubscriptionAppIndex) ?  mSvlteCi : mCi);
+                        log("update mUiccApplications[" + i + "]");
+                    }
                 }
             }
 
-            createAndUpdateCatService();
+            // MTK
+            if (mIsSvlte) {
+                if (targetIndex == mGsmUmtsSubscriptionAppIndex) {
+                    createAndUpdateCatService(mSvlteCi);
+                } else {
+                    //no need to create catservice for csim and ruim.
+                }
+            } else {
+                createAndUpdateCatService(mCi);
+            }
 
             // Reload the carrier privilege rules if necessary.
             log("Before privilege rules: " + mCarrierPrivilegeRules + " : " + mCardState);
@@ -186,8 +286,9 @@ public void update(Context c, CommandsInterface ci, IccCardStatus ics) {
 
             RadioState radioState = mCi.getRadioState();
             if (DBG) log("update: radioState=" + radioState + " mLastRadioState="
-                    + mLastRadioState);
-            // No notifications while radio is off or we just powering up
+                    + mLastRadioState /* MTK */ + " isUpdateSimInfo= " + isUpdateSimInfo);
+             // No notifications while radio is off or we just powering up
+            if (isUpdateSimInfo) {  // MTK
             if (radioState == RadioState.RADIO_ON && mLastRadioState == RadioState.RADIO_ON) {
                 if (oldState != CardState.CARDSTATE_ABSENT &&
                         mCardState == CardState.CARDSTATE_ABSENT) {
@@ -200,6 +301,7 @@ public void update(Context c, CommandsInterface ci, IccCardStatus ics) {
                     mHandler.sendMessage(mHandler.obtainMessage(EVENT_CARD_ADDED, null));
                 }
             }
+            }  // MTK
             if (mCi.needsOldRilFeature("simactivation")) {
                 if (mCardState == CardState.CARDSTATE_PRESENT) {
                     if (!mDefaultAppsActivated) {
@@ -217,13 +319,15 @@ public void update(Context c, CommandsInterface ci, IccCardStatus ics) {
         }
     }
 
-    protected void createAndUpdateCatService() {
+    // MTK
+    // protected void createAndUpdateCatService() {
+    protected void createAndUpdateCatService(CommandsInterface ci) {
         if (mUiccApplications.length > 0 && mUiccApplications[0] != null) {
             // Initialize or Reinitialize CatService
             if (mCatService == null) {
-                mCatService = CatService.getInstance(mCi, mContext, this, mPhoneId);
+                mCatService = CatService.getInstance(ci /* mCi */, mContext, this, mPhoneId);
             } else {
-                ((CatService)mCatService).update(mCi, mContext, this);
+                ((CatService)mCatService).update(ci /* mCi */, mContext, this);
             }
         } else {
             if (mCatService != null) {
@@ -254,6 +358,13 @@ private void sanitizeApplicationIndexes() {
                 checkIndex(mCdmaSubscriptionAppIndex, AppType.APPTYPE_RUIM, AppType.APPTYPE_CSIM);
         mImsSubscriptionAppIndex =
                 checkIndex(mImsSubscriptionAppIndex, AppType.APPTYPE_ISIM, null);
+
+        // MTK
+        if (DBG) {
+            log("sanitizeApplicationIndexes  GSM index= " + mGsmUmtsSubscriptionAppIndex +
+                    "  CDMA index = " + mCdmaSubscriptionAppIndex + "  IMS index = "
+                    + mImsSubscriptionAppIndex);
+        }
     }
 
     private int checkIndex(int index, AppType expectedAppType, AppType altExpectedAppType) {
@@ -267,6 +378,16 @@ private int checkIndex(int index, AppType expectedAppType, AppType altExpectedAp
             return -1;
         }
 
+        // MTK-START
+        if (mUiccApplications[index] == null) {
+            loge("App index " + index + " is null since there are no applications");
+            return -1;
+        }
+
+        log("checkIndex mUiccApplications[" + index + "].getType()= "
+            + mUiccApplications[index].getType());
+        // MTK-END
+
         if (mUiccApplications[index].getType() != expectedAppType &&
             mUiccApplications[index].getType() != altExpectedAppType) {
             loge("App index " + index + " is invalid since it's not " +
@@ -438,6 +559,10 @@ public void handleMessage(Message msg){
                 case EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE:
                 case EVENT_SIM_IO_DONE:
                 case EVENT_SIM_GET_ATR_DONE:
+                // MTK-START
+                case EVENT_GET_ATR_DONE:
+                case EVENT_OPEN_CHANNEL_WITH_SW_DONE:
+                // MTK-END
                     AsyncResult ar = (AsyncResult)msg.obj;
                     if (ar.exception != null) {
                         loglocal("Exception: " + ar.exception);
@@ -449,6 +574,64 @@ public void handleMessage(Message msg){
                 case EVENT_CARRIER_PRIVILIGES_LOADED:
                     onCarrierPriviligesLoadedMessage();
                     break;
+                // MTK-START
+                case EVENT_CDMA_CARD_IMSI_DONE:
+                    log("Handler EVENT_CDMA_CARD_IMSI_DONE mIsSvlte=" + mIsSvlte);
+                    if (mIsSvlte && mUiccApplications != null) {
+                        if (mGsmUmtsSubscriptionAppIndex >= 0
+                            && mUiccApplications[mGsmUmtsSubscriptionAppIndex] != null
+                            && mCdmaSubscriptionAppIndex >= 0
+                            && mUiccApplications[mCdmaSubscriptionAppIndex] != null) {
+                            mCsimRecords =
+                                mUiccApplications[mCdmaSubscriptionAppIndex].getIccRecords();
+                            mUsimRecords =
+                                mUiccApplications[mGsmUmtsSubscriptionAppIndex].getIccRecords();
+                            if ((mUsimRecords != null) || (mCsimRecords != null)) {
+                                if ((mUsimRecords.getIMSI() != null)
+                                    && (mUsimRecords.getIMSI() != mCdmaUsimImsi)
+                                    && (mCsimRecords.getIMSI() != null)
+                                    && (mCsimRecords.getIMSI() != mCdmaCsimImsi)) {
+                                    mCdmaUsimImsi = mUsimRecords.getIMSI();
+                                    mCdmaCsimImsi = mCsimRecords.getIMSI();
+                                    broadcastCdmaCardImsiIntent();
+                                }
+                            }
+                        }
+                    }
+                    break;
+                case EVENT_CDMA_CARD_TYPE:
+                    if (DBG) {
+                        log("handleMessgage (EVENT_CDMA_CARD_TYPE)");
+                    }
+                    ar = (AsyncResult) msg.obj;
+                    if (ar.exception == null) {
+                        int[] resultType = (int[]) ar.result;
+                        if (resultType != null) {
+                            loge("SvlteCardType: TODO!");
+                            /*
+                            mSvlteCardType = SvlteCardType.getCardTypeFromInt(resultType[0]);
+                            if (mSvlteCardType.isValidCardType()) {
+                                broadcastSvlteCardTypeChanged(mPhoneId, mSvlteCardType.getValue());
+                            } else {
+                                log("invalid cardType=" + resultType[0]);
+                            }
+                            */
+                        }
+                    }
+                    break;
+                case EVENT_C2K_WP_CARD_TYPE_READY:
+                    if (DBG) {
+                        log("handleMessgage (EVENT_C2K_WP_CARD_TYPE_READY)");
+                    }
+                    loge("SvlteCardType: TODO!");
+                    /*
+                    mSvlteCardType = SvlteCardType.transformCardTypeFromString(getIccCardType());
+                    if (mSvlteCardType.isValidCardType()) {
+                        broadcastSvlteCardTypeChanged(mPhoneId, mSvlteCardType.getValue());
+                    }
+                    */
+                    break;
+                 // MTK-END
                 default:
                     loge("Unknown Event " + msg.what);
             }
@@ -722,11 +905,11 @@ public UICCConfig getUICCConfig() {
     }
 
     private void log(String msg) {
-        Rlog.d(LOG_TAG, msg);
+        Rlog.d(LOG_TAG, msg /* MTK */  + " (phoneId " + mPhoneId + ")");
     }
 
     private void loge(String msg) {
-        Rlog.e(LOG_TAG, msg);
+        Rlog.e(LOG_TAG, msg /* MTK */  + " (phoneId " + mPhoneId + ")");
     }
 
     private void loglocal(String msg) {
@@ -797,4 +980,259 @@ public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         mLocalLog.dump(fd, pw, args);
         pw.flush();
     }
+
+    // MTK
+
+    private static final int EVENT_GET_ATR_DONE = 100;
+    private static final int EVENT_OPEN_CHANNEL_WITH_SW_DONE = 101;
+    private static final int EVENT_CDMA_CARD_IMSI_DONE = 102;
+    private static final int EVENT_CDMA_CARD_TYPE = 103;
+    private static final int EVENT_C2K_WP_CARD_TYPE_READY = 104;
+
+    static final String[] UICCCARD_PROPERTY_RIL_UICC_TYPE = {
+        "gsm.ril.uicctype",
+        "gsm.ril.uicctype.2",
+        "gsm.ril.uicctype.3",
+        "gsm.ril.uicctype.4",
+    };
+
+    private String mIccType = null; /* Add for USIM detect */
+    private CommandsInterface mSvlteCi; /* Add for C2K SVLTE */
+    private boolean mIsSvlte = false;
+    private static final String[]  PROPERTY_RIL_FULL_UICC_TYPE = {
+        "gsm.ril.fulluicctype",
+        "gsm.ril.fulluicctype.2",
+        "gsm.ril.fulluicctype.3",
+        "gsm.ril.fulluicctype.4",
+    };
+
+    private IccRecords mUsimRecords = null;
+    private IccRecords mCsimRecords = null;
+    private String mCdmaCsimImsi = null;
+    private String mCdmaUsimImsi = null;
+    private boolean mCsimRigisterDone = false;
+    private boolean mUsimRigisterDone = false;
+
+    // private SvlteCardType mSvlteCardType = SvlteCardType.UNKNOW_CARD;
+
+    public UiccCard(Context c, CommandsInterface ci, IccCardStatus ics, int phoneId, boolean isUpdateSiminfo) {
+        if (DBG) log("Creating simId " + phoneId + ",isUpdateSiminfo" + isUpdateSiminfo);
+        mCardState = ics.mCardState;
+        mPhoneId = phoneId;
+        update(c, ci, ics, isUpdateSiminfo);
+    }
+
+    public void exchangeSimIo(int fileID, int command,
+                                           int p1, int p2, int p3, String pathID, String data, String pin2, Message onComplete) {
+        mCi.iccIO(command, fileID, pathID, p1, p2, p3, data, pin2,
+              mHandler.obtainMessage(EVENT_SIM_IO_DONE, onComplete));
+    }
+
+    public void iccGetAtr(Message onComplete) {
+        mCi.iccGetATR(mHandler.obtainMessage(EVENT_GET_ATR_DONE, onComplete));
+    }
+
+    public String getIccCardType() {
+        //int slot = -1;
+        //if (SubscriptionController.getInstance() != null) {
+        //    slot = SubscriptionController.getInstance().getSlotId(
+        //            SubscriptionController.getInstance().getSubIdUsingPhoneId(
+        //            mPhoneId));
+        //    mIccType = SystemProperties.get(UICCCARD_PROPERTY_RIL_UICC_TYPE[slot]);
+        //}
+        mIccType = SystemProperties.get(UICCCARD_PROPERTY_RIL_UICC_TYPE[mPhoneId]);
+        if (DBG) log("getIccCardType(): iccType = " + mIccType + ", slot " + mPhoneId);
+        return mIccType;
+    }
+
+    public String[] getFullIccCardType() {
+        return SystemProperties.get(PROPERTY_RIL_FULL_UICC_TYPE[mPhoneId]).split(",");
+    }
+
+    // MTK-START
+    /**
+     * Request to get SVLTE UICC card type.
+     *
+     * @return index for UICC card type
+     *
+     */
+    public int getSvlteCardType() {
+        // MTK TODO
+        /*
+        if (DBG) {
+            log("getSvlteCardType(): mSvlteCardType = " + mSvlteCardType.getValue()
+                    + ", slot " + mPhoneId);
+        }
+        return mSvlteCardType.getValue();
+        */
+        loge("getSvlteCardType: TODO!");
+        return 0;
+    }
+
+    private void broadcastSvlteCardTypeChanged(int slotId, int cardType) {
+        Intent i = new Intent(TelephonyIntents.ACTION_SVLTE_CARD_TYPE);
+        i.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        i.putExtra(PhoneConstants.SLOT_KEY, slotId);
+        i.putExtra(TelephonyIntents.INTENT_KEY_SVLTE_CARD_TYPE, cardType);
+        log("Broadcasting intent ACTION_SVLTE_CARD_TYPE, slotId " +
+                slotId + ", cardType " + cardType);
+        ActivityManagerNative.broadcastStickyIntent(i, READ_PHONE_STATE,
+                UserHandle.USER_ALL);
+    }
+    // MTK-END
+
+    public void iccOpenChannelWithSw(String AID, Message onComplete) {
+        mCi.iccOpenChannelWithSw(AID,
+            mHandler.obtainMessage(EVENT_OPEN_CHANNEL_WITH_SW_DONE, onComplete));
+    }
+
+    //For C2K SVLTE
+    /**
+     * UiccCard for SVLTE.
+     * @param c  Context
+     * @param ci CommandsInterface
+     * @param ics IccCardStatus
+     * @param slotId Card slot id
+     * @param svlteCi CommandsInterface
+     */
+    public UiccCard(Context c, CommandsInterface ci, IccCardStatus ics, int phoneId,
+        CommandsInterface svlteCi) {
+        if (DBG) {
+            log("Creating phoneId " + phoneId + ",svlteCi" + svlteCi);
+        }
+        // MTK-START
+        // MTK TODO
+        /*
+        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+            mIsSvlte = true;
+            mSvlteCi = svlteCi;
+            UiccController.getInstance().registerForC2KWPCardTypeReady(mHandler,
+                EVENT_C2K_WP_CARD_TYPE_READY, null);
+            ci.registerForCdmaCardType(mHandler, EVENT_CDMA_CARD_TYPE, null);
+        }
+        */
+        // MTK-END
+        mCardState = ics.mCardState;
+        mPhoneId = phoneId;
+        update(c, ci, ics);
+    }
+    /**
+     * Set LTE flag.
+     * @param isSvlte svlte flag
+    */
+    /*
+    public void setSvlteFlag(boolean isSvlte) {
+        if (CdmaFeatureOptionUtils.isCdmaLteDcSupport()) {
+            mIsSvlte = isSvlte;
+        } else {
+            log("setSvlteFlag Error");
+        }
+        log("setSvlteFlag mIsSvlte:" + mIsSvlte);
+    }
+    */
+    //Update LTE UiccApplication
+    /*public void update(Context c, CommandsInterface ci, IccCardStatus ics,
+        CommandsInterface svlteCi) {
+        log("update svlteCi");
+        mSvlteCi = svlteCi;
+        update(c, ci, ics);
+    }*/
+    /*
+    private void configModemRemoteSimAccess() {
+        String cardType = SystemProperties.get(PROPERTY_RIL_FULL_UICC_TYPE[0]);
+        Rlog.d(LOG_TAG, "configModemRemoteSimAccess cardType=" + cardType);
+        String appType[] = cardType.split(",");
+        int type = 0;
+        for (int i = 0; i < appType.length; i++) {
+            if ("USIM".equals(appType[i]) || "SIM".equals(appType[i])) {
+                Rlog.d(LOG_TAG, "UiccCard cardType: contain USIM/SIM");
+                type |= 0x01;
+                continue;
+            } else if ("CSIM".equals(appType[i]) || "RUIM".equals(appType[i])) {
+                Rlog.d(LOG_TAG, "UiccCard cardType: contain CSIM/RUIM");
+                type |= 0x02;
+                continue;
+            }
+        }
+        switch (type) {
+            case 0:
+                // no card
+                mCi.configModemStatus(2, 1, null);
+                if (mSvlteCi != null) {
+                    mSvlteCi.configModemStatus(2, 1, null);
+                }
+                break;
+            case 1:
+                // GSM only card
+                mCi.configModemStatus(2, 1, null);
+                if (mSvlteCi != null) {
+                    mSvlteCi.configModemStatus(2, 1, null);
+                }
+                break;
+            case 2:
+                // UIM only card
+                mCi.configModemStatus(1, 1, null);
+                if (mSvlteCi != null) {
+                    mSvlteCi.configModemStatus(1, 1, null);
+                }
+                break;
+            case 3:
+                // LTE card
+                mCi.configModemStatus(2, 1, null);
+                if (mSvlteCi != null) {
+                    mSvlteCi.configModemStatus(2, 1, null);
+                }
+                break;
+            default:
+                break;
+            }
+    }
+    */
+
+    /**
+    * This funtion is to register for card imsi done.
+    * @param index int uicc card index
+    */
+    public void registerCdmaCardImsiDone(int index) {
+        log("registerCdmaCardImsiDone: index =" + index
+            + " mCdmaSubscriptionAppIndex=" + mCdmaSubscriptionAppIndex
+            + " mGsmUmtsSubscriptionAppIndex=" + mGsmUmtsSubscriptionAppIndex);
+        if ((!mCsimRigisterDone) && (index != UiccController.INDEX_SVLTE)) {
+            if (mCdmaSubscriptionAppIndex >= 0
+                && mUiccApplications[mCdmaSubscriptionAppIndex] != null) {
+                mCsimRecords = mUiccApplications[mCdmaSubscriptionAppIndex].getIccRecords();
+                if (mCsimRecords != null) {
+                    mCsimRecords.registerForImsiReady(mHandler, EVENT_CDMA_CARD_IMSI_DONE, null);
+                    mCsimRigisterDone = true;
+                    log("registerCdmaCardImsiDone: index != UiccController.INDEX_SVLTE");
+                }
+            }
+        } else if ((!mUsimRigisterDone) && (index == UiccController.INDEX_SVLTE)) {
+            if (mGsmUmtsSubscriptionAppIndex >= 0
+                && mUiccApplications[mGsmUmtsSubscriptionAppIndex] != null) {
+                mUsimRecords = mUiccApplications[mGsmUmtsSubscriptionAppIndex].getIccRecords();
+                if (mUsimRecords != null) {
+                    mUsimRecords.registerForImsiReady(mHandler, EVENT_CDMA_CARD_IMSI_DONE, null);
+                    mUsimRigisterDone = true;
+                    log("registerCdmaCardImsiDone: index == UiccController.INDEX_SVLTE");
+                }
+            }
+        }
+    }
+
+    private void broadcastCdmaCardImsiIntent() {
+        // MTK TODO
+        /*
+        Intent intent = new Intent(TelephonyIntents.ACTION_CDMA_CARD_IMSI);
+        intent.putExtra(TelephonyIntents.INTENT_KEY_CDMA_CARD_CSIM_IMSI, mCdmaCsimImsi);
+        intent.putExtra(TelephonyIntents.INTENT_KEY_CDMA_CARD_USIM_IMSI, mCdmaUsimImsi);
+        intent.putExtra(TelephonyIntents.INTENT_KEY_SVLTE_MODE_SLOT_ID,
+            SvlteModeController.getActiveSvlteModeSlotId());
+        log("Broadcasting intent broadcastCdmaCardImsiIntent mCdmaCsimImsi=" + mCdmaCsimImsi
+            + " mCdmaUsimImsi=" + mCdmaUsimImsi + " getActiveSvlteModeSlotId() = " +
+            SvlteModeController.getActiveSvlteModeSlotId());
+        ActivityManagerNative.broadcastStickyIntent(intent, READ_PHONE_STATE, UserHandle.USER_ALL);
+        */
+    }
+    // MTK-END
 }
diff --git a/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java b/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
index 4fdcbda..dc644a1 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
@@ -21,10 +21,12 @@
 import android.os.Handler;
 import android.os.Message;
 import android.os.Registrant;
+import android.os.SystemProperties;
 import android.os.RegistrantList;
 import android.telephony.Rlog;
 
 import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneConstants;
 import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppState;
 import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppType;
@@ -107,9 +109,12 @@
         mContext = c;
         mCi = ci;
 
+        // MTK
+        mPhoneId = mUiccCard.getPhoneId();
+
         mIccFh = createIccFileHandler(as.app_type);
         mIccRecords = createIccRecords(as.app_type, mContext, mCi);
-        if (mAppState == AppState.APPSTATE_READY) {
+        if (mAppState == AppState.APPSTATE_READY /* MTK */ && mAppType != AppType.APPTYPE_ISIM) {
             queryFdn();
             queryPin1State();
         }
@@ -155,7 +160,7 @@ void update (IccCardApplicationStatus as, Context c, CommandsInterface ci) {
                 if (DBG) log(oldAppType + " changed state: " + oldAppState + " -> " + mAppState);
                 // If the app state turns to APPSTATE_READY, then query FDN status,
                 //as it might have failed in earlier attempt.
-                if (mAppState == AppState.APPSTATE_READY) {
+                if (mAppState == AppState.APPSTATE_READY /* MTK */ && mAppType != AppType.APPTYPE_ISIM) {
                     queryFdn();
                     queryPin1State();
                 }
@@ -178,6 +183,8 @@ void dispose() {
     }
 
     private IccRecords createIccRecords(AppType type, Context c, CommandsInterface ci) {
+		if (DBG) log("createIccRecords, AppType = " + type);  // MTK
+
         if (type == AppType.APPTYPE_USIM || type == AppType.APPTYPE_SIM) {
             return new SIMRecords(this, c, ci);
         } else if (type == AppType.APPTYPE_RUIM || type == AppType.APPTYPE_CSIM){
@@ -251,11 +258,13 @@ private void onQueryFdnEnabled(AsyncResult ar) {
     private void onChangeFdnDone(AsyncResult ar) {
         synchronized (mLock) {
             int attemptsRemaining = -1;
+            boolean bNotifyFdnChanged = false;  // MTK
 
             if (ar.exception == null) {
                 mIccFdnEnabled = mDesiredFdnEnabled;
                 if (DBG) log("EVENT_CHANGE_FACILITY_FDN_DONE: " +
                         "mIccFdnEnabled=" + mIccFdnEnabled);
+                bNotifyFdnChanged = true;  // MTK
             } else {
                 attemptsRemaining = parsePinPukErrorResult(ar);
                 loge("Error change facility fdn with exception " + ar.exception);
@@ -264,6 +273,11 @@ private void onChangeFdnDone(AsyncResult ar) {
             response.arg1 = attemptsRemaining;
             AsyncResult.forMessage(response).exception = ar.exception;
             response.sendToTarget();
+            // MTK
+            if (bNotifyFdnChanged) {
+                log("notifyFdnChangedRegistrants");
+                notifyFdnChangedRegistrants();
+            }
         }
     }
 
@@ -353,13 +367,16 @@ private void onChangeFacilityLock(AsyncResult ar) {
     private int parsePinPukErrorResult(AsyncResult ar) {
         int[] result = (int[]) ar.result;
         if (result == null) {
-            return -1;
+            // xen0n refactored
+            // return -1;
+            return SystemProperties.getInt(PROPERTY_PIN2_RETRY[getSlotId()], -1);
         } else {
             int length = result.length;
             int attemptsRemaining = -1;
             if (length > 0) {
                 attemptsRemaining = result[0];
             }
+
             log("parsePinPukErrorResult: attemptsRemaining=" + attemptsRemaining);
             return attemptsRemaining;
         }
@@ -413,6 +430,24 @@ public void handleMessage(Message msg){
                     if (DBG) log("handleMessage (EVENT_RADIO_UNAVAILABLE)");
                     mAppState = AppState.APPSTATE_UNKNOWN;
                     break;
+                // MTK-START
+                // [ALPS01827777]--- START ---
+                // Need to query lock setting since it might be changed when
+                // entering PUK to change PIN.
+                case EVENT_PUK1_CHANGE_PIN1_DONE:
+                    log("EVENT_PUK1_CHANGE_PIN1_DONE");
+                    int attemptsRemainingPuk = -1;
+                    ar = (AsyncResult) msg.obj;
+                    if ((ar.exception != null) && (ar.result != null)) {
+                        attemptsRemainingPuk = parsePinPukErrorResult(ar);
+                    }
+                    Message responsePuk = (Message) ar.userObj;
+                    AsyncResult.forMessage(responsePuk).exception = ar.exception;
+                    responsePuk.arg1 = attemptsRemainingPuk;
+                    responsePuk.sendToTarget();
+                    queryPin1State();
+                    break;
+                case EVENT_PUK2_CHANGE_PIN2_DONE:
                 default:
                     loge("Unknown Event " + msg.what);
             }
